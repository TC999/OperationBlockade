/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#define _CRT_SECURE_NO_WARNINGS

#include <windows.h>
#include "defs.h"
#include <stdio.h>
#include <wchar.h>
#include <time.h>
#include <CommCtrl.h>
#include <float.h>
#pragma comment(lib, "Comctl32.lib")
#define snwprintf _snwprintf
#define wtol _wtol
#define __usercall

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

float* __cdecl sub_401000(float* a1, float a2);
int __cdecl sub_401040(int a1, float a2); // idb
float* __cdecl sub_401080(float* a1, float a2);
int __cdecl sub_4010C0(int a1);
int __cdecl sub_4010D0(_DWORD* a1, int a2);
double __cdecl sub_401100(float* a1, float* a2);
double __cdecl sub_401170(float* a1, float* a2);
double __cdecl sub_4011F0(int a1);
BOOL __cdecl sub_401200(float* a1);
int __thiscall sub_401270(int this);
int __stdcall sub_4013C0(int a1, int a2, int a3, int(__thiscall* a4)(int));
int __thiscall sub_4013F0(_DWORD* this);
int __thiscall sub_401450(_DWORD* this);
void __thiscall sub_401480(float* this, float a2, float a3, float a4);
void __thiscall sub_4014C0(float* this, float a2, float a3, float a4);
int __thiscall sub_401550(float* this);
float* __thiscall sub_401600(float* this);
int __thiscall sub_401EC0(float* this);
char __thiscall sub_402110(float* this, float* a2, float a3);
char __thiscall sub_402170(float* this, float a2, float a3, float a4, float a5, float a6, float a7);
double __thiscall sub_4022C0(float* this, float a2, float a3, float a4);
char __thiscall sub_402300(float* this, float* a2, int* a3, int* a4);
float* __thiscall sub_402430(float* this, float* a2, float* a3);
int __stdcall sub_402470(int a1);
char __thiscall sub_402480(_BYTE* this, char a2);
void __stdcall nullsub_4(int);
_DWORD* __thiscall sub_4024C0(_DWORD* this);
int __thiscall sub_402530(_DWORD* this);
char __thiscall sub_402540(int this, int a2);
int __thiscall sub_402670(_DWORD* this, int a2, int a3);
int __thiscall sub_402690(_DWORD* this, int a2, int a3, int a4);
HRESULT __cdecl sub_4026C0(LPCCH lpMultiByteStr);
BOOL __cdecl sub_402710(int a1);
int __stdcall sub_4027C0(int, int, int, int); // weak
HRESULT sub_402820();
BOOL sub_4028F0();
BOOL sub_402960();
int __cdecl sub_402990(LPCCH lpMultiByteStr); // idb
int sub_402B90();
char* __thiscall sub_402C60(char* Destination, char* Source);
void __thiscall sub_402CB0(int this);
void __thiscall sub_402DA0(int this, float a2);
int __thiscall sub_402FC0(int this);
int __thiscall sub_4030B0(_DWORD* this, int a2, char* String2, int a4);
_DWORD* __thiscall sub_403180(_DWORD* this);
void __thiscall sub_403220(void* this);
int __thiscall sub_4033A0(int this);
char* __thiscall sub_403620(_DWORD* this, char* String2);
char __thiscall sub_4036D0(_DWORD* this, int a2);
int __thiscall sub_403710(_DWORD* this, char* String2);
void __thiscall sub_403760(int this);
void __thiscall sub_4037E0(int this);
void* __thiscall sub_403860(void* this, char a2);
void __thiscall sub_403880(int this);
void __thiscall sub_403920(int this);
_DWORD* sub_403A30(_DWORD* a1, int a2, char* Format, ...);
void __thiscall sub_403A90(void* this); // idb
void __thiscall sub_403AE0(void* this); // idb
_DWORD* __thiscall sub_403B10(_DWORD* this);
void __thiscall sub_403B60(_DWORD* this);
void __thiscall sub_403B70(_DWORD* this);
bool __thiscall sub_403BB0(_DWORD* this, int a2, const char* a3);
int __thiscall sub_403C80(_DWORD* this, int a2, char a3);
int __thiscall sub_403CB0(_DWORD* this, int a2);
void __thiscall sub_403CE0(_DWORD* this);
char* __thiscall sub_403D90(char* this, const char* a2);
// char __usercall sub_403E30@<al>(int a1@<ecx>, int a2@<ebp>);
// int __userpurge sub_403E80@<eax>(int a1@<ecx>, int a2@<ebp>, char *ArgList);
// char __userpurge sub_403EC0@<al>(int a1@<ecx>, int a2@<ebp>, int a3@<edi>, char *FileName);
int __thiscall sub_403F40(_DWORD* this);
bool __thiscall sub_403F50(int this);
char __thiscall sub_403FE0(FILE** this);
_DWORD* __thiscall sub_4044D0(_DWORD* this, int a2);
bool __thiscall sub_404510(int this);
void __thiscall sub_4046A0(void*); // idb
bool __thiscall sub_4046C0(FILE** this, int a2, int ArgList);
bool __thiscall sub_404950(int this, int a2);
_BYTE* __thiscall sub_404F60(_DWORD* this, int a2, void* a3, float* a4);
int __thiscall sub_4050B0(_DWORD* this);
// int __usercall sub_4051C0@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, int a3@<edi>);
bool __thiscall sub_405770(FILE** this, unsigned int Buffer);
BOOL __thiscall sub_4057E0(FILE** this, void* Buffer);
BOOL __thiscall sub_405800(FILE** this, void* Buffer);
BOOL __thiscall sub_405820(FILE** this, FILE** a2);
char __thiscall sub_405850(int this, int Buffer);
bool __thiscall sub_4059A0(FILE** this, unsigned int Buffer);
int __thiscall sub_4059D0(_DWORD* this, int a2);
int __thiscall sub_4059F0(_DWORD* this, int a2, int a3);
int __thiscall sub_405A30(_DWORD* this, char* String1, int a3, char a4);
int __thiscall sub_405BB0(_DWORD* this, int a2);
char __thiscall sub_405BE0(_DWORD* this, int a2);
char __thiscall sub_405C00(_DWORD* this, int a2);
int __thiscall sub_405C20(_DWORD* this, int a2);
int __stdcall sub_405C40(int a1, int a2, int a3);
int __thiscall sub_405DF0(void* this, _DWORD* a2, int a3);
int __stdcall sub_405E20(int a1, int a2, int a3, int a4);
int __stdcall sub_406000(_DWORD* a1, int a2);
// int __userpurge sub_406110@<eax>(_DWORD *a1@<ecx>, int a2@<esi>, int a3, float *a4, int a5, char a6);
float* __thiscall sub_4063E0(_DWORD* this, int a2, void* a3, float* a4, float a5, int a6);
int __thiscall sub_406620(_DWORD* this, int a2, _BYTE* a3, float* a4, float a5, int a6);
// float *__userpurge sub_4066C0@<eax>(_DWORD *a1@<ecx>, int a2@<esi>, _DWORD *a3, float *a4, float *a5, float *a6, float *a7, float *a8);
_DWORD* __thiscall sub_4068D0(_DWORD* this);
int __thiscall sub_406980(_DWORD* this);
// char *__userpurge sub_4069C0@<eax>(int a1@<ecx>, int a2@<ebp>, char *String1);
int __thiscall sub_406A50(_DWORD* this, int a2);
_DWORD* __cdecl sub_406A90(int a1, char a2);
_DWORD* __thiscall sub_406B00(_DWORD* this, int a2, char a3);
_DWORD* __cdecl sub_406BE0(_DWORD* a1);
void __thiscall sub_406C20(void* this);
int __thiscall sub_406CB0(int this, int a2);
int __thiscall sub_406CF0(int this, float a2);
void __thiscall sub_406D30(int this, float a2);
int __thiscall sub_406DF0(int this, int a2);
char __thiscall sub_406F00(float* this, int a2);
int __thiscall sub_407120(_DWORD* this, int a2);
void* __thiscall sub_407190(_DWORD* this, int a2, char a3);
int __thiscall sub_407250(_DWORD* this);
char __thiscall sub_4072A0(_DWORD* this, int a2, int a3, char a4);
double __thiscall sub_407320(_DWORD* this, int a2);
char __thiscall sub_407350(_DWORD* this, int a2);
int __thiscall sub_407390(_DWORD* this, int a2, char a3);
int __thiscall sub_4073C0(_DWORD* this, int a2, char a3);
int __thiscall sub_4073F0(_DWORD* this, int a2, const void* a3);
char* __thiscall sub_407430(_DWORD* this, int a2, char* a3);
int __thiscall sub_407460(_DWORD* this, int a2);
int __thiscall sub_4074B0(_DWORD* this, int a2);
int __thiscall sub_407510(_DWORD* this, int a2, float a3);
int __thiscall sub_407560(_DWORD* this, int a2, float a3);
int __thiscall sub_4075B0(_DWORD* this, int a2, float a3);
int __thiscall sub_407600(_DWORD* this, int a2, int a3, int a4, int a5);
_BYTE* __thiscall sub_407650(_DWORD* this, int a2, char a3);
_BYTE* __thiscall sub_407670(_DWORD* this, int a2, char a3);
int __thiscall sub_407690(int this, int a2, _DWORD* a3);
char __thiscall sub_407710(float* this, int a2, int a3, int a4, int a5, int a6, int a7, int* a8, float* a9);
// BOOL __userpurge sub_407A90@<eax>(int a1@<ecx>, int a2@<ebx>, int a3@<esi>, int a4, int a5, int a6, int a7, int a8, int a9, int *a10, _DWORD *a11, int a12, float *a13);
bool __thiscall sub_407F00(int this, int a2, int* a3, float a4, int* a5, float* a6);
double __thiscall sub_4081A0(int this, int a2, float a3, float a4);
int __thiscall sub_408540(_DWORD* this, int a2);
int __thiscall sub_408580(_DWORD* this, int a2, int a3);
float* __thiscall sub_4085B0(int this, int a2, int a3);
_DWORD* __thiscall sub_4085F0(int this, int a2, _DWORD* a3, _DWORD* a4);
int __thiscall sub_408640(_DWORD* this, int a2, char a3);
bool __thiscall sub_408660(_DWORD* this, int a2);
char __thiscall sub_408680(int this, int a2, float* a3, float* a4, float* a5, float* a6, float* a7, float* a8);
int __thiscall sub_408860(_DWORD* this, int a2);
int __thiscall sub_408880(_DWORD* this);
int __thiscall sub_408890(_DWORD** this);
BOOL __thiscall sub_4088A0(int this);
BOOL __thiscall sub_4088E0(int this);
double __thiscall sub_408920(int this);
int __thiscall sub_408960(_DWORD* this, float a2);
int __thiscall sub_4089D0(_DWORD* this, int a2, int a3);
int __thiscall sub_408A30(_DWORD* this, _DWORD* a2);
_DWORD* __thiscall sub_408A50(_DWORD* this);
void __thiscall sub_408B70(void* this);
char __thiscall sub_408D20(int this);
void __thiscall sub_408EE0(_DWORD* this);
int __thiscall sub_408EF0(int this, int a2);
int __thiscall sub_408F30(_DWORD* this);
int __stdcall sub_408F40(int a1);
char __stdcall sub_408F60(int a1);
double __thiscall sub_408F80(float* this, int a2);
float* __thiscall sub_408FB0(float* this);
int __thiscall sub_4090F0(int this);
int __cdecl sub_4096B0(int* a1, int* a2);
int __thiscall sub_409850(int this, int** a2);
_DWORD* __thiscall sub_409960(_DWORD* this, int a2);
int __thiscall sub_409A00(int this, void* a2);
_BYTE* __thiscall sub_409AD0(int* this, int a2, unsigned int a3);
_DWORD* __thiscall sub_409AF0(_DWORD** this, char* String1, char a3);
_DWORD* __thiscall sub_409B10(_DWORD* this);
int __thiscall sub_409B70(_DWORD* this);
// char __userpurge sub_409BE0@<al>(int a1@<ecx>, int a2@<ebx>, int a3@<ebp>, int a4@<edi>, int a5@<esi>, float a6, float a7, float a8, float a9, float a10, int a11, float a12, float a13, int a14);
int __thiscall sub_409EF0(_DWORD* this, int a2);
void sub_40A050();
char* sub_40A060();
char sub_40A0F0();
char sub_40A120(char a1, char* Format, ...);
int __thiscall sub_40A1D0(int this, char* FileName);
int __thiscall sub_40A800(int this);
int __thiscall sub_40A830(int this);
int __thiscall sub_40A980(_DWORD* this);
char __thiscall sub_40A9B0(int this, unsigned int a2);
int __thiscall sub_40AA00(_DWORD* this, int a2);
int __thiscall sub_40AA20(_DWORD* this, int a2);
int __thiscall sub_40AA40(int this, char* String2);
bool __thiscall sub_40AAF0(_DWORD* this, char* String2, char a3);
bool __thiscall sub_40ABC0(_DWORD* this, char* String2, char a3);
char __thiscall sub_40ACC0(_DWORD* this, char* String2, char* a3);
bool __thiscall sub_40AD80(void* this, char* String2);
unsigned int __thiscall sub_40ADB0(_DWORD* this);
int __thiscall sub_40AE00(_DWORD* this, char* String2);
char __thiscall sub_40AE70(_DWORD* this, char* String2);
char* __thiscall sub_40AF00(const char* this, char* ArgList, char** a3);
float* __thiscall sub_40AF60(const char* this, char* ArgList, float* a3);
int __thiscall sub_40AFC0(void* this, char* String2, _DWORD* a3);
char* __thiscall sub_40AFE0(void* this, char* String2, char** a3);
char __thiscall sub_40B030(char* this, char* ArgList, float* a3);
char __thiscall sub_40B130(const char* this, char* ArgList, _BYTE* a3);
void __thiscall sub_40B1B0(const char* this, char* ArgList, float* a3);
void __thiscall sub_40B1D0(const char* this, char* ArgList, float* a3, float* a4);
void __thiscall sub_40B1F0(const char* this, char* ArgList, float* a3, float* a4);
char __thiscall sub_40B310(const char* this, char* ArgList, _DWORD* a3, const char** a4);
char __thiscall sub_40B420(const char* this, char* ArgList, float* a3, const char** a4);
char __thiscall sub_40B530(const char* this, char* ArgList, _DWORD* a3, _DWORD* a4, const char** a5);
int __thiscall sub_40B6E0(int this, char* String2, char a3);
int __thiscall sub_40B800(int* this);
unsigned int __thiscall sub_40B840(_DWORD* this, int a2, unsigned int a3, int a4);
_DWORD* __thiscall sub_40BB60(_DWORD* this, _DWORD* a2, int a3);
void __cdecl sub_40BBF0(int a1, int a2);
int* __thiscall sub_40BCC0(int* this, int* a2);
int sub_40BF40();
_DWORD* sub_40BF50();
void __cdecl sub_40BF70(); // idb
_DWORD* __thiscall sub_40BF80(_DWORD* this);
int __thiscall sub_40BFD0(_DWORD); // weak
_DWORD* __thiscall sub_40BFE0(int this, _DWORD* a2, int a3, int a4, char a5);
_DWORD* __thiscall sub_40C130(_DWORD** this, _DWORD* a2, int a3, char a4);
_DWORD* __thiscall sub_40C1F0(int this, _DWORD* a2, int a3, char a4);
_DWORD* __thiscall sub_40C2B0(int this, _DWORD* a2);
_DWORD* __thiscall sub_40C310(_DWORD* this, _DWORD* a2);
_DWORD* __thiscall sub_40C4C0(_DWORD* this, _DWORD* a2);
_DWORD* __thiscall sub_40C630(_DWORD* this, int a2, int a3);
_DWORD* __thiscall sub_40C660(_DWORD* this, int a2, int a3);
int __thiscall sub_40C690(_DWORD* this);
bool __cdecl sub_40C6F0(float* a1, float* a2, float* a3);
char __cdecl sub_40C910(float* a1, float* a2, float* a3, float* a4, float* a5, float* a6);
char __cdecl sub_40C9E0(float* a1, float* a2, float* a3, float* a4, float* a5, float* a6);
BOOL __cdecl sub_40CC10(float* a1, float* a2, float* a3, float* a4);
BOOL __cdecl sub_40CC80();
char __cdecl sub_40CCD0(float* a1, float a2, float* a3, float* a4, float* a5, float* a6, float* a7);
bool __cdecl sub_40D330(float* a1, float* a2, float* a3, float* a4, float* a5, float* a6);
bool __cdecl sub_40D900(float* a1, float a2, float* a3, float* a4, float* a5);
double __cdecl sub_40DD90(float* a1, float* a2, float* a3, float* a4);
double __cdecl sub_40E420(float* a1, float* a2, float* a3);
float* __thiscall sub_40E510(float* this, float* a2);
float* __thiscall sub_40E530(float* this, float* a2);
void __thiscall sub_40E550(float* this, float a2);
float* __thiscall sub_40E570(float* this, float* a2, float* a3);
double __thiscall sub_40E5D0(float* this);
void __thiscall sub_40E5F0(void*); // idb
void __thiscall sub_40E620(void*); // idb
long double __thiscall sub_40E640(int this, float a2, int a3, int a4);
long double __thiscall sub_40E6D0(int* this, float a2);
char __thiscall sub_40E780(LPVOID* this, FILE* Stream);
_BYTE* __thiscall sub_40E850(_BYTE* this, float a2);
_BYTE* __thiscall sub_40E880(_BYTE* this, int a2, int a3, int a4);
_BYTE* __thiscall sub_40E8B0(_BYTE* this, int a2, int a3, int a4);
int* __cdecl sub_40E8E0(int a1);
int* __cdecl sub_40E910(int a1);
unsigned int* __cdecl sub_40EA70(unsigned int* a1);
void __cdecl sub_40EB70(unsigned int* a1);
int sub_40EBA0();
void sub_40EC30();
int __thiscall sub_40EC60(int this);
int __thiscall sub_40ED60(_DWORD* this);
int __thiscall sub_40ED70(_DWORD* this, int a2, int a3, int a4, int a5, int a6);
char __thiscall sub_40EDB0(int this, int a2);
char __thiscall sub_40F460(_BYTE* this, int a2, char a3);
_DWORD* __thiscall sub_40F4A0(_DWORD* this, int a2, int a3, int a4);
int* __thiscall sub_40F4C0(_DWORD* this, int a2, unsigned int a3, _WORD* a4);
char* __thiscall sub_40F510(char* this);
void __thiscall sub_40F620(char* this);
// bool __thiscall std::codecvt_base::do_always_noconv(std::codecvt_base *__hidden this); idb
_DWORD* __thiscall sub_40F7B0(int this, _DWORD* a2);
FILE* __thiscall sub_40FC90(struct _RTL_CRITICAL_SECTION* this);
int __thiscall sub_40FD50(struct _RTL_CRITICAL_SECTION* this, char** a2, int a3);
_DWORD* __thiscall sub_40FDD0(int this, _DWORD* a2, char* String2);
_DWORD* __thiscall sub_40FEE0(int this, _DWORD* a2);
_DWORD* __thiscall sub_4102F0(int this, _DWORD* a2, const CHAR* lpMultiByteStr, int a4);
int __stdcall sub_410A90(int a1, unsigned int a2, float a3);
int __thiscall sub_410AB0(int this, unsigned int a2, float a3);
void __stdcall sub_4113D0(int a1);
_BYTE* __thiscall sub_4113F0(_DWORD* this, int a2, __int16 a3, __int16 a4, char a5);
_DWORD* __thiscall sub_411430(_DWORD* this, int a2);
bool __thiscall sub_411480(_DWORD* this, int** a2, int a3, _WORD* a4, int a5, int a6, int a7);
bool __thiscall sub_4117A0(_DWORD* this, int** a2, _WORD* a3, int a4, int a5, int a6);
bool __thiscall sub_4117D0(int this, int** a2, _WORD* a3, int a4, int a5, int a6);
char __thiscall sub_411820(int this, __int16 a2, int a3, unsigned int a4);
int __thiscall sub_4118C0(int this, _DWORD* a2, int a3);
void __thiscall sub_411920(int this, int** a2, int a3);
void __thiscall sub_4119F0(int this);
_DWORD* __thiscall sub_411B60(int this, int a2);
void __thiscall sub_411BB0(int this, int a2);
FILE* __thiscall sub_411C50(int this);
int __thiscall sub_411D20(_DWORD* this);
void __thiscall sub_411DE0(int this, char* a2);
int sub_411E30();
int sub_411E40();
void __cdecl sub_411E70(); // idb
int __thiscall sub_411EE0(int this, _DWORD* a2, _DWORD* a3, _DWORD* a4);
int __cdecl sub_412120(const char** a1, const char** a2);
int __stdcall sub_412140(const char* a1, const char* a2);
char __thiscall sub_4122F0(int this, int a2);
void __thiscall sub_412620(_DWORD* this, int a2);
void __thiscall sub_4129B0(_DWORD* this, int a2);
void __thiscall sub_412A30(char* this);
_DWORD* __thiscall sub_412AB0(_DWORD* this);
int __thiscall sub_412CC0(int this, int a2);
// int __userpurge sub_412DB0@<eax>(int a1@<ecx>, int a2@<edi>, int a3);
void __thiscall sub_413090(int this, float a2, float a3, float a4, float a5);
int __thiscall sub_413100(int this, int a2, int a3, int a4);
int __thiscall sub_413120(int this, int a2);
int __thiscall sub_413130(int this, int a2, int a3, int a4, int a5);
int __thiscall sub_413160(int this, int a2, int a3, int a4);
char __thiscall sub_413180(int this, int a2, char a3);
_DWORD* __thiscall sub_4131B0(_DWORD* this, _DWORD* a2);
float* __thiscall sub_4131D0(float* this, float* a2, float* a3);
int __thiscall sub_413240(_DWORD* this, int a2, int a3, int a4, int a5);
void __thiscall sub_413270(float* this, int);
void __thiscall sub_413290(int this, int);
_DWORD* __thiscall sub_4132B0(_DWORD* this);
void __thiscall sub_413300(LPVOID* this);
char __thiscall sub_4133C0(_DWORD* this);
int __thiscall sub_4134A0(_DWORD* this);
void __thiscall sub_4134F0(_DWORD* this);
void __thiscall sub_413550(int this);
_DWORD* __thiscall sub_413780(_DWORD* this);
int __thiscall sub_413830(_DWORD* this, char* String1);
_DWORD* __thiscall sub_413870(_DWORD* this, int a2);
char __stdcall sub_413990(_BYTE* a1);
char __thiscall sub_4139B0(_DWORD* this);
char __thiscall sub_4139F0(_DWORD* this, int a2);
char __thiscall sub_414C80(_DWORD* this, int a2);
int __thiscall sub_414CE0(void* this);
int __fastcall sub_414CF0(int a1);
void __thiscall sub_414D70(LPVOID* this);
char __thiscall sub_414E60(int this);
void __thiscall sub_4151F0(int this);
_DWORD* __thiscall sub_415270(int this, int a2);
void __thiscall sub_415330(int this, void* a2);
char __thiscall sub_4153B0(_DWORD* this, int a2);
char __thiscall sub_415430(_DWORD* this, int a2);
// Iostream_init *__thiscall Iostream_init::Iostream_init(Iostream_init *__hidden this); idb
_DWORD* __thiscall sub_415660(_DWORD* this, int a2);
int __thiscall nullsub_1(_DWORD); // weak
int __thiscall sub_415770(int this, float* a2, float* a3, int a4, int a5);
void __thiscall sub_415910(void* this);
void __thiscall sub_415930(int this, int a2, float a3);
void __thiscall sub_4159B0(int this, float a2, _DWORD* a3, _DWORD* a4, float* a5, int a6, float* a7);
float* __thiscall sub_416260(float* this, float* a2);
float* __thiscall sub_416290(float* this, float a2);
float* __thiscall sub_4162C0(float* this, float* a2, float* a3);
float* __thiscall sub_4162F0(float* this, float* a2, float a3);
float* __thiscall sub_416320(float* this, float* a2, float a3);
char __thiscall sub_416350(int this, _DWORD* a2, char a3);
void __thiscall sub_4164A0(int this, int a2);
void __thiscall sub_4164D0(float* this);
int __thiscall sub_416570(float* this);
int __thiscall sub_416EE0(int this, int a2);
char __thiscall sub_416F80(_DWORD* this, char a2);
int __thiscall sub_417120(void* this, int a2);
int __thiscall sub_417140(_DWORD* this, int a2);
int __thiscall sub_417160(_DWORD* this);
char* __thiscall sub_417180(char* this);
char __thiscall sub_417190(int this, int a2, _DWORD* a3, unsigned __int8 a4);
void __thiscall sub_417260(float* this);
char __thiscall sub_4176E0(_DWORD* this, _DWORD* a2, _DWORD* a3, _BYTE* a4, int a5);
int __thiscall sub_417770(float* this);
char __thiscall sub_4183A0(int this, int a2, float a3);
char __thiscall sub_418420(int this, int a2, float a3, float* a4, float* a5, _DWORD* a6);
float* __thiscall sub_418E20(float* this, float* a2);
bool __thiscall sub_418E50(int this, char a2, float a3);
double __cdecl sub_419640(float* a1);
double __cdecl sub_419670(float* a1, float* a2);
float* __cdecl sub_419690(float* a1, float* a2, float* a3);
bool __thiscall sub_4196F0(int this, float* a2, float a3, float a4, char a5, char a6);
bool __thiscall sub_4198A0(_DWORD* this, float* a2, float a3, float a4, char a5, char a6);
bool __thiscall sub_419910(int this, float a2, float a3, float a4, char a5, char a6);
char __thiscall sub_419A30(_DWORD* this, float a2, float a3, float a4);
char __thiscall sub_419BC0(_DWORD* this, int a2);
bool __thiscall sub_419C40(int this, float* a2);
int __thiscall sub_419CC0(_DWORD* this);
char* __thiscall sub_419CF0(char* this, char* a2, unsigned int a3, _DWORD* a4);
int __thiscall sub_41A000(_DWORD* this, char* a2, unsigned int a3, const void* a4);
char* __thiscall sub_41A300(_DWORD* this, char* a2, char* a3);
bool __cdecl sub_41A360(char a1);
LRESULT sub_41A390();
INT_PTR __stdcall DialogFunc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4); // idb
int sub_41B030();
int __cdecl CompareFunction(_DWORD* a1, _DWORD* a2);
int __cdecl sub_41B760(int a1, int a2);
int __cdecl sub_41B970(int a1, int a2, int a3, _DWORD* a4);
_DWORD* __thiscall sub_41BB80(_DWORD* this);
int __thiscall sub_41BB90(_DWORD* this);
int __thiscall sub_41BC00(_DWORD* this, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __thiscall sub_41BEF0(_DWORD* this, int a2, int a3, int a4, int a5);
int __thiscall sub_41C050(_DWORD* this);
int __thiscall sub_41C060(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_41C090(_DWORD* this, int a2, int a3);
void __thiscall sub_41C0B0(int this, float a2);
void __thiscall sub_41C0E0(float* this);
void __thiscall sub_41C150(int this);
void __thiscall sub_41C190(int this);
double __thiscall sub_41C200(float* this, float a2);
// Iostream_init *__thiscall Iostream_init::Iostream_init(Iostream_init *__hidden this); idb
double __stdcall sub_41C2A0(float a1);
double __thiscall sub_41C2F0(float* this, float a2);
BOOL __thiscall sub_41C310(int this, float a2, float a3);
BOOL __thiscall sub_41C380(float* this, float a2);
void __thiscall sub_41C3C0(int this, float, float, int);
void __thiscall sub_41C4E0(float* this);
char __cdecl sub_41C550(HWND a1, int a2, LPCGUID pcGuidDevice);
LPDIRECTSOUND sub_41C680();
_DWORD* __thiscall sub_41C6A0(_DWORD* this);
FILE* __thiscall sub_41C700(int this);
char __thiscall sub_41C740(int this);
unsigned int __thiscall sub_41C760(int this, const char* a2);
char __thiscall sub_41C7A0(int this, char a2);
char __thiscall sub_41C7E0(_BYTE* this, char a2);
char __thiscall sub_41C810(int this);
char __thiscall sub_41C940(int this);
char __thiscall sub_41C9A0(char* this, char* a2);
char __thiscall sub_41CA40(int this);
char __thiscall sub_41CD90(int this);
// char __usercall sub_41CE60@<al>(int a1@<ebx>, unsigned int a2);
char __thiscall sub_41CF00(int this);
int __thiscall sub_41CF50(int this);
int __thiscall sub_41CF80(int this, float a2);
int __thiscall sub_41CFD0(int this, float a2);
char __thiscall sub_41D010(_DWORD* this, float a2);
char __fastcall sub_41D090(int a1);
// char __userpurge sub_41D0C0@<al>(int a1@<ecx>, int a2@<ebp>, float a3);
char __thiscall sub_41D1A0(char* this);
// char __usercall sub_41D4F0@<al>(int a1@<ecx>, int a2@<ebp>);
void __thiscall sub_41D700(_DWORD* this);
void __thiscall sub_41D790(_DWORD* this);
void __thiscall sub_41D7A0(_DWORD* this);
char __thiscall sub_41D840(int this);
char __thiscall sub_41D860(int this);
char __thiscall sub_41D8A0(_BYTE* this, char a2);
int __thiscall sub_41D8B0(_DWORD* this, int a2, int a3, int a4, int a5, int a6, int a7);
int __thiscall sub_41D8E0(int this, char a2, int a3);
int __thiscall sub_41D900(_DWORD* this, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __thiscall sub_41D940(_DWORD* this, int a2, int a3);
int __thiscall sub_41D960(_DWORD* this, _DWORD* a2, _DWORD* a3);
int __thiscall sub_41D9A0(int this);
_DWORD* __thiscall sub_41D9C0(_DWORD* this);
void __thiscall sub_41DB10(_DWORD* this);
char* __thiscall sub_41DE10(_DWORD* this, char* String2, int a3, char a4, char a5, char a6, char a7);
int __thiscall sub_41E250(_DWORD* this, char* String2);
int __thiscall sub_41E2D0(_DWORD* this, _DWORD* a2, char a3, char a4);
char __stdcall sub_41E3D0(int a1);
char __thiscall sub_41E410(_DWORD* this, int a2);
unsigned int __cdecl sub_41E920(int* a1, int* a2);
void __thiscall sub_41EA30(float* this, int a2, int a3);
int __thiscall sub_41EFE0(float* this, int a2);
int __thiscall sub_41F0F0(_DWORD* this);
void __thiscall sub_41F120(int this);
void __thiscall sub_41F1A0(int this, char a2);
void __thiscall sub_41F220(int this, char a2);
int __thiscall sub_41F2A0(void** this);
// char __usercall sub_41F2F0@<al>(int a1@<ecx>, void *a2@<esi>);
int sub_41F390();
int __cdecl sub_41F3D0(float a1, float a2, float a3, float a4, float a5, float a6, float a7, int a8);
int __thiscall sub_41F5B0(int this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __thiscall sub_41F6C0(int this, float a2);
int __thiscall sub_41F790(int this, int a2);
int __thiscall sub_41F860(void** this);
// char __usercall sub_41F8F0@<al>(int a1@<ecx>, int a2@<edi>);
int sub_41F9E0();
int __cdecl sub_41FA20(int a1, char a2);
int __cdecl sub_41FBB0(int a1, int a2, int a3, float a4, float a5, int a6, float a7, float a8, float a9, float a10, float a11, float a12, float a13, float a14); // idb
int __cdecl sub_420350(_DWORD* a1, _DWORD* a2, _DWORD* a3, _DWORD* a4, int a5);
int sub_4204A0();
int sub_4204C0();
bool __cdecl sub_420600(float* a1, float* a2, int a3, int a4, int a5, float a6, float a7, float* a8, float a9, float a10, float a11, float a12);
bool __cdecl sub_420B50(float* a1, float a2, int a3, int a4, int a5, float a6, float a7, float* a8, float* a9, float a10, float a11, float a12, float a13);
float* __thiscall sub_4210B0(float* this, float* a2);
float* __thiscall sub_4210D0(float* this, float* a2, float* a3);
float* __thiscall sub_421100(float* this, float* a2);
char __thiscall sub_421110(int this, const char* a2);
char sub_421190(int a1, char* Format, ...);
char __thiscall sub_4211E0(int this, char a2);
char __thiscall sub_421280(int this);
_DWORD* __thiscall sub_4212C0(int this, int a2);
_DWORD* __thiscall sub_421300(int this, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
_DWORD* __thiscall sub_421350(int this, int a2);
int __thiscall sub_421370(_DWORD* this, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
void __thiscall sub_4213B0(int this);
int __thiscall sub_421430(_DWORD* this, int a2, int a3, int a4, int a5);
void __thiscall sub_421460(int this, int a2);
_DWORD* __thiscall sub_421540(void** this);
_DWORD* __thiscall sub_4215C0(_DWORD* this);
void __thiscall sub_4216E0(void* this);
int __thiscall sub_421810(int this, const char* a2, int a3, int a4);
_BYTE* __thiscall sub_421980(int this, int a2, unsigned int a3);
char __stdcall sub_421AB0(int a1, char* a2, float* a3, _DWORD* a4);
int __thiscall sub_421B20(_DWORD* this, int a2);
void __thiscall sub_421B40(_DWORD* this, int a2);
int __thiscall sub_421B70(int this, int a2);
char* __stdcall sub_421DB0(int a1, char a2);
double __stdcall sub_421DE0(int a1, char a2, char a3);
int __thiscall sub_421E30(_DWORD** this, float a2, float a3, float a4, int a5, float* a6);
void __thiscall sub_422000(int this);
int __cdecl sub_422080(char* FileName, _DWORD* Buffer);
_DWORD* __thiscall sub_4221E0(_DWORD* this);
void __thiscall sub_422200(int this);
void __thiscall sub_422230(int* this);
int __thiscall sub_422270(int this, int a2);
int __thiscall sub_422290(int this);
int __thiscall sub_4223D0(_DWORD* this);
_DWORD* __thiscall sub_422400(_DWORD* this, char* String1, char a3);
_DWORD* __thiscall sub_4226E0(_DWORD* this, _DWORD* a2);
int __thiscall sub_422740(_DWORD* this, int a2);
int __thiscall sub_422760(_DWORD* this, _DWORD* a2, _DWORD* a3, _DWORD* a4, _DWORD* a5);
FILE* __thiscall sub_4227C0(_DWORD* this);
double __cdecl sub_422830(float a1, float a2);
char* __cdecl sub_4228F0(char* Str);
unsigned int __cdecl sub_422950(const char* a1);
FILE* sub_4229D0(char* Format, ...);
char __cdecl sub_422AE0(LPCSTR lpFileName);
char __cdecl sub_422B20(char* FileName);
int __cdecl sub_422B60(int a1, const char* a2);
INT __cdecl sub_422BA0(CHAR* lpAppName, LPCSTR lpKeyName, INT nDefault);
char __cdecl sub_422C40(const char* phkResult, const char** a2, char a3);
int __cdecl sub_422D00(LPCSTR lpAppName, LPCSTR lpKeyName, CHAR* nSize, LPSTR lpReturnedString, char* lpDefault);
int __cdecl sub_422DC0(HKEY hKey, LPCSTR lpValueName, int Data);
int __cdecl sub_422E60(CHAR* lpAppName, LPCSTR lpKeyName, LPCSTR lpString);
bool __cdecl sub_422EF0(LPCSTR lpFileName);
char __cdecl sub_422F40(const char* a1);
const void* __thiscall sub_423060(_DWORD* this, int a2);
double __thiscall sub_4230F0(_DWORD* this);
double __thiscall sub_423120(int* this);
void* sub_4231A0();
int __cdecl sub_4231C0(int a1);
int sub_423230();
int __cdecl sub_423260(unsigned __int8* a1, int a2, unsigned int a3);
int sub_4232B0();
int __cdecl sub_423310(unsigned int a1, char a2);
FILE* __cdecl sub_423340(char* FileName, unsigned int a2);
int __thiscall sub_4233C0(int this, int a2, const char* a3);
void __thiscall sub_4234A0(void* this);
char __thiscall sub_423520(int this, char a2);
char __thiscall sub_423600(_DWORD* this);
const char* __thiscall sub_4242F0(_DWORD** this, char* String2);
const char* __thiscall sub_424300(_DWORD** this, int a2, int a3, char* String2, char a5);
const char* __thiscall sub_424350(_DWORD* this, char* String2);
int __thiscall sub_424390(_DWORD* this, int a2);
_DWORD* __thiscall sub_4243A0(_DWORD* this);
void __thiscall sub_424520(int this);
char __thiscall sub_424630(int* this);
void __thiscall sub_4246F0(int* this);
char __thiscall sub_424730(_DWORD* this, int a2);
void __thiscall sub_424C80(_DWORD* this, int a2);
char __thiscall sub_424E30(_DWORD* this, int a2);
char __thiscall sub_425030(_DWORD* this, int ArgList, int a3);
int __thiscall sub_425140(int this);
int __thiscall sub_425F60(int this);
const char* __thiscall sub_426000(_DWORD* this, char* String2);
const char* __thiscall sub_426040(_DWORD* this, char* String2);
char __thiscall sub_426060(int this, int a2, int ArgList);
char __thiscall sub_4261C0(_DWORD* this, char* String2, char a3);
int __thiscall sub_4262D0(int* this);
char __stdcall sub_4263C0(int a1, int a2);
char __stdcall sub_4263D0(int a1, int a2, int a3);
_DWORD* __thiscall sub_4263E0(_DWORD* this, int a2);
int sub_426580();
// int unknown_libname_1(); weak
// void __cdecl unknown_libname_2(); idb
int sub_4265C0();
// int unknown_libname_3(); weak
// void __cdecl unknown_libname_4(); idb
int sub_426600();
// int unknown_libname_5(); weak
// void __cdecl unknown_libname_6(); idb
int sub_426640();
// int unknown_libname_7(); weak
// void __cdecl unknown_libname_8(); idb
int sub_426680();
// int unknown_libname_9(); weak
// void __cdecl unknown_libname_10(); idb
int sub_4266C0();
// int unknown_libname_11(); weak
// void __cdecl unknown_libname_12(); idb
int sub_426700();
// int unknown_libname_13(); weak
// void __cdecl unknown_libname_14(); idb
int sub_426740();
// int unknown_libname_15(); weak
// void __cdecl unknown_libname_16(); idb
int sub_426780();
// int unknown_libname_17(); weak
// void __cdecl unknown_libname_18(); idb
int sub_4267C0();
// int unknown_libname_19(); weak
// void __cdecl unknown_libname_20(); idb
int sub_426800();
// int unknown_libname_21(); weak
// void __cdecl unknown_libname_22(); idb
int sub_426840();
// int unknown_libname_23(); weak
// void __cdecl unknown_libname_24(); idb
int sub_426880();
// int unknown_libname_25(); weak
// void __cdecl unknown_libname_26(); idb
char sub_4268C0();
void sub_426D40();
LRESULT __stdcall sub_426E30(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
int __cdecl sub_426F50(int a1);
LONG __stdcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS* ExceptionInfo); // idb
char* __cdecl sub_426FE0(int a1);
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
int __cdecl sub_4278D0(int a1, int a2, int a3);
int __cdecl sub_4278F0(int a1, int a2, int a3);
// int __usercall sub_427950@<eax>(int a1@<edi>, void *a2@<esi>);
int sub_427B80();
char sub_427CB0();
int sub_427CF0();
int sub_427EA0();
bool __cdecl sub_427EB0(int* a1);
void __noreturn sub_4281B0(char* Format, ...);
char sub_4282E0(char a1, char* Format, ...);
void sub_428420();
void __thiscall sub_428580(void* this);
char __thiscall sub_428590(_DWORD* this, int a2, int a3);
char __thiscall sub_4285C0(_DWORD* this, int a2);
char __thiscall sub_4285F0(_DWORD* this, int a2, int a3);
char __thiscall sub_428620(_DWORD* this, int a2);
char __thiscall sub_428650(int this);
int __thiscall sub_428680(_DWORD* this, int a2);
int __thiscall sub_4286C0(_DWORD* this, int a2);
void __thiscall sub_428720(_DWORD* this);
int __cdecl sub_428780(LPWSTR lpWideCharStr, LPCCH lpMultiByteStr, unsigned int a3);
void __cdecl sub_4287D0(LPSTR lpMultiByteStr, wchar_t* String, size_t a3);
LPCCH __cdecl sub_428820(LPWSTR lpWideCharStr, LPCCH lpMultiByteStr, unsigned int a3);
void __cdecl sub_428840(LPSTR lpMultiByteStr, wchar_t* String, size_t a3);
int** __thiscall sub_428860(int** this, char* FileName);
int __thiscall sub_428C90(_DWORD* this);
bool __thiscall sub_428CD0(_DWORD* this);
int __thiscall sub_428D50(_DWORD* this, const char* a2);
char __thiscall sub_428DE0(_DWORD* this, char a2);
void __thiscall sub_428E30(int* this);
void __thiscall sub_428E50(int this);
int __thiscall sub_428EB0(void* this);
int __thiscall sub_428EC0(void* this, int a2);
int __thiscall sub_428EE0(void* this, int a2);
int __thiscall sub_428F00(void* this);
int __thiscall sub_428F10(void* this);
int __thiscall sub_428F20(int* this);
int __thiscall sub_428F60(int* this);
int __thiscall sub_428F80(void* this, int a2);
int __cdecl sub_429090(LPSTR lpFilename, int a2); // idb
int __thiscall sub_4291F0(_DWORD* this, const void* a2);
void __thiscall sub_429240(int this, int a2);
unsigned int __cdecl sub_429310(char* a1, char* a2);
unsigned int __cdecl sub_429820(_DWORD* a1, _DWORD* a2);
// _DWORD __thiscall Concurrency::details::TaskStack::TaskStack(Concurrency::details::TaskStack *__hidden this); idb
void* __thiscall sub_429A90(void* this, int a2, int a3, int a4, char* Source);
int __thiscall sub_429AD0(void* this);
int __thiscall sub_429AE0(_DWORD* this);
int __thiscall sub_429AF0(_DWORD* this);
char* __thiscall sub_429B00(char* this);
bool __thiscall sub_429B10(_DWORD* this, _DWORD* a2);
int __cdecl sub_429B40(void** a1, int a2, int a3, int a4, char* a5, int a6);
int sub_429DD0();
_DWORD* __thiscall sub_429DE0(_DWORD* this, char* FileName);
void __thiscall sub_429E40(FILE*** this);
bool __thiscall sub_429E70(_DWORD* this, _BYTE* a2, int a3);
char __thiscall sub_42A010(void* this, _BYTE* a2);
void __thiscall sub_42A070(_DWORD* this);
int __thiscall sub_42A0E0(_DWORD* this);
char __thiscall sub_42A370(_DWORD* this);
char __thiscall sub_42A390(void* this, _BYTE* a2);
bool __thiscall sub_42A400(_DWORD* this);
char __thiscall sub_42A4F0(_DWORD* this, _BYTE* a2);
char __thiscall sub_42A560(_DWORD* this, _BYTE* a2);
int __thiscall sub_42A5C0(void* this);
float* __thiscall sub_42A5F0(float* this, char* a2);
int __thiscall sub_42A770(void* this);
// int __usercall sub_42A780@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>);
int __thiscall sub_42A7A0(_DWORD* this);
// int __usercall sub_42A7C0@<eax>(int a1@<ecx>, int a2@<ebp>);
void __thiscall sub_42A840(_DWORD* this);
int __thiscall sub_42A860(int this);
void __thiscall sub_42A9D0(LPVOID* this);
int __fastcall sub_42AA30(int a1, int a2, char* k);
void __thiscall sub_42CA00(void*); // idb
int __fastcall sub_42CA20(int a1);
char __thiscall sub_42CB00(void* this);
char __thiscall sub_42CB20(_DWORD* this, int a2);
void __thiscall sub_42CB30(_DWORD* this, int ArgList, int a3);
void __thiscall sub_42E480(_DWORD* this, int ArgList, int a3, void* a4);
void __thiscall sub_42EF80(_DWORD* this, int ArgList, int a3, float* a4);
void __thiscall sub_42F620(_DWORD* this, int ArgList, int a3);
int __thiscall sub_42FB40(_DWORD* this, int* a2, int* a3, int a4, float* a5);
int __thiscall sub_42FBB0(_DWORD* this, int* a2, float a3, float a4, int a5, int a6);
unsigned int __thiscall sub_42FC10(_DWORD* this, int a2);
int __thiscall sub_42FCC0(_DWORD* this, float a2, float a3, int a4);
int __thiscall sub_42FDD0(_DWORD* this);
char __thiscall sub_42FE50(_DWORD* this);
int __thiscall sub_42FEB0(int this, float a2, float a3);
int __thiscall sub_430A90(int this);
int __thiscall sub_430BC0(int this, int* a2, int* a3, int a4, float* a5);
char __thiscall sub_430DC0(int this, int* a2, float a3, float a4, int a5, int a6);
char __thiscall sub_430F00(int this, int a2, int* a3, float a4, int a5);
char __thiscall sub_431040(int this, int a2);
int __thiscall sub_4317B0(_DWORD* this, int a2);
char __thiscall sub_4318B0(_DWORD* this);
char __thiscall sub_431A70(int this, int a2);
int __thiscall sub_433360(int this, int a2);
char __thiscall sub_4333C0(int this, int a2);
char __stdcall sub_4334A0(int a1, char a2);
void __thiscall sub_4334E0(int this, float a2);
char __cdecl sub_433790(int a1);
void __thiscall sub_433EF0(int this);
char* __thiscall sub_433F70(_DWORD* this, char* a2, unsigned int a3, const void* a4);
char* __thiscall sub_434200(_DWORD* this, char* a2, char* a3);
void sub_434250();
int __thiscall sub_434270(int this);
void __thiscall sub_435880(LPVOID* this);
char __thiscall sub_4359A0(int this, int a2);
int __thiscall sub_436A40(int this, int a2);
int __thiscall sub_436A90(int this);
int __thiscall sub_436D70(_DWORD* this);
int __thiscall sub_436DD0(_DWORD* this);
_BYTE* __thiscall sub_436E20(char* this);
int __thiscall sub_436E40(char* this, const char* a2);
unsigned int __thiscall sub_436EC0(_DWORD* this, unsigned int a2, int a3, int ArgList);
int __thiscall sub_436FA0(int this, int a2, float a3);
int __thiscall sub_436FD0(int this, int a2, float a3);
BOOL __thiscall sub_437000(float* this);
void __thiscall sub_437020(float* this, float a2, float a3);
char __thiscall sub_437180(_DWORD* this, int a2, int a3);
char __thiscall sub_4371A0(int this, char a2);
_DWORD* __thiscall sub_437450(int this, char a2);
int __thiscall sub_437540(_DWORD* this, int a2);
char __thiscall sub_4375C0(void* this, char* String1);
_DWORD* __thiscall sub_4376B0(_DWORD* this, int a2);
int __thiscall sub_4379D0(int* this, int a2, int a3, int a4);
char* __thiscall sub_437AA0(char* this, int a2, int a3);
_DWORD* __thiscall sub_437AE0(_DWORD* this);
_DWORD* __thiscall sub_437B10(_DWORD* this);
int __thiscall sub_437B40(_DWORD* this);
// void __userpurge sub_437B70(int a1@<ecx>, int a2@<ebp>, float a3);
_DWORD* __thiscall sub_4383D0(_DWORD** this, int a2);
char* __thiscall sub_438430(char* this, int a2, int a3, int a4, int a5);
int __thiscall sub_438460(_DWORD** this, int a2, float a3, float a4, float a5);
_DWORD* __thiscall sub_4385C0(_DWORD* this);
int __thiscall sub_438730(int this);
BOOL __thiscall sub_438840(_DWORD* this);
void __thiscall sub_4389A0(_DWORD* this);
void __thiscall sub_4389F0(int this, char a2);
char __thiscall sub_438A70(int this);
char* __thiscall sub_438B40(int this);
int __thiscall sub_438D00(int* this);
char __thiscall sub_438DC0(int* this);
int __thiscall sub_438FF0(_DWORD* this);
int __thiscall sub_439020(int this, int a2);
char __thiscall sub_439070(int this, int a2);
char __thiscall sub_43A080(_DWORD* this, int a2, int a3);
int __thiscall sub_43A120(int this, int a2);
_DWORD* __thiscall sub_43A180(_DWORD* this);
void __thiscall sub_43A1D0(_DWORD* this);
int __thiscall sub_43A1E0(int* this);
void __thiscall sub_43A230(int* this, int ArgList);
char __thiscall sub_43A460(_DWORD* this, int a2, char a3);
char __thiscall sub_43A480(int this, int a2, char a3);
int __thiscall sub_43A4A0(_DWORD* this);
int __thiscall sub_43A520(int* this);
// char __userpurge sub_43A540@<al>(int a1@<ecx>, int a2@<ebp>, int a3);
_DWORD* __thiscall sub_43A740(_DWORD* this, int a2);
char __thiscall sub_43A760(_DWORD** this, char* String1, int a3);
char __thiscall sub_43A840(int** this);
_DWORD* __thiscall sub_43A850(_DWORD* this, int a2);
char __thiscall sub_43A950(int this);
void __thiscall sub_43AAC0(int* this);
int __thiscall sub_43AB00(_DWORD* this);
char __thiscall sub_43AC00(int this, char* String1, int a3);
_DWORD* __thiscall sub_43AE80(_DWORD* this, int a2);
bool __thiscall sub_43AEF0(int this);
char __thiscall sub_43AF30(int this, char* String1, int a3);
char __stdcall sub_43B150(int a1, int a2, int a3);
void __thiscall sub_43B160(int this);
int __thiscall sub_43B180(_DWORD* this);
char __thiscall sub_43B2F0(_DWORD* this, int a2, int a3, int a4, int a5);
bool __thiscall sub_43B330(_DWORD* this);
_DWORD* __thiscall sub_43B390(_DWORD* this, int a2);
char __thiscall sub_43B440(int this, char* String1, int a3);
_DWORD* __thiscall sub_43B6C0(_DWORD* this, int a2);
char __thiscall sub_43B6E0(_DWORD* this, int a2, int a3, int a4);
bool __thiscall sub_43B730(int this);
char __thiscall sub_43B870(int this, char* String1, int a3);
FILE* __stdcall sub_43B9A0(int a1, int ArgList, int a3, int a4);
bool __thiscall sub_43B9E0(_DWORD* this);
_DWORD* __thiscall sub_43BA40(_DWORD* this, int a2);
char __thiscall sub_43BA60(_DWORD** this, char* String1, int a3);
char __thiscall sub_43BAF0(_DWORD* this, char* String1);
_DWORD* __thiscall sub_43BB70(_DWORD* this, int a2);
char __thiscall sub_43BB90(int this);
char __thiscall sub_43BBE0(_DWORD* this);
char __thiscall sub_43BD20(int this, char* String1, int a3);
_DWORD* __thiscall sub_43BDB0(_DWORD* this, int a2);
void __thiscall sub_43BE50(LPVOID* this);
void __thiscall sub_43BE80(int this);
FILE* sub_43BFA0();
char __thiscall sub_43BFC0(int this, char* String1, int a3);
char __thiscall sub_43C290(int this, int a2);
char __thiscall sub_43C3A0(_DWORD* this, int a2, int a3, int a4, int a5);
_DWORD* __thiscall sub_43C3D0(_DWORD* this, int a2);
char __thiscall sub_43C470(int this);
char __thiscall sub_43C4D0(int this, char* String1, int a3);
_DWORD* __thiscall sub_43C730(_DWORD* this, int a2);
char __thiscall sub_43C760(int* this);
void __thiscall sub_43C820(int* this);
char __thiscall sub_43C860(int this, int a2, int a3);
char __thiscall sub_43C8A0(int this, int a2, int a3);
// char __userpurge sub_43C8E0@<al>(int a1@<ecx>, int a2@<ebp>, int a3);
char __thiscall sub_43C930(int** this);
int __thiscall sub_43C990(int this, int a2);
void __thiscall sub_43CA50(int this);
char __thiscall sub_43CAC0(_DWORD* this, int a2, int a3, int a4, int a5);
int __thiscall sub_43CB00(_DWORD* this);
// char __userpurge sub_43CDB0@<al>(_DWORD *a1@<ecx>, int a2@<ebp>, int a3);
int __thiscall sub_43CDE0(int this);
void __thiscall sub_43CF70(_DWORD* this);
char __thiscall sub_43D010(int** this, char* String1, int a3);
_DWORD* __thiscall sub_43D040(_DWORD* this, int a2);
char __thiscall sub_43D060(_DWORD* this);
char __thiscall sub_43D0A0(int** this, char* String1, int a3);
_DWORD* __thiscall sub_43D0D0(_DWORD* this, int a2);
char __thiscall sub_43D0F0(int this);
char __thiscall sub_43D140(_DWORD** this, char* String1, int a3);
_DWORD* __thiscall sub_43D1D0(_DWORD* this, int a2);
char __thiscall sub_43D1F0(int this);
char __thiscall sub_43D240(_DWORD** this, char* String1, int a3);
_DWORD* __thiscall sub_43D280(_DWORD* this, int a2);
char __thiscall sub_43D2F0(_DWORD** this, char* String1, int a3);
char __thiscall sub_43D340(int this, int a2);
_DWORD* __thiscall sub_43D450(_DWORD* this, int a2);
const char* __thiscall sub_43D480(int this);
char __thiscall sub_43D4D0(int** this, char* String1, int a3);
_DWORD* __thiscall sub_43D580(_DWORD* this, int a2);
void __thiscall sub_43D5A0(_BYTE* this);
char __thiscall sub_43D5B0(int this, int a2);
char __thiscall sub_43D5D0(int this, char* String1, int a3);
const char** __thiscall sub_43D7C0(const char** this, int a2);
// char __userpurge sub_43D8A0@<al>(_DWORD *a1@<ecx>, int a2@<ebp>, int a3);
char __thiscall sub_43D8D0(_DWORD* this);
char __thiscall sub_43DA70(int this);
const char* __thiscall sub_43DC50(_DWORD* this);
char __thiscall sub_43DC90(_DWORD* this);
void __thiscall sub_43DD80(int* this);
char __thiscall sub_43DDF0(int this, char* String1, int a3);
_DWORD* __thiscall sub_43DE90(_DWORD* this, int a2);
void __thiscall sub_43E040(LPVOID* this);
bool __thiscall sub_43E0C0(_DWORD* this);
char __thiscall sub_43E100(int this, char* String1, int a3);
char __thiscall sub_43E540(int this, int a2);
_DWORD* __thiscall sub_43E670(_DWORD* this, _DWORD* a2, int a3, int a4, int a5);
bool __thiscall sub_43E720(int this);
int sub_43E8D0();
char __thiscall sub_43E8F0(_DWORD* this, int a2, int a3);
int __thiscall sub_43E9B0(_DWORD* this);
int __thiscall sub_43EA00(_DWORD* this, const char* a2, int a3, int a4, char a5);
char __thiscall sub_43EB00(int this, int a2);
_DWORD* __thiscall sub_43EF90(void* this, _DWORD* a2, int a3);
_DWORD* __thiscall sub_43EFC0(void* this, _DWORD* a2, const CHAR* a3, int a4);
_DWORD* __thiscall sub_43EFF0(_DWORD* this, _DWORD* a2);
float* __thiscall sub_43F030(float* this, char* a2);
int __thiscall sub_43F320(void* this);
// int __usercall sub_43F330@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>);
// unsigned int __usercall sub_43F350@<eax>(int a1@<ecx>, int a2@<ebp>);
int __thiscall sub_43F3E0(int this);
_DWORD* __thiscall sub_43F560(_DWORD* this, int a2);
int __fastcall sub_442440(int a1);
char __thiscall sub_442520(int this);
int __thiscall sub_4426B0(_DWORD* this, int ArgList, int a3);
int __thiscall sub_442EE0(_DWORD* this, int* a2, int* a3, int a4, _DWORD* a5);
int __thiscall sub_442F30(_DWORD* this, int* a2, float a3, float a4, int a5, int a6);
_WORD* __thiscall sub_442F80(_DWORD* this, _WORD* a2);
int __thiscall sub_443080(_DWORD* this);
char __thiscall sub_443130(_DWORD* this);
__int16 __thiscall sub_443180(_DWORD* this, int a2);
int __thiscall sub_4431F0(_DWORD* this, int a2, int a3);
int __thiscall sub_443210(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_443250(int this, int a2, int ArgList);
int __thiscall sub_443590(int this);
int __thiscall sub_4436D0(int* this, int a2);
BOOL __thiscall sub_4438C0(float* this);
double __thiscall sub_4438E0(float* this);
char __thiscall sub_443910(float** this, int* a2, int* a3);
// int __userpurge sub_443950@<eax>(_DWORD *a1@<ecx>, int a2@<ebx>, int *a3, int *a4, int a5, _DWORD *a6);
unsigned int __thiscall sub_443B50(int this, int* a2, float a3, float a4, float a5, int a6);
bool __thiscall sub_443CD0(int this, int a2, int a3, float a4, float a5);
char __thiscall sub_444030(_DWORD* this, char a2);
char __thiscall sub_4440B0(int this, char a2);
char __thiscall sub_4442A0(int this);
void sub_444A90();
char __thiscall sub_444AA0(int this, int a2);
int __thiscall sub_4476E0(int* this, int a2, int a3);
int __thiscall sub_447720(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_447750(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_4477A0(int this, int a2);
int __thiscall sub_4477F0(int this, int a2);
void __thiscall sub_447AA0(_DWORD* this, float a2);
char __cdecl sub_447D70(int a1);
char __thiscall sub_447D80(int this);
int __thiscall sub_4481C0(_DWORD* this);
int __thiscall sub_4481E0(_DWORD* this);
void __thiscall sub_448210(int this);
int __thiscall sub_448290(int this);
int __thiscall sub_4482D0(_DWORD* this);
_DWORD* __thiscall sub_448300(_DWORD* this, _DWORD* a2, int* a3);
void __stdcall nullsub_8(int, int);
int __thiscall sub_448350(_DWORD* this, int a2);
int __thiscall sub_448390(_DWORD* this, char* a2, unsigned int a3, const void* a4);
char* __thiscall sub_4486E0(_DWORD* this, char* a2, char* a3);
int __thiscall sub_448730(_DWORD* this);
_DWORD* __thiscall sub_448750(_DWORD* this, _DWORD* a2, _DWORD* a3);
unsigned int __thiscall sub_4487A0(_DWORD* this, char* a2, unsigned int a3, const void* a4);
char* __thiscall sub_448B20(_DWORD* this, char* a2, char* a3);
_DWORD* __stdcall sub_448B80(_DWORD* a1, _DWORD* a2, _DWORD* a3);
_DWORD* __cdecl sub_448BB0(int* a1, int* a2, _DWORD* a3);
_DWORD* __cdecl sub_448BE0(_DWORD* a1, _DWORD* a2);
void* __thiscall sub_448C00(void* this, char a2);
int __thiscall sub_448C20(int this);
_DWORD* __thiscall sub_448C90(_DWORD* this, char* a2);
int __thiscall sub_448F60(void* this);
_DWORD* __fastcall sub_448F70(_DWORD* a1, int a2, char* String1, char a4);
int __thiscall sub_449660(int** this);
int __thiscall sub_4496E0(void* this, char* a2);
int __thiscall sub_449AA0(LPVOID* this);
_DWORD* __thiscall sub_449AE0(_DWORD* this);
_DWORD* __thiscall sub_449B20(_DWORD* this);
char __thiscall sub_449B70(_DWORD* this);
int __thiscall sub_449C10(char* this);
char __thiscall sub_449C40(char* this, int a2, _DWORD* a3, _DWORD* a4, char a5, char a6, float a7, int a8);
char __thiscall sub_44A1D0(char* this, int a2, float* a3, float* a4, float a5, char a6, char a7, float a8, int a9);
float* __cdecl sub_44A250(int a1, float* a2, float* a3, float* a4, float* a5, float a6, float* a7);
double __cdecl sub_44A3E0(float* a1, float* a2, float a3, float a4);
char __thiscall sub_44A440(char* this, int a2, _DWORD* a3, _DWORD* a4, char a5, char a6);
int __thiscall sub_44A490(char* this, int a2, _DWORD* a3, float* a4, char a5, char a6);
char __thiscall sub_44A730(int this, int a2);
void __stdcall sub_44AE60(int* a1, int a2, float a3, int a4, int a5);
int __stdcall sub_44AF10(int a1);
int __stdcall sub_44AF40(int a1);
char __thiscall sub_44B390(char* this, int a2);
int __thiscall sub_44B3F0(_DWORD* this);
int __thiscall sub_44B460(_DWORD** this);
int __thiscall sub_44B470(_DWORD** this);
_DWORD* __stdcall sub_44B480(_DWORD* a1, _DWORD* a2, _DWORD* a3);
_DWORD* __thiscall sub_44B4B0(_DWORD* this, char* ArgList);
int __thiscall sub_44B5E0(LPVOID* this);
int __thiscall sub_44B620(int this);
int __thiscall sub_44B7A0(_DWORD* this);
float* __thiscall sub_44B870(float* this, char* a2);
int __thiscall sub_44C220(int this);
int __thiscall sub_44C250(_DWORD* this);
float* __thiscall sub_44C330(float* this, char* a2);
int __thiscall sub_44C460(void* this);
_DWORD* __thiscall sub_44C470(_DWORD* this, char* a2);
int __thiscall sub_44C610(void* this);
float* __thiscall sub_44C620(float* this, char* String1);
int __thiscall sub_44C710(void* this);
_DWORD* __thiscall sub_44C720(_DWORD* this, char* a2);
int __thiscall sub_44C990(LPVOID* this);
_DWORD* __thiscall sub_44C9D0(_DWORD* this);
_DWORD* __thiscall sub_44CA40(_DWORD* this, char a2);
FILE* __thiscall sub_44CA60(_DWORD* this);
char __thiscall sub_44CB20(int this);
_DWORD* __thiscall sub_44CD90(_DWORD* this, float* a2);
// char __userpurge sub_44CDD0@<al>(int a1@<ecx>, int a2@<ebp>, int a3);
int __thiscall sub_44D3B0(_DWORD* this, int a2);
int __thiscall sub_44D740(_DWORD* this);
int __thiscall sub_44D770(_DWORD* this, int a2);
int __thiscall sub_44D7B0(_DWORD* this);
int __stdcall sub_44D7C0(int a1, int* a2, _DWORD* a3);
void __stdcall sub_44D850(int a1, float* a2, _DWORD* a3, _DWORD* a4);
_DWORD* __stdcall sub_44DAD0(int* a1, float* a2, int a3, int a4);
void __thiscall sub_44DBF0(char* this, int a2, float* a3, int a4);
void __thiscall sub_44DD20(char* this, float* a2, _DWORD* a3);
void __thiscall sub_44DF20(char* this, float a2, float a3, float* a4);
int __thiscall sub_44E040(char* this, int a2, int a3, int a4, float a5, int* a6);
int __thiscall sub_44E3D0(char* this, int a2, const void* a3);
int __thiscall sub_44E6F0(_DWORD* this, int a2, const void* a3, _DWORD* a4);
char __thiscall sub_44E7B0(_DWORD* this, int a2);
char __thiscall sub_44E7D0(_DWORD* this, int a2);
char __thiscall sub_44E870(_DWORD* this);
int __thiscall sub_44E8F0(_DWORD** this);
int __thiscall sub_44E900(_DWORD** this);
int __thiscall sub_44E910(_DWORD* this);
int __thiscall sub_44E940(int* this);
int __thiscall sub_44E980(_DWORD* this);
void __thiscall sub_44E9B0(LPVOID* this);
unsigned int __thiscall sub_44E9E0(_DWORD* this, char* a2, unsigned int a3, const void* a4);
char* __thiscall sub_44ED10(_DWORD* this, char* a2, char* a3);
unsigned int __thiscall sub_44ED60(_DWORD* this, char* a2, unsigned int a3, _DWORD* a4);
_DWORD* __thiscall sub_44F0E0(_DWORD* this, _DWORD* a2, _DWORD* a3);
_DWORD* __thiscall sub_44F190(int this, _DWORD* a2, unsigned int a3, _DWORD* a4);
void __cdecl sub_44F3A0(int a1, int a2);
_DWORD* __thiscall sub_44F490(_DWORD* this, _DWORD* a2);
char __thiscall sub_44F6F0(int this);
char __thiscall sub_44F9E0(int this);
void __thiscall sub_450790(_DWORD* this);
char __thiscall sub_4507D0(int this, int a2);
char __thiscall sub_450A10(_DWORD* this, int a2, int a3);
char __thiscall sub_450A30(int this, int a2);
void __thiscall sub_450AA0(int** this, int, int);
int __thiscall sub_450AC0(int this, int a2, int a3);
char __thiscall sub_450BB0(_DWORD* this);
BOOL sub_450BC0();
int __thiscall sub_450BF0(_DWORD* this, int a2, int a3);
void __thiscall sub_450C70(_DWORD* this, int a2);
// int __usercall sub_450D30@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>);
void* __thiscall sub_450FB0(void* this, int a2, int a3, int a4);
double __thiscall sub_4510D0(float* this, float a2, float a3);
char* __thiscall sub_451390(char* this, char* FileName);
// void __thiscall unknown_libname_27(void *); idb
void __thiscall sub_451710(LPVOID* this);
void __thiscall sub_451770(int this);
int __thiscall sub_4517D0(_DWORD* this);
int __thiscall sub_451820(_DWORD* this);
int __thiscall sub_451870(_DWORD* this);
int __thiscall sub_451890(_DWORD* this);
int __thiscall sub_4518B0(char* this);
_DWORD* __thiscall sub_4519E0(_DWORD* this, char* String1);
void __thiscall sub_455730(void*); // idb
_BYTE* __thiscall sub_455750(_BYTE* this);
int __thiscall sub_4557B0(int this);
char __thiscall sub_455830(void* this);
int __thiscall sub_455850(_DWORD* this, int a2, int* a3, int a4);
int __thiscall sub_455AC0(_DWORD* this, int a2, int a3, float* a4, float* a5, float a6, float a7);
int __thiscall sub_455DC0(_DWORD* this, int a2);
int __thiscall sub_455E30(_DWORD* this);
char __thiscall sub_455ED0(_DWORD* this);
int __thiscall sub_455F20(_DWORD* this, int a2);
char __thiscall sub_455FB0(float* this, int a2);
int __thiscall sub_456000(_DWORD* this, int a2, int* a3, int a4, int a5);
int __thiscall sub_456050(_DWORD* this, float* a2, int a3, float a4, int a5, int a6);
_DWORD* __thiscall sub_4560B0(_DWORD* this, int a2, _DWORD* a3, int a4, int a5);
void __thiscall sub_456370(int this);
int __thiscall sub_4565B0(int this);
int __stdcall sub_456860(int a1);
int __thiscall sub_456870(int this, int a2, int* a3, int a4, int a5);
char __thiscall sub_456A40(int this, float* a2, int a3, float a4, int a5, int a6);
char __thiscall sub_456C50(int this, float* a2, float a3, char a4, _DWORD* a5);
int __thiscall sub_456F30(int this, float a2);
char __thiscall sub_4570A0(int this, int a2);
char __thiscall sub_458880(int this);
char __thiscall sub_4588F0(_DWORD* this, int a2);
int __thiscall sub_4589E0(_DWORD* this);
int __thiscall sub_458A00(_DWORD* this, int a2);
int __thiscall sub_458A10(int* this, _DWORD* a2);
int __thiscall sub_458BE0(_DWORD* this);
void __stdcall sub_458BF0(void* a1, int a2);
_DWORD* __stdcall sub_458C00(_DWORD* a1, _DWORD* a2, _DWORD* a3);
_DWORD* __stdcall sub_458C40(_DWORD* a1, _DWORD* a2, _DWORD* a3);
_DWORD* __cdecl sub_458C70(_DWORD* a1, _DWORD* a2, _DWORD* a3);
_DWORD* __cdecl sub_458CA0(int a1, int a2, _DWORD* a3);
_DWORD* __cdecl sub_458CD0(_DWORD* a1, _DWORD* a2);
_DWORD* __thiscall sub_458CF0(_DWORD* this);
void __thiscall sub_458DD0(void*); // idb
void __thiscall sub_458DE0(char* this);
char __fastcall sub_458EE0(int a1);
int __thiscall sub_45A420(float* this, int a2, int a3, char a4, int a5);
int __thiscall sub_45A7E0(_DWORD* this);
int __thiscall sub_45A810(_DWORD* this);
int __thiscall sub_45A840(_DWORD* this);
int __thiscall sub_45A870(_DWORD* this, int a2);
int __thiscall sub_45A890(_DWORD* this, int ArgList, int a3, int a4);
int __thiscall sub_45A920(_DWORD* this, int ArgList, int a3, int a4);
void __thiscall sub_45A9D0(_DWORD* this);
char __thiscall sub_45AA80(_DWORD* this);
BOOL sub_45AB10();
int __thiscall sub_45AB70(_DWORD* this);
int __thiscall sub_45ABF0(int this);
void __thiscall sub_45ADB0(_DWORD* this);
char __thiscall sub_45AF60(_DWORD* this);
char __thiscall sub_45B150(_DWORD* this, int ArgList, int a3, int a4);
// char __usercall sub_45B200@<al>(int *a1@<ecx>, int a2@<edi>);
char __thiscall sub_45B2B0(int this, const char* a2);
char __thiscall sub_45B3E0(int this, float* a2);
void __thiscall sub_45B4B0(_DWORD* this, int ArgList);
// char __usercall sub_45B4E0@<al>(int *a1@<ecx>, int a2@<edi>);
// char __userpurge sub_45B510@<al>(int a1@<ecx>, int a2@<edi>, int a3);
char __thiscall sub_45C640(int this, int a2);
void __thiscall sub_45C7E0(int this);
_DWORD* __thiscall sub_45C860(_DWORD* this, char a2);
void __thiscall sub_45C880(_DWORD* this);
int __thiscall sub_45C900(_DWORD* this);
unsigned int __thiscall sub_45C920(_DWORD* this, char* a2, unsigned int a3, _DWORD* a4);
_DWORD* __thiscall sub_45CC50(_DWORD* this, _DWORD* a2, _DWORD* a3);
void __thiscall sub_45CCA0(int this);
void __thiscall sub_45CD60(int this);
void __thiscall sub_45CF30(int this, char a2);
// int __usercall sub_45CFA0@<eax>(int a1@<ecx>, int a2@<ebp>);
int __thiscall sub_45D050(_DWORD* this);
// void __usercall sub_45D070(int a1@<ecx>, int a2@<ebp>);
void __thiscall sub_45D130(_DWORD* this);
_DWORD* __thiscall sub_45D180(_DWORD* this, int a2);
_DWORD* __thiscall sub_45DF90(_DWORD* this);
int __thiscall sub_45E0B0(int this);
// char __userpurge sub_45E2A0@<al>(int a1@<ecx>, int a2@<ebp>, int a3, int a4, int a5, int a6);
int __thiscall sub_45E6F0(_DWORD* this, int a2);
int __thiscall sub_45E720(int this, const char* a2, int a3);
char __thiscall sub_45E760(int this);
char __thiscall sub_45E880(int this);
int __thiscall sub_45E960(_DWORD* this, int a2);
int __thiscall sub_45E9B0(_DWORD* this, int a2, int a3);
char __thiscall sub_45EA00(_DWORD* this, int a2);
int __thiscall sub_45EA60(_DWORD* this);
int __thiscall sub_45EA80(int this, int a2);
int __thiscall sub_45EC70(_DWORD* this);
_DWORD* __thiscall sub_45ECB0(_DWORD* this);
int __thiscall sub_45ECD0(int this);
// void __userpurge sub_45ED50(int a1@<ecx>, int a2@<edi>, _DWORD *a3, _DWORD *a4);
int __thiscall sub_45EE50(int this, int a2);
int __thiscall sub_45EFA0(_DWORD* this);
int __thiscall sub_45F000(_DWORD* this);
int __thiscall sub_45F050(_DWORD* this);
int __thiscall sub_45F080(_DWORD* this);
void __thiscall sub_45F160(float* this, float* a2);
float* __thiscall sub_45F2E0(float* this, int a2, int a3, int a4, int a5, float a6);
_DWORD* __thiscall sub_45F350(_DWORD* this, int a2, char a3);
int __thiscall sub_45F3A0(char* this, int a2, bool* a3, bool* a4, _DWORD* a5);
double __thiscall sub_45F480(int this);
double __thiscall sub_45F4A0(_DWORD* this);
double __thiscall sub_45F520(int this);
char __thiscall sub_45F5C0(int this, int a2, int a3);
void __thiscall sub_45F620(int this, int a2, char a3);
// char __userpurge sub_45F9E0@<al>(int a1@<ecx>, int a2@<edi>, int a3);
int __thiscall sub_461D40(int this, int* a2, int* a3, int a4, _DWORD* a5);
void __thiscall sub_461FD0(_DWORD* this, float* a2, float a3, float a4, int a5, int a6);
void __thiscall sub_462090(int this, float a2);
void __thiscall sub_4621B0(int* this);
int __thiscall sub_462240(int this);
const char* __thiscall sub_462480(_DWORD* this, char* String1);
unsigned int __thiscall sub_4624D0(_DWORD* this, int a2);
char __thiscall sub_462520(_DWORD* this, int a2, int a3);
_DWORD* __thiscall sub_462660(_DWORD* this);
// INT __usercall sub_4626F0@<eax>(int a1@<ecx>, int a2@<edi>);
int __thiscall sub_4629B0(int this, int a2);
int __thiscall sub_4629F0(int this, int a2);
int __thiscall sub_462A80(_DWORD* this, _BYTE* a2, _BYTE* a3);
_DWORD* __thiscall sub_462B20(_DWORD* this);
_DWORD* __thiscall sub_462DD0(_DWORD* this, int a2);
int __thiscall sub_462F00(int this, int a2);
_DWORD* __thiscall sub_462F90(_DWORD* this);
_DWORD* __thiscall sub_463020(_DWORD* this);
int __thiscall sub_463070(_DWORD* this);
_DWORD* __thiscall sub_4630B0(_DWORD* this);
int __thiscall sub_4630D0(char* this);
int __thiscall sub_463110(_DWORD* this);
int __thiscall sub_463150(_DWORD* this);
int __thiscall sub_463180(_BYTE* this);
char __thiscall sub_4632B0(int this, int ArgList);
char __stdcall sub_463710(const char* a1);
unsigned int __thiscall sub_463780(_DWORD* this);
char* __thiscall sub_4638A0(int this, char* a2, unsigned int a3, _DWORD* a4);
_DWORD* __thiscall sub_463AF0(_DWORD* this, _DWORD* a2, int* a3);
_DWORD* __thiscall sub_463B30(_DWORD* this, _DWORD* a2, int a3, int a4, int a5, float a6, float a7, int a8, int a9, char* a10, int a11, int a12);
int __thiscall sub_463E00(void* this);
_DWORD* __thiscall sub_463EB0(_DWORD* this, float a2, _DWORD* a3);
// void __userpurge sub_463F60(int a1@<ecx>, int a2@<edi>, float a3);
int __thiscall sub_4645D0(int* this, int a2);
_DWORD* __thiscall sub_464730(_DWORD* this);
void __thiscall sub_464780(_DWORD* this);
BOOL __thiscall sub_4647E0(_DWORD* this);
int sub_4647F0();
char* __stdcall sub_464800(int a1);
// char __userpurge sub_464810@<al>(_DWORD *a1@<ecx>, int a2@<ebp>, int a3, int a4);
char __thiscall sub_4649C0(int this, int a2);
int __thiscall sub_464A40(int this, int a2);
// int __usercall sub_464AA0@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>);
int __thiscall sub_464AC0(_DWORD* this);
// char __usercall sub_464AE0@<al>(int a1@<ecx>, int a2@<ebp>);
void __thiscall sub_464BB0(_DWORD* this);
int __thiscall sub_464C00(_DWORD* this);
_DWORD* __thiscall sub_464C90(_DWORD* this, int a2);
int __fastcall sub_465C10(int a1);
int __thiscall sub_465C60(LPVOID* this);
char __thiscall sub_465CD0(void* this);
int __thiscall sub_465CF0(_DWORD* this, int* a2, int* a3, int a4, float* a5);
int __thiscall sub_465D40(_DWORD* this, int* a2, float a3, float a4, char a5, int a6);
int __thiscall sub_465D90(_DWORD* this, int a2);
int __thiscall sub_465E00(_DWORD* this, int a2, int a3);
int __thiscall sub_465F20(_DWORD* this);
char __thiscall sub_465FB0(_DWORD* this);
_DWORD* __thiscall sub_465FF0(_DWORD* this, int a2, int a3);
int __thiscall sub_466370(_DWORD* this);
int __thiscall sub_466410(int this, int* a2, int* a3, int a4, float* a5);
bool __thiscall sub_4665E0(int this, int* a2, float a3, float a4, char a5, int a6);
bool __thiscall sub_4666E0(char* this, int a2, int a3, float a4, char a5);
int __thiscall sub_466AA0(int this);
char __thiscall sub_466D00(int this, int a2);
int __thiscall sub_467A00(int this, int a2);
char __thiscall sub_467A50(int this, char a2);
char __thiscall sub_467B60(int this, int a2);
void __thiscall sub_467BA0(int this, float a2);
char __cdecl sub_467E30(int a1);
// int __usercall sub_468000@<eax>(int a1@<ecx>, int a2@<ebp>);
void __thiscall sub_468370(int this);
int __thiscall sub_468400(int this, float a2);
// void __userpurge sub_4685D0(int a1@<ecx>, int a2@<edi>, char *String2, int a4, float a5, float a6, float a7);
int __stdcall sub_468750(_DWORD* a1, float a2);
int __thiscall sub_4687D0(int* this, int a2, int a3);
// int __usercall sub_468A00@<eax>(int a1@<ecx>, int a2@<ebp>);
double __thiscall sub_468BE0(int* this, int a2, int a3, int* a4);
char __thiscall sub_468CA0(int* this, float* a2, int* a3, float* a4, int* a5);
_DWORD* __thiscall sub_468E90(_DWORD** this, int a2);
char __thiscall sub_468F60(int this, int a2);
int __thiscall sub_468F80(int this, int a2);
int __fastcall sub_468FA0(int a1);
void* __thiscall sub_468FF0(void* this, char* a2);
int __thiscall sub_4690A0(void* this);
int __thiscall sub_4690E0(_DWORD* this);
int __thiscall sub_469120(_DWORD* this);
unsigned int __thiscall sub_469160(int this, _DWORD* a2, const char* a3, const char* a4);
unsigned int __thiscall sub_469370(int this, _DWORD* a2);
void* __thiscall sub_4694A0(void* this);
void __thiscall sub_469580(void* this);
int __thiscall sub_469650(_DWORD* this, char* String2, char* a3, char a4);
BOOL __stdcall sub_4696E0(int a1, char* String2);
int __thiscall sub_469700(_DWORD* this, int a2, const char* a3);
char __thiscall sub_4697A0(int this);
int __cdecl sub_46A230(const void* a1, const void* a2); // idb
int __thiscall sub_46A280(int this, const char* a2);
char __thiscall sub_46A340(int this);
char __thiscall sub_46A3A0(_BYTE* this, LPCSTR lpFileName);
int __thiscall sub_46A410(int this, const void* a2, unsigned int a3);
char __thiscall sub_46A490(_BYTE* this);
int __thiscall sub_46A4A0(_DWORD* this, int a2);
int __thiscall sub_46A4C0(int this, const void* a2, unsigned int a3);
int __thiscall sub_46A570(_DWORD* this, char* a2, unsigned int a3, const void* a4);
// int sf_close();
// int __cdecl sf_open_read(_DWORD, _DWORD); weak
// int __cdecl sf_read_short(_DWORD, _DWORD, _DWORD); weak
// HRESULT __stdcall DirectSoundCreate(LPCGUID pcGuidDevice, LPDIRECTSOUND *ppDS, LPUNKNOWN pUnkOuter);
// int __stdcall DirectInputCreateA(int, int, int, int);
BOOL __cdecl sub_46B940(float a1, float a2);
_DWORD __stdcall sub_46B970(_DWORD, _DWORD); // weak
float* __stdcall sub_46B976(float*, float*, float*);
_BYTE* __stdcall sub_46B97C(_BYTE*, _BYTE*, _BYTE*);
int __stdcall sub_46B982(int a1, int a2);
float* __stdcall sub_46B9FD(float* a1, float* a2, float* a3);
int __stdcall sub_46BDA2(int a1, int a2, int a3, int a4);
int __stdcall sub_46BE02(int a1, int a2, int a3, int a4);
float* __stdcall sub_46BE62(float* a1, float a2);
float* __stdcall sub_46BEE6(float* a1, float a2);
float* __stdcall sub_46BF69(float* a1, float a2);
float* __stdcall sub_46BFED(int a1, int a2, float a3);
float* __stdcall sub_46C107(float* a1, float* a2);
int __stdcall sub_46C1FD(int a1, float a2, float a3, float a4, float a5); // idb
double __cdecl sub_46C29E(float* a1);
float* __stdcall sub_46C2C4(float* a1, float a2, float a3, float a4);
float* __stdcall sub_46C3AA(float* a1, float* a2, float* a3, float a4);
float* __stdcall sub_46C4AC(float* a1, float* a2, float* a3, float* a4);
float* __stdcall sub_46C53F(float* a1, float* a2);
float* __stdcall sub_46C5C5(float* a1, float* a2, float* a3);
float* __stdcall sub_46C69B(float* a1, float a2, float a3, float a4);
float* __stdcall sub_46C6DE(float* a1, float* a2, float* a3, float* a4);
void* __thiscall sub_46C80E(void* this);
float* __thiscall sub_46C811(float* this, unsigned int a2);
int __stdcall sub_46C866(int a1, int a2, int a3, int(__thiscall* a4)(int));
unsigned int* __thiscall sub_46C888(unsigned int* this, unsigned int a2);
int __stdcall sub_46C967(float* a1, unsigned int a2, unsigned int a3, float* a4, float* a5);
_DWORD* __cdecl sub_46CAA2(int a1);
// int __usercall sub_46CAC9@<eax>(int a1@<eax>, _DWORD *a2@<ecx>);
// int __usercall sub_46CB5B@<eax>(int a1@<eax>, int a2@<edi>, unsigned int *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6, int a7, unsigned int *a8, unsigned int a9, int a10);
int __stdcall sub_46CF1A(int a1, int a2, int* a3, int a4, int a5, int a6, int a7, int* a8, int* a9, int a10);
int __stdcall sub_46D19F(int a1, int a2, int* a3, int a4, int a5, int* a6, int* a7, int a8);
int __stdcall sub_46D30C(int a1, int a2, unsigned int a3, int* a4);
int __stdcall sub_46D461(int a1, unsigned __int8* a2, unsigned int a3, int a4, int a5, unsigned int a6, int a7, unsigned int a8, BOOL a9, int* a10, int* a11, int a12, _DWORD* a13, char* a14, int* a15);
int __stdcall sub_46D89A(int a1, const WCHAR* a2, int a3, int a4, unsigned int a5, int a6, unsigned int a7, BOOL a8, int* a9, int* a10, int a11, _DWORD* a12, char* a13, int* a14);
void sub_46D8FD(int a1, char* Format, ...);
BOOL __stdcall sub_46D957(const char* ArgList, int a2, const char* a3);
_DWORD* __thiscall sub_46DA95(_DWORD* this);
int __thiscall sub_46DA9F(_DWORD* this);
void __thiscall sub_46DABD(int this);
void* __thiscall sub_46DADF(void* this, char a2);
unsigned int* __cdecl sub_46DAFE(unsigned int a1, signed int a2, int a3);
int __thiscall sub_46DE48(_DWORD* this);
int __thiscall sub_46E258(_DWORD* this);
float* __thiscall sub_46E785(float* this, float* a2, float* a3);
float* __thiscall sub_46E7B3(float* this, float* a2, float a3);
int __thiscall sub_46E7DF(_DWORD* this);
int __thiscall sub_46E96A(_DWORD* this);
int __thiscall sub_46EAAE(_DWORD* this);
int __thiscall sub_46EBB4(_DWORD* this);
int __thiscall sub_46ECF4(_DWORD* this);
int __thiscall sub_46EE09(_DWORD* this);
int __thiscall sub_46EF3E(_DWORD* this);
int __thiscall sub_46F081(_DWORD* this);
int __thiscall sub_46F1AB(_DWORD* this);
int __thiscall sub_46F246(_DWORD* this);
int __thiscall sub_46F37E(_DWORD* this);
int __thiscall sub_46F497(_DWORD* this);
int __thiscall sub_46F5CF(_DWORD* this);
int __thiscall sub_46F6F9(_DWORD* this);
int __thiscall sub_46F82B(_DWORD* this);
int __thiscall sub_46F91C(_DWORD* this);
int __thiscall sub_46FB1E(_DWORD* this);
int __thiscall sub_46FD22(_DWORD* this);
int __thiscall sub_470113(_DWORD* this);
// int *__usercall sub_470516@<eax>(unsigned int a1@<ebx>, unsigned int a2@<edi>, int a3);
int __thiscall sub_470616(int** this);
int __thiscall sub_470947(_DWORD* this);
int __thiscall sub_470E39(int** this, int a2, int a3, int* a4);
_DWORD* __thiscall sub_470F78(_DWORD* this);
void __thiscall sub_470F91(int this);
void* __thiscall sub_470FEA(void* this, char a2);
int __thiscall sub_471009(int* this, int a2, unsigned int a3);
void __cdecl __noreturn sub_4716F6(int a1);
int sub_471714(); // weak
int nullsub_2(); // weak
char __cdecl sub_471746(int a1);
_DWORD* __cdecl sub_47175E(int a1, int a2);
int __thiscall sub_471771(_DWORD* this, int a2, int a3);
int __thiscall sub_4719C6(int* this, unsigned __int8* a2, unsigned int a3);
unsigned int __thiscall sub_471E3C(_DWORD* this, _BYTE* a2, unsigned int a3);
unsigned int __cdecl sub_4720BE(jmp_buf Buf, void* a2, unsigned int a3);
void __cdecl __noreturn sub_472101(jmp_buf Buf, const char* ArgList);
void __cdecl sub_472121(int a1, const char* ArgList);
int __thiscall sub_472138(_DWORD* this, int a2, unsigned int a3);
int __thiscall sub_47264E(_DWORD* this, _DWORD* a2, unsigned int a3);
int __thiscall sub_472972(int* this, int a2, unsigned int a3);
int __thiscall sub_4729A4(int this, unsigned __int8* a2, unsigned int a3, _DWORD* a4);
_DWORD* __thiscall sub_472AF9(_DWORD* this);
int __thiscall sub_472B0B(int this, const WCHAR* lpWideCharStr, LPSTR lpMultiByteStr);
void __thiscall sub_472C9E(int this);
float* __stdcall sub_472CA9(float* a1, float* a2, float* a3);
float* __stdcall sub_472D27(float* a1, float* a2, float* a3);
float* __stdcall sub_472D71(float* a1, float* a2, float* a3);
float* __stdcall sub_472E1D(float* a1, float* a2, float* a3);
float* __stdcall sub_472E91(float* a1, float* a2, float* a3);
_BYTE* __stdcall sub_472F4B(_BYTE* a1, _BYTE* a2, _BYTE* a3);
BOOL __thiscall sub_47304C(float* this, float* a2);
char* __thiscall sub_473099(_DWORD* this, int a2, int a3, float* a4);
_BYTE* __thiscall sub_473102(_DWORD* this, int a2, int a3, float* a4);
char* __thiscall sub_473198(_DWORD* this, int a2, int a3, float* a4);
char* __thiscall sub_473210(_DWORD* this, int a2, int a3, float* a4);
__int16* __thiscall sub_47328E(_DWORD* this, int a2, int a3, float* a4);
unsigned int* __thiscall sub_4732F8(_DWORD* this, int a2, int a3, float* a4);
float* __thiscall sub_473397(float* this, float* a2, float* a3);
float* __thiscall sub_4733C5(float* this, float* a2, unsigned int a3, int a4);
_DWORD* __thiscall sub_4735C3(_DWORD* this, char a2);
void __thiscall sub_4735E3(float* this, float* a2);
int __thiscall sub_47362B(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_473703(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_473812(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_4738FF(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_4739EC(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_473AD9(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_473BE2(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_473CF1(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_473DDA(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_473E72(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_473F81(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_47406E(float* this, int a2, int a3, float* a4);
int __thiscall sub_474183(float* this, int a2, int a3, float* a4);
int __thiscall sub_47423D(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_4742F1(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_4743E0(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_4744C4(_DWORD* this, int a2, int a3, float* a4);
int __thiscall sub_47458F(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_474686(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_474785(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_4748AC(_DWORD* this, int a2, int a3, float* a4);
int __thiscall sub_474977(_DWORD* this, int a2, int a3, int a4);
int __thiscall sub_474A79(_DWORD* this, int a2, int a3, float* a4);
void __thiscall sub_474B10(int this, int a2, int a3, float* a4);
void __thiscall sub_474B9C(int this, int a2, int a3, float* a4);
void __thiscall sub_474C42(int this, int a2, int a3, float* a4);
void __thiscall sub_474CDE(int this, int a2, int a3, float* a4);
void __thiscall sub_474D83(int this, int a2, int a3, float* a4);
void __thiscall sub_474E25(int this, int a2, int a3, float* a4);
void __thiscall sub_474ED5(int this, int a2, int a3, float* a4);
void __thiscall sub_474F84(int this, int a2, int a3, float* a4);
void __thiscall sub_475026(int this, int a2, int a3, float* a4);
void __thiscall sub_475098(int this, int a2, int a3, float* a4);
void __thiscall sub_47514A(int this, int a2, int a3, float* a4);
void __thiscall sub_4751E9(int this, int a2, int a3, float* a4);
void __thiscall sub_475270(int this, int a2, int a3, _DWORD* a4);
void __thiscall sub_4752D5(int this, int a2, int a3, float* a4);
void __thiscall sub_475343(int this, int a2, int a3, float* a4);
void __thiscall sub_4753CC(int this, int a2, int a3, float* a4);
void __thiscall sub_475455(int this, int a2, int a3, float* a4);
int __thiscall sub_4754C5(int this, int a2);
int __thiscall sub_4755BD(_DWORD* this);
int __thiscall sub_4757B0(int this, unsigned int a2, unsigned int a3, int a4);
signed int __thiscall sub_475A81(_DWORD* this, int a2, int a3, const void* a4);
void __thiscall sub_475AFA(int this, int a2, int a3, void* a4);
int __thiscall sub_475B69(int this, int a2);
int __thiscall sub_475CAA(_DWORD* this);
int __thiscall sub_476004(_DWORD* this, unsigned int a2, unsigned int a3, int a4);
signed int __thiscall sub_4762B1(_DWORD* this, int a2, int a3, const void* a4);
void __thiscall sub_476337(int this, int a2, int a3, void* a4);
void __thiscall sub_4763AB(_DWORD* this);
_DWORD* __thiscall sub_4763B2(_DWORD* this, char a2);
void __thiscall sub_4763D1(int this);
void __thiscall sub_476415(LPVOID* this);
float* __cdecl sub_476468(int a1);
void* __thiscall sub_476B8B(void* this, char a2);
LPVOID* __thiscall sub_476BAA(LPVOID* this, char a2);
void* __thiscall sub_476BC9(void* this, char a2);
void __thiscall sub_476BE8(int this);
LPVOID* __thiscall sub_476BED(LPVOID* this, char a2);
void __thiscall sub_476C0C(LPVOID* this);
unsigned int __cdecl sub_476C11(_DWORD* a1, int a2, int a3);
int __cdecl sub_476CD2(int a1);
// int __usercall sub_476CDB@<eax>(int a1@<esi>);
int __cdecl sub_476E4E(_DWORD* a1);
char __cdecl sub_476EEB(int a1);
int __cdecl sub_476F95(_DWORD* a1, char a2);
// char __usercall sub_476FFA@<al>(int a1@<esi>);
_DWORD* __cdecl sub_4770A5(_DWORD* a1, int a2, int a3);
char __cdecl sub_477129(int a1);
// char __usercall sub_4771F0@<al>(int a1@<esi>);
// char __usercall sub_47727E@<al>(char a1@<cl>, int a2@<esi>, char a3);
// char __usercall sub_477579@<al>(_DWORD *a1@<esi>);
char __cdecl sub_47782B(_DWORD* a1);
char __cdecl sub_477A67(_DWORD* a1);
// char __usercall sub_477BE1@<al>(_DWORD *a1@<esi>);
// char __usercall sub_477D38@<al>(_DWORD *a1@<ebx>);
// char __usercall sub_477FCC@<al>(_DWORD *a1@<ebx>);
char __cdecl sub_4781F5(int a1);
char __cdecl sub_4782CC(_DWORD* a1);
char __cdecl sub_478368(_DWORD* a1);
char __cdecl sub_47843F(_DWORD* a1);
int __cdecl sub_4784D6(_DWORD* a1);
char __cdecl sub_4786C6(_DWORD* a1);
char __cdecl sub_478747(_DWORD* a1, int a2);
int __cdecl sub_478834(_DWORD* a1);
int __cdecl sub_478861(int a1);
void __cdecl __noreturn sub_4788E1(int a1);
int sub_4788FE(); // weak
int __cdecl sub_47891B(int* a1, int a2);
int __cdecl sub_47894E(int a1, char* Buffer); // idb
int __cdecl sub_4789E6(int* a1);
void(__cdecl __noreturn** __cdecl sub_4789FA(void(__cdecl __noreturn** a1)(int a1)))(int a1);
_BYTE* __cdecl sub_478A49(int a1, const void* a2);
_DWORD* __cdecl sub_478AD1(_DWORD* a1, int a2, int a3, int a4);
void __cdecl __noreturn sub_478AEB(jmp_buf Buf, int a2); // idb
int(__cdecl* __cdecl sub_478B0A(int a1, int a2))(int, int);
void __cdecl __noreturn sub_478B21(jmp_buf Buf, const void* a2);
int(__cdecl* __cdecl sub_478B46(int a1, const void* a2))(int, _BYTE*);
jmp_buf __cdecl sub_478B71(_BYTE* a1, int a2, int a3, int a4);
int __cdecl sub_478C74(jmp_buf Buf, int a2); // idb
unsigned int __cdecl sub_478DE7(jmp_buf Buf, int a2);
// int (__cdecl *__usercall sub_478E09@<eax>(int a1@<ebx>, jmp_buf Buf, char *a3, char *a4))(jmp_buf, int, _DWORD);
int(__cdecl* __cdecl sub_4791B0(jmp_buf Buf, char** a2))(jmp_buf, int, _DWORD);
int __cdecl sub_4791FD(int a1, void* a2, void* a3);
void __cdecl sub_479320(void** a1, void** a2, void** a3);
int __cdecl sub_4793A1(int a1, int a2, int a3);
int __cdecl sub_4793BD(int a1, int a2);
char __cdecl sub_4793D6(int a1, int a2);
int __cdecl sub_4793EF(int a1, int a2, double* a3);
int __cdecl sub_47941A(int a1, int a2, _DWORD* a3);
int __cdecl sub_479447(int a1, int a2, unsigned int* a3, _DWORD* a4, _DWORD* a5, _DWORD* a6, _DWORD* a7, _DWORD* a8, _DWORD* a9);
int __cdecl sub_479518(int a1, int a2, _DWORD* a3, _DWORD* a4);
int __cdecl sub_47954C(int a1, int a2, _DWORD* a3, _DWORD* a4, _DWORD* a5);
int __cdecl sub_4795B3(int a1);
int __cdecl sub_4795BF(int a1);
int __cdecl sub_4795DB(int a1);
int __cdecl sub_4795F8(int a1, unsigned __int8 a2, int a3);
char __cdecl sub_479646(int* a1, char* a2);
int __cdecl sub_479705(int a1);
int __cdecl sub_479711(int a1, double a2, double a3); // idb
int __cdecl sub_479748(int a1);
unsigned int __cdecl sub_479754(int a1, int a2);
void __cdecl sub_479839(int* a1, int a2);
char __cdecl sub_479949(int* a1, _BYTE* a2, unsigned __int8* a3);
int __cdecl sub_479AC0(int a1, _BYTE* a2);
unsigned int __cdecl sub_479B06(int a1, int a2, unsigned int a3, char a4);
unsigned __int8* __cdecl sub_479D3E(int* a1, _BYTE* a2, unsigned __int8* a3, int a4, char a5);
int __cdecl sub_47A08C(int* a1, int a2, int a3, int a4, int a5);
int __cdecl sub_47A294(int* a1, int a2, _WORD* a3);
int __cdecl sub_47A5E6(int* a1, char* a2, int a3, int a4);
void __cdecl sub_47A6F4(jmp_buf Buf);
void __cdecl sub_47A9FD(jmp_buf Buf);
void __cdecl sub_47AB10(jmp_buf Buf);
void __cdecl sub_47ACAF(int a1, int a2, double a3);
void __cdecl sub_47ACCB(int a1, int a2, unsigned int a3, int a4, char a5, char a6, char a7, char a8, char a9);
void __cdecl sub_47AD6C(int a1, int a2, int a3, __int16 a4);
void __cdecl sub_47AD90(int a1, int a2, char a3);
void __cdecl sub_47ADAC(int a1, int a2, char a3);
void __cdecl sub_47ADDF(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_47AE26(jmp_buf Buf, int a2, int a3); // idb
int(__cdecl* __cdecl sub_47AE50(_DWORD* a1, int a2, int(__cdecl* a3)(int, int)))(int, int);
int __cdecl sub_47AE90(int a1, unsigned int a2, unsigned int a3);
char* __cdecl sub_47AEDA(jmp_buf Buf, int a2, int a3);
void __cdecl sub_47AF2E(int a1, LPVOID lpMem);
int __cdecl sub_47AF37(int a1);
int __cdecl sub_47AF52(int a1, _BYTE* a2, unsigned int a3);
int __cdecl sub_47AF93(int a1, void* a2);
void* __cdecl sub_47AFA4(int a1);
__int16 __cdecl sub_47AFCE(_BYTE* a1, int a2);
int __cdecl sub_47B039(unsigned __int16* a1, char* a2);
// float *__usercall sub_47B061@<eax>(float *result@<eax>, int a2);
// _WORD *__usercall sub_47B093@<eax>(_BYTE *@<eax>, _WORD *);
// unsigned int __usercall sub_47B0C6@<eax>(unsigned __int16 *a1@<eax>, unsigned int *a2);
// float *__usercall sub_47B113@<eax>(float *result@<eax>, float *a2@<ecx>);
// float *__usercall sub_47B1B2@<eax>(unsigned __int16 *a1@<edi>, float *a2, float *a3, int a4);
// float *__usercall sub_47B28E@<eax>(float *a1@<edx>, float *a2@<edi>);
// __int16 __usercall sub_47B3C0@<ax>(_BYTE *a1@<edi>, int a2@<esi>, unsigned __int16 a3);
__int16 __cdecl sub_47B421(_BYTE* a1, int a2, int a3, int a4);
char __cdecl sub_47B8BE(unsigned __int16* a1, char* a2);
int __cdecl sub_47B9A3(int a1, char* a2);
int __cdecl sub_47B9F1(unsigned __int16* a1, char* a2);
__int16 __cdecl sub_47BAF1(_BYTE* a1, int a2);
__int16 __cdecl sub_47BB23(_BYTE* a1, _WORD* a2);
__int16 __cdecl sub_47BB7C(_BYTE* a1, int a2);
int __cdecl sub_47BCD2(int a1, int a2);
int __cdecl sub_47BCE4(int a1, int a2);
const void** __cdecl sub_47BCFE(int a1, int a2, int a3, int a4, int a5, unsigned int a6);
int __cdecl sub_47BD45(const void* a1, void* a2, int a3);
int __cdecl sub_47BD68(void* a1, unsigned int a2);
unsigned int sub_47BD85();
// int __usercall sub_47BDB7@<eax>(int a1@<esi>);
// int __usercall sub_47BF72@<eax>(int *a1@<esi>);
// void __usercall sub_47C0E8(int a1@<ebx>);
int __cdecl sub_47C17A(int a1);
int __cdecl sub_47C1B7(_DWORD* a1);
int __cdecl sub_47C24D(int a1);
_DWORD* __cdecl sub_47C287(int a1);
int __cdecl sub_47C29B(int a1);
int __cdecl sub_47C2DF(_DWORD* a1, unsigned int a2, unsigned int a3);
_DWORD* __cdecl sub_47C3FD(_DWORD* a1, unsigned int a2, unsigned int a3);
int __cdecl sub_47C4AC(_DWORD* a1, unsigned int a2, unsigned int a3, unsigned int a4);
int __cdecl sub_47C53E(_DWORD* a1, unsigned int a2, int a3, signed int a4);
int __cdecl sub_47C5DC(_DWORD* a1, unsigned int a2, char a3, int a4, int a5, int a6);
int __cdecl sub_47C63D(_DWORD* a1, unsigned int a2, char a3, int a4, int a5, int a6);
int __cdecl sub_47C69E(_DWORD* a1);
// int __usercall sub_47C81D@<eax>(int a1@<esi>, int a2, char a3);
// int __usercall sub_47C8A5@<eax>(int a1@<esi>, int a2, char a3);
int __cdecl sub_47C930(int a1, int a2, unsigned int a3, unsigned int a4, char a5);
int __cdecl sub_47CA4E(int a1, int a2, unsigned int a3, unsigned int a4, char a5);
_DWORD* __cdecl sub_47CB71(_DWORD* a1, unsigned int a2);
int __cdecl sub_47CC52(int a1);
_DWORD* __cdecl sub_47CC85(_DWORD* a1);
int __cdecl sub_47CD3C(int a1);
int __cdecl sub_47CD61(int a1);
int __cdecl sub_47CD7F(int a1);
int __cdecl sub_47CD9E(int a1);
char __fastcall sub_47CDBD(int a1, int a2);
char __cdecl sub_47CE2E(int a1);
// int __usercall sub_47D01D@<eax>(int a1@<ebx>);
int __cdecl sub_47D24A(int a1);
int __cdecl sub_47D37A(int a1);
int __cdecl sub_47D39E(int a1);
int __cdecl sub_47D3D1(_DWORD* a1);
int __cdecl sub_47D414(_DWORD* a1);
int __cdecl sub_47D455(_DWORD* a1, int a2, _BYTE* a3, int a4);
int __cdecl sub_47D53A(_DWORD* a1, _BYTE* a2, int a3);
int __cdecl sub_47D552(int* a1, int a2);
void* __cdecl sub_47D8C7(int a1);
void __cdecl sub_47D90B(LPVOID lpMem);
void* __cdecl sub_47D91C(jmp_buf Buf, size_t Size);
void __cdecl sub_47D953(int a1, LPVOID lpMem);
void* __cdecl sub_47D96D(int a1, void* a2, const void* a3, unsigned int a4);
// char *__usercall sub_47D991@<eax>(int a1@<ebx>, int a2, char *a3, char a4, unsigned int a5);
int __cdecl sub_47D9C3(unsigned __int8* a1);
int __cdecl sub_47D9E9(int Buf, _BYTE* a2, unsigned int a3);
BOOL __cdecl sub_47DA03(jmp_buf Buf);
unsigned __int8 __cdecl sub_47DA61(jmp_buf Buf, unsigned __int8* a2);
char __cdecl sub_47DAC5(int a1, char* a2, int a3);
void __cdecl sub_47DCDB(int* a1, int a2, int a3);
char __cdecl sub_47DFA4(int a1, int a2, _BYTE* a3, unsigned __int8* a4, int a5);
char* __cdecl sub_47E11F(jmp_buf Buf);
int __cdecl sub_47E2BE(jmp_buf Buf, unsigned int a2);
void __cdecl sub_47E34C(jmp_buf Buf, int a2, int a3);
void __cdecl sub_47E542(jmp_buf Buf, int a2, int a3);
int __cdecl sub_47E66C(jmp_buf Buf, int a2, unsigned int a3);
void __cdecl sub_47E6B6(jmp_buf Buf, int a2, unsigned int a3);
void __cdecl sub_47E7C1(jmp_buf Buf, int a2, unsigned int a3);
void __cdecl sub_47E8B0(jmp_buf Buf, int a2, size_t Size);
int __cdecl sub_47EA58(jmp_buf Buf, int a2, unsigned int a3);
// int __usercall sub_47EAA3@<eax>(int a1@<ebx>, jmp_buf Buf);
int __cdecl sub_47ECCF(int a1, _BYTE* a2, unsigned int a3);
void* __cdecl sub_47EDD8(int a1, size_t Size);
void __cdecl sub_47EDE6(int a1, LPVOID lpMem);
// int std::_Unchecked<std::_Vector_val<std::_Simple_types<void *>>>(); weak
int __cdecl sub_47EDFC(int a1);
int sub_47EE13();
int __cdecl nullsub_3(_DWORD); // weak
// int __usercall sub_47EE17@<eax>(int a1@<esi>);
// int __usercall sub_47EEBF@<eax>(_DWORD *a1@<edi>);
// int __usercall sub_47EFF0@<eax>(_DWORD *a1@<edi>);
// int __usercall sub_47F0C4@<eax>(_DWORD *a1@<esi>);
int __cdecl sub_47F15A(_DWORD* a1, int a2, int a3, int a4);
unsigned int __cdecl sub_47F1C2(_DWORD* a1, int a2, unsigned int* a3, unsigned int a4);
int __cdecl sub_47F2CA(int a1, int a2, int a3, int a4);
int __cdecl sub_47F2ED(_DWORD* a1, int a2);
int __cdecl sub_47F357(int a1, char a2);
_DWORD* __thiscall sub_47F42A(_DWORD* this);
_DWORD* __cdecl sub_47F469(_DWORD* a1);
int __cdecl sub_47F47C(_DWORD* a1, int a2);
int sub_47F656();
int __cdecl sub_47F659(_DWORD* a1);
int __cdecl sub_47F7F8(int a1, int a2);
// char __usercall sub_47F95E@<al>(int a1@<esi>);
int __cdecl sub_47FA41(_DWORD* a1, int a2);
void __cdecl sub_47FF6B(int a1);
int __cdecl sub_47FFA9(int a1, char a2);
int __cdecl sub_4800A1(int a1, int a2, int a3);
char __cdecl sub_48024B(unsigned __int8** a1, int a2, int a3, int a4);
int __cdecl sub_480335(int a1, int a2, int a3, int a4, int a5);
char __cdecl sub_48041F(_DWORD* a1);
char __cdecl sub_48047E(_DWORD* a1, int a2);
int __cdecl sub_48084B(_DWORD* a1);
_DWORD* __cdecl sub_48097A(int a1);
// char __usercall sub_4809B7@<al>(_DWORD *a1@<edi>);
char __cdecl sub_480A10(_DWORD* a1, int a2);
char __cdecl sub_480C0D(_DWORD* a1, int* a2);
char __cdecl sub_480E36(_DWORD* a1, int a2);
char __cdecl sub_480F18(_DWORD* a1, int* a2);
int __cdecl sub_481286(int* a1);
int __cdecl sub_481529(int a1);
int __cdecl sub_48158D(_DWORD* a1);
_DWORD* __cdecl sub_481744(int a1);
int __cdecl sub_4817B8(int a1, int a2, int a3, int a4, int a5, _DWORD* a6, int a7);
unsigned int __cdecl sub_48181D(_DWORD* a1, int a2, int a3, int a4, int a5, _DWORD* a6);
unsigned int __cdecl sub_4818AD(_DWORD* a1, int a2, int a3, int a4, int a5, _DWORD* a6, int a7);
int __cdecl sub_481939(int a1, int a2);
int(__cdecl** __cdecl sub_4819E1(int a1, char a2))(int a1, int a2);
int __cdecl sub_481A65(_DWORD* a1);
_DWORD* __cdecl sub_481A82(_DWORD* a1, int a2, _DWORD* a3, int a4, int a5, _DWORD* a6, int a7);
_DWORD* __cdecl sub_481B48(int a1, int a2, int a3, _DWORD* a4);
_DWORD* __cdecl sub_481B55(int a1, int a2, int a3, _DWORD* a4);
const void** __cdecl sub_481B60(unsigned int* a1, int a2, char** a3, int* a4);
_BYTE*** __cdecl sub_481C3D(int a1, int a2, int a3, _BYTE*** a4);
const void** __cdecl sub_481C94(int a1, int a2, char** a3, int* a4);
int __cdecl sub_481CFE(int a1, int a2, int a3, _BYTE*** a4);
unsigned __int8** __cdecl sub_481DA2(unsigned __int8** a1, int a2, unsigned __int8** a3, int* a4);
int __cdecl sub_481EA9(int a1);
// int __usercall sub_48206A@<eax>(int a1@<eax>);
_BYTE* __cdecl sub_48211A(int a1, int a2, int a3, _DWORD* a4, _BYTE* a5);
const void** __cdecl sub_482185(int a1, int* a2, int a3, int a4, int a5);
_BYTE* __cdecl sub_4821A8(_DWORD* a1, _DWORD* a2, int a3, _BYTE** a4, int a5);
_BYTE* __cdecl sub_4822DA(_DWORD* a1, _DWORD* a2, int a3, int* a4, int a5);
int __cdecl sub_48261E(int a1);
// int __usercall sub_482740@<eax>(int a1@<eax>);
int __cdecl sub_4827F0(int a1);
const void** __cdecl sub_482808(int a1, int a2, const void** a3, int a4, int a5, _DWORD* a6, int a7);
int __cdecl sub_4828AE(int a1, int a2, _DWORD* a3, int a4, int a5, _DWORD* a6);
_BYTE* __cdecl sub_4828DF(_DWORD* a1, _DWORD* a2, int a3, _BYTE** a4);
char __cdecl sub_482A35(_DWORD* a1, _DWORD* a2, int a3, int a4);
int __cdecl sub_482C1B(int a1);
_WORD* __cdecl sub_482C93(int a1, _WORD* a2, int a3, int a4);
// int __usercall sub_482CFF@<eax>(int a1@<eax>, int *a2@<esi>);
int __cdecl sub_483037(int a1, int a2, int a3, int a4);
// int __usercall sub_48318A@<eax>(int *a1@<eax>, int a2@<esi>, int a3);
// int __usercall sub_4832C2@<eax>(int a1@<edi>, int a2);
// int __usercall sub_48334F@<eax>(int a1@<eax>, int a2@<edi>, int a3, int a4, int a5);
int __cdecl sub_4834CF(int a1, int a2, int a3, int a4, int a5, int a6, _BYTE* a7);
// _WORD *__usercall sub_4835E9@<eax>(int a1@<eax>, int a2, int a3, int a4);
int __cdecl sub_4836B9(int a1, int a2, _DWORD* a3, int a4);
__int16 __cdecl sub_483762(_DWORD* a1, int a2, _DWORD* a3, int a4);
// int __usercall sub_4839D0@<eax>(int a1@<eax>);
int __cdecl sub_483A60(int a1);
int __cdecl sub_483A85(_DWORD* a1, char a2);
int __cdecl sub_483B87(int a1);
int __cdecl sub_483B99(int a1);
int __cdecl sub_483CB6(_DWORD* a1, char* a2);
// int __usercall sub_483D81@<eax>(_DWORD *a1@<esi>);
int __cdecl sub_483EAE(_DWORD* a1);
// void __usercall sub_483FD9(int a1@<edi>);
int __cdecl sub_48409E(_DWORD* a1, int a2, _DWORD* a3, int a4);
int __cdecl sub_484126(int a1, int a2, _DWORD* a3, int a4);
int __cdecl sub_4841B3(_DWORD* a1, int a2, void** a3, int a4);
_DWORD* __cdecl sub_48429E(int a1, int a2, _BYTE** a3, int a4);
char __cdecl sub_48439D(_DWORD* a1, int a2, void** a3, int a4);
// int __usercall sub_484521@<eax>(_DWORD *a1@<esi>);
void __cdecl sub_48455F(_DWORD* a1);
int __cdecl sub_484630(int a1);
int __cdecl sub_484647(_DWORD* a1);
int(__cdecl* __cdecl sub_4846D1(_DWORD* a1, int a2, _DWORD* a3))(_DWORD, _DWORD, _DWORD);
_DWORD* __cdecl sub_48473D(int a1, int a2, int a3);
int __cdecl sub_4847CB(int* a1, int* a2, int a3);
int __cdecl sub_484F66(_DWORD* a1, int a2);
int __cdecl sub_484F9C(unsigned int a1, unsigned __int8* a2, unsigned int a3);
int __cdecl sub_4850B5(int a1, int a2, int a3);
_BYTE* __cdecl sub_4850C7(int a1, int a2, int a3, int a4, int a5);
_BYTE* __cdecl sub_4853DC(int a1, int a2, int a3, int a4, int a5);
char __cdecl sub_48559A(int a1, int a2, __int16* a3, _DWORD* a4, int a5);
int __cdecl sub_4855D7(int a1, int a2, __m64* a3, int a4, int a5);
char __cdecl sub_485623(int a1, int a2, __m64* a3, _DWORD* a4, int a5);
char __cdecl sub_48566F(int a1, int a2, __int16* a3, int a4, int a5);
int __cdecl sub_485A50(char a1, char a2, int a3, int a4, int a5);
int __cdecl sub_485A84(_DWORD* a1, int a2, int a3);
int __cdecl sub_485FE8(int a1, int a2);
// int __usercall sub_485FFB@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, unsigned int a4, int a5, int a6, _DWORD *a7, int a8, unsigned int *a9, unsigned int *a10);
int __cdecl sub_486393(_DWORD* a1, unsigned int* a2, _DWORD* a3, int a4, int a5);
int __cdecl sub_486412(unsigned int a1, unsigned int a2, _DWORD* a3, unsigned int* a4, unsigned int* a5, _DWORD* a6, _DWORD* a7, int a8, int a9);
int __cdecl sub_486515(_DWORD* a1, _DWORD* a2, _DWORD* a3, _DWORD* a4);
int __cdecl sub_486544(_DWORD* a1, _DWORD* a2, int a3);
int __cdecl sub_486659(__int16* a1, __int16* a2, int* a3, int a4, int a5, int a6);
int __cdecl sub_486ABB(__m64* a1, __m64* a2, __m64* a3, int a4, int a5, int a6);
__int16 __cdecl sub_4871C8(_WORD* a1, _WORD* a2, _WORD* a3, int a4, int a5, int a6);
char __cdecl sub_487523(__m64* a1, __m64* a2, __m64* a3, _DWORD* a4, int a5, int a6);
int __cdecl sub_4882D2(int a1, int a2, int a3, int a4, _DWORD* a5, unsigned __int8** a6);
// int __stdcall WSACleanup();
// struct hostent *__stdcall gethostbyname(const char *name);
// int __stdcall gethostname(char *name, int namelen);
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
void __cdecl sub_4885A6(LPVOID lpMem);
// double __usercall sub_48861D@<st0>(char a1@<zf>, unsigned int a2@<eax>, __int16 a3@<dx>, double result@<st0>, int a5, int a6);
// double __usercall sub_4886ED@<st0>(char a1@<zf>, unsigned int a2@<eax>, __int16 a3@<dx>, double result@<st0>, int a5, int a6);
// int _snprintf(char *const Buffer, const size_t BufferCount, const char *const Format, ...);
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
void __cdecl sub_488CEE(LPVOID lpMem);
void* __cdecl sub_488DD7(LPVOID lpMem, SIZE_T dwBytes);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// void *__cdecl operator new(unsigned int); idb
// int sprintf(char *const Buffer, const char *const Format, ...);
// int __cdecl _vsnprintf(char *const Buffer, const size_t BufferCount, const char *const Format, va_list ArgList);
// void *__cdecl malloc(size_t Size);
LPVOID __cdecl sub_489562(unsigned int a1);
// void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *)); idb
// char *__cdecl strrchr(const char *Str, int Ch);
// int __cdecl fclose(FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// void __stdcall `eh vector constructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *), void (__thiscall *)(void *)); idb
size_t __cdecl sub_4898CA(void* Buffer, size_t ElementSize, size_t ElementCount, FILE* Stream);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction CompareFunction);
// int __cdecl atexit(void (__cdecl *)());
// int __cdecl fflush(FILE *Stream);
int sub_489D27();
// _DWORD __cdecl flsall(_DWORD); weak
// int __cdecl fputs(const char *Buffer, FILE *Stream);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// int __cdecl ftell(FILE *Stream);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// char *__cdecl strstr(const char *Str, const char *SubStr);
// int __cdecl atol(const char *String);
int __cdecl sub_48A1BB(char* String); // idb
// double __cdecl atof(const char *String);
size_t __cdecl sub_48A21D(void* Buffer, size_t ElementSize, size_t ElementCount, FILE* Stream);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// void __cdecl __noreturn exit(int Code);
// wchar_t *__cdecl wcscpy(wchar_t *Destination, const wchar_t *Source);
// size_t __cdecl wcslen(const wchar_t *String);
// int __cdecl _findfirst(LPCSTR lpFileName, int); idb
// int __cdecl _findnext(HANDLE hFindFile, int); idb
// int __cdecl _findclose(intptr_t FindHandle);
// double __cdecl floor(double X);
// struct tm *__cdecl localtime(const __time32_t *const Time);
// __time32_t __cdecl time(__time32_t *const Time);
// char *__cdecl asctime(const struct tm *Tm);
// char *__cdecl strchr(const char *Str, int Val);
// int sscanf(const char *const Buffer, const char *const Format, ...);
// int __cdecl tolower(int C);
// int __cdecl isupper(int C);
// int __cdecl isdigit(int C);
// int __cdecl isspace(int C);
// int __cdecl isalnum(int C);
// int __cdecl isprint(int C);
// int __cdecl getc(FILE *Stream);
// double __cdecl ceil(double X);
int __cdecl sub_48B1FD(FILE* Stream, int a2, int a3); // idb
// int __cdecl _finite(double X);
// int __cdecl _except_handler3(int, PVOID TargetFrame, int); idb
// char *__cdecl _strdup(const char *Source);
// void __cdecl __noreturn longjmp(jmp_buf Buf, int Value);
// int __cdecl _setjmp3(_DWORD, _DWORD); weak
int __cdecl sub_48B813(int a1, int a2);
// double __fastcall _startOneArgErrorHandling(_DWORD, _DWORD); weak
// double _load_CW(void); weak
// double _convertTOStoQNaN(void); weak
void __thiscall __noreturn sub_48CB2B(EXCEPTION_POINTERS* this);
// int __cdecl _output(FILE *File, int, int); idb
char __cdecl sub_48D4A3(int a1);
int sub_48D4D0();
int __cdecl sub_48D618(int a1);
// int __sbh_heap_init(); weak
// int __cdecl __sbh_find_block(_DWORD); weak
_DWORD* __cdecl sub_48D6E8(_DWORD* a1, int a2);
// int __cdecl __sbh_alloc_block(_DWORD); weak
// int __sbh_resize_block(); weak
int* sub_48E1BC();
_UNKNOWN** __cdecl sub_48E300(LPVOID* lpMem);
void __cdecl sub_48E356(int a1);
unsigned int __cdecl sub_48E418(unsigned int a1, _DWORD* a2, unsigned int* a3);
void __cdecl sub_48E46F(int a1, int a2, _BYTE* a3);
int __cdecl sub_48E4B4(unsigned int a1);
int __cdecl sub_48E6BC(int a1, unsigned int a2, unsigned int a3);
int __cdecl sub_48E7E0(int a1, _DWORD* a2, _BYTE* a3, unsigned int a4);
// _DWORD __cdecl _lock(_DWORD); weak
// _DWORD __cdecl _unlock(_DWORD); weak
// int __cdecl _callnewh(size_t Size);
// void *__cdecl memcpy_0(void *, const void *Src, size_t Size);
// void __cdecl _lock_file(FILE *Stream);
// void __cdecl _unlock_file(FILE *Stream);
// _DWORD __cdecl _stbuf(_DWORD); weak
// _DWORD __cdecl _ftbuf(_DWORD, _DWORD); weak
SIZE_T __cdecl sub_48F4F9(_DWORD* lpMem);
// void *__cdecl memset(void *, int Val, size_t Size);
// int __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_492D53(int a1, int a2);
int __cdecl sub_492D69(int a1, int a2);
int __cdecl sub_492D7F(int a1, int a2);
int __cdecl sub_492DAC(int a1, int a2);
// LONG __stdcall __CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
LONG(__stdcall* sub_493081())(struct _EXCEPTION_POINTERS* ExceptionInfo);
LPTOP_LEVEL_EXCEPTION_FILTER sub_493092();
// int __cdecl strtol(const char *String, char **EndPtr, int Radix);
// _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _strcmpi(const char *String1, const char *String2);
// int __cdecl _strnicmp(const char *String1, const char *String2, size_t MaxCount);
void sub_4986BA();
// int __stdcall DirectInputCreateA(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int sf_close(void); weak

//-------------------------------------------------------------------------
// Data declarations

// extern _UNKNOWN Direct3DCreate8; weak
_UNKNOWN* off_49901C = &loc_4013A0; // weak
void* (__thiscall* off_499040)(std::locale::facet* __hidden this, unsigned int) = &std::locale::facet::`scalar deleting destructor'; // weak
_UNKNOWN * off_499064 = &loc_402510; // weak
_UNKNOWN* off_499098 = &loc_403200; // weak
int(__stdcall* off_4990BC)(int, int, int) = &sub_405C40; // weak
_UNKNOWN* off_4990C8 = &loc_406960; // weak
_UNKNOWN* off_4990E8 = &loc_406BC0; // weak
_UNKNOWN* off_499114 = &loc_408B50; // weak
_UNKNOWN* off_49914C = &loc_409B50; // weak
_UNKNOWN* off_499184 = &loc_40ED40; // weak
_UNKNOWN* off_4991B0 = &loc_40F600; // weak
void* (__thiscall* off_4991D4)(std::ios_base* __hidden this, unsigned int) = &std::ios_base::`scalar deleting destructor'; // weak
_UNKNOWN * off_4991F4 = &loc_4132E0; // weak
_UNKNOWN* off_499224 = &loc_41A340; // weak
_UNKNOWN* off_499230 = &loc_414D50; // weak
_UNKNOWN* off_4992B4 = &loc_41DAF0; // weak
_UNKNOWN* off_4992F4 = &loc_41F6A0; // weak
_UNKNOWN* off_499314 = &loc_4216C0; // weak
_UNKNOWN* off_499334 = &loc_4223B0; // weak
_UNKNOWN* off_499368 = &loc_423480; // weak
_UNKNOWN* off_4993AC = &loc_424500; // weak
_UNKNOWN* off_4993D0 = &loc_428560; // weak
_UNKNOWN* off_499400 = &loc_42A750; // weak
_UNKNOWN* off_49940C = &loc_42A9B0; // weak
_UNKNOWN* off_49941C = &loc_42CA60; // weak
_UNKNOWN* off_499458 = &loc_430A70; // weak
_UNKNOWN* off_4994B8 = &loc_435860; // weak
int(__stdcall* off_499508)(int, int, int) = &sub_4379D0; // weak
_UNKNOWN* off_49951C = &loc_438710; // weak
_UNKNOWN* off_49955C = &loc_43A1B0; // weak
_UNKNOWN* off_499588 = &loc_43A930; // weak
_UNKNOWN* off_4995C0 = &loc_43A930; // weak
_UNKNOWN* off_4995F8 = &loc_43A930; // weak
_UNKNOWN* off_499630 = &loc_43A930; // weak
_UNKNOWN* off_499668 = &loc_43A930; // weak
_UNKNOWN* off_4996A0 = &loc_43A930; // weak
_UNKNOWN* off_4996D8 = &loc_43A930; // weak
_UNKNOWN* off_499710 = &loc_43BE30; // weak
_UNKNOWN* off_499748 = &loc_43A930; // weak
_UNKNOWN* off_499780 = &loc_43A930; // weak
_UNKNOWN* off_4997B8 = &loc_43CA30; // weak
_UNKNOWN* off_4997F0 = &loc_43A930; // weak
_UNKNOWN* off_499828 = &loc_43A930; // weak
_UNKNOWN* off_499860 = &loc_43A930; // weak
_UNKNOWN* off_499898 = &loc_43A930; // weak
_UNKNOWN* off_4998D0 = &loc_43A930; // weak
_UNKNOWN* off_499908 = &loc_43A930; // weak
_UNKNOWN* off_499940 = &loc_43A930; // weak
_UNKNOWN* off_499978 = &loc_43E020; // weak
_UNKNOWN* off_4999B0 = &loc_43F300; // weak
_UNKNOWN* off_4999BC = &loc_43F540; // weak
_UNKNOWN* off_4999C8 = &loc_442480; // weak
_UNKNOWN* off_4999E8 = &loc_443570; // weak
_UNKNOWN* off_499A18 = &loc_448F40; // weak
_UNKNOWN* off_499A24 = &loc_449640; // weak
_UNKNOWN* off_499A30 = &loc_449A80; // weak
_UNKNOWN* off_499A3C = &loc_449B00; // weak
_UNKNOWN* off_499A68 = &loc_44B5C0; // weak
_UNKNOWN* off_499A74 = &loc_44C200; // weak
_UNKNOWN* off_499A80 = &loc_44C440; // weak
_UNKNOWN* off_499A8C = &loc_44C5F0; // weak
_UNKNOWN* off_499A98 = &loc_44C6F0; // weak
_UNKNOWN* off_499AA4 = &loc_44C970; // weak
int(__stdcall* off_499AB0)(char) = &sub_44CA40; // weak
_UNKNOWN* off_499ADC = &loc_451750; // weak
_UNKNOWN* off_499AE0 = &loc_4519C0; // weak
_UNKNOWN* off_499AEC = &loc_455790; // weak
void* (__thiscall* off_499B10)(std::strstreambuf* __hidden this, unsigned int) = &std::strstreambuf::`scalar deleting destructor'; // weak
_UNKNOWN * off_499B48 = &loc_458DB0; // weak
int dword_499B68[4] = { -1891072, -796416, -14090467, -16747027 }; // weak
_UNKNOWN* off_499B78 = &loc_45DEF0; // weak
_UNKNOWN* off_499B84 = &loc_45E090; // weak
_UNKNOWN* off_499BDC = &loc_463DE0; // weak
int dword_499BFC[10] =
{
  -4532509,
  -8472360,
  -9726279,
  -6626858,
  -1979526,
  -150199,
  -22918,
  -32703,
  -14204284,
  -15187076
}; // weak
int dword_499C24[10] =
{
  -7429203,
  -10449756,
  -9726279,
  -9065565,
  -6122141,
  -5077693,
  -4751259,
  -5020610,
  -12566388,
  -14869158
}; // weak
_UNKNOWN* off_499C4C = &loc_464760; // weak
_UNKNOWN* off_499C6C = &loc_464C70; // weak
_UNKNOWN* off_499C78 = &loc_465C40; // weak
_UNKNOWN* off_499C98 = &loc_466350; // weak
int(__stdcall* off_499CD4)(int, int, int) = &sub_405C40; // weak
_UNKNOWN* off_499CF8 = &loc_468B60; // weak
_UNKNOWN* off_499D18 = &loc_468FD0; // weak
_UNKNOWN* off_499D24 = &loc_469560; // weak
const IID riid = { 1453877417u, 2772u, 4558u, { 176u, 58u, 0u, 32u, 175u, 11u, 167u, 112u } }; // idb
_UNKNOWN unk_499D54; // weak
_UNKNOWN unk_499D64; // weak
_UNKNOWN unk_499D74; // weak
const IID rclsid = { 3828804531u, 21071u, 4558u, { 159u, 83u, 0u, 32u, 175u, 11u, 167u, 112u } }; // idb
_UNKNOWN unk_499D94; // weak
_UNKNOWN unk_499DAC; // weak
const IID stru_499DE4 = { 1359141583u, 9243u, 4563u, { 174u, 167u, 0u, 96u, 151u, 176u, 20u, 17u } }; // idb
const IID stru_499DF4 = { 678381645u, 14174u, 17496u, { 162u, 114u, 177u, 56u, 226u, 248u, 10u, 106u } }; // idb
const IID stru_499E04 =
{
  2205692672u,
  16483u,
  19594u,
  { 157u, 179u, 130u, 131u, 10u, 127u, 235u, 49u }
}; // idb
const IID stru_499E14 =
{
  2471138595u,
  41930u,
  19397u,
  { 173u, 160u, 214u, 217u, 93u, 151u, 148u, 33u }
}; // idb
_UNKNOWN unk_499E24; // weak
_UNKNOWN unk_499E34; // weak
int dword_499ED8[28] =
{
  8,
  12,
  16,
  4,
  0,
  1,
  1,
  2,
  1,
  2,
  2,
  3,
  1,
  2,
  2,
  3,
  2,
  3,
  3,
  4,
  0,
  2,
  1,
  2,
  1,
  0,
  -1598689907,
  1051772663
}; // weak
int(__stdcall* off_49A774)(char) = &sub_4735C3; // weak
int(__stdcall* off_49A7D8)(char) = &sub_476B8B; // weak
int(__stdcall* off_49A818)(char) = &sub_476BAA; // weak
int(__stdcall* off_49A824)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A830)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A83C)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A848)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A854)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A860)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A86C)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A878)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A884)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A890)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A89C)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A8A8)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A8B4)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A8C0)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A8CC)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A8D8)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A8E4)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A8F0)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A8FC)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A908)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A914)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A920)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A92C)(char) = &sub_4763B2; // weak
int(__stdcall* off_49A938)(char) = &sub_476BC9; // weak
int(__stdcall* off_49A944)(char) = &sub_476BC9; // weak
int(__stdcall* off_49A950)(char) = &sub_476BED; // weak
int(__stdcall* off_49A95C)(char) = &sub_476BED; // weak
int(__stdcall* off_49A968)(char) = &sub_476BED; // weak
int(__stdcall* off_49A974)(char) = &sub_476BED; // weak
int(__stdcall* off_49A980)(char) = &sub_476BED; // weak
char* off_49A990[120] =
{
  "Bogus message code %d",
  "Sorry, there are legal restrictions on arithmetic coding",
  "ALIGN_TYPE is wrong, please fix",
  "MAX_ALLOC_CHUNK is wrong, please fix",
  "Bogus buffer control mode",
  "Invalid component ID %d in SOS",
  "IDCT output block size %d not supported",
  "Bogus input colorspace",
  "Bogus JPEG colorspace",
  "Bogus marker length",
  "Wrong JPEG library version: library is %d, caller expects %d",
  "Sampling factors too large for interleaved scan",
  "Invalid memory pool code %d",
  "Unsupported JPEG data precision %d",
  "Invalid progressive parameters Ss=%d Se=%d Ah=%d Al=%d",
  "Invalid progressive parameters at scan script entry %d",
  "Bogus sampling factors",
  "Invalid scan script at entry %d",
  "Improper call to JPEG library in state %d",
  "JPEG parameter struct mismatch: library thinks size is %u, caller expects %u",
  "Bogus virtual array access",
  "Buffer passed to JPEG library is too small",
  "Suspension not allowed here",
  "CCIR601 sampling not implemented yet",
  "Too many color components: %d, max %d",
  "Unsupported color conversion request",
  "Bogus DAC index %d",
  "Bogus DAC value 0x%x",
  "Bogus DHT counts",
  "Bogus DHT index %d",
  "Bogus DQT index %d",
  "Empty JPEG image (DNL not supported)",
  "Read from EMS failed",
  "Write to EMS failed",
  "Didn't expect more than one scan",
  "Input file read error",
  "Output file write error --- out of disk space?",
  "Fractional sampling not implemented yet",
  "Huffman code size table overflow",
  "Missing Huffman code table entry",
  "Maximum supported image dimension is %u pixels",
  "Empty input file",
  "Premature end of input file",
  "Cannot transcode due to multiple use of quantization table %d",
  "Scan script does not transmit all data",
  "Invalid color quantization mode change",
  "Not implemented yet",
  "Requested feature was omitted at compile time",
  "Backing store not supported",
  "Huffman table 0x%02x was not defined",
  "JPEG datastream contains no image",
  "Quantization table 0x%02x was not defined",
  "Not a JPEG file: starts with 0x%02x 0x%02x",
  "Insufficient memory (case %d)",
  "Cannot quantize more than %d color components",
  "Cannot quantize to fewer than %d colors",
  "Cannot quantize to more than %d colors",
  "Invalid JPEG file structure: two SOF markers",
  "Invalid JPEG file structure: missing SOS marker",
  "Unsupported JPEG process: SOF type 0x%02x",
  "Invalid JPEG file structure: two SOI markers",
  "Invalid JPEG file structure: SOS before SOF",
  "Failed to create temporary file %s",
  "Read failed on temporary file",
  "Seek failed on temporary file",
  "Write failed on temporary file --- out of disk space?",
  "Application transferred too few scanlines",
  "Unsupported marker type 0x%02x",
  "Virtual array controller messed up",
  "Image too wide for this implementation",
  "Read from XMS failed",
  "Write to XMS failed",
  "Copyright (C) 1996, Thomas G. Lane",
  "6a  7-Feb-96",
  "Caution: quantization tables are too coarse for baseline JPEG",
  "Adobe APP14 marker: version %d, flags 0x%04x 0x%04x, transform %d",
  "Unknown APP0 marker (not JFIF), length %u",
  "Unknown APP14 marker (not Adobe), length %u",
  "Define Arithmetic Table 0x%02x: 0x%02x",
  "Define Huffman Table 0x%02x",
  "Define Quantization Table %d  precision %d",
  "Define Restart Interval %u",
  "Freed EMS handle %u",
  "Obtained EMS handle %u",
  "End Of Image",
  "        %3d %3d %3d %3d %3d %3d %3d %3d",
  "JFIF APP0 marker, density %dx%d  %d",
  "Warning: thumbnail image size does not match data length %u",
  "Unknown JFIF minor revision number %d.%02d",
  "    with %d x %d thumbnail image",
  "Skipping marker 0x%02x, length %u",
  "Unexpected marker 0x%02x",
  "        %4u %4u %4u %4u %4u %4u %4u %4u",
  "Quantizing to %d = %d*%d*%d colors",
  "Quantizing to %d colors",
  "Selected %d colors for quantization",
  "At marker 0x%02x, recovery action %d",
  "RST%d",
  "Smoothing not supported with nonstandard sampling ratios",
  "Start Of Frame 0x%02x: width=%u, height=%u, components=%d",
  "    Component %d: %dhx%dv q=%d",
  "Start of Image",
  "Start Of Scan: %d components",
  "    Component %d: dc=%d ac=%d",
  "  Ss=%d, Se=%d, Ah=%d, Al=%d",
  "Closed temporary file %s",
  "Opened temporary file %s",
  "Unrecognized component IDs %d %d %d, assuming YCbCr",
  "Freed XMS handle %u",
  "Obtained XMS handle %u",
  "Unknown Adobe color transform code %d",
  "Inconsistent progression sequence for component %d coefficient %d",
  "Corrupt JPEG data: %u extraneous bytes before marker 0x%02x",
  "Corrupt JPEG data: premature end of data segment",
  "Corrupt JPEG data: bad Huffman code",
  "Warning: unknown JFIF revision number %d.%02d",
  "Premature end of JPEG file",
  "Corrupt JPEG data: found marker 0x%02x instead of RST%d",
  "Invalid SOS parameters for sequential JPEG",
  "Application transferred too many scanlines"
}; // weak
char byte_49BD08[] = { '0' }; // weak
int dword_49BD24[7] = { 128, 8, 136, 34, 170, 85, 255 }; // weak
int dword_49BD40[7] = { 255, 15, 255, 51, 255, 85, 255 }; // weak
char byte_49C054[268] =
{
  '\x89',
  'P',
  'N',
  'G',
  '\r',
  '\n',
  '\x1A',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\0',
  '\0',
  '\x0E',
  '\0',
  '\0',
  '\0',
  '\x0F',
  '\0',
  '\0',
  '\0',
  '\x1B',
  '\0',
  '\0',
  '\0',
  '\x1C',
  '\0',
  '\0',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\0',
  '\a',
  '\0',
  '\0',
  '\0',
  '\r',
  '\0',
  '\0',
  '\0',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\x1A',
  '\0',
  '\0',
  '\0',
  '\x1D',
  '\0',
  '\0',
  '\0',
  '*',
  '\0',
  '\0',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\b',
  '\0',
  '\0',
  '\0',
  '\f',
  '\0',
  '\0',
  '\0',
  '\x11',
  '\0',
  '\0',
  '\0',
  '\x19',
  '\0',
  '\0',
  '\0',
  '\x1E',
  '\0',
  '\0',
  '\0',
  ')',
  '\0',
  '\0',
  '\0',
  '+',
  '\0',
  '\0',
  '\0',
  '\t',
  '\0',
  '\0',
  '\0',
  '\v',
  '\0',
  '\0',
  '\0',
  '\x12',
  '\0',
  '\0',
  '\0',
  '\x18',
  '\0',
  '\0',
  '\0',
  '\x1F',
  '\0',
  '\0',
  '\0',
  '(',
  '\0',
  '\0',
  '\0',
  ',',
  '\0',
  '\0',
  '\0',
  '5',
  '\0',
  '\0',
  '\0',
  '\n',
  '\0',
  '\0',
  '\0',
  '\x13',
  '\0',
  '\0',
  '\0',
  '\x17',
  '\0',
  '\0',
  '\0',
  ' ',
  '\0',
  '\0',
  '\0',
  '\'',
  '\0',
  '\0',
  '\0',
  '-',
  '\0',
  '\0',
  '\0',
  '4',
  '\0',
  '\0',
  '\0',
  '6',
  '\0',
  '\0',
  '\0',
  '\x14',
  '\0',
  '\0',
  '\0',
  '\x16',
  '\0',
  '\0',
  '\0',
  '!',
  '\0',
  '\0',
  '\0',
  '&',
  '\0',
  '\0',
  '\0',
  '.',
  '\0',
  '\0',
  '\0',
  '3',
  '\0',
  '\0',
  '\0',
  '7',
  '\0',
  '\0',
  '\0',
  '<',
  '\0',
  '\0',
  '\0',
  '\x15',
  '\0',
  '\0',
  '\0',
  '\"',
  '\0',
  '\0',
  '\0',
  '%',
  '\0',
  '\0',
  '\0',
  '/',
  '\0',
  '\0',
  '\0',
  '2',
  '\0',
  '\0',
  '\0',
  '8',
  '\0',
  '\0',
  '\0',
  ';',
  '\0',
  '\0',
  '\0',
  '=',
  '\0',
  '\0',
  '\0',
  '#',
  '\0',
  '\0',
  '\0',
  '$',
  '\0',
  '\0',
  '\0',
  '0',
  '\0',
  '\0',
  '\0',
  '1',
  '\0',
  '\0',
  '\0',
  '9',
  '\0',
  '\0',
  '\0',
  ':',
  '\0',
  '\0',
  '\0',
  '>',
  '\0',
  '\0',
  '\0',
  '?',
  '\0',
  '\0',
  '\0'
}; // weak
int dword_49C160[64] =
{
  0,
  1,
  8,
  16,
  9,
  2,
  3,
  10,
  17,
  24,
  32,
  25,
  18,
  11,
  4,
  5,
  12,
  19,
  26,
  33,
  40,
  48,
  41,
  34,
  27,
  20,
  13,
  6,
  7,
  14,
  21,
  28,
  35,
  42,
  49,
  56,
  57,
  50,
  43,
  36,
  29,
  22,
  15,
  23,
  30,
  37,
  44,
  51,
  58,
  59,
  52,
  45,
  38,
  31,
  39,
  46,
  53,
  60,
  61,
  54,
  47,
  55,
  62,
  63
}; // weak
int dword_49C260[16] = { 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63 }; // weak
int dword_49C2A0[] = { 1600 }; // weak
int dword_49C2A8[] = { 0 }; // weak
int dword_49C320[7] = { 0, 4, 0, 2, 0, 1, 0 }; // weak
int dword_49C33C[7] = { 8, 8, 4, 4, 2, 2, 1 }; // weak
int dword_49C358[] = { 0 }; // weak
int dword_49C374[7] = { 8, 8, 8, 4, 4, 2, 2 }; // weak
int dword_49C820[256] =
{
  0,
  1996959894,
  -301047508,
  -1727442502,
  124634137,
  1886057615,
  -379345611,
  -1637575261,
  249268274,
  2044508324,
  -522852066,
  -1747789432,
  162941995,
  2125561021,
  -407360249,
  -1866523247,
  498536548,
  1789927666,
  -205950648,
  -2067906082,
  450548861,
  1843258603,
  -187386543,
  -2083289657,
  325883990,
  1684777152,
  -43845254,
  -1973040660,
  335633487,
  1661365465,
  -99664541,
  -1928851979,
  997073096,
  1281953886,
  -715111964,
  -1570279054,
  1006888145,
  1258607687,
  -770865667,
  -1526024853,
  901097722,
  1119000684,
  -608450090,
  -1396901568,
  853044451,
  1172266101,
  -589951537,
  -1412350631,
  651767980,
  1373503546,
  -925412992,
  -1076862698,
  565507253,
  1454621731,
  -809855591,
  -1195530993,
  671266974,
  1594198024,
  -972236366,
  -1324619484,
  795835527,
  1483230225,
  -1050600021,
  -1234817731,
  1994146192,
  31158534,
  -1731059524,
  -271249366,
  1907459465,
  112637215,
  -1614814043,
  -390540237,
  2013776290,
  251722036,
  -1777751922,
  -519137256,
  2137656763,
  141376813,
  -1855689577,
  -429695999,
  1802195444,
  476864866,
  -2056965928,
  -228458418,
  1812370925,
  453092731,
  -2113342271,
  -183516073,
  1706088902,
  314042704,
  -1950435094,
  -54949764,
  1658658271,
  366619977,
  -1932296973,
  -69972891,
  1303535960,
  984961486,
  -1547960204,
  -725929758,
  1256170817,
  1037604311,
  -1529756563,
  -740887301,
  1131014506,
  879679996,
  -1385723834,
  -631195440,
  1141124467,
  855842277,
  -1442165665,
  -586318647,
  1342533948,
  654459306,
  -1106571248,
  -921952122,
  1466479909,
  544179635,
  -1184443383,
  -832445281,
  1591671054,
  702138776,
  -1328506846,
  -942167884,
  1504918807,
  783551873,
  -1212326853,
  -1061524307,
  -306674912,
  -1698712650,
  62317068,
  1957810842,
  -355121351,
  -1647151185,
  81470997,
  1943803523,
  -480048366,
  -1805370492,
  225274430,
  2053790376,
  -468791541,
  -1828061283,
  167816743,
  2097651377,
  -267414716,
  -2029476910,
  503444072,
  1762050814,
  -144550051,
  -2140837941,
  426522225,
  1852507879,
  -19653770,
  -1982649376,
  282753626,
  1742555852,
  -105259153,
  -1900089351,
  397917763,
  1622183637,
  -690576408,
  -1580100738,
  953729732,
  1340076626,
  -776247311,
  -1497606297,
  1068828381,
  1219638859,
  -670225446,
  -1358292148,
  906185462,
  1090812512,
  -547295293,
  -1469587627,
  829329135,
  1181335161,
  -882789492,
  -1134132454,
  628085408,
  1382605366,
  -871598187,
  -1156888829,
  570562233,
  1426400815,
  -977650754,
  -1296233688,
  733239954,
  1555261956,
  -1026031705,
  -1244606671,
  752459403,
  1541320221,
  -1687895376,
  -328994266,
  1969922972,
  40735498,
  -1677130071,
  -351390145,
  1913087877,
  83908371,
  -1782625662,
  -491226604,
  2075208622,
  213261112,
  -1831694693,
  -438977011,
  2094854071,
  198958881,
  -2032938284,
  -237706686,
  1759359992,
  534414190,
  -2118248755,
  -155638181,
  1873836001,
  414664567,
  -2012718362,
  -15766928,
  1711684554,
  285281116,
  -1889165569,
  -127750551,
  1634467795,
  376229701,
  -1609899400,
  -686959890,
  1308918612,
  956543938,
  -1486412191,
  -799009033,
  1231636301,
  1047427035,
  -1362007478,
  -640263460,
  1088359270,
  936918000,
  -1447252397,
  -558129467,
  1202900863,
  817233897,
  -1111625188,
  -893730166,
  1404277552,
  615818150,
  -1160759803,
  -841546093,
  1423857449,
  601450431,
  -1285129682,
  -1000256840,
  1567103746,
  711928724,
  -1274298825,
  -1022587231,
  1510334235,
  755167117
}; // weak
int dword_49CC20[16] = { 0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384 }; // weak
int dword_49CC60[42] =
{
  0,
  -1,
  -3,
  -7,
  -15,
  -31,
  -63,
  -127,
  -255,
  -511,
  -1023,
  -2047,
  -4095,
  -8191,
  -16383,
  -32767,
  0,
  1,
  2,
  4,
  8,
  16,
  32,
  64,
  128,
  256,
  512,
  1024,
  2048,
  0,
  -1,
  -3,
  -7,
  -15,
  -31,
  -63,
  -127,
  -255,
  -511,
  -1023,
  -2047,
  0
}; // weak
int dword_49CD08[16] = { 0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384 }; // weak
int dword_49CD48[16] =
{
  0,
  -1,
  -3,
  -7,
  -15,
  -31,
  -63,
  -127,
  -255,
  -511,
  -1023,
  -2047,
  -4095,
  -8191,
  -16383,
  -32767
}; // weak
_UNKNOWN unk_49CD88; // weak
__int16 word_49CE08[32] =
{
  0,
  0,
  0,
  16368,
  25071,
  -20152,
  12624,
  16374,
  28618,
  -28339,
  -6226,
  16372,
  4522,
  -4244,
  -12190,
  16370,
  0,
  0,
  0,
  16368,
  -16581,
  -16217,
  9321,
  16361,
  8379,
  31687,
  20858,
  16353,
  -21667,
  -8590,
  -22443,
  16337
}; // weak
double dbl_49CE48[32] =
{
  -2.806365133607738e290,
  -8.725361348362577e304,
  7.060040092414972e292,
  2.198717930572604e307,
  -5.25550893328388e135,
  -1.633336165558543e150,
  1.322241949062971e138,
  4.116127510240656e152,
  -5.947069108795764e251,
  -1.916733552100678e266,
  1.485934532178541e254,
  4.804056856191809e268,
  -1.115582625434502e97,
  -3.59277442543773e111,
  2.787805895438145e99,
  9.005858530110888e113,
  -1.289364537707698e300,
  -1.903296802258063e295,
  3.247406250881963e302,
  4.791008286605129e297,
  -2.413923434303696e145,
  -3.563802592111746e140,
  6.080136738415951e147,
  8.971498616821829e142,
  -2.801217775012362e261,
  -4.085895162922157e256,
  7.014286087427145e263,
  1.022058586664661e259,
  -5.251889437868931e106,
  -7.662414802624461e101,
  1.315241142534617e109,
  1.916957593830032e104
}; // weak
int dword_49CF48[] = { 1 }; // weak
int dword_49CF58[19] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 }; // weak
_UNKNOWN unk_49D0D0; // weak
_UNKNOWN unk_49D150; // weak
_UNKNOWN unk_49D1D0; // weak
_UNKNOWN unk_49D248; // weak
_SCOPETABLE_ENTRY stru_49D698[2] = { { -1, NULL, &loc_48CB7C }, { 0, &loc_48CB68, &loc_48CB6C } }; // weak
_PVFV dword_4A0090 = NULL; // idb
char* off_4A03E0[2] = { "DebugFont.tga", "DebugFont.tga" }; // weak
char* off_4A03E4[128] =
{
  "DebugFont.tga",
  (char*)0x20,
  NULL,
  NULL,
  (char*)0x3D000000,
  (char*)0x3D400000,
  NULL,
  NULL,
  (char*)0x21,
  (char*)0x3D400000,
  NULL,
  (char*)0x3DA00000,
  (char*)0x3D400000,
  NULL,
  NULL,
  (char*)0x22,
  (char*)0x3DC00000,
  NULL,
  (char*)0x3E000000,
  (char*)0x3D400000,
  NULL,
  NULL,
  (char*)0x23,
  (char*)0x3E100000,
  NULL,
  (char*)0x3E300000,
  (char*)0x3D400000,
  NULL,
  NULL,
  (char*)0x24,
  (char*)0x3E400000,
  NULL,
  (char*)0x3E600000,
  (char*)0x3D400000,
  NULL,
  NULL,
  (char*)0x25,
  (char*)0x3E700000,
  NULL,
  (char*)0x3E880000,
  (char*)0x3D400000,
  NULL,
  NULL,
  (char*)0x26,
  (char*)0x3E900000,
  NULL,
  (char*)0x3EA00000,
  (char*)0x3D400000,
  NULL,
  NULL,
  (char*)0x27,
  (char*)0x3EA80000,
  NULL,
  (char*)0x3EB80000,
  (char*)0x3D400000,
  NULL,
  NULL,
  (char*)0x28,
  (char*)0x3EC00000,
  NULL,
  (char*)0x3ED00000,
  (char*)0x3D400000,
  NULL,
  NULL,
  (char*)0x29,
  (char*)0x3ED80000,
  NULL,
  (char*)0x3EE80000,
  (char*)0x3D400000,
  NULL,
  NULL,
  (char*)0x2A,
  (char*)0x3EF00000,
  NULL,
  (char*)0x3F000000,
  (char*)0x3D400000,
  NULL,
  NULL,
  (char*)0x2B,
  (char*)0x3F040000,
  NULL,
  (char*)0x3F0C0000,
  (char*)0x3D400000,
  NULL,
  NULL,
  (char*)0x2C,
  (char*)0x3F100000,
  NULL,
  (char*)0x3F180000,
  (char*)0x3D400000,
  NULL,
  NULL,
  (char*)0x2D,
  (char*)0x3F1C0000,
  NULL,
  (char*)0x3F240000,
  (char*)0x3D400000,
  NULL,
  NULL,
  (char*)0x2E,
  (char*)0x3F280000,
  NULL,
  (char*)0x3F300000,
  (char*)0x3D400000,
  NULL,
  NULL,
  (char*)0x2F,
  (char*)0x3F340000,
  NULL,
  (char*)0x3F3C0000,
  (char*)0x3D400000,
  NULL,
  NULL,
  (char*)0x30,
  (char*)0x3F400000,
  NULL,
  (char*)0x3F480000,
  (char*)0x3D400000,
  NULL,
  NULL,
  (char*)0x31,
  (char*)0x3F4C0000,
  NULL,
  (char*)0x3F540000,
  (char*)0x3D400000,
  NULL,
  NULL,
  (char*)0x32
}; // weak
_UNKNOWN unk_4A0E68; // weak
_UNKNOWN unk_4A18E8; // weak
char aName[] = "Name"; // idb
char aDialoguegroup[] = "DialogueGroup"; // idb
char aDialogueIni[] = "Dialogue.ini"; // idb
char byte_4A1D44 = '\x01'; // weak
char byte_4A1D45 = '\x01'; // weak
char byte_4A1D46 = '\x01'; // weak
char Mode[3] = "rb"; // idb
char asc_4A1DC4[2] = "\\"; // weak
char aUnknownFailedT[] = "*(UNKNOWN) FAILED TO LOAD"; // idb
char asc_4A1DF8[] = "  "; // idb
char aSetindicesFail[] = "SetIndices failed"; // idb
char aSetstreamsourc[] = "SetStreamSource failed"; // idb
CHAR aWeldnormals[] = "WeldNormals"; // idb
CHAR KeyName[] = "LoadModelTextures"; // idb
char aMesh05[] = "Mesh05"; // idb
char aCloud08[] = "cloud08"; // idb
char aSky08[] = "sky08"; // idb
BYTE dword_4A1EC4 = 50u; // idb
char aMousespeed[] = "MouseSpeed"; // idb
char File[] = "error.ini"; // idb
char aW[] = "w+"; // idb
char aIniFileErrorsS[] = "INI File Errors, see error.ini"; // idb
CHAR Operation[] = "open"; // idb
char asc_4A1F30[2] = "\n"; // weak
char asc_4A1F34[3] = "//"; // idb
char asc_4A1F38[3] = "*/"; // idb
char asc_4A1F3C[3] = "/*"; // idb
char asc_4A1FC8[] = ","; // idb
char aFalse[] = "false"; // idb
char aTrue[] = "true"; // idb
char aInitializedMou[] = "Initialized mouse successfully"; // idb
char aInitializedKey[] = "Initialized keyboard successfully"; // idb
char aCanTRegisterWi[] = "Can't register with DirectInput"; // idb
char aCanTSetKeyboar[] = "Can't set keyboard cooperative level"; // idb
char aCanTSetDirecti[43] = "Can't set DirectInput keyboard data format"; // weak
char aCanTObtainKeyb[32] = "Can't obtain keyboard interface"; // weak
char aCouldnTSetCoop[] = "Couldn't set coop level"; // idb
char aCouldnTSetMous[30] = "Couldn't set mouse dataformat"; // weak
char aCouldnTObtainM[32] = "Couldn't obtain mouse interface"; // weak
char aRecquiredKeybo[] = "Recquired keyboard"; // idb
char aReacquiredKeyb[] = "Reacquired keyboard"; // idb
char aCouldnTAcquire[] = "Couldn't acquire keyboard"; // idb
char aKeyboardLost[] = "Keyboard lost"; // idb
char aCanTAcquireMou[] = "Can't acquire mouse"; // idb
char aReacquiredMous[] = "Reacquired mouse"; // idb
char aStartsearchfor_1[] = "StartSearchForIpxHosts: done EnumHosts"; // idb
char aCanTEnumHosts[] = "Can't enum hosts"; // idb
char aEnumQueryTooLa[21] = "Enum Query Too Large"; // weak
char aAddressingErro[17] = "Addressing Error"; // weak
char aInvalidParam[14] = "Invalid Param"; // weak
char aInvalidHostAdd[21] = "Invalid Host Address"; // weak
char aInvalidFlags[14] = "Invalid Flags"; // weak
char aInvalideDevice[24] = "Invalide Device Address"; // weak
char aIpxIsnTInstall[20] = "IPX isn't Installed"; // weak
char aCouldnTSetPeer[] = "Couldn't Set Peer Info"; // idb
char aMpSettingPeerI[] = "MP: setting peer info"; // idb
char aStartsearchfor_0[] = "StartSearchForIpxHosts: EnumHosts"; // idb
char aCouldnTSetDevi[] = "Couldn't Set Device Address Service Provider"; // idb
char aMpSettingSp[] = "MP: setting sp"; // idb
char aMpDoneCreating_0[] = "MP: done creating device address"; // idb
char aCouldnTCreateD_1[] = "Couldn't Create Device Instance"; // idb
char aMpCreateDevice[] = "MP: create device address"; // idb
char aMpDoneSettingS[] = "MP: done setting sp"; // idb
char aCouldnTSetHost[42] = "Couldn't Set HostAddress Service Provider"; // weak
char aMpSetSp[] = "MP: set sp"; // idb
char aMpDoneCreating[] = "MP: done creating host address"; // idb
char aCouldnTCreateH[] = "Couldn't Create Host Address"; // idb
char aMpCreatingHost[] = "MP: creating host address"; // idb
char aMpInitPeerDone[] = "MP: init peer done"; // idb
char aCouldnTInitDpl[] = "Couldn't Init DPlay Peer"; // idb
char aCouldnTInitPee[] = "Couldn't init peer"; // idb
char aMpInitPeer[] = "MP: init peer"; // idb
char aMpCreatingPeer_0[] = "MP: creating peer done"; // idb
char aCouldnTCreateD_0[] = "Couldn't Create DPLay Peer"; // idb
char aCouldnTCreateD[] = "couldn't create dplay peer"; // idb
char aMpCreatingPeer[] = "MP: creating peer"; // idb
char aStartsearchfor[] = "StartSearchForIpxHosts:deleting old hosts"; // idb
char aStopsearchfori_0[] = "StopSearchForIpxHosts:done deleting old hosts"; // idb
char aStopsearchfori[] = "StopSearchForIpxHosts:deleting old hosts"; // idb
char aConnectionFail[] = "Connection Failed"; // idb
char aHostRejectedTh[] = "Host Rejected the Connection"; // idb
char aSessionIsFull[] = "Session is Full"; // idb
char aHostNotFound[15] = "Host Not Found"; // weak
char aMpLaunchSucces[] = "MP: launch successful"; // idb
char aMpDoneHostIng[] = "MP: done host()ing"; // idb
char aCouldnTHost[] = "Couldn't Host"; // idb
char aDataTooLarge[] = "Data Too Large"; // idb
char aInvalidDeviceA[23] = "Invalid Device Address"; // weak
char aMpHosting[] = "MP: hosting"; // idb
char aCanTEnumhosts[] = "Can't EnumHosts"; // idb
char aInvalidIpAddre[19] = "Invalid IP Address"; // weak
char aMpDoneEnumhost[] = "MP: done EnumHosts"; // idb
char aMpEnumhosts[] = "MP: EnumHosts"; // idb
char aCouldnTGetspca[19] = "Couldn't GetSPCaps"; // weak
char aMpDoneSettingP[] = "MP: done setting port"; // idb
char aCouldnTSetHost_1[] = "Couldn't Set Host Port"; // idb
wchar_t aPort[5] = L"port"; // weak
char aMpSettingPort[] = "MP: setting port"; // idb
char aMpDoneSettingH[] = "MP: done setting hosts ip"; // idb
char aCouldnTSetHost_0[] = "Couldn't Set Host IP Address"; // idb
wchar_t aHostname[9] = L"hostname"; // weak
char aMpSettingHosts[] = "MP: setting hosts ip"; // idb
char aPlayerNotReach[] = "Player Not Reachable"; // idb
char aMpDisconnectFi[] = "MP: disconnect finished successfully"; // idb
char aMpStartingDisc[] = "MP: starting disconnect"; // idb
char aPf3[6] = "*.pf3"; // weak
CHAR aIni[] = "*.ini"; // idb
char aCheckingFileCh[] = "Checking file checksums for multiplayer..."; // idb
char aParticleDat[] = "particle.dat"; // idb
char aWb[] = "wb"; // idb
char aSpeed[] = "speed"; // idb
int dword_4A2988 = 1; // weak
int dword_4A2990[] = { 300 }; // weak
int dword_4A2994[11] = { 200, 512, 384, 640, 480, 800, 600, 1024, 768, 1152, 864 }; // weak
char aDXD[] = "%d x %d"; // idb
char aLow[4] = "Low"; // weak
char aMedium[7] = "Medium"; // weak
char aHigh[5] = "High"; // weak
CHAR aZbuffertoggle[] = "ZBufferToggle"; // idb
char aAnimatedocean[] = "AnimatedOcean"; // idb
CHAR aLoadeverything[] = "LoadEverythingAtStart"; // idb
CHAR aWaitforvsync[] = "WaitForVSync"; // idb
CHAR aFullscreen_0[] = "FullScreen"; // idb
CHAR aMaxparticles[] = "MaxParticles"; // idb
CHAR aTexturescaledo[] = "TextureScaledown"; // idb
char aPickvideomodeS[] = "PickVideoMode(): %s %dx%d, %d bit"; // idb
char aFullscreen[11] = "FULLSCREEN"; // weak
char aWindowed[9] = "WINDOWED"; // weak
CHAR aScreendepth[] = "ScreenDepth"; // idb
CHAR aScreenheight[] = "ScreenHeight"; // idb
CHAR aScreenwidth[] = "ScreenWidth"; // idb
char aRef[4] = "REF"; // weak
_UNKNOWN* off_4A2AEC = &unk_4C4148; // weak
CHAR aError[] = "Error"; // idb
char aSwitchingToThe[130] = "\n\nSwitching to the reference rasterizer,\na software device that implements the entire\nDirect3D feature set, but runs very slowly."; // weak
CHAR Caption[] = "Fatal Error"; // idb
char aThisProgramWil[30] = "\n\nThis program will now exit."; // weak
char aGenericApplica[73] = "Generic application error. Enable\ndebug output for detailed information."; // weak
char aNotEnoughVideo[25] = "Not enough video memory."; // weak
char aAD3dObjectHasA[91] = "A D3D object has a non-zero reference\ncount (meaning things were not properly\ncleaned up)."; // weak
char aCouldNotResetT[37] = "Could not reset the Direct3D device."; // weak
char aCouldNotLoadRe[31] = "Could not load required media."; // weak
char aThisSampleRequ_0[218] = "This sample requires functionality that is\nnot available on your Direct3D hardware\naccelerator with the current desktop display\nsettings.\nPress F2 while the app is running to see a\nlist of available devices and modes."; // weak
char aYourDirect3dHa_0[186] = "Your Direct3D hardware accelerator cannot\nrender into a window with the current\ndesktop display settings.\nPress F2 while the app is running to see a\nlist of available devices and modes."; // weak
char aYourDirect3dHa[144] = "Your Direct3D hardware accelerator cannot\nrender into a window.\nPress F2 while the app is running to see a\nlist of available devices and modes."; // weak
char aNoHardwareAcce[53] = "No hardware-accelerated Direct3D devices\nwere found."; // weak
char aThisSampleRequ[96] = "This sample requires functionality that is\nnot available on your Direct3D hardware\naccelerator."; // weak
char aThisSampleCann[170] = "This sample cannot run in a desktop\nwindow with the current display settings.\nPlease change your desktop settings to a\n16- or 32-bit display mode and re-run this\nsample."; // weak
char aNotEnoughMemor[19] = "Not enough memory."; // weak
char aCouldNotInitia[231] = "Could not initialize Direct3D. You may\nwant to check that the latest version of\nDirectX is correctly installed on your\nsystem.  Also make sure that this program\nwas compiled with header files that match\nthe installed DirectX DLLs."; // weak
char aCouldNotFindAn[48] = "Could not find any compatible Direct3D\ndevices."; // weak
char aSoundFailedCre[] = "SOUND: failed creating primary sound buffer"; // idb
char aSoundCreatedPr[] = "SOUND: created primary sound buffer"; // idb
char aSoundCanTSetDs[] = "SOUND: can't set dsound cooperative level"; // idb
char aSoundCanTCreat[] = "SOUND: can't create directsound object"; // idb
char aInitsoundDirec[] = "InitSound: DirectSound was already init'd"; // idb
char aSoundDuplicate[] = "SOUND: duplicated sound '%s'"; // idb
char aSoundCanTLoadS_0[] = "SOUND: can't load sound, name not init'd"; // idb
char aSoundCouldnTPa[] = "SOUND: Couldn't pan"; // idb
char aSoundStreamsta_0[] = "Sound::StreamStart(): couldn't createsoundbuffer"; // idb
char aSoundStreamsta[] = "Sound::StreamStart(): directsound not init'd"; // idb
char aSoundCanTReset[] = "SOUND: Can't reset file."; // idb
char byte_4A34BC = '\x01'; // weak
BYTE dword_4A34C0 = 100u; // idb
char aVolume[] = "Volume"; // idb
char aDoppler[] = "Doppler"; // idb
char aSoundmanagerDo[] = "SoundManager: Done deleting soundresource"; // idb
char aDSD[12] = "%d(%s)(%d): "; // idb
float flt_4A35C4[] = { 2.0799693e23 }; // weak
float flt_4A35C8[] = { 0.0 }; // weak
int dword_4A35CC[] = { 83 }; // weak
int dword_4A35D0[] = { 80 }; // weak
int dword_4A35D4[] = { 0 }; // weak
float flt_4A35D8[] = { 0.0 }; // weak
_UNKNOWN unk_4A3BA8; // weak
char aSuccessfullyLo[] = "-Successfully loaded texture '%s'"; // idb
char aTexturesLoaded[] = "TEXTURES LOADED:"; // idb
int dword_4A3F58 = 1; // weak
int dword_4A4320 = 100; // weak
char asc_4A4AA0[2] = "|"; // idb
char asc_4A4AA4[] = "--------------------------------------------------\n"; // idb
char aA[] = "a"; // idb
char aD[] = "%d"; // idb
char aSlave2[] = "Slave2"; // idb
char aSlave1[] = "Slave1"; // idb
char aTextcolor[] = "TextColor"; // idb
char aText[] = "Text"; // idb
char aTextfont[] = "TextFont"; // idb
char aEditrestricted[] = "EditRestricted"; // idb
char aEditmaxchars[] = "EditMaxChars"; // idb
char aTextz[] = "TextZ"; // idb
char aTextsize[] = "TextSize"; // idb
char aTextpos[] = "TextPos"; // idb
char aTextcentered[] = "TextCentered"; // idb
char aBoundsize[] = "BoundSize"; // idb
char aBoundpos[] = "BoundPos"; // idb
char aZ[] = "Z"; // idb
char aSize[] = "Size"; // idb
char aPos[] = "Pos"; // idb
char aLit[] = "Lit"; // idb
char aPush[] = "Push"; // idb
char aNormal[] = "Normal"; // idb
char aColor[] = "Color"; // idb
char aEsc[] = "ESC"; // idb
char aEnter[] = "ENTER"; // idb
char aSpace[] = "SPACE"; // idb
char aHotkey[] = "Hotkey"; // idb
char aImage[] = "Image"; // idb
char aVisible[] = "Visible"; // idb
char aEnabled[] = "Enabled"; // idb
char aListbox[] = "LISTBOX"; // idb
char aRadiobutton[] = "RADIOBUTTON"; // idb
char aCheckbox[] = "CHECKBOX"; // idb
char aEditbox[] = "EDITBOX"; // idb
char aButton[] = "BUTTON"; // idb
char aStatic[] = "STATIC"; // idb
char aType[] = "Type"; // idb
char aControl[] = "Control"; // idb
char aSoundsRollover[20] = "Sounds\\rollover.wav"; // weak
char aSoundsClickWav[17] = "Sounds\\click.wav"; // weak
char aSoundsUiMusicW[20] = "Sounds\\UI Music.wav"; // weak
char asc_4A4C9C[] = "\\/:*?<>|"; // idb
char aFile[] = "File"; // idb
char aUiIni[] = "UI.ini"; // idb
char aCursor[] = "cursor"; // idb
char aUiHiding[] = "UI: Hiding"; // idb
char byte_4A4DB0 = '\x01'; // weak
char byte_4A4DB1 = '\x01'; // weak
int dword_4A4DB4 = 1103101952; // weak
int dword_4A4DB8 = 1193033728; // weak
int dword_4A4DC0 = -1428843805; // weak
int dword_4A4DC4 = 1250832828; // weak
int dword_4A4DC8 = -1955726171; // weak
int dword_4A4DCC = 11675128; // weak
int dword_4A4DD0 = -16777216; // weak
int dword_4A4DD4 = -12566464; // weak
int dword_4A4DD8 = 1174011904; // weak
int dword_4A4DDC = 1192009728; // weak
char byte_4A4DE0 = '\x01'; // weak
char aReturningSucce[] = "Returning successfully from InitD3D"; // idb
char aCreatedeviceFa_2[] = "CreateDevice failed"; // idb
char aCreatedeviceFa_1[41] = "CreateDevice failed: Out of Video Memory"; // weak
char aCreatedeviceFa_0[35] = "CreateDevice failed: Not Available"; // weak
char aCreatedeviceFa[34] = "CreateDevice failed: Invalid Call"; // weak
char aGetadapterdisp_0[] = "GetAdapterDisplayMode succeeded"; // idb
char aGetadapterdisp[] = "GetAdapterDisplayMode failed"; // idb
char aUnknown[10] = "<unknown>"; // weak
CHAR MultiByteStr[] = "Logo1.avi"; // idb
CHAR aSkiplogo[] = "SkipLogo"; // idb
char aPickedVideoMod[] = "Picked video mode"; // idb
char aPickvideomodeR[] = "PickVideoMode returned false"; // idb
char aSkipvideomode[] = "-SkipVideoMode"; // idb
char aHost[] = "-host"; // idb
char aJoin[] = "-join"; // idb
char aCreatedD3d8Obj[] = "Created d3d8 object"; // idb
char aDirect3dcreate[] = "Direct3DCreate8 failed"; // idb
char aD3dReleaseWork[] = "d3d release worked"; // idb
char aDeviceReleaseW[] = "device release worked"; // idb
char aCleanupsoundWo[] = "CleanupSound worked"; // idb
char aDeleteInputlay[] = "delete inputlayer worked"; // idb
char aSpritedestroyW[] = "SpriteDestroy worked"; // idb
char aSpheredestroyW[] = "SphereDestroy worked"; // idb
char aGGameShutdownO[] = "g_game shutdown ok"; // idb
char aCleanup[] = "Cleanup()"; // idb
char aGettingMinimiz[] = "-Getting minimized"; // idb
char aGettingRestore[] = "-Getting restored"; // idb
char aSCausedS0x04x[] = "%s caused %s: 0x%04x"; // idb
char aUnknownExcepti[23] = "Unknown exception type"; // weak
char aAMicrosoftCExc[26] = "a Microsoft C++ Exception"; // weak
char aADllInitializa[28] = "a DLL Initialization Failed"; // weak
char aAStackOverflow[17] = "a Stack Overflow"; // weak
char aAPrivilegedIns[25] = "a Privileged Instruction"; // weak
char aAnIntegerOverf[20] = "an Integer Overflow"; // weak
char aAnIntegerDivid[26] = "an Integer Divide by Zero"; // weak
char aAFloatUnderflo[18] = "a Float Underflow"; // weak
char aAFloatStackChe[20] = "a Float Stack Check"; // weak
char aAFloatOverflow[17] = "a Float Overflow"; // weak
char aAFloatInvalidO[26] = "a Float Invalid Operation"; // weak
char aAFloatInexactR[23] = "a Float Inexact Result"; // weak
char aAFloatDivideBy[23] = "a Float Divide by Zero"; // weak
char aAFloatDenormal[25] = "a Float Denormal Operand"; // weak
char aAArrayBoundsEx[24] = "a Array Bounds Exceeded"; // weak
char aAnInvalidDispo[23] = "an Invalid Disposition"; // weak
char aANoncontinuabl[27] = "a Noncontinuable Exception"; // weak
char aAnIllegalInstr[23] = "an Illegal Instruction"; // weak
char aANoMemory[12] = "a No Memory"; // weak
char aAnInPageError[17] = "an In Page Error"; // weak
char aAnAccessViolat[20] = "an Access Violation"; // weak
char aABreakpoint[13] = "a Breakpoint"; // weak
char aADatatypeMisal[24] = "a Datatype Misalignment"; // weak
char aAControlBreak[16] = "a Control-Break"; // weak
char aAControlC[12] = "a Control-C"; // weak
char aMemshutdownWor[] = "_MemShutdown worked"; // idb
char aCouninitialize[] = "CoUninitialize worked"; // idb
char aGameFailedToIn[] = "Game Failed to Init()"; // idb
char aInitd3dAndInit[] = "Initd3d and Init() both returned fine"; // idb
char aCreatewindowWo[] = "CreateWindow worked"; // idb
char aCanTCreateWind[] = "Can't create window"; // idb
CHAR WindowName[] = "Operation Blockade"; // idb
char aRegisterclasse[] = "RegisterClassEx worked"; // idb
CHAR ClassName[] = "BlockadeClass"; // idb
char aCoinitializeex_0[] = "CoInitializeEx worked"; // idb
char aCoinitializeex[] = "CoInitializeEx failed"; // idb
CHAR aShowcursor[] = "ShowCursor"; // idb
char aInvertmouse[] = "InvertMouse"; // idb
CHAR aMemorycheck[] = "MemoryCheck"; // idb
char aMeminitWorked[] = "MemInit worked"; // idb
char aCouldnTInitial[] = "Couldn't initialize memory manager"; // idb
CHAR aLogs[] = "Logs"; // idb
CHAR aRellog[] = "RelLog"; // idb
char aSoftwareInfogr[39] = "Software\\Infogrames\\Operation Blockade"; // weak
char aInstallOperati[32] = "\\install\\Operation Blockade.msi"; // weak
char aGGamePreinitWo[] = "g_game->PreInit() worked"; // idb
char aGamePreinitFai[] = "Game PreInit Failed"; // idb
char aProfileinitWor[] = "ProfileInit worked"; // idb
char aSpriteinitWork[] = "SpriteInit worked"; // idb
char aSphereinitWork[] = "SphereInit worked"; // idb
char aInputlayerWork[] = "InputLayer worked"; // idb
char aInitsoundWorke[] = "InitSound worked"; // idb
char aAboutToInitsou[] = "About to InitSound"; // idb
char aPresentInvalid[] = "Present: invalid call"; // idb
char aPresentDeviceL[] = "Present: Device Lost"; // idb
char aPresentNotRese[] = "Present: Not Reset"; // idb
char aFunctionScreen_2[] = "Function \"Screenshot\": IDirect3DSurface8::LockRect failed."; // idb
char aFunctionScreen_1[] = "Function \"Screenshot\": Could not allocate memory for bitmap bits."; // idb
char aFunctionScreen_0[] = "Function \"Screenshot\": IDirect3DDevice8::GetFrontBuffer failed."; // idb
char aFunctionScreen[] = "Function \"Screenshot\": IDirect3DDevice8::CreateImageSurface failed."; // idb
CHAR aScreens[] = "screens"; // idb
CHAR aOperationBlock_0[] = "Operation Blockade Fatal Error"; // idb
char SubStr[] = "@@"; // idb
char aLibObject[11] = "Lib:Object"; // weak
char aRvaBase[9] = "Rva+Base"; // weak
char aValue[6] = "Value"; // weak
char aBy[3] = "by"; // weak
char aPublics[8] = "Publics"; // weak
char aAddress_0[8] = "Address"; // weak
char aClass[6] = "Class"; // weak
char aLength[7] = "Length"; // weak
char aStart[6] = "Start"; // weak
char aIs[3] = "is"; // weak
char aAddress[8] = "address"; // weak
char aLoad[5] = "load"; // weak
char aPreferred[10] = "Preferred"; // weak
char aMap[5] = ".map"; // weak
char aDll_0[5] = ".dll"; // weak
char aDll[5] = ".DLL"; // weak
char aExe_0[5] = ".EXE"; // weak
char aExe[5] = ".exe"; // weak
char a0xX[] = "0x%x\n"; // idb
char asc_4A5C78[2] = " "; // weak
char aRt[] = "rt"; // idb
char aEffect[] = "Effect"; // idb
char aFireeffect[] = "fireEffect"; // idb
char aVelocity[9] = "velocity"; // weak
char aRof[4] = "rof"; // weak
char aBullet[] = "Bullet"; // idb
char aBullettype[] = "bulletType"; // idb
char aSplashradius[] = "splashRadius"; // idb
char aSplashdamage[13] = "splashDamage"; // weak
char aTimetillkamika[17] = "timeTillKamikaze"; // weak
char aRangedroptorpe[18] = "rangeDropTorpedos"; // weak
char aDivesound[] = "diveSound"; // idb
char aDivebombbullet[] = "diveBombBulletType"; // idb
char aBomb[] = "bomb"; // idb
char aTimetilldive[13] = "timeTillDive"; // weak
char aBombbayeffect[] = "bombBayEffect"; // idb
char aTheExtradataDa[] = "the ExtraData.dat file has become corrupted, please delete it"; // idb
char aTheFileExtrada[] = "the file ExtraData.dat has become corrupted, please delete it"; // idb
char aExtradataDatHa[] = "ExtraData.dat has become corrupted, please delete it"; // idb
char aBay[] = "bay"; // idb
char aRangedropbombs[15] = "rangeDropBombs"; // weak
char aRangeopendoors[15] = "rangeOpenDoors"; // weak
char aAirplaneGun[] = "Airplane Gun"; // idb
char aGun[] = "gun"; // idb
char aTimetillattack[15] = "timeTillAttack"; // weak
char aSpecialattackt[] = "specialAttackTime"; // idb
char aSputtersound[] = "sputterSound"; // idb
char aRumblesound[] = "rumbleSound"; // idb
char aSoundEffect[] = "Sound Effect"; // idb
char aEnginesound[] = "engineSound"; // idb
char aSmallimpacts[] = "smallImpacts"; // idb
char aImpacts[] = "Impacts"; // idb
char aBigimpacts[] = "bigImpacts"; // idb
char aPlanesputteref[] = "planeSputterEffect"; // idb
char aPlaneexplodeef[] = "planeExplodeEffect"; // idb
char aPlanefireeffec[] = "planeFireEffect"; // idb
char aPlanesmokeeffe[] = "planeSmokeEffect"; // idb
char aCustumPath[12] = "Custum Path"; // weak
char aPath[5] = "Path"; // weak
char aRollfactor[] = "rollFactor"; // idb
char aVerticalvariat[18] = "verticalVariation"; // weak
char aHorizontalvari[20] = "horizontalVariation"; // weak
char aPathsegmenttim[16] = "pathSegmentTime"; // weak
char aDiveyawrange[13] = "diveYawRange"; // weak
char aDivecloserange[15] = "diveCloseRange"; // weak
char aDiverange[10] = "diveRange"; // weak
char aDivealtitude[13] = "diveAltitude"; // weak
char aRange[] = "range"; // idb
char aAltitude[9] = "altitude"; // weak
char aStartdist[] = "startDist"; // idb
char aSpeedv[] = "speedV"; // idb
char aSpeeds[] = "speedS"; // idb
char aSpeedr[] = "speedR"; // idb
char aFormationbreak[] = "formationBreakDist"; // idb
char aFormationvertv[] = "formationVertVar"; // idb
char aFormationhorzv[] = "formationHorzVar"; // idb
char aFormationscale[] = "formationScale"; // idb
char aHealth[7] = "health"; // weak
int dword_4A621C = 1802464627; // weak
char byte_4A6220 = 'e'; // weak
char asc_4A6264[] = "*"; // idb
char aDeleteTheCorru[] = "delete the corrupted ExtraData.dat"; // idb
char aTail[5] = "tail"; // weak
char aNose[5] = "nose"; // weak
char aLeftwing[9] = "leftWing"; // weak
char aRightwing[10] = "rightWing"; // weak
char aFuselage[9] = "fuselage"; // weak
char aThrust[] = "thrust"; // idb
char aModelfile[] = "modelFile"; // idb
char aGoodguy[] = "goodGuy"; // idb
char aScoringgroup[] = "scoringGroup"; // idb
char aUnitvalue[] = "unitValue"; // idb
char aV1[3] = "V1"; // weak
char aKamikaze[9] = "KAMIKAZE"; // weak
char aDiveBomber[12] = "DIVE_BOMBER"; // weak
char aBomber[7] = "BOMBER"; // weak
char aTransport[10] = "TRANSPORT"; // weak
char aFighter[8] = "FIGHTER"; // weak
char aType_0[] = "type"; // idb
char* off_4A70F0 = "TypewriterFont.tga"; // weak
_UNKNOWN unk_4A70F8; // weak
char* off_4A7B78 = "ArialBlackFont.tga"; // weak
_UNKNOWN unk_4A7B80; // weak
_UNKNOWN unk_4A8600; // weak
char* off_4A90B8 = "ArialSmallFont.tga"; // weak
_UNKNOWN unk_4A90C0; // weak
_UNKNOWN unk_4A9B40; // weak
char byte_4A9F14 = '\x01'; // weak
char aFinishedLoadin_0[] = "Finished Loading Interface Stuff"; // idb
char aE[2] = "E"; // weak
char aW_0[2] = "W"; // weak
char aQ[2] = "Q"; // weak
char aHitarrowsmallT[18] = "HitArrowSmall.tga"; // weak
char aIconsInsignias_0[26] = "icons\\InsigniasLights.tga"; // weak
char aIconsSpecialat_0[29] = "icons\\SpecialAttackRadar.tga"; // weak
char aIconsSpecialat[28] = "icons\\SpecialAttackRing.tga"; // weak
char aIconsGrenadesp[30] = "icons\\GrenadeSpecialIcons.tga"; // weak
char aIconsSuperbazo[23] = "icons\\superbazooka.tga"; // weak
char aIconsBazookaTg[18] = "icons\\bazooka.tga"; // weak
char aIcons203mmTga[16] = "icons\\203mm.tga"; // weak
char aIcons155mmTga[16] = "icons\\155mm.tga"; // weak
char aIcons105mmTga[16] = "icons\\105mm.tga"; // weak
char aIcons40mmTga[15] = "icons\\40mm.tga"; // weak
char aIcons50calTga[16] = "icons\\50cal.tga"; // weak
char aIcons45calTga[16] = "icons\\45cal.tga"; // weak
char aIcons30calTga[16] = "icons\\30cal.tga"; // weak
char aBinocularsTga[15] = "binoculars.tga"; // weak
char aIconsInsignias[26] = "Icons\\InsigniasLights.tga"; // weak
char aIconsHealthgod[20] = "icons\\healthGod.tga"; // weak
char aIconsHealthsha[23] = "icons\\healthShadow.tga"; // weak
char aIconsHealth5Tg[18] = "icons\\health5.tga"; // weak
char aIconsHealth4Tg[18] = "icons\\health4.tga"; // weak
char aIconsHealth3Tg[18] = "icons\\health3.tga"; // weak
char aIconsHealth2Tg[18] = "icons\\health2.tga"; // weak
char aIconsHealth1Tg[18] = "icons\\health1.tga"; // weak
CHAR aShowcrosshair[] = "ShowCrosshair"; // idb
char aLoadingLoading[] = "Loading Loading Interface Stuff"; // idb
char aScore[6] = "Score"; // weak
char asc_4AA198[2] = "_"; // weak
char aCheatCodeEnabl[27] = "*** Cheat Code Enabled ***"; // weak
char aSayUncle[] = "say uncle"; // idb
char aEatYourSpinach[] = "eat your spinach"; // idb
int dword_4AA1E0 = -150199; // weak
int dword_4AA1E4 = -5077693; // weak
char* off_4AA1E8 = "United Sovereign Territories 1st Division"; // weak
char* off_4AA5F0[13] =
{
  "Littleton",
  "Paulsburg",
  "Lyonshire",
  "Orr",
  "South Brookland",
  "Cboins",
  "Cossik",
  "North Brookland",
  "New Carlstein",
  "Port Gregory",
  "Van Howberg",
  "Jespersonian Territory",
  "Enemy Island"
}; // weak
char* off_4AA620 = "Enemy Island"; // weak
const char* dword_4AA624 = NULL; // weak
int dword_4AA628[] = { 1064178811 }; // weak
int dword_4AA62C[23] =
{
  1036831949,
  -1084311470,
  1036831949,
  -1111993876,
  1051260355,
  1065353216,
  1056629064,
  1008981770,
  1060823368,
  1065353216,
  1066527621,
  1061158912,
  1068205343,
  1061997773,
  1070386381,
  -1082130432,
  1069799178,
  -1082130432,
  1072735191,
  -1082130432,
  1075125944,
  1060487823,
  1078187786
}; // weak
char aCommander[] = "Commander"; // idb
char aMapshellexplod_0[] = "MapShellExplodeColor"; // idb
char aMapshellexplod[] = "MapShellExplode"; // idb
char aMapexplodespar[] = "MapExplodeSparks"; // idb
char aMapexplode[] = "MapExplode"; // idb
char aMapblasthalo[] = "MapBlastHalo"; // idb
char aSoundsWarmapEx[26] = "Sounds\\WarMap Explode.wav"; // weak
char aMapMapworksPf3[17] = "Map\\MapWorks.pf3"; // weak
char aCommanderprovi_0[] = "CommanderProvinceNext"; // idb
char aCommandertakeb_0[] = "CommanderTakebackNext"; // idb
char aSoundsDialogue_0[35] = "Sounds\\Dialogue\\Commander\\In00.wav"; // weak
char aEnemyInsignia[] = "Enemy Insignia"; // idb
char aPlayeremblem[] = "PlayerEmblem"; // idb
char aCameratrack[] = "CameraTrack"; // idb
char aIntrocamera[] = "IntroCamera"; // idb
char aCanTLoadWorldM[] = "Can't load world map model"; // idb
char aDecember1941Op[52] = "December 1941: Operation Blockade: Mission Briefing"; // weak
char aCommanderprovi[] = "CommanderProvinceName"; // idb
char aCommandertakeb[] = "CommanderTakebackStart"; // idb
char aSoundsWarmapLo[23] = "Sounds\\WarMap Loop.wav"; // weak
char aSoundsCelebrat[23] = "Sounds\\Celebration.wav"; // weak
char aSoundsDialogue[35] = "Sounds\\Dialogue\\President\\VM01.wav"; // weak
char aMainmenu[] = "MainMenu"; // idb
char aWwiivictoryTga[16] = "WWIIVictory.tga"; // weak
char aSoundsWarmapWa[18] = "Sounds\\WarMap.wav"; // weak
char aLevelselect[] = "LevelSelect"; // idb
CHAR aShowintro[] = "ShowIntro"; // idb
char aLoadingMap[12] = "Loading Map"; // weak
char* off_4AAEC8[12] =
{
  "Special Mission 01",
  "Special Mission 02",
  "Special Mission 04",
  "Special Mission 05",
  "Special Mission 07",
  "Special Mission 09",
  "Special Mission 10",
  "Special Mission 11",
  "Special Mission 13",
  "Special Mission 14",
  "Special Mission 16",
  "Special Mission 18"
}; // weak
char aSoundsNewspape[27] = "Sounds\\NewspaperSplash.wav"; // weak
char aExitbutton[] = "ExitButton"; // idb
char aOptions[] = "Options"; // idb
char aOptionsbutton[] = "OptionsButton"; // idb
char aConnectiontype[] = "ConnectionType"; // idb
char aMultiplayerbut[] = "MultiplayerButton"; // idb
char aNameentry[] = "NameEntry"; // idb
char aSingleplayerbu[] = "SinglePlayerButton"; // idb
char aCrosshair[] = "Crosshair"; // idb
char aBlood[] = "Blood"; // idb
char aParticles[] = "Particles"; // idb
char aCouldnTLoadBan[] = "Couldn't load bang sound"; // idb
char aSoundsInterfac[] = "Sounds\\InterfaceBang.wav"; // idb
CHAR aGore[] = "Gore"; // idb
char aOkbutton[] = "OkButton"; // idb
char aSavedgames[] = "savedGames"; // idb
char aArrowdown[] = "ArrowDown"; // idb
char aSavedgames_0[] = "SavedGames"; // idb
char aArrowup[] = "ArrowUp"; // idb
CHAR aUsername[] = "Username"; // idb
char aCancelbutton[] = "CancelButton"; // idb
char aDeletechar[] = "DeleteChar"; // idb
char aDeletebutton[] = "DeleteButton"; // idb
char aAddplayer[] = "AddPlayer"; // idb
char aAddbutton[] = "AddButton"; // idb
char aSps[] = ".sps"; // idb
CHAR FileName[] = "Saved\\*.sps"; // idb
char aNameedit[] = "NameEdit"; // idb
char aHardbutton[] = "hardButton"; // idb
char aMediumbutton[] = "mediumButton"; // idb
char aEasybutton[] = "easyButton"; // idb
char Default[] = "Player"; // idb
char aLevelhighscore[] = "LevelHighScore"; // idb
char aGamescore[] = "GameScore"; // idb
char aLevellist[] = "LevelList"; // idb
CHAR aShowalllevels[] = "ShowAllLevels"; // idb
char aLeveldown[] = "LevelDown"; // idb
char aLevelup[] = "LevelUp"; // idb
char aObjectives[] = "Objectives"; // idb
char aIpxbutton[] = "IpxButton"; // idb
char aNetnameentry[] = "NetNameEntry"; // idb
char aTcpipbutton[] = "TcpipButton"; // idb
char aMoveTheCursorO[62] = "\n\n\nMove the cursor over\none of the choices\nto get more info.\n"; // weak
char aLanIpxClickThi[137] = "LAN (IPX)\n\nClick this to play\nwith players on a\nLocal Area Network,\nphysically connected\nto your computer.\n\nYou must have IPX\ninstalled."; // weak
char aInternetTcpIpC[142] = "Internet (TCP/IP)\n\nClick this to play\nwith other players\non the Internet.\n\nYou must have TCP/IP\ninstalled, and be\nconnected to the\nInternet.\n"; // weak
char aHelptext[] = "HelpText"; // idb
CHAR aNetusername[] = "NetUsername"; // idb
char aUiNetnameentry[] = "UI NetNameEntry: name=%s"; // idb
char aTcpip[] = "Tcpip"; // idb
char aIpx[] = "Ipx"; // idb
char aErrormsg[] = "ErrorMsg"; // idb
char aUnableToSearch[32] = "Unable to Search for IPX Hosts:"; // weak
char aUiIpxUnableToS[] = "UI IPX: unable to search for hosts"; // idb
char aUiIpxSearchFor[] = "UI IPX: search for hosts"; // idb
char aHostlist[] = "HostList"; // idb
char aUiIpxDeactivat[] = "UI IPX: deactivate, stop search for hosts"; // idb
char aStaging[] = "Staging"; // idb
char aUiIpxSuccessHo[] = "UI IPX: success hosting game"; // idb
char aUnableToHost[16] = "Unable to Host:"; // weak
char aCreatebutton[] = "CreateButton"; // idb
char aConnecting[] = "Connecting"; // idb
char aUnableToConnec[19] = "Unable to Connect:"; // weak
char aJoinbutton[] = "JoinButton"; // idb
char aUserip[] = "UserIP"; // idb
char aToHostANewGame[191] = "To host a new game,\nclick the Create\nbutton. Players will\nneed your IP address,\nshown at left, to\njoin your game.\nTo connect to an\nexisting game, enter\nthe host's IP address\nand click Join.\n"; // weak
CHAR a127001[] = "127.0.0.1"; // idb
char aHostip[] = "HostIP"; // idb
char aTcpip_0[] = "TcpIp"; // idb
char aTelegram[] = "Telegram"; // idb
char aSoundsMissionf[25] = "Sounds\\MissionFailed.wav"; // weak
char aObjectivetext[] = "ObjectiveText"; // idb
char aTitle[] = "Title"; // idb
char aDialogue[] = "Dialogue"; // idb
char aLine[] = "Line"; // idb
char aObjectivedialo[] = "ObjectiveDialogue.ini"; // idb
char aCommanderspeci[] = "CommanderSpecialMission"; // idb
char aHelpscreen[] = "HelpScreen"; // idb
char aQAWTEBSpaceMou[107] = "Q,A\nW,T\nE,B\nSPACE, Mouse Button 1\nG, Mouse Button 3\n1\n2\n3\n4\nTAB, Mouse Wheel\n[\n]\nMouse Button 2\nEsc\nF1\nF9\n"; // weak
char aHelptext2[] = "HelpText2"; // idb
char aAirStrikeTorpe[171] = "Air Strike\nTorpedo Run\nBombing Run\nFire Weapon\nGrenade\nAnti-personnel\nAnti-air\nAnti-ship\nAnti-tank\nCycle weapons\nCycle back\nCycle forward\nBinoculars\nMenu\nHelp\nScreenshot\n"; // weak
char aHelptext1[] = "HelpText1"; // idb
char aOkbutton_0[] = "okButton"; // idb
char aLine2[] = "Line2"; // idb
char aAreYouSureYouW[32] = "Are you sure you want to delete"; // weak
char aLine1[] = "Line1"; // idb
char aErrormsg2[] = "ErrorMsg2"; // idb
char aErrormsg1[] = "ErrorMsg1"; // idb
char aMissionfailed[] = "MissionFailed"; // idb
char aAbortbutton[] = "abortButton"; // idb
char aRetrybutton[] = "retryButton"; // idb
char aAbortbutton_0[] = "AbortButton"; // idb
char aRetrybutton_0[] = "RetryButton"; // idb
char aIngamemenu[] = "IngameMenu"; // idb
char aRestartmission[] = "RestartMissionButton"; // idb
char aAbortmissionbu[] = "AbortMissionButton"; // idb
char aResumebutton[] = "ResumeButton"; // idb
char aScoring[] = "Scoring"; // idb
char aLevelscore[] = "LevelScore"; // idb
char aHealth_0[] = "Health"; // idb
char aNone[] = "None"; // idb
char aIcondown[] = "IconDown"; // idb
char aIconup[] = "IconUp"; // idb
char aSoundsScorescr[28] = "Sounds\\ScoreScreenMusic.wav"; // weak
char aSoldier[8] = "Soldier"; // weak
char aDifficulty[] = "difficulty"; // idb
char aChattext[] = "ChatText"; // idb
char aChatbar[] = "ChatBar"; // idb
char aReady4[] = "Ready4"; // idb
char aReady3[] = "Ready3"; // idb
char aReady2[] = "Ready2"; // idb
char aReady1[] = "Ready1"; // idb
char aReadybutton[] = "readyButton"; // idb
char aKickbutton[] = "kickButton"; // idb
char aFightbutton[] = "fightButton"; // idb
char aPlayerslist[] = "PlayersList"; // idb
char aTheHostKickedY[37] = "The host kicked you out of the game."; // weak
char aVeteran[8] = "Veteran"; // weak
char aRecruit[8] = "Recruit"; // weak
char aDifficulty_0[] = "Difficulty"; // idb
CHAR aMultiplayermis[] = "MultiplayerMission"; // idb
char aMonth[] = "Month"; // idb
CHAR aMultiplayersky[] = "MultiplayerSky"; // idb
char aTimeOfDay[] = "Time of Day"; // idb
char aYear[] = "Year"; // idb
char aHostip_0[] = "HostIp"; // idb
char aHostipright[] = "HostIpRight"; // idb
char aHostipleft[] = "HostIpLeft"; // idb
char aHostLeftTheGam[19] = "Host Left the Game"; // weak
char aGameDataIsOutO[26] = "Game data is out of sync."; // weak
char aYouVeBeenKicke[20] = "You've been kicked!"; // weak
char aTurnrate[9] = "turnRate"; // weak
char aInactivetime[13] = "inactiveTime"; // weak
char aActivetime[11] = "activeTime"; // weak
char aExplodeeffect[] = "explodeEffect"; // idb
char aInvalidGunType[17] = "invalid gun type"; // weak
char aAntiAircraft[14] = "ANTI_AIRCRAFT"; // weak
char aAntiGround[12] = "ANTI_GROUND"; // weak
char aPleaseDeleteEx[] = "please delete ExtraData.dat, it is corrupted"; // idb
char aCollisionObjec[37] = "collision object not found for a gun"; // weak
char aExtradataDatIs[] = "ExtraData.dat is corrupted, please delete it"; // idb
char aBoatGun[] = "Boat Gun"; // idb
char aSpeedthreshold[] = "speedThresholdForGuns"; // idb
char aLaunchNodeNotN[25] = "launch node not numbered"; // weak
char aLaunch[] = "launch"; // idb
char aTimebetweenlau[] = "timeBetweenLaunches"; // idb
char aPlaneelevatort[18] = "planeElevatorTime"; // weak
char aPlaneelevatord[19] = "planeElevatorDepth"; // weak
char aDecklength[11] = "deckLength"; // weak
char aActiverange[12] = "activeRange"; // weak
char aTankExitNodeNo[25] = "tank exit node not found"; // weak
char aInvalidTankNum[20] = "invalid tank number"; // weak
char aTankNodeNotNum[23] = "tank node not numbered"; // weak
char aTank_0[] = "tank"; // idb
char aTankExit[] = "tank exit"; // idb
char aLandrange[10] = "landRange"; // weak
char aDriftspeed[11] = "driftSpeed"; // weak
char aPercentgunguys[] = "percentGunGuys"; // idb
char aNumtroops[] = "numTroops"; // idb
char aTimetillsailho[17] = "timeTillSailHome"; // weak
char aDepth[6] = "depth"; // weak
char aTimetilluturn[14] = "timeTillUTurn"; // weak
char aPausespeed[11] = "pauseSpeed"; // weak
char aPausetime[10] = "pauseTime"; // weak
char aTimetillpause[14] = "timeTillPause"; // weak
char aEnginedying[] = "engineDying"; // idb
char aBigburnfrequen[17] = "bigBurnFrequency"; // weak
char aBigburneffect[] = "bigBurnEffect"; // idb
char aEndburnfrequen[17] = "endBurnFrequency"; // weak
char aBeginburnfrequ[19] = "beginBurnFrequency"; // weak
char aBeginburnhealt[23] = "beginBurnHealthPercent"; // weak
char aSmallburneffec[] = "smallBurnEffect"; // idb
char aBubblySoundEff[] = "Bubbly Sound Effect"; // idb
char aBubblysoundeff[] = "bubblySoundEffect"; // idb
char aSailhome[] = "sailHome"; // idb
char aSlowdownspeed[14] = "slowDownSpeed"; // weak
char aSlowdownrange[] = "slowDownRange"; // idb
char aMaxpitch[9] = "maxPitch"; // weak
char aPathsegmentvar[21] = "pathSegmentVariation"; // weak
char aFadetime[] = "fadeTime"; // idb
char aLifetime[] = "lifeTime"; // idb
char aSpecialdeathhe[] = "specialDeathHealthPercent"; // idb
char aStarthealthper[] = "startHealthPercent"; // idb
char aTimebeforestop[] = "timeBeforeStopToStartSinking"; // idb
char aAnimsinkrate[] = "animSinkRate"; // idb
char aAnimsinkshore[] = "animSinkShore"; // idb
char aAnimsinksternr[] = "animSinkSternR"; // idb
char aAnimsinksternl[] = "animSinkSternL"; // idb
char aAnimsinkstern[] = "animSinkStern"; // idb
char aAnimsinkbowr[] = "animSinkBowR"; // idb
char aAnimsinkbowl[] = "animSinkBowL"; // idb
char aAnimsinkbow[] = "animSinkBow"; // idb
char aAnimsinkr[] = "animSinkR"; // idb
char aAnimsinkl[] = "animSinkL"; // idb
char aFailedToLoadAn_0[28] = "failed to load an animation"; // weak
char aAnimsink[] = "animSink"; // idb
char aSternCollision[33] = "stern collision object not found"; // weak
char aStern[] = "*stern"; // idb
char aBow[] = "*bow"; // idb
char aHull_0[] = "*hull"; // idb
char aHull[] = "hull"; // idb
char aInvalidBoatTyp[] = "invalid boat type"; // idb
char aCarrier[8] = "CARRIER"; // weak
char aCargoBoat[11] = "CARGO_BOAT"; // weak
char aBattleship[11] = "BATTLESHIP"; // weak
char aLct[4] = "LCT"; // weak
char aHiggins[8] = "HIGGINS"; // weak
char aUBoat[7] = "U_BOAT"; // weak
char aPatrolBoat[12] = "PATROL_BOAT"; // weak
CHAR aBoatturretdebu[] = "BoatTurretDebug"; // idb
char aBoatmanagerRes[] = "BoatManager::Reset()"; // idb
char aWakestripTga[] = "WakeStrip.tga"; // idb
char aImpactflesh[] = "impactFlesh"; // idb
char aImpacttank[] = "impactTank"; // idb
char aImpactship[] = "impactShip"; // idb
char aImpactboat[] = "impactBoat"; // idb
char aImpactairplane[] = "impactAirplane"; // idb
char aImpactplayer[] = "impactPlayer"; // idb
char aImpactrock[] = "impactRock"; // idb
char aImpactsand[] = "impactSand"; // idb
char aImpactwater[] = "impactWater"; // idb
char aImpactnone[] = "impactNone"; // idb
char aWidth[6] = "width"; // weak
char aLength_0[7] = "length"; // weak
char aStrip[] = "STRIP"; // idb
char aScale[] = "scale"; // idb
char aNodename[] = "nodeName"; // idb
char aModel[] = "MODEL"; // idb
char aRadius[7] = "radius"; // weak
char aTexturefile[] = "textureFile"; // idb
char aSprite[] = "SPRITE"; // idb
char aRibbonuvscroll[] = "ribbonuvScrollSpeed"; // idb
char aRibbonfadeaten[] = "ribbonfadeAtEnd"; // idb
char aRibbonfacecame[] = "ribbonfaceCamera"; // idb
char aRibbonendwidth[] = "ribbonendWidth"; // idb
char aRibbonstartwid[] = "ribbonstartWidth"; // idb
char aRibbonwidth[] = "ribbonWidth"; // idb
char aRibbonrenderin[] = "ribbonrenderInterval"; // idb
char aRibbonlength[] = "ribbonlength"; // idb
char aRibbonblue[] = "ribbonblue"; // idb
char aRibbongreen[] = "ribbongreen"; // idb
char aRibbonred[] = "ribbonred"; // idb
char aRibbontexture[] = "ribbonTexture"; // idb
char aCustomImpacts[15] = "Custom Impacts"; // weak
char aTraileffect[] = "trailEffect"; // idb
char aTorpedospeed[13] = "torpedoSpeed"; // weak
char aTorpedodepth[13] = "torpedoDepth"; // weak
char aTorpedoaccel[] = "torpedoAccel"; // idb
char aDrag[] = "drag"; // idb
char aArmorpiercing[] = "armorPiercing"; // idb
char aDamage[7] = "damage"; // weak
char aLife[5] = "life"; // weak
char aGravity[8] = "gravity"; // weak
char aExplodeup[] = "explodeUp"; // idb
char aMagnitude[10] = "magnitude"; // weak
char aCustumChunk[13] = "Custum Chunk"; // weak
char aChunk[] = "Chunk"; // idb
char aName_0[] = "name"; // idb
char aChunksfile[] = "chunksFile"; // idb
char aDefaultImpacts[] = "Default Impacts"; // idb
char byte_4AC684 = '\x01'; // weak
char aSystem[] = "system"; // idb
char aPercentsForThe[] = "percents for the sounds exceeds 100%, see %s : %s"; // idb
char aSound[] = "sound"; // idb
CHAR aLoadsounds[] = "LoadSounds"; // idb
char aPitch[] = "pitch"; // idb
char aVolume_0[] = "volume"; // idb
char aDiewithpe[] = "dieWithPE"; // idb
char aDoppler_0[] = "doppler"; // idb
char aEnginepitch[] = "enginePitch"; // idb
char aEnginefade[] = "engineFade"; // idb
char aEngine[] = "engine"; // idb
char aDontduplicate[] = "dontDuplicate"; // idb
char aFadepercent[] = "fadePercent"; // idb
char aLooping[] = "looping"; // idb
char aStreaming[] = "streaming"; // idb
char aAlwaysloaded[] = "alwaysLoaded"; // idb
char aCreakfreq[10] = "creakFreq"; // weak
char aCreaksoundeffe[] = "creakSoundEffect"; // idb
char aWindsoundeffec[] = "windSoundEffect"; // idb
char aWindfreq[9] = "windFreq"; // weak
char aSeagullsoundef[] = "seagullSoundEffect"; // idb
char aSeagullfreq[12] = "seagullFreq"; // weak
char aSeagullrange[13] = "seagullRange"; // weak
char aWavesoundeffec[] = "waveSoundEffect"; // idb
char aLoopingnightso[] = "loopingNightSound"; // idb
char aLoopingdaysoun[] = "loopingDaySound"; // idb
char aExpandrate[11] = "expandRate"; // weak
char aStartsize[10] = "startSize"; // weak
char aRippleEffect[] = "Ripple Effect"; // idb
char aRippleeffect[] = "rippleEffect"; // idb
char aChunkExplosion[] = "Chunk Explosion"; // idb
char aChunkexplosion[] = "chunkExplosion"; // idb
char aSoundeffect[] = "soundEffect"; // idb
char aParticleEffect[] = "Particle Effect"; // idb
char aParticleeffect[] = "particleEffect"; // idb
char aAmbientSounds[] = "Ambient Sounds"; // idb
char aLoading[8] = "Loading"; // weak
char aTakeback[] = "-Takeback"; // idb
char aCorrectUsageJo[] = "Correct Usage: -Join <PlayerName> <Address>"; // idb
char aJoin_0[] = "-Join"; // idb
char aCorrectUsageHo[] = "Correct Usage: -Host <PlayerName>"; // idb
char aHost_0[] = "-Host"; // idb
char aRunmission[] = "-RunMission"; // idb
char aZrange[7] = "ZRange"; // weak
char aRadius_0[7] = "Radius"; // weak
char aChasecam[] = "ChaseCam"; // idb
char aViewerIni[] = "Viewer.ini"; // idb
char aCorrectUsageVi[] = "Correct Usage: -viewer <PF3FILE.pf3> <anim1.pf3> ..."; // idb
char aViewer[] = "-viewer"; // idb
char aUseAndToCycleA[65] = "Use '[' and ']' to cycle animations; '+' and '-' to cycle models"; // weak
char aCouldnTCreateV[] = "Couldn't create viewer modelobj"; // idb
char aChasenode[] = "ChaseNode"; // idb
char aModel_0[] = "Model"; // idb
char aViewerIniDoesn[] = "Viewer.ini doesn't have any [Model #] sections"; // idb
char aFinishedLoadin_3[] = "Finished loading infantry anim info, see file new.ini"; // idb
char aNumframes[10] = "numFrames"; // weak
char aNumtextures[12] = "numTextures"; // weak
char aStrip_0[] = "strip"; // idb
char aNumstrips[10] = "numStrips"; // weak
char aStrips[] = "Strips"; // idb
char aStartedToLoadI[] = "Started to load infantry anim info, see file new.ini"; // idb
char aFinishedLoadin_2[] = "Finished Loading Infantry Info"; // idb
char aHardthudsounde[] = "hardThudSoundEffect"; // idb
char aSoftthudsounde[] = "softThudSoundEffect"; // idb
char aScreamsoundeff[] = "screamSoundEffect"; // idb
char aMortaroffset[13] = "mortarOffset"; // weak
char aMortarfirefram[16] = "mortarFireFrame"; // weak
char aMortarairtime[] = "mortarAirTime"; // idb
char aMortarbulletty[] = "mortarBulletType"; // idb
char aDyingwhilestan_0[] = "dyingWhileStandingFromExplosion"; // idb
char aDyingwhilestan[] = "dyingWhileStandingFromShot"; // idb
char aDyingwhilesetu_0[] = "dyingWhileSetupFromExplosion"; // idb
char aDyingwhilesetu[] = "dyingWhileSetupFromShot"; // idb
char aIdlingwhileset[] = "idlingWhileSetup"; // idb
char aReloadingandfi[] = "reloadingAndFiring"; // idb
char aSettingupmorta[] = "settingUpMortar"; // idb
char aGrenadeoffset[14] = "grenadeOffset"; // weak
char aGrenadeframe[13] = "grenadeFrame"; // weak
char aGrenadeairtime[15] = "grenadeAirTime"; // weak
char aGrenadespinrat[16] = "grenadeSpinRate"; // weak
char aGrenadebullett[] = "grenadeBulletType"; // idb
char aShotbullettype[] = "shotBulletType"; // idb
char aDyingfromexplo[] = "dyingFromExplosion"; // idb
char aDyingfromshotr[] = "dyingFromShotRight"; // idb
char aDyingfromshotl[] = "dyingFromShotLeft"; // idb
char aDyingfromshot[] = "dyingFromShot"; // idb
char aThrowinggrenad[] = "throwingGrenade"; // idb
char aShotoffset[11] = "shotOffset"; // weak
char aShotframe[10] = "shotFrame"; // weak
char aUnaiming[] = "unaiming"; // idb
char aFiring[] = "firing"; // idb
char aAiming[] = "aiming"; // idb
char aWalkingfastrig[] = "walkingFastRight"; // idb
char aWalkingright[] = "walkingRight"; // idb
char aWalkingfastlef[] = "walkingFastLeft"; // idb
char aWalkingleft[] = "walkingLeft"; // idb
char aTimetillfire[13] = "timeTillFire"; // weak
char aTimetillsetup[14] = "timeTillSetup"; // weak
char aTimetillgrenad[16] = "timeTillGrenade"; // weak
char aOffsetz[8] = "offsetZ"; // weak
char aSize_0[5] = "size"; // weak
char aWalkspeed[10] = "walkSpeed"; // weak
char aInvalidSoldier[21] = "Invalid soldier type"; // weak
char aMortarGuy[] = "MORTAR_GUY"; // idb
char aGunGuy[] = "GUN_GUY"; // idb
char aTroopcIni[11] = "TroopC.ini"; // weak
char aTroopbIni[11] = "TroopB.ini"; // weak
char aTroopaIni[11] = "TroopA.ini"; // weak
char aAniminfo[9] = "animInfo"; // weak
char aStartedLoading_1[] = "Started Loading Infantry Info"; // idb
char aInvalidInfantr[] = "Invalid Infantry Type"; // idb
int dword_4AD1B0 = -1; // weak
char aProvincetaken[] = "ProvinceTaken"; // idb
char aDialogueShould[] = "dialogue should look like 'wave,line,delay', see SpecialMissions.ini"; // idb
char aObjectivetimet[] = "objectiveTimeText"; // idb
char aMustkilleveryt[] = "mustKillEverythingWave"; // idb
char aMustkilltext[] = "mustKillText"; // idb
char aMustkillunit[] = "mustKillUnit"; // idb
char aAirplanetype[] = "airplaneType"; // idb
char aCarrierwaves[13] = "carrierWaves"; // weak
char aBoattype[] = "boatType"; // idb
char aMustkillalluni[] = "mustKillAllUnits"; // idb
char aUnitstokill[] = "unitsToKill"; // idb
char aTime[] = "time"; // idb
char aMissionWave[] = "Mission Wave"; // idb
char aBombingrunrelo[21] = "bombingRunReloadTime"; // weak
char aBombingrunnump[20] = "bombingRunNumPlanes"; // weak
char aBombingrunairp[] = "bombingRunAirplane"; // idb
char aTorpedorunrelo[21] = "torpedoRunReloadTime"; // weak
char aTorpedorunnump[20] = "torpedoRunNumPlanes"; // weak
char aTorpedorunairp[] = "torpedoRunAirplane"; // idb
char aAirstriketime[14] = "airStrikeTime"; // weak
char aAirstrikereloa[20] = "airStrikeReloadTime"; // weak
char aAirstrikenumpl[19] = "airStrikeNumPlanes"; // weak
char aAirstrikeairpl[] = "airStrikeAirplane"; // idb
char aTank[] = "Tank"; // idb
char aTanks[] = "tanks"; // idb
char aMortarguys[] = "mortarGuys"; // idb
char aInfantry[] = "Infantry"; // idb
char aGunguys[] = "gunGuys"; // idb
char aResupplyfreq[13] = "resupplyFreq"; // weak
char aResupplymaxuni[] = "resupplyMaxUnits"; // idb
char aResupplyammo[13] = "resupplyAmmo"; // weak
char aResupplyhealth[15] = "resupplyHealth"; // weak
char aJunkersAirplan[] = "'Junkers' airplane not found, you must have a TRANSPORT airplane named 'Junkers'"; // idb
char aJunkers[] = "Junkers"; // idb
char aAirplane[] = "Airplane"; // idb
char aCargoShipBoatN[] = "'Cargo Ship' boat not found, you must have a CARGO_BOAT named 'Cargo Ship'"; // idb
char aCargoShip[] = "Cargo Ship"; // idb
char aBoat[] = "Boat"; // idb
char aGun_0[] = "Gun"; // idb
char aGuntype[] = "gunType"; // idb
char aPlayerhealth[13] = "playerHealth"; // weak
char aMission[] = "Mission"; // idb
char aMissionsSpecia_1[] = "Missions/SpecialMissionsVeteran.ini"; // idb
char aMissionsMissio_1[] = "Missions/MissionsVeteran.ini"; // idb
char aMissionsSpecia_0[36] = "Missions/SpecialMissionsSoldier.ini"; // weak
char aMissionsMissio_0[] = "Missions/MissionsSoldier.ini"; // idb
char aMissionsSpecia[36] = "Missions/SpecialMissionsRecruit.ini"; // weak
char aMissionsMissio[] = "Missions/MissionsRecruit.ini"; // idb
CHAR aShowmissionwav[] = "ShowMissionWaveHealth"; // idb
char aStartedLoading[] = "Started loading mission manager"; // idb
char aSoundsMissionc[27] = "Sounds\\MissionComplete.wav"; // weak
char aYouSalvagedAmm[] = "You salvaged ammo and medical supplies."; // idb
char aCancelmission[] = "CancelMission()"; // idb
char aHostIsAborting[] = "Host is aborting multiplayer mission; send everyone a msg"; // idb
char aMissionComplet[39] = "Mission Completed; Press N to Continue"; // weak
char aSoundsDatespla_1[23] = "Sounds\\DateSplash3.wav"; // weak
char aSoundsDatespla_0[23] = "Sounds\\DateSplash2.wav"; // weak
char aSoundsDatespla[23] = "Sounds\\DateSplash1.wav"; // weak
char aWaitingForPlay[23] = "Waiting for Players..."; // weak
char aLoadingMission[16] = "Loading Mission"; // weak
char aMissionComplet_0[18] = "Mission Completed"; // weak
char aDeleteExtradat[] = "delete ExtraData.dat, it is corrupt"; // idb
char aFinishedLoadin_4[] = "Finished Loading Gun Info"; // idb
char aTimeinair[10] = "timeInAir"; // weak
char aAimingpitch[12] = "aimingPitch"; // weak
char aAimingrange[12] = "aimingRange"; // weak
char aAiminglightmod[] = "aimingLightModel"; // idb
char aCouldNotFindTh[] = "could not find the recoilNode for an artillery gun"; // idb
char aRecoilnodename[] = "recoilNodeName"; // idb
char aCouldNotFindAN[] = "could not find a note key"; // idb
char aShakevariance[14] = "shakeVariance"; // weak
char aMaxpitchshake[14] = "maxPitchShake"; // weak
char aShellexpendern[] = "shellExpenderNodeName"; // idb
char aShellnodename[] = "shellNodeName"; // idb
char aAlternatebarre[17] = "alternateBarrels"; // weak
char aBase[] = "base"; // idb
char aFlashtime[] = "flashTime"; // idb
char aNumbarrels[11] = "numBarrels"; // weak
char aOutofammosound[] = "outOfAmmoSoundEffect"; // idb
char aBeltsoundeffec[] = "beltSoundEffect"; // idb
char aShellsoundeffe[] = "shellSoundEffect"; // idb
char aFiresoundeffec[] = "fireSoundEffect"; // idb
char aGunoffset[10] = "gunOffset"; // weak
char aMousemovementy_3[] = "mouseMovementYPower"; // idb
char aMousemovementy_2[] = "mouseMovementYUnitsMax"; // idb
char aMousemovementy_1[] = "mouseMovementYUnitsMin"; // idb
char aMousemovementy_0[] = "mouseMovementYFactorMax"; // idb
char aMousemovementy[21] = "mouseMovementYFactor"; // weak
char aMousemovementx_3[] = "mouseMovementXPower"; // idb
char aMousemovementx_2[] = "mouseMovementXUnitsMax"; // idb
char aMousemovementx_1[] = "mouseMovementXUnitsMin"; // idb
char aMousemovementx_0[] = "mouseMovementXFactorMax"; // idb
char aMousemovementx[21] = "mouseMovementXFactor"; // weak
char aCrosshair_0[10] = "crosshair"; // weak
char aGrenade[] = "Grenade"; // idb
char aSuperbazooka[13] = "SuperBazooka"; // weak
char aBazooka[8] = "Bazooka"; // weak
char a203mm[6] = "203mm"; // weak
char a155mm[6] = "155mm"; // weak
char a105mm[6] = "105mm"; // weak
char a40mm[5] = "40mm"; // weak
char a50cal[6] = "50cal"; // weak
char a45cal[6] = "45cal"; // weak
char a30cal[] = "30cal"; // idb
char aAmmotype[] = "ammoType"; // idb
char aGrenade_0[] = "GRENADE"; // idb
char aArtillery[] = "ARTILLERY"; // idb
char aBazooka_0[] = "BAZOOKA"; // idb
char aMachineGun[] = "MACHINE_GUN"; // idb
char aStartedLoading_2[] = "Started Loading Gun Info"; // idb
char aFinishedLoadin_1[] = "Finished Loading Player Manager Stuff"; // idb
CHAR aAdjustgunposit[] = "AdjustGunPosition"; // idb
char aMindamageperce[17] = "MinDamagePercent"; // weak
char aMindamageangle[15] = "MinDamageAngle"; // weak
char aMaxdamageangle[15] = "MaxDamageAngle"; // weak
char aCouldnTFindBar[] = "Couldn't find 'barrel' node in mpturret model"; // idb
char aBarrel[] = "barrel"; // idb
char aCouldnTFindTur_0[] = "Couldn't find 'turret' node in mpturret model"; // idb
char aMpturretmodelf[] = "mpTurretModelFile"; // idb
char aCouldnTFindTur[] = "Couldn't find 'turret' node in fpturret model"; // idb
char aTurret[] = "turret"; // idb
char aFpturretmodelf[] = "fpTurretModelFile"; // idb
char aMpradius[9] = "mpRadius"; // weak
char aHeight[7] = "height"; // weak
char aPlayerradius[13] = "playerRadius"; // weak
char aPlayerIni[] = "Player.ini"; // idb
char aChatter[] = "Chatter"; // idb
char aStartedLoading_0[] = "Started Loading Player Manager Stuff"; // idb
CHAR aSaved[] = "Saved"; // idb
char aAirstrikebombe[] = "AirStrikeBomber"; // idb
char aAirstriketorpe[] = "AirStrikeTorpedo"; // idb
char aAirstrikefight[] = "AirStrikeFighter"; // idb
char aSpecialAttack[] = "Special Attack"; // idb
char aPoints[7] = "points"; // weak
char aPosition[9] = "position"; // weak
char aIcon[] = "icon"; // idb
char aScoringgroup_0[] = "ScoringGroup"; // idb
char aScoringIni[] = "Scoring.ini"; // idb
char aChatterenemyki[] = "ChatterEnemyKill"; // idb
char asc_4AE234[4] = "\n\n\n"; // weak
char aAmmoUsedD[23] = "Ammo Used        = %d\n"; // weak
char aAmmoResupplied[23] = "Ammo Resupplied  = %d\n"; // weak
char aAmmoLowD[23] = "Ammo Low         = %d\n"; // weak
char aAmmoEndingD[23] = "Ammo Ending      = %d\n"; // weak
char aAmmoStartingD[23] = "Ammo Starting    = %d\n"; // weak
char aAmmoNameS[23] = "Ammo Name        = %s\n"; // weak
char aHealthLost02f[29] = "Health Lost         = %0.2f\n"; // weak
char aHealthResuppli[29] = "Health Resupplied   = %0.2f\n"; // weak
char aHealthLow02f[29] = "Health Low          = %0.2f\n"; // weak
char aHealthEnding02[29] = "Health Ending       = %0.2f\n"; // weak
char aHealthStarting[29] = "Health Starting     = %0.2f\n"; // weak
char aDifficultyD[17] = "Difficulty = %d\n"; // weak
char aPlayerS[13] = "Player = %s\n"; // weak
char aMissionS[14] = "Mission = %s\n"; // weak
char aMissionTxt[] = "mission.txt"; // idb
CHAR aWritemissionst[] = "WriteMissionStats"; // idb
char aHostSendingLis[] = "Host sending list of players:"; // idb
char* off_4AE3F8[10] =
{
  "Day 1",
  "Day 2",
  "Day 3",
  "Day 4",
  "Sunset 1",
  "Sunset 2",
  "Sunset 3",
  "Sunset 4",
  "Night 1",
  "Night 2"
}; // weak
float flt_4AE420[] = { 8000.0 }; // weak
float flt_4AE424[19] =
{
  36000.0,
  15000.0,
  36000.0,
  8000.0,
  36000.0,
  2000.0,
  36000.0,
  4000.0,
  36000.0,
  8000.0,
  36000.0,
  2000.0,
  36000.0,
  4000.0,
  36000.0,
  15000.0,
  36000.0,
  35000.0,
  36000.0
}; // weak
char aSun[] = "sun"; // idb
char aClouddummy[] = "cloudDummy"; // idb
CHAR aLoadsky[] = "LoadSky"; // idb
char aIdlesound[] = "idleSound"; // idb
char aTotallyexplode[] = "totallyExplodeEffect"; // idb
char aBaseexplodeeff[] = "baseExplodeEffect"; // idb
char aTurretexplodee[] = "turretExplodeEffect"; // idb
char aCustomPath[12] = "Custom Path"; // weak
char aCouldNotFindBa_2[46] = "could not find barrel collision node for tank"; // weak
char aCouldNotFindTu_0[46] = "could not find turret collision node for tank"; // weak
char aCouldNotFindBa_1[44] = "could not find base collision node for tank"; // weak
char aCouldNotFindBa_0[36] = "could not find barrel node for tank"; // weak
char aCouldNotFindTu[36] = "could not find turret node for tank"; // weak
char aCouldNotFindBa[34] = "could not find base node for tank"; // weak
char aCharred512Tga[17] = "_Charred_512.tga"; // weak
char a512[] = "512"; // idb
int dword_4AE740 = 0; // weak
_UNKNOWN unk_4AE748; // weak
char aFoam[] = "foam"; // idb
char aWave[] = "wave"; // idb
char aWater4Tga[] = "water4.tga"; // idb
char aWater3Tga[] = "water3.tga"; // idb
char aWater2Tga[] = "water2.tga"; // idb
char aWater1Tga[] = "water1.tga"; // idb
char aIslandPf3[11] = "Island.pf3"; // weak
char aWater[] = "water"; // idb
char aIsland[] = "*island"; // idb
char aExtradataDat[14] = "ExtraData.dat"; // weak
char aAB[] = "a+b"; // idb
_UNKNOWN unk_4AE9F0; // weak
_UNKNOWN unk_4AEF90; // weak
_UNKNOWN* off_4AEFB8 = &unk_4AEF90; // weak
int(__stdcall* off_4AEFBC[6])(int, int, int) = { &sub_472CA9, &sub_472D71, &sub_472E91, &sub_472F4B, &sub_472D27, &sub_472E1D }; // weak
_UNKNOWN unk_4B1460; // weak
_UNKNOWN unk_4B14E0; // weak
_DWORD dword_4B1560[8] = { 16, 33, 66, 132, 272, 584, 1360, 4080 }; // weak
float flt_4B1580[3] = { 0.082000002, 0.60939997, 0.30860001 }; // weak
int dword_4B158C[4] = { 0, 2, 3, 1 }; // weak
int dword_4B159C[4] = { 0, 2, 1, 3 }; // weak
char byte_4B15AC = '\x02'; // weak
__int64 qword_4B15B0 = 36029346783166592LL; // weak
__int64 qword_4B15B8 = -51228819435421784LL; // weak
__int64 qword_4B15C0 = 72059135947964775LL; // weak
__int64 qword_4B15C8 = 72059543969857990LL; // weak
__int64 qword_4B15D0 = -4294967296LL; // weak
int dword_4B1608 = 9; // weak
int dword_4B160C = 5; // weak
_UNKNOWN unk_4B1610; // weak
_UNKNOWN unk_4B2610; // weak
int dword_4B2710[19] =
{
  0,
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255,
  511,
  1023,
  2047,
  4095,
  8191,
  16383,
  32767,
  65535,
  39029,
  39027
}; // weak
char aAcos[5] = "acos"; // weak
char aAsin[5] = "asin"; // weak
_TBYTE tbyte_4B2910 = NaN; // weak
_TBYTE tbyte_4B291A = 1.570796326794896619; // weak
void(__cdecl __noreturn* off_4B2954)() = &terminate; // weak
_UNKNOWN* off_4B2968 = &off_4B2968; // weak
LPVOID off_4B296C = &off_4B2968; // idb
int dword_4B2978 = -1; // weak
_UNKNOWN** off_4B4988 = &off_4B2968; // weak
int dword_4B498C = 480; // weak
_UNKNOWN unk_4B53E0; // weak
_UNKNOWN unk_4B53F8; // weak
LPVOID ppv = NULL; // idb
int dword_4B5A94 = 0; // weak
int dword_4B5A98 = 0; // weak
int dword_4B5A9C = 0; // weak
HWND hWnd = NULL; // idb
int dword_4B5AA8 = 0; // weak
_UNKNOWN unk_4B5AAC; // weak
int dword_4B5AB0 = 0; // weak
_BYTE byte_4F5AB8[64]; // weak
char byte_4F5AF8; // weak
CHAR AppName[]; // idb
char byte_4F5B00; // weak
FILE* dword_4F5B04; // idb
_DWORD dword_4F5B08[80]; // weak
float flt_4F5C48[16]; // weak
int dword_4F5C88; // weak
LPVOID dword_4F5C8C; // idb
LPCRITICAL_SECTION lpCriticalSection; // idb
int dword_4F5C94; // weak
int dword_4F5C98; // weak
int dword_4F5C9C; // weak
int dword_4F5CA0; // weak
void* Base; // idb
size_t NumOfElements; // idb
int dword_4F5CB0; // weak
char byte_4F5CB4; // weak
float flt_4F5CB8; // weak
float flt_4F5CBC; // weak
float flt_4F5CC0; // weak
int dword_4F5CC4; // weak
HWND dword_4F5CC8; // idb
HWND dword_4F5CCC; // idb
HWND dword_4F5CD0; // idb
BYTE dword_4F5CD4[56]; // weak
char byte_4F5D0C; // weak
HWND dword_4F5D10; // idb
int dword_4F5D14; // weak
int dword_4F5D18; // weak
_UNKNOWN unk_4F5D20; // weak
_UNKNOWN unk_4F5F20; // weak
_UNKNOWN unk_4F615C; // weak
int dword_4F6160[]; // weak
_UNKNOWN unk_4F6244; // weak
int dword_4F624C[]; // weak
_UNKNOWN unk_4F6EEC; // weak
int dword_4F6EFC[]; // weak
int dword_4FA0A8[38908]; // weak
BYTE dword_520098; // idb
int dword_52009C; // weak
HWND dword_5200A0; // idb
HWND dword_5200A4; // idb
int dword_5200A8; // weak
int dword_5200AC; // weak
int dword_5200B0; // weak
HWND dword_5200B4; // idb
char byte_5200B8; // weak
BYTE dword_5200BC; // idb
HWND dword_5200C0; // idb
HWND dword_5200C4; // idb
int dword_5200C8; // weak
int dword_5200CC; // weak
int dword_5200D0; // weak
LPDIRECTSOUND ppDS; // idb
int dword_5200D8; // weak
int dword_5200DC; // weak
int dword_5200E8; // weak
int dword_5200EC; // weak
int dword_5200F0; // weak
int dword_5200F8; // weak
char byte_5200FC; // weak
int dword_520100; // weak
int dword_520108; // weak
int dword_52010C; // weak
int dword_520110; // weak
int dword_520118; // weak
int dword_52011C; // weak
int dword_520120; // weak
int dword_520124; // weak
int dword_52012C[255]; // weak
int dword_520528; // weak
FILE* Stream; // idb
int dword_520530; // weak
char byte_520534; // idb
struct HKEY__ phkResult; // idb
int dword_52073C; // weak
_UNKNOWN unk_520740; // weak
CHAR Buffer[264]; // idb
int dword_520850; // weak
int dword_520858; // weak
char byte_520860; // weak
struct tagRECT Rect; // idb
HINSTANCE hInstance; // idb
int dword_52087C; // weak
char ArgList[]; // idb
char byte_520884; // weak
char byte_520885; // weak
WPARAM wParam; // idb
int dword_520890; // weak
int dword_520898; // weak
int dword_52089C; // weak
int dword_52096C; // weak
int dword_520970; // weak
char byte_520974; // weak
int dword_520978; // weak
int dword_52097C; // weak
int dword_520980; // weak
int dword_520984; // weak
int dword_520988; // weak
int dword_52098C; // weak
int dword_520994; // weak
int dword_520998; // weak
int dword_52099C; // weak
int dword_5209A0; // weak
int dword_5209A4; // weak
int dword_5209AC; // weak
int dword_5209B0; // weak
int dword_5209B4; // weak
int dword_5209B8; // idb
char byte_5209BC; // weak
int dword_5209C0; // weak
struct tagRECT stru_5209C8; // idb
int dword_5209D8; // weak
char byte_5209DC; // weak
int dword_5209E0; // weak
HWND dword_5209E4; // idb
int dword_5209EC; // weak
int dword_5209F0; // weak
int dword_5209F4; // weak
int dword_5209F8; // weak
int dword_520A00; // weak
int dword_520A04; // idb
int dword_520A08; // weak
char byte_520A10; // weak
int dword_520A14; // weak
char byte_520A18; // weak
int dword_520A20; // weak
int dword_520A28; // weak
int dword_520A30; // weak
int dword_520A38[3]; // weak
BYTE dword_520A44; // idb
int dword_520A48; // weak
int dword_520A4C; // weak
int dword_520A50; // weak
int dword_520A58; // weak
char byte_520A60[16]; // idb
char byte_520A70; // weak
int dword_520A78; // weak
int dword_520A80; // weak
int dword_520A88; // weak
char byte_520A90; // weak
int dword_520A98; // weak
int dword_520A9C[10]; // weak
int dword_520AC4[93]; // weak
float flt_520C38; // weak
CHAR byte_520C3C[260]; // weak
char byte_520D40[64]; // idb
char byte_520D80[1024]; // weak
char byte_521180[1024]; // weak
char byte_521580[260]; // weak
char byte_521684; // weak
char byte_521688[64]; // idb
CHAR String[24]; // idb
char dword_5216E0[]; // idb
char byte_5216E4; // weak
int dword_5216E8; // weak
int dword_5216EC[3]; // weak
char byte_5216F8; // weak
int dword_5216FC; // idb
_UNKNOWN unk_521700; // weak
BYTE Data; // idb
BOOL(__stdcall* IsDebuggerPresent)();
int dword_521724; // weak
int dword_521728; // weak
int dword_52230C; // weak
__int64 qword_522318; // weak
int dword_522320; // weak
int dword_52233C; // weak
int dword_522340; // weak
int dword_5223BC; // weak
int dword_522424; // idb
LPTOP_LEVEL_EXCEPTION_FILTER lpfn; // idb
int dword_523A68; // weak
int dword_523A6C; // weak
void* dword_523A70; // idb
int dword_523A74; // weak
LPVOID lpMem; // idb
int dword_523A7C; // weak
HANDLE hHeap; // idb
int dword_523A84; // weak
// extern LSTATUS (__stdcall *RegOpenKeyA)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern LSTATUS (__stdcall *RegQueryValueExA)(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern LSTATUS (__stdcall *RegCreateKeyA)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegSetValueExA)(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern LSTATUS (__stdcall *RegOpenKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// extern HANDLE (__stdcall *FindFirstFileA)(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// extern BOOL (__stdcall *CreateDirectoryA)(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// extern UINT (__stdcall *GetDriveTypeA)(LPCSTR lpRootPathName);
// extern DWORD (__stdcall *GetLogicalDrives)();
// extern UINT (__stdcall *GetPrivateProfileIntA)(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName);
// extern BOOL (__stdcall *WritePrivateProfileStringA)(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern DWORD (__stdcall *GetPrivateProfileStringA)(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern BOOL (__stdcall *DeleteFileA)(LPCSTR lpFileName);
// extern void (__stdcall *DebugBreak)();
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern DWORD (__stdcall *GetCurrentDirectoryA)(DWORD nBufferLength, LPSTR lpBuffer);
// extern BOOL (__stdcall *ResetEvent)(HANDLE hEvent);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern DWORD (__stdcall *GetLastError)();
// extern HLOCAL (__stdcall *LocalFree)(HLOCAL hMem);
// extern DWORD (__stdcall *FormatMessageA)(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern LPVOID (__stdcall *MapViewOfFile)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
// extern HANDLE (__stdcall *CreateFileMappingA)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation);
// extern BOOL (__stdcall *UnmapViewOfFile)(LPCVOID lpBaseAddress);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern void (__stdcall *OutputDebugStringA)(LPCSTR lpOutputString);
// extern LONG (__stdcall *InterlockedDecrement)(volatile LONG *lpAddend);
// extern BOOL (__stdcall *SetEvent)(HANDLE hEvent);
// extern LONG (__stdcall *InterlockedIncrement)(volatile LONG *lpAddend);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern HANDLE (__stdcall *CreateEventA)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern void (__stdcall *FatalAppExitA)(UINT uAction, LPCSTR lpMessageText);
// extern SIZE_T (__stdcall *HeapSize)(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern BOOL (__stdcall *VirtualFree)(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// extern BOOL (__stdcall *HeapDestroy)(HANDLE hHeap);
// extern DWORD (__stdcall *GetEnvironmentVariableA)(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize);
// extern HANDLE (__stdcall *HeapCreate)(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// extern LPVOID (__stdcall *HeapReAlloc)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern HINSTANCE (__stdcall *ShellExecuteA)(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
// extern HICON (__stdcall *LoadIconA)(HINSTANCE hInstance, LPCSTR lpIconName);
// extern ATOM (__stdcall *RegisterClassA)(const WNDCLASSA *lpWndClass);
// extern HWND (__stdcall *CreateWindowExA)(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// extern int (*wsprintfA)(LPSTR, LPCSTR, ...);
// extern BOOL (__stdcall *PostMessageA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern LRESULT (__stdcall *DefWindowProcA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *DestroyWindow)(HWND hWnd);
// extern BOOL (__stdcall *PeekMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
// extern LRESULT (__stdcall *DispatchMessageA)(const MSG *lpMsg);
// extern BOOL (__stdcall *TranslateMessage)(const MSG *lpMsg);
// extern int (__stdcall *MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// extern int (__stdcall *ShowCursor)(BOOL bShow);
// extern LRESULT (__stdcall *SendMessageA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern INT_PTR (__stdcall *DialogBoxParamA)(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// extern HWND (__stdcall *GetDlgItem)(HWND hDlg, int nIDDlgItem);
// extern int (__stdcall *GetSystemMetrics)(int nIndex);
// extern BOOL (__stdcall *EndDialog)(HWND hDlg, INT_PTR nResult);
// extern BOOL (__stdcall *MoveWindow)(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint);
// extern BOOL (__stdcall *EnableWindow)(HWND hWnd, BOOL bEnable);
// extern BOOL (__stdcall *GetWindowRect)(HWND hWnd, LPRECT lpRect);
// extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow);
// extern BOOL (__stdcall *SetWindowPos)(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags);
// extern BOOL (__stdcall *GetClientRect)(HWND hWnd, LPRECT lpRect);
// extern BOOL (__stdcall *UpdateWindow)(HWND hWnd);
// extern ATOM (__stdcall *RegisterClassExA)(const WNDCLASSEXA *);
// extern HWND (__stdcall *GetDesktopWindow)();
// extern void (__stdcall *PostQuitMessage)(int nExitCode);
// extern BOOL (__stdcall *SetCursorPos)(int X, int Y);
// extern BOOL (__stdcall *UnregisterClassA)(LPCSTR lpClassName, HINSTANCE hInstance);
// extern LONG (__stdcall *SetWindowLongA)(HWND hWnd, int nIndex, LONG dwNewLong);
// extern DWORD (__stdcall *timeGetTime)();
// extern HRESULT (__stdcall *CoInitializeEx)(LPVOID pvReserved, DWORD dwCoInit);
// extern void (__stdcall *CoUninitialize)();
// extern HRESULT (__stdcall *CoCreateInstance)(const IID *const rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, const IID *const riid, LPVOID *ppv);


//----- (00401000) --------------------------------------------------------
float* __cdecl sub_401000(float* a1, float a2)
{
    long double v2; // st7
    float* result; // eax
    long double v4; // st6
    long double v5; // st7
    float v6; // [esp+8h] [ebp+8h]

    v2 = cos(a2);
    result = a1;
    v6 = sin(a2);
    v4 = v2;
    v5 = v6 * *a1 + v2 * a1[1];
    *a1 = v4 * *a1 - v6 * a1[1];
    a1[1] = v5;
    return result;
}

//----- (00401040) --------------------------------------------------------
int __cdecl sub_401040(int a1, float a2)
{
    long double v2; // st7
    int result; // eax
    long double v4; // st6
    long double v5; // st7
    float v6; // [esp+8h] [ebp+8h]

    v2 = cos(a2);
    result = a1;
    v6 = sin(a2);
    v4 = v2;
    v5 = v6 * *(float*)(a1 + 8) + v2 * *(float*)(a1 + 4);
    *(float*)(a1 + 8) = v4 * *(float*)(a1 + 8) - v6 * *(float*)(a1 + 4);
    *(float*)(a1 + 4) = v5;
    return result;
}

//----- (00401080) --------------------------------------------------------
float* __cdecl sub_401080(float* a1, float a2)
{
    long double v2; // st7
    float* result; // eax
    long double v4; // st6
    long double v5; // st7
    float v6; // [esp+8h] [ebp+8h]

    v2 = cos(a2);
    result = a1;
    v6 = sin(a2);
    v4 = v2;
    v5 = v6 * *a1 + v2 * a1[2];
    *a1 = v4 * *a1 - v6 * a1[2];
    a1[2] = v5;
    return result;
}

//----- (004010C0) --------------------------------------------------------
int __cdecl sub_4010C0(int a1)
{
    return a1 + 48;
}

//----- (004010D0) --------------------------------------------------------
int __cdecl sub_4010D0(_DWORD* a1, int a2)
{
    _DWORD* v2; // eax
    int result; // eax

    v2 = (_DWORD*)sub_4010C0(a2);
    *a1 = *v2;
    a1[1] = v2[1];
    result = v2[2];
    a1[2] = result;
    return result;
}

//----- (00401100) --------------------------------------------------------
double __cdecl sub_401100(float* a1, float* a2)
{
    double v2; // st7
    float v4; // [esp+4h] [ebp+4h]

    v2 = a1[2] * a2[2] + a1[1] * a2[1] + *a1 * *a2;
    v4 = v2;
    if (v2 > 1.0)
        return acos(1.0);
    if (v4 < -1.0)
        v4 = -1.0;
    return acos(v4);
}

//----- (00401170) --------------------------------------------------------
double __cdecl sub_401170(float* a1, float* a2)
{
    double v3; // st7
    double result; // st7
    float v5; // [esp+Ch] [ebp+4h]

    v3 = a1[2] * a2[2] + a1[1] * a2[1] + *a1 * *a2;
    v5 = v3;
    if (v3 <= 1.0)
    {
        if (v5 < -1.0)
            v5 = -1.0;
    }
    else
    {
        v5 = 1.0;
    }
    result = acos(v5);
    if (*a1 * a2[1] - a1[1] * *a2 < 0.0)
        return result * -1.0;
    return result;
}

//----- (004011F0) --------------------------------------------------------
double __cdecl sub_4011F0(int a1)
{
    return asin(*(float*)(a1 + 8));
}

//----- (00401200) --------------------------------------------------------
BOOL __cdecl sub_401200(float* a1)
{
    double v1; // st7
    double v2; // st7
    double v3; // st7
    BOOL result; // eax

    v1 = *a1;
    result = 0;
    if (v1 < 0.0000099999997 && v1 > -0.0000099999997)
    {
        v2 = a1[1];
        if (v2 < 0.0000099999997 && v2 > -0.0000099999997)
        {
            v3 = a1[2];
            if (v3 < 0.0000099999997 && v3 > -0.0000099999997)
                return 1;
        }
    }
    return result;
}

//----- (00401270) --------------------------------------------------------
int __thiscall sub_401270(int this)
{
    *(_DWORD*)(this + 4) = 0;
    *(_DWORD*)(this + 8) = 0;
    *(_DWORD*)(this + 12) = 0;
    *(_BYTE*)(this + 16) = 1;
    *(_DWORD*)(this + 320) = 0;
    *(_DWORD*)(this + 316) = 0;
    *(_DWORD*)(this + 312) = 0;
    *(_DWORD*)(this + 308) = 0;
    *(_DWORD*)(this + 300) = 0;
    *(_DWORD*)(this + 296) = 0;
    *(_DWORD*)(this + 292) = 0;
    *(_DWORD*)(this + 288) = 0;
    *(_DWORD*)(this + 280) = 0;
    *(_DWORD*)(this + 276) = 0;
    *(_DWORD*)(this + 272) = 0;
    *(_DWORD*)(this + 268) = 0;
    *(_DWORD*)(this + 324) = 1065353216;
    *(_DWORD*)(this + 304) = 1065353216;
    *(_DWORD*)(this + 284) = 1065353216;
    *(_DWORD*)(this + 264) = 1065353216;
    *(_DWORD*)(this + 388) = 1065353216;
    *(_DWORD*)(this + 368) = 1065353216;
    *(_DWORD*)(this + 348) = 1065353216;
    *(_DWORD*)(this + 328) = 1065353216;
    *(_DWORD*)(this + 384) = 0;
    *(_DWORD*)(this + 380) = 0;
    *(_DWORD*)(this + 376) = 0;
    *(_DWORD*)(this + 372) = 0;
    *(_DWORD*)(this + 364) = 0;
    *(_DWORD*)(this + 360) = 0;
    *(_DWORD*)(this + 356) = 0;
    *(_DWORD*)(this + 352) = 0;
    *(_DWORD*)(this + 344) = 0;
    *(_DWORD*)(this + 340) = 0;
    *(_DWORD*)(this + 336) = 0;
    *(_DWORD*)(this + 332) = 0;
    *(_DWORD*)this = &off_49901C;
    sub_401450((_DWORD*)this);
    *(_DWORD*)(this + 20) = dword_4A4DB4;
    *(_DWORD*)(this + 24) = dword_4A4DB8;
    *(_DWORD*)(this + 28) = 1061752795;
    return this;
}
// 49901C: using guessed type _UNKNOWN *off_49901C;
// 4A4DB4: using guessed type int dword_4A4DB4;
// 4A4DB8: using guessed type int dword_4A4DB8;

//----- (004013C0) --------------------------------------------------------
int __stdcall sub_4013C0(int a1, int a2, int a3, int(__thiscall* a4)(int))
{
    int result; // eax
    int v6; // edi

    result = a3 - 1;
    if (a3 - 1 >= 0)
    {
        v6 = a3;
        do
        {
            result = a4(a1);
            a1 += a2;
            --v6;
        } while (v6);
    }
    return result;
}

//----- (004013F0) --------------------------------------------------------
int __thiscall sub_4013F0(_DWORD* this)
{
    int result; // eax

    *this = &off_49901C;
    result = sub_408F30((_DWORD*)dword_520970);
    if ((_DWORD*)result == this)
        result = sub_408EF0(dword_520970, 0);
    *this = &off_499040;
    return result;
}
// 49901C: using guessed type _UNKNOWN *off_49901C;
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 520970: using guessed type int dword_520970;

//----- (00401450) --------------------------------------------------------
int __thiscall sub_401450(_DWORD* this)
{
    int result; // eax

    result = 0;
    this[10] = 0;
    this[9] = 0;
    this[8] = 0;
    this[11] = 0;
    this[12] = 1065353216;
    this[13] = 0;
    this[14] = 0;
    this[15] = 0;
    this[16] = 1065353216;
    return result;
}

//----- (00401480) --------------------------------------------------------
void __thiscall sub_401480(float* this, float a2, float a3, float a4)
{
    this[8] = a2 + this[8];
    this[9] = a3 + this[9];
    this[10] = a4 + this[10];
    this[11] = a2 + this[11];
    this[12] = a3 + this[12];
    this[13] = a4 + this[13];
}

//----- (004014C0) --------------------------------------------------------
void __thiscall sub_4014C0(float* this, float a2, float a3, float a4)
{
    if (a2 != 0.0)
    {
        sub_401040((int)(this + 11), a2);
        sub_401040((int)(this + 14), a2);
    }
    if (a4 != 0.0)
    {
        sub_401080(this + 11, a4);
        sub_401080(this + 14, a4);
    }
    if (a3 != 0.0)
    {
        sub_401000(this + 11, a3);
        sub_401000(this + 14, a3);
    }
}

//----- (00401550) --------------------------------------------------------
int __thiscall sub_401550(float* this)
{
    double v2; // st7
    float v4; // [esp+8h] [ebp-8h]

    v2 = (double)(unsigned int)dword_5209D8;
    if (v2 == 0.0)
        v4 = 1.0;
    else
        v4 = (double)(unsigned int)dword_5209F4 / v2;
    sub_46C1FD((int)(this + 66), this[7], v4, this[5], this[6]);
    (*(void(__stdcall**)(_DWORD, int, float*))(**(_DWORD**)ArgList + 148))(*(_DWORD*)ArgList, 3, this + 66);
    sub_46C6DE(this + 82, this + 8, this + 11, this + 14);
    return (*(int(__stdcall**)(_DWORD, int, float*))(**(_DWORD**)ArgList + 148))(*(_DWORD*)ArgList, 2, this + 82);
}
// 5209D8: using guessed type int dword_5209D8;
// 5209F4: using guessed type int dword_5209F4;

//----- (00401600) --------------------------------------------------------
float* __thiscall sub_401600(float* this)
{
    double v2; // st7
    double v3; // st7
    float v4; // eax
    double v5; // st7
    double v6; // st7
    double v7; // st6
    double v8; // st7
    double v9; // st6
    float v10; // ecx
    double v11; // st7
    double v12; // st7
    long double v13; // st7
    double v14; // st7
    double v15; // st6
    float v16; // ebp
    double v17; // st5
    double v18; // st5
    double v19; // st5
    float v20; // edx
    double v21; // st7
    float v23; // [esp+10h] [ebp-B0h]
    float v24; // [esp+10h] [ebp-B0h]
    float v25; // [esp+14h] [ebp-ACh]
    float v26; // [esp+14h] [ebp-ACh]
    float v27; // [esp+18h] [ebp-A8h]
    float v28; // [esp+18h] [ebp-A8h]
    float v29; // [esp+18h] [ebp-A8h]
    float v30; // [esp+18h] [ebp-A8h]
    float v31; // [esp+1Ch] [ebp-A4h]
    float v32; // [esp+1Ch] [ebp-A4h]
    float v33; // [esp+1Ch] [ebp-A4h]
    float v34; // [esp+1Ch] [ebp-A4h]
    float v35; // [esp+20h] [ebp-A0h]
    float v36; // [esp+20h] [ebp-A0h]
    float v37; // [esp+24h] [ebp-9Ch]
    float v38; // [esp+24h] [ebp-9Ch]
    float v39; // [esp+24h] [ebp-9Ch]
    float v40; // [esp+24h] [ebp-9Ch]
    float v41; // [esp+28h] [ebp-98h]
    float v42; // [esp+28h] [ebp-98h]
    float v43; // [esp+28h] [ebp-98h]
    float v44; // [esp+28h] [ebp-98h]
    float v45; // [esp+2Ch] [ebp-94h]
    float v46; // [esp+30h] [ebp-90h]
    float v47; // [esp+34h] [ebp-8Ch]
    float v48; // [esp+38h] [ebp-88h] BYREF
    float v49; // [esp+3Ch] [ebp-84h]
    float v50; // [esp+40h] [ebp-80h]
    float v51; // [esp+44h] [ebp-7Ch]
    float v52; // [esp+48h] [ebp-78h]
    float v53; // [esp+4Ch] [ebp-74h]
    float v54; // [esp+50h] [ebp-70h]
    float v55; // [esp+54h] [ebp-6Ch]
    float v56; // [esp+58h] [ebp-68h]
    float v57; // [esp+5Ch] [ebp-64h]
    float v58; // [esp+60h] [ebp-60h]
    float v59; // [esp+64h] [ebp-5Ch]
    float v60; // [esp+68h] [ebp-58h]
    float v61; // [esp+6Ch] [ebp-54h]
    float v62; // [esp+70h] [ebp-50h]
    float v63; // [esp+74h] [ebp-4Ch]
    float v64; // [esp+78h] [ebp-48h]
    float v65; // [esp+7Ch] [ebp-44h]
    float v66; // [esp+80h] [ebp-40h]
    float v67; // [esp+84h] [ebp-3Ch]
    float v68; // [esp+88h] [ebp-38h]
    float v69; // [esp+8Ch] [ebp-34h]
    float v70; // [esp+90h] [ebp-30h]
    float v71; // [esp+94h] [ebp-2Ch]
    float v72; // [esp+98h] [ebp-28h]
    float v73; // [esp+9Ch] [ebp-24h]
    float v74; // [esp+A0h] [ebp-20h]
    float v75; // [esp+A4h] [ebp-1Ch]
    float v76; // [esp+A8h] [ebp-18h] BYREF
    float v77; // [esp+ACh] [ebp-14h]
    float v78; // [esp+B0h] [ebp-10h]
    __int64 v79; // [esp+B4h] [ebp-Ch]
    float v80; // [esp+BCh] [ebp-4h]

    v79 = (unsigned int)dword_5209D8;
    v2 = (double)(unsigned int)dword_5209D8;
    if (v2 == 0.0)
    {
        v23 = 1.0;
    }
    else
    {
        v79 = (unsigned int)dword_5209F4;
        v23 = (double)(unsigned int)dword_5209F4 / v2;
    }
    v48 = this[11];
    v3 = v48 - this[8];
    v49 = this[12];
    v4 = this[13];
    v48 = v3;
    v5 = v49 - this[9];
    v50 = v4;
    v49 = v5;
    v50 = v4 - this[10];
    sub_46B970(&v48, &v48);
    v6 = v49 * this[16];
    v7 = v50 * this[15];
    v52 = v48;
    v53 = v49;
    v55 = v6 - v7;
    v8 = v50 * this[14];
    v9 = v48 * this[16];
    v54 = v50;
    v10 = this[15];
    v76 = this[14];
    v77 = v10;
    v56 = v8 - v9;
    v57 = v48 * this[15] - v49 * this[14];
    v11 = this[5];
    v25 = v11 * v48;
    v27 = v49 * v11;
    v31 = v50 * v11;
    v12 = this[6];
    v52 = v12 * v48;
    v53 = v49 * v12;
    v54 = v50 * v12;
    v13 = tan(this[7] * 0.5);
    v51 = v13;
    v24 = v13 * v23;
    v78 = this[16];
    sub_46B970(&v76, &v76);
    v76 = v76 * v51;
    v58 = v76;
    v64 = v76;
    v77 = v77 * v51;
    v65 = v77;
    v78 = v78 * v51;
    v60 = v78;
    v66 = v78;
    v45 = v55 * v24;
    v46 = v56 * v24;
    v56 = v46;
    v47 = v57 * v24;
    v35 = v76 * -1.0;
    v67 = v35;
    v70 = v35;
    v37 = v77 * -1.0;
    v68 = v37;
    v71 = v37;
    v41 = v78 * -1.0;
    v69 = v41;
    v72 = v41;
    v55 = v45 * -1.0;
    v14 = v46 * -1.0;
    v57 = v47 * -1.0;
    v15 = v55 + v76;
    v59 = v14 + v77;
    v16 = this[5];
    v60 = v57 + v78;
    v59 = v16 * v59;
    v60 = v16 * v60;
    v58 = v25 + v15 * v16;
    v59 = v27 + v59;
    v60 = v31 + v60;
    v17 = v45 + v76;
    v51 = v17;
    v65 = v46 + v77;
    v66 = v47 + v78;
    v65 = v16 * v65;
    v66 = v16 * v66;
    v64 = v25 + v17 * v16;
    v65 = v27 + v65;
    v66 = v31 + v66;
    v18 = v55 + v35;
    v80 = v18;
    v68 = v14 + v37;
    v69 = v57 + v41;
    v68 = v16 * v68;
    v69 = v16 * v69;
    v67 = v25 + v18 * v16;
    v68 = v27 + v68;
    v69 = v31 + v69;
    v19 = v35 + v45;
    *(float*)&v79 = v19;
    v71 = v46 + v37;
    v63 = v78;
    v62 = v77;
    v61 = v76;
    v73 = v35;
    v74 = v37;
    v72 = v47 + v41;
    v71 = v16 * v71;
    v72 = v16 * v72;
    v75 = v41;
    v70 = v25 + v19 * v16;
    v71 = v27 + v71;
    v20 = this[6];
    v72 = v31 + v72;
    v28 = v14 + v77;
    v32 = v57 + v78;
    v29 = v20 * v28;
    v33 = v20 * v32;
    v26 = v52 + v15 * v20;
    v30 = v53 + v29;
    v34 = v54 + v33;
    v62 = v46 + v77;
    v63 = v47 + v78;
    v62 = v20 * v62;
    v63 = v20 * v63;
    v61 = v52 + v51 * v20;
    v62 = v53 + v62;
    v63 = v54 + v63;
    v75 = v57 + v41;
    v73 = v20 * v80;
    v75 = v20 * v75;
    v73 = v52 + v73;
    v21 = (v14 + v37) * v20 + v53;
    v75 = v54 + v75;
    v38 = v46 + v37;
    v42 = v47 + v41;
    v39 = v20 * v38;
    v43 = v20 * v42;
    v36 = v52 + *(float*)&v79 * v20;
    v40 = v53 + v39;
    v44 = v54 + v43;
    this[42] = v58 + this[8];
    this[43] = v59 + this[9];
    this[44] = v60 + this[10];
    this[45] = v64 + this[8];
    this[46] = v65 + this[9];
    this[47] = v66 + this[10];
    this[48] = v67 + this[8];
    this[49] = v68 + this[9];
    this[50] = v69 + this[10];
    this[51] = v70 + this[8];
    this[52] = v71 + this[9];
    this[53] = v72 + this[10];
    this[54] = v26 + this[8];
    this[55] = v30 + this[9];
    this[56] = v34 + this[10];
    this[57] = v61 + this[8];
    this[58] = v62 + this[9];
    this[59] = v63 + this[10];
    this[60] = v73 + this[8];
    this[61] = v21 + this[9];
    this[62] = v75 + this[10];
    this[63] = v36 + this[8];
    this[64] = v40 + this[9];
    this[65] = v44 + this[10];
    sub_46C4AC(this + 18, this + 48, this + 42, this + 45);
    sub_46C4AC(this + 22, this + 54, this + 60, this + 57);
    sub_46C4AC(this + 26, this + 45, this + 42, this + 54);
    sub_46C4AC(this + 30, this + 48, this + 51, this + 63);
    sub_46C4AC(this + 34, this + 42, this + 48, this + 60);
    return sub_46C4AC(this + 38, this + 45, this + 57, this + 63);
}
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);
// 5209D8: using guessed type int dword_5209D8;
// 5209F4: using guessed type int dword_5209F4;

//----- (00401EC0) --------------------------------------------------------
int __thiscall sub_401EC0(float* this)
{
    _DWORD v3[16]; // [esp+4h] [ebp-40h] BYREF

    memset(&v3[11], 0, 16);
    memset(&v3[6], 0, 16);
    memset(&v3[1], 0, 16);
    v3[15] = 1065353216;
    v3[10] = 1065353216;
    v3[5] = 1065353216;
    v3[0] = 1065353216;
    (*(void(__stdcall**)(_DWORD, int, _DWORD*))(**(_DWORD**)ArgList + 148))(*(_DWORD*)ArgList, 256, v3);
    sub_41F3D0(this[42], this[43], this[44], 0.050000001, COERCE_FLOAT(200), COERCE_FLOAT(200), COERCE_FLOAT(200), 255);
    sub_41F3D0(this[45], this[46], this[47], 0.050000001, COERCE_FLOAT(200), COERCE_FLOAT(200), COERCE_FLOAT(200), 255);
    sub_41F3D0(this[48], this[49], this[50], 0.050000001, COERCE_FLOAT(200), COERCE_FLOAT(200), COERCE_FLOAT(200), 255);
    sub_41F3D0(this[51], this[52], this[53], 0.050000001, COERCE_FLOAT(200), COERCE_FLOAT(200), COERCE_FLOAT(200), 255);
    sub_41F3D0(this[54], this[55], this[56], 500.0, COERCE_FLOAT(200), COERCE_FLOAT(200), COERCE_FLOAT(200), 255);
    sub_41F3D0(this[57], this[58], this[59], 500.0, COERCE_FLOAT(200), COERCE_FLOAT(200), COERCE_FLOAT(200), 255);
    sub_41F3D0(this[60], this[61], this[62], 500.0, COERCE_FLOAT(200), COERCE_FLOAT(200), COERCE_FLOAT(200), 255);
    return sub_41F3D0(this[63], this[64], this[65], 500.0, COERCE_FLOAT(200), COERCE_FLOAT(200), COERCE_FLOAT(200), 255);
}

//----- (00402110) --------------------------------------------------------
char __thiscall sub_402110(float* this, float* a2, float a3)
{
    int v3; // edx
    float* i; // ecx
    double v5; // st7

    v3 = 0;
    for (i = this + 19; ; i += 4)
    {
        v5 = *(i - 1) * *a2 + i[1] * a2[2] + *i * a2[1] + i[2];
        if (v5 < 0.0 && v5 * v5 > a3)
            break;
        if (++v3 >= 6)
            return 1;
    }
    return 0;
}

//----- (00402170) --------------------------------------------------------
char __thiscall sub_402170(float* this, float a2, float a3, float a4, float a5, float a6, float a7)
{
    int v7; // edx
    float* v8; // ecx
    double v9; // st7
    double v10; // st6
    double v11; // st6
    double v12; // st7
    double v13; // st6
    double v14; // st7
    float v16; // [esp+0h] [ebp-14h]
    float v17; // [esp+0h] [ebp-14h]
    float v18; // [esp+4h] [ebp-10h]
    float v19; // [esp+4h] [ebp-10h]
    float v20; // [esp+8h] [ebp-Ch]
    float v21; // [esp+8h] [ebp-Ch]
    float v22; // [esp+Ch] [ebp-8h]
    float v23; // [esp+10h] [ebp-4h]

    v7 = 0;
    v8 = this + 19;
    do
    {
        v18 = a4 * v8[1];
        v9 = a3 * *v8;
        v22 = v18 + v9;
        v10 = a2 * *(v8 - 1);
        v16 = v10;
        if (v10 + v22 + v8[2] < 0.0)
        {
            v11 = a7 * v8[1];
            v20 = v11;
            v23 = v11 + v9;
            if (v23 + v16 + v8[2] < 0.0)
            {
                v12 = a6 * *v8;
                v13 = v18 + v12;
                if (v13 + v16 + v8[2] < 0.0)
                {
                    v21 = v20 + v12;
                    if (v21 + v16 + v8[2] < 0.0)
                    {
                        v14 = a5 * *(v8 - 1);
                        v17 = v14;
                        if (v14 + v22 + v8[2] < 0.0 && v17 + v23 + v8[2] < 0.0)
                        {
                            v19 = v13;
                            if (v17 + v19 + v8[2] < 0.0 && v17 + v21 + v8[2] < 0.0)
                                return 0;
                        }
                    }
                }
            }
        }
        ++v7;
        v8 += 4;
    } while (v7 < 6);
    return 1;
}

//----- (004022C0) --------------------------------------------------------
double __thiscall sub_4022C0(float* this, float a2, float a3, float a4)
{
    float v5[3]; // [esp+0h] [ebp-18h] BYREF
    float v6[3]; // [esp+Ch] [ebp-Ch] BYREF

    v5[1] = a3;
    v5[0] = a2;
    v5[2] = a4;
    sub_46C5C5(v6, v5, this + 82);
    return v6[2];
}

//----- (00402300) --------------------------------------------------------
char __thiscall sub_402300(float* this, float* a2, int* a3, int* a4)
{
    double v5; // st7
    int v6; // ecx
    float v8; // [esp+Ch] [ebp-Ch] BYREF
    float v9; // [esp+10h] [ebp-8h]
    float v10; // [esp+14h] [ebp-4h]

    v8 = 0.0;
    v9 = 0.0;
    v10 = 0.0;
    sub_46C5C5(&v8, a2, this + 82);
    sub_46C5C5(&v8, &v8, this + 66);
    if (v10 <= 0.0 || v10 >= 1.0)
    {
        *a4 = 0;
        *a3 = 0;
    }
    else
    {
        v9 = v9 * 0.5;
        v5 = 0.5 - v9;
        *a3 = (__int64)((v8 * 0.5 + 0.5) * (double)dword_5209F4);
        v6 = (__int64)(v5 * (double)dword_5209D8);
        *a4 = v6;
        if (*a3 >= 0 && *a3 < dword_5209F4 && (double)v6 >= 0.0 && v6 < dword_5209D8)
            return 1;
    }
    return 0;
}
// 5209D8: using guessed type int dword_5209D8;
// 5209F4: using guessed type int dword_5209F4;

//----- (00402430) --------------------------------------------------------
float* __thiscall sub_402430(float* this, float* a2, float* a3)
{
    sub_46C5C5(a3, a2, this + 82);
    return sub_46C5C5(a3, a3, this + 66);
}

//----- (00402470) --------------------------------------------------------
int __stdcall sub_402470(int a1)
{
    return 0;
}

//----- (00402480) --------------------------------------------------------
char __thiscall sub_402480(_BYTE* this, char a2)
{
    char result; // al

    result = a2;
    this[16] = a2;
    return result;
}

//----- (004024C0) --------------------------------------------------------
_DWORD* __thiscall sub_4024C0(_DWORD* this)
{
    sub_401270((int)this);
    *this = &off_499064;
    this[98] = 0;
    this[99] = 0;
    this[100] = 0;
    this[101] = 0;
    this[104] = 0;
    this[102] = -1097229926;
    this[103] = 1120403456;
    return this;
}
// 499064: using guessed type _UNKNOWN *off_499064;

//----- (00402530) --------------------------------------------------------
int __thiscall sub_402530(_DWORD* this)
{
    *this = &off_499064;
    return sub_4013F0(this);
}
// 499064: using guessed type _UNKNOWN *off_499064;

//----- (00402540) --------------------------------------------------------
char __thiscall sub_402540(int this, int a2)
{
    double v3; // st7
    double v4; // st7
    char v6; // c0
    long double v7; // st6
    int v8; // ecx
    int v9; // edx
    float v11; // [esp+4h] [ebp-4h]
    float v12; // [esp+4h] [ebp-4h]

    v11 = 0.0;
    v3 = 0.0;
    if (!*(_BYTE*)(dword_520970 + 296))
    {
        v11 = sub_408F80((float*)dword_520970, 0);
        v3 = sub_408F80((float*)dword_520970, 1);
    }
    v12 = v11 * 0.25 + *(float*)(this + 404);
    *(float*)(this + 404) = v12;
    v4 = v3 * 0.0099999998 + *(float*)(this + 408);
    *(float*)(this + 408) = v4;
    if (v6 && v4 < -1.0)
    {
        v4 = -1.0;
    }
    else if (v4 >= 1.0)
    {
        v4 = 1.0;
    }
    *(float*)(this + 408) = v4;
    v7 = v12 * 0.017453292;
    v8 = *(_DWORD*)(this + 396);
    v9 = *(_DWORD*)(this + 400);
    *(_DWORD*)(this + 44) = *(_DWORD*)(this + 392);
    *(_DWORD*)(this + 48) = v8;
    *(_DWORD*)(this + 52) = v9;
    *(_DWORD*)(this + 56) = 0;
    *(_DWORD*)(this + 60) = 0;
    *(_DWORD*)(this + 64) = 1065353216;
    *(float*)(this + 32) = sin(v7) * *(float*)(this + 412) + *(float*)(this + 392);
    *(float*)(this + 36) = cos(v7) * *(float*)(this + 412) + *(float*)(this + 396);
    *(float*)(this + 40) = v4 * *(float*)(this + 416) + *(float*)(this + 400);
    return sub_428620((_DWORD*)this, a2);
}
// 4025B3: variable 'v6' is possibly undefined
// 520970: using guessed type int dword_520970;

//----- (00402670) --------------------------------------------------------
int __thiscall sub_402670(_DWORD* this, int a2, int a3)
{
    int result; // eax

    result = a2;
    this[103] = a2;
    this[104] = a3;
    return result;
}

//----- (00402690) --------------------------------------------------------
int __thiscall sub_402690(_DWORD* this, int a2, int a3, int a4)
{
    int result; // eax

    this[98] = a2;
    result = a4;
    this[99] = a3;
    this[100] = a4;
    return result;
}

//----- (004026C0) --------------------------------------------------------
HRESULT __cdecl sub_4026C0(LPCCH lpMultiByteStr)
{
    HRESULT result; // eax
    int v2; // esi

    if (!sub_402710((int)lpMultiByteStr))
        return -2147467259;
    result = sub_402820();
    if (result >= 0)
    {
        v2 = sub_402990(lpMultiByteStr);
        if (!v2)
            v2 = dword_4B5AA8 != 0;
        sub_4028F0();
        return v2;
    }
    return result;
}
// 4B5AA8: using guessed type int dword_4B5AA8;

//----- (00402710) --------------------------------------------------------
BOOL __cdecl sub_402710(int a1)
{
    WNDCLASSA WndClass; // [esp+4h] [ebp-12Ch] BYREF
    CHAR WindowName[260]; // [esp+2Ch] [ebp-104h] BYREF

    memset(&WndClass, 0, sizeof(WndClass));
    WndClass.lpfnWndProc = (WNDPROC)sub_4027C0;
    WndClass.hInstance = hInstance;
    WndClass.lpszClassName = (LPCSTR)(&dword_4A0090 + 10);
    if (!RegisterClassA(&WndClass))
        return 0;
    wsprintfA(WindowName, (LPCSTR)&dword_4A0090 + 32, &dword_4A0090 + 10, a1);
    hWnd = CreateWindowExA(0, (LPCSTR)&dword_4A0090 + 40, WindowName, 0, 0, 0, 0, 0, 0, 0, hInstance, 0);
    return hWnd != 0;
}
// 4027C0: using guessed type int __stdcall sub_4027C0(int, int, int, int);

//----- (00402820) --------------------------------------------------------
HRESULT sub_402820()
{
    HRESULT Instance; // eax
    HRESULT v1; // esi
    int v3; // eax
    int v4; // esi
    int v5; // eax
    int v6; // esi
    int v7; // eax
    int v8; // esi

    Instance = CoCreateInstance(&rclsid, 0, 3u, &riid, &ppv);
    v1 = Instance;
    if (Instance >= 0)
    {
        v3 = (**(int(__stdcall***)(LPVOID, void*, int*))ppv)(ppv, &unk_499D74, &dword_4B5A94);
        v4 = v3;
        if (v3 >= 0)
        {
            v5 = (**(int(__stdcall***)(LPVOID, void*, int*))ppv)(ppv, &unk_499D54, &dword_4B5A98);
            v6 = v5;
            if (v5 >= 0)
            {
                v7 = (**(int(__stdcall***)(LPVOID, void*, int*))ppv)(ppv, &unk_499D64, &dword_4B5A9C);
                v8 = v7;
                if (v7 >= 0)
                {
                    return 0;
                }
                else
                {
                    sub_4229D0((char*)&dword_4A0090 + 64, v7);
                    sub_4028F0();
                    return v8;
                }
            }
            else
            {
                sub_4229D0((char*)&dword_4A0090 + 140, v5);
                sub_4028F0();
                return v6;
            }
        }
        else
        {
            sub_4229D0((char*)&dword_4A0090 + 212, v3);
            sub_4028F0();
            return v4;
        }
    }
    else
    {
        sub_4229D0((char*)&dword_4A0090 + 288, Instance);
        sub_4028F0();
        return v1;
    }
}
// 4B5A94: using guessed type int dword_4B5A94;
// 4B5A98: using guessed type int dword_4B5A98;
// 4B5A9C: using guessed type int dword_4B5A9C;

//----- (004028F0) --------------------------------------------------------
BOOL sub_4028F0()
{
    if (ppv)
        (*(void(__stdcall**)(LPVOID))(*(_DWORD*)ppv + 8))(ppv);
    ppv = 0;
    if (dword_4B5A94)
        (*(void(__stdcall**)(int))(*(_DWORD*)dword_4B5A94 + 8))(dword_4B5A94);
    dword_4B5A94 = 0;
    if (dword_4B5A98)
        (*(void(__stdcall**)(int))(*(_DWORD*)dword_4B5A98 + 8))(dword_4B5A98);
    dword_4B5A98 = 0;
    if (dword_4B5A9C)
        (*(void(__stdcall**)(int))(*(_DWORD*)dword_4B5A9C + 8))(dword_4B5A9C);
    dword_4B5A9C = 0;
    return DestroyWindow(hWnd);
}
// 4B5A94: using guessed type int dword_4B5A94;
// 4B5A98: using guessed type int dword_4B5A98;
// 4B5A9C: using guessed type int dword_4B5A9C;

//----- (00402960) --------------------------------------------------------
BOOL sub_402960()
{
    (*(void(__stdcall**)(int))(*(_DWORD*)dword_4B5A94 + 36))(dword_4B5A94);
    *(&dword_4A0090 + 7) = 0;
    return PostMessageA(hWnd, 0x10u, 0, 0);
}
// 4B5A94: using guessed type int dword_4B5A94;

//----- (00402990) --------------------------------------------------------
int __cdecl sub_402990(LPCCH lpMultiByteStr)
{
    int v1; // eax
    int v2; // esi
    int v4; // eax
    int v5; // esi
    int v6; // eax
    int v7; // esi
    int v8; // eax
    int v9; // esi
    int v10; // eax
    int v11; // ebp
    int v12; // [esp+40h] [ebp-230h] BYREF
    int v13; // [esp+44h] [ebp-22Ch] BYREF
    int v14; // [esp+48h] [ebp-228h] BYREF
    tagMSG Msg; // [esp+4Ch] [ebp-224h] BYREF
    WCHAR WideCharStr[260]; // [esp+68h] [ebp-208h] BYREF

    MultiByteToWideChar(0, 0, lpMultiByteStr, -1, WideCharStr, 260);
    v1 = (*(int(__stdcall**)(LPVOID, WCHAR*, _DWORD))(*(_DWORD*)ppv + 52))(ppv, WideCharStr, 0);
    v2 = v1;
    if (v1 >= 0)
    {
        v4 = (*(int(__stdcall**)(int, HWND))(*(_DWORD*)dword_4B5A98 + 124))(dword_4B5A98, hWnd);
        v5 = v4;
        if (v4 >= 0)
        {
            v6 = sub_402B90();
            v7 = v6;
            if (v6 >= 0)
            {
                v8 = (*(int(__stdcall**)(int))(*(_DWORD*)dword_4B5A94 + 32))(dword_4B5A94);
                v9 = v8;
                if (v8 >= 0)
                {
                    v10 = (*(int(__stdcall**)(int))(*(_DWORD*)dword_4B5A94 + 28))(dword_4B5A94);
                    v11 = v10;
                    if (v10 >= 0)
                    {
                        *(&dword_4A0090 + 7) = (_PVFV)1;
                        do
                        {
                            if ((*(int(__stdcall**)(int, int*, int*, int*, _DWORD))(*(_DWORD*)dword_4B5A9C + 32))(
                                dword_4B5A9C,
                                &v12,
                                &v13,
                                &v14,
                                0) == -2147467260)
                                goto LABEL_17;
                            v11 = (*(int(__stdcall**)(int, int, int, int))(*(_DWORD*)dword_4B5A9C + 48))(
                                dword_4B5A9C,
                                v12,
                                v13,
                                v14);
                            if (v11 < 0)
                                sub_4229D0((char*)&dword_4A0090 + 400, v11, lpMultiByteStr);
                            if (v12 != 1)
                                LABEL_17:
                            Sleep(0x64u);
                            else
                                *(&dword_4A0090 + 7) = 0;
                            while (PeekMessageA(&Msg, hWnd, 0, 0, 1u))
                            {
                                TranslateMessage(&Msg);
                                DispatchMessageA(&Msg);
                            }
                        } while (*(&dword_4A0090 + 7));
                        return v11;
                    }
                    else
                    {
                        sub_4229D0((char*)&dword_4A0090 + 444, v10);
                        return v11;
                    }
                }
                else
                {
                    sub_4229D0((char*)&dword_4A0090 + 468, v8);
                    return v9;
                }
            }
            else
            {
                sub_4229D0((char*)&dword_4A0090 + 496, v6);
                return v7;
            }
        }
        else
        {
            sub_4229D0("Failed(0x%08lx) to set message drain for %s", v4, lpMultiByteStr);
            return v5;
        }
    }
    else
    {
        sub_4229D0("Failed(0x%08lx) in RenderFile(%s)", v1, lpMultiByteStr);
        return v2;
    }
}
// 4B5A94: using guessed type int dword_4B5A94;
// 4B5A98: using guessed type int dword_4B5A98;
// 4B5A9C: using guessed type int dword_4B5A9C;

//----- (00402B90) --------------------------------------------------------
int sub_402B90()
{
    int v1; // eax
    int v2; // esi
    int v3; // eax
    int v4; // esi
    int v5; // eax
    int v6; // esi
    int v7; // eax
    int v8; // [esp+18h] [ebp-4h] BYREF

    if (!dword_4B5A98)
        return 1;
    v1 = (*(int(__stdcall**)(int, int*))(*(_DWORD*)dword_4B5A98 + 140))(dword_4B5A98, &v8);
    v2 = v1;
    if (v1 < 0)
    {
        sub_4229D0("FAILED(hr=0x%x) in pVW->get_FullScreenMode(&lMode)", v1);
        return v2;
    }
    if (!v8)
    {
        v3 = (*(int(__stdcall**)(int, void*))(*(_DWORD*)dword_4B5A98 + 128))(dword_4B5A98, &unk_4B5AAC);
        v4 = v3;
        if (v3 < 0)
        {
            sub_4229D0("FAILED(hr=0x%x) in pVW->get_MessageDrain((OAHWND *) &hDrain)", v3);
            return v4;
        }
        v5 = (*(int(__stdcall**)(int, HWND))(*(_DWORD*)dword_4B5A98 + 124))(dword_4B5A98, hWnd);
        v6 = v5;
        if (v5 < 0)
        {
            sub_4229D0("FAILED(hr=0x%x) in pVW->put_MessageDrain((OAHWND) s_hHiddenWindow)", v5);
            return v6;
        }
        v8 = -1;
        v7 = (*(int(__stdcall**)(int, int))(*(_DWORD*)dword_4B5A98 + 144))(dword_4B5A98, -1);
        v2 = v7;
        if (v7 < 0)
            sub_4229D0("FAILED(hr=0x%x) in pVW->put_FullScreenMode(lMode)", v7);
    }
    return v2;
}
// 4B5A98: using guessed type int dword_4B5A98;

//----- (00402C60) --------------------------------------------------------
char* __thiscall sub_402C60(char* Destination, char* Source)
{
    *((_DWORD*)Destination + 18) = 0;
    *((_DWORD*)Destination + 19) = 0;
    *((_DWORD*)Destination + 20) = 0;
    Destination[84] = 1;
    Destination[100] = 1;
    *((_DWORD*)Destination + 22) = 0;
    *((_DWORD*)Destination + 23) = 0;
    *((_DWORD*)Destination + 24) = 0;
    memset(Destination, 0, 0x40u);
    strncpy(Destination, Source, 0x3Fu);
    *((_DWORD*)Destination + 16) = 0;
    *((_DWORD*)Destination + 17) = 0;
    *((_DWORD*)Destination + 26) = 0;
    return Destination;
}

//----- (00402CB0) --------------------------------------------------------
void __thiscall sub_402CB0(int this)
{
    int v2; // ecx
    int i; // edi
    void* v4; // eax
    int j; // edi
    void* v6; // eax

    v2 = *(_DWORD*)(this + 104);
    if (v2)
        sub_41D9A0(v2);
    if (*(_BYTE*)(this + 100))
    {
        for (i = 0; i < *(_DWORD*)(this + 92); ++i)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 88) + 4 * i));
    }
    memset(*(void**)(this + 88), 0, 4 * *(_DWORD*)(this + 92));
    v4 = *(void**)(this + 88);
    *(_DWORD*)(this + 92) = 0;
    sub_488CEE(v4);
    *(_DWORD*)(this + 96) = 0;
    *(_DWORD*)(this + 88) = 0;
    if (*(_BYTE*)(this + 84))
    {
        for (j = 0; j < *(_DWORD*)(this + 76); ++j)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 72) + 4 * j));
    }
    memset(*(void**)(this + 72), 0, 4 * *(_DWORD*)(this + 76));
    v6 = *(void**)(this + 72);
    *(_DWORD*)(this + 76) = 0;
    sub_488CEE(v6);
    *(_DWORD*)(this + 80) = 0;
    *(_DWORD*)(this + 72) = 0;
}

//----- (00402DA0) --------------------------------------------------------
void __thiscall sub_402DA0(int this, float a2)
{
    int v3; // ebp
    double v4; // st7
    double v5; // st7
    int v6; // edx
    int v7; // edi
    int v8; // eax
    _DWORD* v9; // eax
    int v10; // ecx
    int v11; // eax
    int v12; // ecx
    int v13; // eax
    _DWORD* v14; // edi
    _DWORD* v15; // edx
    int v16; // ecx
    int v17; // eax
    int v18; // ecx
    int v19; // eax
    char* v20; // eax
    int v21; // edi
    int v22; // ecx
    int v23; // [esp+Ch] [ebp-18h] BYREF
    int v24; // [esp+10h] [ebp-14h]
    int v25; // [esp+14h] [ebp-10h]
    _DWORD v26[3]; // [esp+18h] [ebp-Ch] BYREF

    if (*(_DWORD*)(this + 76))
    {
        v3 = **(_DWORD**)(this + 72);
        if (*(_BYTE*)v3)
        {
            if (*(float*)(this + 68) <= 0.0)
            {
                v11 = *(_DWORD*)(this + 104);
                if (v11 && *(_BYTE*)(v11 + 53))
                {
                    v12 = *(_DWORD*)(this + 76);
                    v13 = 0;
                    if (v12 > 0)
                    {
                        v14 = *(_DWORD**)(this + 72);
                        v15 = v14;
                        while (*v15 != v3)
                        {
                            ++v13;
                            ++v15;
                            if (v13 >= v12)
                                goto LABEL_23;
                        }
                        v16 = v12 - 1;
                        *(_DWORD*)(this + 76) = v16;
                        if (v13 != v16)
                        {
                            memcpy(&v14[v13], &v14[v13 + 1], 4 * (v16 + 0x3FFFFFFF * v13));
                            *(_DWORD*)(*(_DWORD*)(this + 72) + 4 * *(_DWORD*)(this + 76)) = 0;
                        }
                    }
                LABEL_23:
                    v17 = *(_DWORD*)(this + 96);
                    v18 = *(_DWORD*)(this + 92) + 1;
                    *(_DWORD*)(this + 92) = v18;
                    if (v18 > v17)
                    {
                        v19 = v17 + 8;
                        *(_DWORD*)(this + 96) = v19;
                        v20 = (char*)sub_488DD7(*(LPVOID*)(this + 88), 4 * v19);
                        if (v20)
                        {
                            v21 = *(_DWORD*)(this + 92);
                            v22 = *(_DWORD*)(this + 96) - v21;
                            *(_DWORD*)(this + 88) = v20;
                            memset(&v20[4 * v21], 0, 4 * v22);
                        }
                    }
                    *(_DWORD*)(*(_DWORD*)(this + 88) + 4 * *(_DWORD*)(this + 92) - 4) = v3;
                    *(_DWORD*)(this + 104) = 0;
                }
            }
            else
            {
                v5 = *(float*)(this + 68) - a2;
                *(float*)(this + 68) = v5;
                if (v5 < 0.0)
                {
                    *(_DWORD*)(this + 68) = 0;
                    v6 = *(_DWORD*)(v3 + 16);
                    if (v6 == -1)
                    {
                        v7 = *(_DWORD*)(*(_DWORD*)(v3 + 12) + 68);
                        v6 = rand() % v7;
                    }
                    v8 = sub_41E2D0(
                        *(_DWORD**)(dword_520970 + 120),
                        *(_DWORD**)(*(_DWORD*)(*(_DWORD*)(v3 + 12) + 64) + 4 * v6),
                        1,
                        0);
                    *(_DWORD*)(this + 104) = v8;
                    if (v8)
                    {
                        v23 = 0;
                        v24 = 0;
                        v25 = 0;
                        memset(v26, 0, sizeof(v26));
                        if (sub_408F30((_DWORD*)dword_520970))
                        {
                            v9 = (_DWORD*)sub_408F30((_DWORD*)dword_520970);
                            v10 = v9[8];
                            v9 += 8;
                            v23 = v10;
                            v24 = v9[1];
                            v25 = v9[2];
                        }
                        sub_41D960(*(_DWORD**)(this + 104), &v23, v26);
                        sub_41D840(*(_DWORD*)(this + 104));
                    }
                    else
                    {
                        *(_DWORD*)(this + 68) = 1056964608;
                    }
                }
            }
        }
        else
        {
            v4 = *(float*)(v3 + 4);
            *(_BYTE*)v3 = 1;
            *(float*)(this + 68) = v4;
            if (v4 <= 0.0)
                *(_DWORD*)(this + 68) = 981668463;
        }
    }
}
// 520970: using guessed type int dword_520970;

//----- (00402FC0) --------------------------------------------------------
int __thiscall sub_402FC0(int this)
{
    int v2; // ecx
    int result; // eax
    int v4; // ecx
    int v5; // ebx
    int v6; // eax
    _DWORD* v7; // edi
    _DWORD* v8; // edx
    int v9; // ecx
    int v10; // eax
    int v11; // ecx
    int v12; // eax
    char* v13; // eax
    int v14; // edi
    int v15; // ecx

    v2 = *(_DWORD*)(this + 104);
    if (v2)
    {
        sub_41D9A0(v2);
        *(_DWORD*)(this + 104) = 0;
    }
    for (result = *(_DWORD*)(this + 76); result > 0; result = *(_DWORD*)(this + 76))
    {
        v4 = *(_DWORD*)(this + 76);
        v5 = **(_DWORD**)(this + 72);
        v6 = 0;
        if (v4 > 0)
        {
            v7 = *(_DWORD**)(this + 72);
            v8 = v7;
            while (*v8 != v5)
            {
                ++v6;
                ++v8;
                if (v6 >= v4)
                    goto LABEL_11;
            }
            v9 = v4 - 1;
            *(_DWORD*)(this + 76) = v9;
            if (v6 != v9)
            {
                memcpy(&v7[v6], &v7[v6 + 1], 4 * (v9 + 0x3FFFFFFF * v6));
                *(_DWORD*)(*(_DWORD*)(this + 72) + 4 * *(_DWORD*)(this + 76)) = 0;
            }
        }
    LABEL_11:
        v10 = *(_DWORD*)(this + 96);
        v11 = *(_DWORD*)(this + 92) + 1;
        *(_DWORD*)(this + 92) = v11;
        if (v11 > v10)
        {
            v12 = v10 + 8;
            *(_DWORD*)(this + 96) = v12;
            v13 = (char*)sub_488DD7(*(LPVOID*)(this + 88), 4 * v12);
            if (v13)
            {
                v14 = *(_DWORD*)(this + 92);
                v15 = *(_DWORD*)(this + 96) - v14;
                *(_DWORD*)(this + 88) = v13;
                memset(&v13[4 * v14], 0, 4 * v15);
            }
        }
        *(_DWORD*)(*(_DWORD*)(this + 88) + 4 * *(_DWORD*)(this + 92) - 4) = v5;
    }
    return result;
}

//----- (004030B0) --------------------------------------------------------
int __thiscall sub_4030B0(_DWORD* this, int a2, char* String2, int a4)
{
    int v5; // eax
    int v6; // eax
    _DWORD* v7; // ebx
    int v8; // eax
    int v9; // eax
    int v10; // ecx
    void* v11; // ecx
    int v12; // eax
    char* v13; // eax
    int v14; // edi
    int v15; // ecx
    int result; // eax

    v5 = this[23];
    if (v5 <= 0)
    {
        v7 = operator new(0x14u);
    }
    else
    {
        v6 = v5 - 1;
        v7 = *(_DWORD**)(this[22] + 4 * v6);
        this[23] = v6;
    }
    v7[1] = a2;
    v8 = sub_403710((_DWORD*)dword_4B5AB0, String2);
    v7[3] = v8;
    sub_4282E0(v8 != 0, "Dialogue group '%s' not found", String2);
    v7[4] = a4;
    v7[2] = this[16];
    *(_BYTE*)v7 = 0;
    v9 = this[20];
    v10 = this[19] + 1;
    this[19] = v10;
    if (v10 > v9)
    {
        v11 = (void*)this[18];
        v12 = v9 + 8;
        this[20] = v12;
        v13 = (char*)sub_488DD7(v11, 4 * v12);
        if (v13)
        {
            v14 = this[19];
            v15 = this[20] - v14;
            this[18] = v13;
            memset(&v13[4 * v14], 0, 4 * v15);
        }
    }
    *(_DWORD*)(this[18] + 4 * this[19] - 4) = v7;
    result = this[16];
    this[16] = result + 1;
    return result;
}
// 4B5AB0: using guessed type int dword_4B5AB0;

//----- (00403180) --------------------------------------------------------
_DWORD* __thiscall sub_403180(_DWORD* this)
{
    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
    *((_BYTE*)this + 16) = 1;
    this[5] = 0;
    this[6] = 0;
    this[7] = 0;
    *((_BYTE*)this + 32) = 1;
    this[9] = 0;
    this[10] = 0;
    this[11] = 0;
    *((_BYTE*)this + 48) = 1;
    *this = &off_499098;
    dword_4B5AB0 = (int)this;
    sub_4033A0((int)this);
    return this;
}
// 499098: using guessed type _UNKNOWN *off_499098;
// 4B5AB0: using guessed type int dword_4B5AB0;

//----- (00403220) --------------------------------------------------------
void __thiscall sub_403220(void* this)
{
    int i; // edi
    int v3; // eax
    void* v4; // esi
    void* v5; // eax
    int v6; // eax
    int v7; // esi
    int k; // edi
    void* v9; // ecx
    void* v10; // eax
    void* v11; // eax
    int j; // [esp+10h] [ebp-14h]

    *(_DWORD*)this = &off_499098;
    dword_4B5AB0 = 0;
    if (*((_BYTE*)this + 48))
    {
        for (i = 0; i < *((_DWORD*)this + 10); ++i)
        {
            v3 = *((_DWORD*)this + 9);
            v4 = *(void**)(v3 + 4 * i);
            if (v4)
            {
                sub_402CB0(*(_DWORD*)(v3 + 4 * i));
                sub_4885A6(v4);
            }
        }
    }
    memset(*((void**)this + 9), 0, 4 * *((_DWORD*)this + 10));
    v5 = (void*)*((_DWORD*)this + 9);
    *((_DWORD*)this + 10) = 0;
    sub_488CEE(v5);
    *((_DWORD*)this + 11) = 0;
    *((_DWORD*)this + 9) = 0;
    if (*((_BYTE*)this + 32))
    {
        v6 = 0;
        for (j = 0; v6 < *((_DWORD*)this + 6); j = v6)
        {
            v7 = *(_DWORD*)(*((_DWORD*)this + 5) + 4 * v6);
            if (v7)
            {
                if (*(_BYTE*)(v7 + 76))
                {
                    for (k = 0; k < *(_DWORD*)(v7 + 68); ++k)
                    {
                        v9 = *(void**)(*(_DWORD*)(v7 + 64) + 4 * k);
                        if (v9)
                            sub_403860(v9, 1);
                    }
                }
                memset(*(void**)(v7 + 64), 0, 4 * *(_DWORD*)(v7 + 68));
                v10 = *(void**)(v7 + 64);
                *(_DWORD*)(v7 + 68) = 0;
                sub_488CEE(v10);
                *(_DWORD*)(v7 + 72) = 0;
                *(_DWORD*)(v7 + 64) = 0;
                sub_4885A6((LPVOID)v7);
                v6 = j;
            }
            ++v6;
        }
    }
    memset(*((void**)this + 5), 0, 4 * *((_DWORD*)this + 6));
    v11 = (void*)*((_DWORD*)this + 5);
    *((_DWORD*)this + 6) = 0;
    sub_488CEE(v11);
    *((_DWORD*)this + 7) = 0;
    *((_DWORD*)this + 5) = 0;
    *(_DWORD*)this = &off_499040;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 499098: using guessed type _UNKNOWN *off_499098;
// 4B5AB0: using guessed type int dword_4B5AB0;

//----- (004033A0) --------------------------------------------------------
int __thiscall sub_4033A0(int this)
{
    char* v2; // ebp
    _DWORD* v3; // eax
    unsigned int v4; // edx
    unsigned int v5; // edi
    char* v6; // esi
    int v7; // eax
    int v8; // edi
    int v9; // eax
    char* v10; // eax
    int v11; // edi
    int v12; // ecx
    int v13; // eax
    int v14; // esi
    int v15; // eax
    char* v16; // eax
    int v17; // esi
    int v18; // ecx
    char ArgList[4]; // [esp+8h] [ebp-174h] BYREF
    int v21; // [esp+Ch] [ebp-170h]
    char Buffer[64]; // [esp+10h] [ebp-16Ch] BYREF
    _DWORD v23[72]; // [esp+50h] [ebp-12Ch] BYREF
    int v24; // [esp+178h] [ebp-4h]

    sub_40A1D0((int)v23, aDialogueIni);
    v2 = 0;
    v24 = 0;
    if (sub_40AAF0(v23, aDialoguegroup, 0))
    {
        while (1)
        {
            v3 = operator new(0x50u);
            if (v3)
            {
                v3[16] = 0;
                v3[17] = 0;
                v3[18] = 0;
                *((_BYTE*)v3 + 76) = 0;
                v2 = (char*)v3;
            }
            sub_40AA40((int)v23, aDialoguegroup);
            sub_40AFC0(v23, aName, ArgList);
            sub_4229D0("Loading Dialogue Group %s", *(const char**)ArgList);
            v4 = strlen(*(const char**)ArgList) + 1;
            v5 = *(_DWORD*)ArgList + v4;
            v21 = 1;
            qmemcpy(v2, *(const void**)ArgList, 4 * (v4 >> 2));
            qmemcpy(&v2[4 * (v4 >> 2)], (const void*)(v5 - v4 + 4 * (v4 >> 2)), v4 & 3);
            while (1)
            {
                sprintf(Buffer, "Sound%d", v21);
                if (!sub_40ABC0(v23, Buffer, 0))
                    break;
                sub_40AFC0(v23, Buffer, ArgList);
                sub_4229D0("  Loading Dialogue Line '%s'", *(const char**)ArgList);
                v6 = (char*)sub_41E250(*(_DWORD**)(dword_520970 + 120), *(char**)ArgList);
                if (!v6)
                {
                    v6 = sub_41DE10(*(_DWORD**)(dword_520970 + 120), *(char**)ArgList, 1, 0, 0, 1, 0);
                    sub_4282E0(v6 != 0, "Couldn't load dialogue sound '%s' for group '%s'", *(const char**)ArgList, v2);
                }
                v7 = *((_DWORD*)v2 + 18);
                v8 = *((_DWORD*)v2 + 17) + 1;
                *((_DWORD*)v2 + 17) = v8;
                if (v8 > v7)
                {
                    v9 = v7 + 8;
                    *((_DWORD*)v2 + 18) = v9;
                    v10 = (char*)sub_488DD7(*((LPVOID*)v2 + 16), 4 * v9);
                    if (v10)
                    {
                        v11 = *((_DWORD*)v2 + 17);
                        v12 = *((_DWORD*)v2 + 18) - v11;
                        *((_DWORD*)v2 + 16) = v10;
                        memset(&v10[4 * v11], 0, 4 * v12);
                    }
                }
                *(_DWORD*)(*((_DWORD*)v2 + 16) + 4 * *((_DWORD*)v2 + 17) - 4) = v6;
                ++v21;
            }
            v13 = *(_DWORD*)(this + 28);
            v14 = *(_DWORD*)(this + 24) + 1;
            *(_DWORD*)(this + 24) = v14;
            if (v14 > v13)
            {
                v15 = v13 + 8;
                *(_DWORD*)(this + 28) = v15;
                v16 = (char*)sub_488DD7(*(LPVOID*)(this + 20), 4 * v15);
                if (v16)
                {
                    v17 = *(_DWORD*)(this + 24);
                    v18 = *(_DWORD*)(this + 28) - v17;
                    *(_DWORD*)(this + 20) = v16;
                    memset(&v16[4 * v17], 0, 4 * v18);
                }
            }
            *(_DWORD*)(*(_DWORD*)(this + 20) + 4 * *(_DWORD*)(this + 24) - 4) = v2;
            if (!sub_40AAF0(v23, aDialoguegroup, 0))
                break;
            v2 = 0;
        }
    }
    v24 = -1;
    return sub_40A830((int)v23);
}
// 520970: using guessed type int dword_520970;

//----- (00403620) --------------------------------------------------------
char* __thiscall sub_403620(_DWORD* this, char* String2)
{
    int v3; // edi
    char* v4; // ebx
    char* v5; // eax
    int v6; // eax
    int v7; // ecx
    void* v8; // edx
    int v9; // eax
    char* v10; // eax
    int v11; // edi
    int v12; // ecx

    v3 = 0;
    if ((int)this[10] <= 0)
    {
    LABEL_4:
        v5 = (char*)operator new(0x6Cu);
        if (v5)
            v4 = sub_402C60(v5, String2);
        else
            v4 = 0;
        v6 = this[11];
        v7 = this[10] + 1;
        this[10] = v7;
        if (v7 > v6)
        {
            v8 = (void*)this[9];
            v9 = v6 + 8;
            this[11] = v9;
            v10 = (char*)sub_488DD7(v8, 4 * v9);
            if (v10)
            {
                v11 = this[10];
                v12 = this[11] - v11;
                this[9] = v10;
                memset(&v10[4 * v11], 0, 4 * v12);
            }
        }
        *(_DWORD*)(this[9] + 4 * this[10] - 4) = v4;
    }
    else
    {
        while (1)
        {
            v4 = *(char**)(this[9] + 4 * v3);
            if (!_strcmpi(v4, String2))
                break;
            if (++v3 >= this[10])
                goto LABEL_4;
        }
    }
    return v4;
}

//----- (004036D0) --------------------------------------------------------
char __thiscall sub_4036D0(_DWORD* this, int a2)
{
    int i; // esi

    for (i = 0; i < this[10]; ++i)
        sub_402DA0(*(_DWORD*)(this[9] + 4 * i), *(float*)(dword_520970 + 68));
    return sub_428620(this, a2);
}
// 520970: using guessed type int dword_520970;

//----- (00403710) --------------------------------------------------------
int __thiscall sub_403710(_DWORD* this, char* String2)
{
    int v3; // esi

    v3 = 0;
    if ((int)this[6] <= 0)
        return 0;
    while (_strcmpi(*(const char**)(this[5] + 4 * v3), String2))
    {
        if (++v3 >= this[6])
            return 0;
    }
    return *(_DWORD*)(this[5] + 4 * v3);
}

//----- (00403760) --------------------------------------------------------
void __thiscall sub_403760(int this)
{
    int i; // ebp
    void* v3; // edi
    void* v4; // eax

    if (*(_BYTE*)(this + 12))
    {
        for (i = 0; i < *(_DWORD*)(this + 4); ++i)
        {
            v3 = *(void**)(*(_DWORD*)this + 4 * i);
            if (v3)
            {
                sub_403920(*(_DWORD*)(*(_DWORD*)this + 4 * i));
                sub_4885A6(v3);
            }
        }
    }
    memset(*(void**)this, 0, 4 * *(_DWORD*)(this + 4));
    v4 = *(void**)this;
    *(_DWORD*)(this + 4) = 0;
    sub_488CEE(v4);
    *(_DWORD*)(this + 8) = 0;
    *(_DWORD*)this = 0;
}

//----- (004037E0) --------------------------------------------------------
void __thiscall sub_4037E0(int this)
{
    int i; // ebp
    void* v3; // edi
    void* v4; // eax

    if (*(_BYTE*)(this + 12))
    {
        for (i = 0; i < *(_DWORD*)(this + 4); ++i)
        {
            v3 = *(void**)(*(_DWORD*)this + 4 * i);
            if (v3)
            {
                sub_402CB0(*(_DWORD*)(*(_DWORD*)this + 4 * i));
                sub_4885A6(v3);
            }
        }
    }
    memset(*(void**)this, 0, 4 * *(_DWORD*)(this + 4));
    v4 = *(void**)this;
    *(_DWORD*)(this + 4) = 0;
    sub_488CEE(v4);
    *(_DWORD*)(this + 8) = 0;
    *(_DWORD*)this = 0;
}

//----- (00403860) --------------------------------------------------------
void* __thiscall sub_403860(void* this, char a2)
{
    sub_403880((int)this);
    if ((a2 & 1) != 0)
        sub_4885A6(this);
    return this;
}

//----- (00403880) --------------------------------------------------------
void __thiscall sub_403880(int this)
{
    int i; // ebp
    int v3; // eax
    void* v4; // edi
    void* v5; // eax

    if (*(_BYTE*)(this + 292))
    {
        for (i = 0; i < *(_DWORD*)(this + 284); ++i)
        {
            v3 = *(_DWORD*)(this + 280);
            v4 = *(void**)(v3 + 4 * i);
            if (v4)
            {
                sub_41C700(*(_DWORD*)(v3 + 4 * i));
                sub_4885A6(v4);
            }
        }
    }
    memset(*(void**)(this + 280), 0, 4 * *(_DWORD*)(this + 284));
    v5 = *(void**)(this + 280);
    *(_DWORD*)(this + 284) = 0;
    sub_488CEE(v5);
    *(_DWORD*)(this + 288) = 0;
    *(_DWORD*)(this + 280) = 0;
}

//----- (00403920) --------------------------------------------------------
void __thiscall sub_403920(int this)
{
    int v2; // ebp
    int v3; // eax
    int v4; // esi
    int v5; // edx
    void* v6; // edi
    void* v7; // eax
    void* v8; // eax
    int i; // [esp+Ch] [ebp-4h]

    if (*(_BYTE*)(this + 76))
    {
        v2 = 0;
        v3 = 0;
        for (i = 0; v3 < *(_DWORD*)(this + 68); i = v3)
        {
            v4 = *(_DWORD*)(*(_DWORD*)(this + 64) + 4 * v3);
            if (v4)
            {
                if (*(_BYTE*)(v4 + 292))
                {
                    if (*(int*)(v4 + 284) > 0)
                    {
                        do
                        {
                            v5 = *(_DWORD*)(v4 + 280);
                            v6 = *(void**)(v5 + 4 * v2);
                            if (v6)
                            {
                                sub_41C700(*(_DWORD*)(v5 + 4 * v2));
                                sub_4885A6(v6);
                            }
                            ++v2;
                        } while (v2 < *(_DWORD*)(v4 + 284));
                    }
                    v2 = 0;
                }
                memset(*(void**)(v4 + 280), 0, 4 * *(_DWORD*)(v4 + 284));
                v7 = *(void**)(v4 + 280);
                *(_DWORD*)(v4 + 284) = 0;
                sub_488CEE(v7);
                *(_DWORD*)(v4 + 288) = 0;
                *(_DWORD*)(v4 + 280) = 0;
                sub_4885A6((LPVOID)v4);
                v3 = i;
            }
            ++v3;
        }
    }
    memset(*(void**)(this + 64), 0, 4 * *(_DWORD*)(this + 68));
    v8 = *(void**)(this + 64);
    *(_DWORD*)(this + 68) = 0;
    sub_488CEE(v8);
    *(_DWORD*)(this + 72) = 0;
    *(_DWORD*)(this + 64) = 0;
}

//----- (00403A30) --------------------------------------------------------
_DWORD* sub_403A30(_DWORD* a1, int a2, char* Format, ...)
{
    char* v3; // eax
    va_list va; // [esp+14h] [ebp+10h] BYREF

    va_start(va, Format);
    *a1 = a2;
    v3 = (char*)malloc(0x100u);
    a1[1] = v3;
    _vsnprintf(v3, 0xFFu, Format, va);
    return a1;
}

//----- (00403A90) --------------------------------------------------------
void __thiscall sub_403A90(void* this)
{
    int v2; // eax
    int v3; // eax

    v2 = *((_DWORD*)this + 11);
    if (v2)
    {
        (*(void(__stdcall**)(int))(*(_DWORD*)v2 + 8))(v2);
        *((_DWORD*)this + 11) = 0;
    }
    v3 = *((_DWORD*)this + 9);
    if (v3)
    {
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)v3 + 8))(*((_DWORD*)this + 9));
        *((_DWORD*)this + 9) = 0;
    }
    if (*((_DWORD*)this + 4))
    {
        sub_488CEE(*((LPVOID*)this + 4));
        *((_DWORD*)this + 4) = 0;
    }
    sub_4885A6(*((LPVOID*)this + 2));
    *((_DWORD*)this + 2) = 0;
}

//----- (00403AE0) --------------------------------------------------------
void __thiscall sub_403AE0(void* this)
{
    int* v2; // ecx

    v2 = (int*)*((_DWORD*)this + 21);
    if (v2)
    {
        sub_422230(v2);
        *((_DWORD*)this + 21) = 0;
    }
    sub_4885A6(*((LPVOID*)this + 19));
    *((_DWORD*)this + 19) = 0;
}

//----- (00403B10) --------------------------------------------------------
_DWORD* __thiscall sub_403B10(_DWORD* this)
{
    _DWORD* result; // eax

    result = this;
    *this = &off_4990BC;
    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
    this[4] = 0;
    this[5] = 0;
    this[7] = 0;
    this[8] = 0;
    this[10] = 0;
    this[9] = 0;
    this[11] = 0;
    this[12] = 0;
    this[13] = 0;
    this[14] = 1;
    *((_BYTE*)this + 60) = 0;
    *((_BYTE*)this + 320) = 0;
    this[145] = 0;
    this[146] = 0;
    return result;
}
// 4990BC: using guessed type int (__stdcall *off_4990BC)(int, int, int);

//----- (00403B60) --------------------------------------------------------
void __thiscall sub_403B60(_DWORD* this)
{
    *this = &off_4990BC;
    sub_403CE0(this);
}
// 4990BC: using guessed type int (__stdcall *off_4990BC)(int, int, int);

//----- (00403B70) --------------------------------------------------------
void __thiscall sub_403B70(_DWORD* this)
{
    int v2; // eax
    _DWORD* v3; // ecx

    v2 = this[14] - 1;
    this[14] = v2;
    if (v2 <= 0)
    {
        v3 = (_DWORD*)this[146];
        if (v3)
            sub_406A50(v3, (int)this);
        if (this)
        {
            sub_403B60(this);
            sub_4885A6(this);
        }
    }
}

//----- (00403BB0) --------------------------------------------------------
bool __thiscall sub_403BB0(_DWORD* this, int a2, const char* a3)
{
    int v3; // ebx
    char* v4; // edx
    int* v5; // ecx
    _DWORD* v6; // eax

    v3 = *(_DWORD*)(this[1] + 172 * a2 + 52);
    if (!v3 || !*(_DWORD*)(v3 + 84))
        return 0;
    if (*(_DWORD*)(v3 + 76))
        sub_4885A6(*(LPVOID*)(v3 + 76));
    v4 = (char*)operator new(strlen(a3) + 1);
    *(_DWORD*)(v3 + 76) = v4;
    strcpy(v4, a3);
    v5 = *(int**)(v3 + 84);
    if (v5)
    {
        sub_422230(v5);
        *(_DWORD*)(v3 + 84) = 0;
    }
    if (byte_4A1D44)
    {
        v6 = sub_422400(*(_DWORD**)(dword_520970 + 124), *(char**)(v3 + 76), 0);
        *(_DWORD*)(v3 + 84) = v6;
        return v6 != 0;
    }
    else
    {
        *(_DWORD*)(v3 + 84) = 0;
        return 0;
    }
}
// 4A1D44: using guessed type char byte_4A1D44;
// 520970: using guessed type int dword_520970;

//----- (00403C80) --------------------------------------------------------
int __thiscall sub_403C80(_DWORD* this, int a2, char a3)
{
    int result; // eax

    result = this[1];
    *(_BYTE*)(result + 172 * a2 + 56) = a3;
    return result;
}

//----- (00403CB0) --------------------------------------------------------
int __thiscall sub_403CB0(_DWORD* this, int a2)
{
    int v2; // eax

    v2 = *(_DWORD*)(this[1] + 172 * a2 + 52);
    if (v2)
        return *(_DWORD*)(v2 + 84);
    else
        return 0;
}

//----- (00403CE0) --------------------------------------------------------
void __thiscall sub_403CE0(_DWORD* this)
{
    char* v2; // eax
    char* v3; // edi
    char* v4; // eax
    char* v5; // edi
    void* v6; // eax
    void* v7; // ecx
    char* v8; // eax
    char* v9; // edi

    v2 = (char*)this[1];
    this[2] = 0;
    if (v2)
    {
        v3 = v2 - 4;
        `eh vector destructor iterator'(v2, 0xACu, *((_DWORD *)v2 - 1), sub_403A90);
            sub_4885A6(v3);
    }
    v4 = (char*)this[8];
    this[1] = 0;
    this[7] = 0;
    if (v4)
    {
        v5 = v4 - 4;
        `eh vector destructor iterator'(v4, 0xACu, *((_DWORD *)v4 - 1), sub_403A90);
            sub_4885A6(v5);
    }
    v6 = (void*)this[11];
    this[8] = 0;
    sub_4885A6(v6);
    v7 = (void*)this[12];
    this[11] = 0;
    sub_4885A6(v7);
    v8 = (char*)this[3];
    this[12] = 0;
    if (v8)
    {
        v9 = v8 - 4;
        `eh vector destructor iterator'(v8, 0x58u, *((_DWORD *)v8 - 1), sub_403AE0);
            sub_4885A6(v9);
    }
    this[3] = 0;
    this[4] = 0;
    this[13] = 0;
}

//----- (00403D90) --------------------------------------------------------
char* __thiscall sub_403D90(char* this, const char* a2)
{
    char* v2; // ebx
    char* result; // eax

    v2 = this + 320;
    strcpy(this + 60, a2);
    strcpy(this + 320, this + 60);
    result = strrchr(this + 320, 92);
    if (result)
    {
        result[1] = 0;
    }
    else
    {
        result = (char*)(strlen(".\\") + 1);
        qmemcpy(v2, ".\\", (unsigned int)result);
    }
    return result;
}

//----- (00403E30) --------------------------------------------------------
char __usercall sub_403E30@<al>(int a1@<ecx>, int a2@<ebp>)
{
    sub_403CE0((_DWORD*)a1);
    sub_4229D0("-Loading '%s'", (const char*)(a1 + 60));
    if (!sub_403EC0(a1, a2, a1 + 60, (char*)(a1 + 60)))
        sub_4281B0("Failed to load model file '%s'", (const char*)(a1 + 60));
    ++*(_DWORD*)(a1 + 52);
    return 1;
}

//----- (00403E80) --------------------------------------------------------
int __userpurge sub_403E80@<eax>(int a1@<ecx>, int a2@<ebp>, char* ArgList)
{
    int result; // eax

    if (!sub_403EC0(a1, a2, (int)ArgList, ArgList))
        sub_4281B0("Failed to load animation file '%s'", ArgList);
    result = *(_DWORD*)(a1 + 52);
    *(_DWORD*)(a1 + 52) = result + 1;
    return result;
}

//----- (00403EC0) --------------------------------------------------------
char __userpurge sub_403EC0@<al>(int a1@<ecx>, int a2@<ebp>, int a3@<edi>, char* FileName)
{
    FILE* v5; // eax
    char result; // al
    char v7; // bl

    v5 = fopen(FileName, Mode);
    *(_DWORD*)(a1 + 20) = v5;
    if (!v5)
        return 0;
    if (sub_403F50(a1) && sub_403FE0((FILE**)a1) && sub_404510(a1))
    {
        v7 = 1;
        if (!*(_DWORD*)(a1 + 52))
        {
            if (byte_4A1D45)
                sub_4051C0((_DWORD*)a1, a2, a3);
        }
    }
    else
    {
        v7 = 0;
    }
    fclose(*(FILE**)(a1 + 20));
    result = v7;
    *(_DWORD*)(a1 + 20) = 0;
    return result;
}
// 4A1D45: using guessed type char byte_4A1D45;

//----- (00403F40) --------------------------------------------------------
int __thiscall sub_403F40(_DWORD* this)
{
    return this[13];
}

//----- (00403F50) --------------------------------------------------------
bool __thiscall sub_403F50(int this)
{
    bool v2; // al
    char v3; // al
    int Buffer; // [esp+4h] [ebp-4h] BYREF

    v2 = sub_4057E0((FILE**)this, &Buffer);
    *(_DWORD*)(this + 24) = -1;
    if (!v2)
        goto LABEL_7;
    if ((Buffer & 0xDAFA0000) == 0xDAFA0000)
        *(_DWORD*)(this + 24) = (unsigned __int16)Buffer;
    if (*(_DWORD*)(this + 24) != -1 && sub_4057E0((FILE**)this, (void*)(this + 28)))
        v3 = 1;
    else
        LABEL_7:
    v3 = 0;
    if (!*(_DWORD*)(this + 52))
        *(_DWORD*)(this + 8) = *(_DWORD*)(this + 28);
    return v3 && sub_4057E0((FILE**)this, (void*)(this + 36)) && sub_4057E0((FILE**)this, (void*)(this + 40));
}

//----- (00403FE0) --------------------------------------------------------
char __thiscall sub_403FE0(FILE** this)
{
    FILE** v1; // ebp
    bool v2; // bl
    int v3; // eax
    int* v4; // eax
    FILE* v5; // edi
    int v6; // eax
    bool v7; // al
    bool v8; // al
    bool v9; // al
    int v10; // ecx
    bool v11; // al
    char* v12; // edx
    bool v13; // bl
    unsigned int v14; // ecx
    unsigned int v15; // ebp
    char* v16; // edi
    char* v17; // edi
    char* v18; // esi
    char v19; // cl
    void* v20; // eax
    bool v21; // cc
    char v22; // bl
    int Buffer; // [esp+10h] [ebp-180h] BYREF
    int v25; // [esp+14h] [ebp-17Ch]
    char* v26; // [esp+18h] [ebp-178h]
    int v27; // [esp+1Ch] [ebp-174h]
    int v28; // [esp+20h] [ebp-170h] BYREF
    _DWORD v29[22]; // [esp+24h] [ebp-16Ch] BYREF
    FILE** v30; // [esp+7Ch] [ebp-114h]
    char v31[260]; // [esp+80h] [ebp-110h] BYREF
    int v32; // [esp+18Ch] [ebp-4h]

    v1 = this;
    v30 = this;
    v2 = sub_405820(this, (FILE**)0xF00D8345) && sub_4057E0(v1, &Buffer);
    v32 = 0;
    memset(v29, 0, sizeof(v29));
    if (!v2)
        goto LABEL_76;
    v3 = Buffer;
    if (Buffer > 0)
    {
        if (!v1[13])
        {
            v4 = (int*)operator new(88 * Buffer + 4);
            if (v4)
            {
                v5 = (FILE*)(v4 + 1);
                *v4 = Buffer;
            }
            else
            {
                v5 = 0;
            }
            v6 = Buffer;
            v1[3] = v5;
            memset(v5, 0, 4 * ((unsigned int)(88 * v6) >> 2));
            v3 = Buffer;
        }
        v27 = 0;
        if (v3 > 0)
        {
            v25 = 0;
            while (1)
            {
                memset(v29, 0, sizeof(v29));
                v7 = v2 && sub_4057E0(v1, v29);
                if ((int)v1[6] < 3)
                {
                    v29[5] = 1065353216;
                    v29[6] = 1065353216;
                    v29[7] = 1065353216;
                    v29[8] = 1065353216;
                    v29[1] = 1065353216;
                    v29[2] = 1065353216;
                    v29[3] = 1065353216;
                    v29[4] = 1065353216;
                    v29[9] = 1065353216;
                    v29[10] = 1065353216;
                    v29[11] = 1065353216;
                }
                else
                {
                    v8 = v7 && sub_4057E0(v1, &v29[5]) && sub_4057E0(v1, &v29[6]) && sub_4057E0(v1, &v29[7]);
                    v29[8] = 1065353216;
                    v9 = v8 && sub_4057E0(v1, &v29[1]) && sub_4057E0(v1, &v29[2]) && sub_4057E0(v1, &v29[3]);
                    v29[4] = 1065353216;
                    v7 = v9 && sub_4057E0(v1, &v29[9]) && sub_4057E0(v1, &v29[10]) && sub_4057E0(v1, &v29[11]);
                }
                v10 = (int)v1[6];
                v29[12] = 1065353216;
                if (v10 >= 3)
                    v7 = v7 && sub_405800(v1, &v29[18]) && sub_405800(v1, (char*)&v29[18] + 1);
                if (LOBYTE(v29[18]))
                {
                    v29[13] = v29[1];
                    v29[14] = v29[2];
                    v29[15] = v29[3];
                    v29[16] = v29[4];
                }
                if (!v7)
                    goto LABEL_58;
                v11 = sub_405770(v1, (unsigned int)&v28);
                v12 = (char*)v28;
                v13 = v11;
                if (*(_BYTE*)v28)
                {
                    v26 = strcpy(v31, (const char*)v1 + 320);
                    if (strlen(v31) == 1)
                        v14 = 0;
                    else
                        v14 = strlen(v31) - 1;
                    if (v31[v14] != 92)
                    {
                        v15 = strlen(asc_4A1DC4) + 1;
                        v16 = &v31[strlen(v31)];
                        qmemcpy(v16, asc_4A1DC4, 4 * (v15 >> 2));
                        v18 = &asc_4A1DC4[4 * (v15 >> 2)];
                        v17 = &v16[4 * (v15 >> 2)];
                        v19 = v15;
                        v1 = v30;
                        qmemcpy(v17, v18, v19 & 3);
                    }
                    strcat(v31, v12);
                    v29[19] = operator new(strlen(v31) + 1);
                    strcpy((char*)v29[19], v31);
                    v12 = (char*)v28;
                }
                else
                {
                    v29[19] = 0;
                }
                sub_4885A6(v12);
                if (v13 && sub_405800(v1, &v29[20]))
                    v2 = 1;
                else
                    LABEL_58:
                v2 = 0;
                v20 = (void*)v29[19];
                if (!v29[19] || !*(_BYTE*)v29[19] || v1[13])
                {
                    v29[21] = 0;
                    goto LABEL_67;
                }
                if (!byte_4A1D44)
                    break;
                v29[21] = sub_422400(*(_DWORD**)(dword_520970 + 124), (char*)v29[19], 0);
                v20 = (void*)v29[19];
                if (!v29[21])
                    goto LABEL_64;
            LABEL_67:
                if (v1[13])
                    sub_4885A6(v20);
                else
                    qmemcpy((char*)v1[3] + v25, v29, 0x58u);
                v29[19] = 0;
                v29[21] = 0;
                v3 = Buffer;
                v21 = ++v27 < Buffer;
                v25 += 88;
                if (!v21)
                    goto LABEL_71;
            }
            v29[21] = 0;
        LABEL_64:
            sub_4229D0("***FAILED to load texture '%s'", (const char*)v20);
            v20 = (void*)v29[19];
            goto LABEL_67;
        }
    LABEL_71:
        if (!v1[13])
            v1[4] = (FILE*)v3;
    }
    if (v2 && sub_405820(v1, (FILE**)0xF00D8346))
        v22 = 1;
    else
        LABEL_76:
    v22 = 0;
    v32 = -1;
    sub_403AE0(v29);
    return v22;
}
// 4A1D44: using guessed type char byte_4A1D44;
// 520970: using guessed type int dword_520970;

//----- (004044D0) --------------------------------------------------------
_DWORD* __thiscall sub_4044D0(_DWORD* this, int a2)
{
    int v2; // edx
    int v3; // eax
    _DWORD* v4; // esi
    _DWORD* i; // ecx

    v2 = this[4];
    v3 = 0;
    if (v2 <= 0)
        return 0;
    v4 = (_DWORD*)this[3];
    for (i = v4; *i != a2; i += 22)
    {
        if (++v3 >= v2)
            return 0;
    }
    return &v4[22 * v3];
}

//----- (00404510) --------------------------------------------------------
bool __thiscall sub_404510(int this)
{
    int v2; // edi
    bool v3; // bl
    int* v4; // eax
    _DWORD* v5; // ebp
    void* v6; // edi
    int v7; // ecx
    char* v8; // eax
    char* v9; // edi
    int v10; // edx
    void* v11; // ecx
    _DWORD* v12; // eax
    int v13; // edx
    int v14; // ecx
    _DWORD* v15; // eax
    int v16; // edx
    int v17; // ecx

    if (!sub_405820((FILE**)this, (FILE**)0xDEFF2843))
        return 0;
    v2 = *(_DWORD*)(this + 28);
    v3 = 1;
    if (v2 > 0)
    {
        v4 = (int*)operator new(172 * v2 + 4);
        if (v4)
        {
            v5 = v4 + 1;
            *v4 = v2;
            `eh vector constructor iterator'(v4 + 1, 0xACu, v2, sub_4046A0, sub_403A90);
                v6 = v5;
        }
        else
        {
            v6 = 0;
        }
        v7 = *(_DWORD*)(this + 28);
        *(_DWORD*)(this + 32) = v6;
        memset(v6, 0, 172 * v7);
        v3 = sub_4046C0((FILE**)this, -1, 0);
    }
    if (*(_DWORD*)(this + 52))
    {
        sub_4050B0((_DWORD*)this);
        v8 = *(char**)(this + 32);
        if (v8)
        {
            v9 = v8 - 4;
            `eh vector destructor iterator'(v8, 0xACu, *((_DWORD *)v8 - 1), sub_403A90);
                sub_4885A6(v9);
        }
    }
    else
    {
        *(_DWORD*)(this + 4) = *(_DWORD*)(this + 32);
    }
    v10 = *(_DWORD*)(this + 52);
    v11 = *(void**)(this + 44);
    *(_DWORD*)(this + 32) = 0;
    v12 = sub_488DD7(v11, 4 * v10 + 4);
    v13 = *(_DWORD*)(this + 52);
    v14 = *(_DWORD*)(this + 36);
    *(_DWORD*)(this + 44) = v12;
    v12[v13] = v14;
    v15 = sub_488DD7(*(LPVOID*)(this + 48), 4 * *(_DWORD*)(this + 52) + 4);
    v16 = *(_DWORD*)(this + 52);
    v17 = *(_DWORD*)(this + 40);
    *(_DWORD*)(this + 48) = v15;
    v15[v16] = v17;
    if (!v3)
        return 0;
    return sub_405820((FILE**)this, (FILE**)0xDEFF2844);
}

//----- (004046A0) --------------------------------------------------------
void __thiscall sub_4046A0(char* this)
{
    memset(this + 84, 0, 0x58u);
}

//----- (004046C0) --------------------------------------------------------
bool __thiscall sub_4046C0(FILE** this, int a2, int ArgList)
{
    int v3; // ebp
    bool v4; // dl
    int v5; // esi
    bool v6; // al
    int* v7; // edi
    bool v8; // bl
    int v9; // ebp
    bool v10; // al
    int* v11; // ebp
    bool v12; // bl
    int v13; // edi
    bool result; // al
    int v15; // ecx
    int v16; // esi
    char v17; // al
    int Buffer; // [esp+10h] [ebp-Ch] BYREF
    int v20; // [esp+14h] [ebp-8h] BYREF
    int v21; // [esp+18h] [ebp-4h] BYREF
    int v22; // [esp+20h] [ebp+4h]

    v3 = (int)this;
    v4 = sub_405820(this, (FILE**)0xFF0D8455) && sub_4057E0((FILE**)v3, &Buffer);
    v5 = *(_DWORD*)(v3 + 32) + 172 * Buffer;
    *(_DWORD*)(v5 + 28) = a2;
    *(_DWORD*)(v5 + 32) = ArgList;
    *(_BYTE*)(v5 + 56) = 0;
    v6 = 0;
    if (v4)
    {
        if (sub_4057E0((FILE**)v3, &v21))
        {
            *(_DWORD*)(v5 + 4) = v21;
            if (sub_405770((FILE**)v3, v5 + 8))
                v6 = 1;
        }
    }
    *(_BYTE*)v5 = 1;
    if (!v6)
        goto LABEL_22;
    v7 = (int*)(v5 + 12);
    if (!sub_4057E0((FILE**)v3, (void*)(v5 + 12)))
        goto LABEL_22;
    v8 = 1;
    *(_DWORD*)(v5 + 16) = malloc(40 * *v7);
    v22 = 0;
    if (*v7 > 0)
    {
        v9 = 0;
        do
        {
            v8 = v8 && sub_405850((int)this, v9 + *(_DWORD*)(v5 + 16));
            v9 += 40;
            ++v22;
        } while (v22 < *v7);
        v3 = (int)this;
        if (!v8)
            goto LABEL_22;
    }
    if (sub_405820((FILE**)v3, (FILE**)0xDFFE9393))
        v10 = 1;
    else
        LABEL_22:
    v10 = 0;
    if (*(int*)(v3 + 24) < 2)
    {
        if (!v10)
            goto LABEL_41;
        goto LABEL_38;
    }
    if (!v10)
    {
    LABEL_36:
        v10 = 0;
        goto LABEL_41;
    }
    v11 = (int*)(v5 + 20);
    if (!sub_4057E0(this, (void*)(v5 + 20)))
        goto LABEL_35;
    v12 = 1;
    *(_DWORD*)(v5 + 24) = operator new(8 * *v11);
    v13 = 0;
    if (*v11 > 0)
    {
        do
            v12 = v12 && sub_4059A0(this, *(_DWORD*)(v5 + 24) + 8 * v13++);
        while (v13 < *v11);
        if (!v12)
            goto LABEL_35;
    }
    if (!sub_405820(this, (FILE**)0x2BC95478))
    {
    LABEL_35:
        v3 = (int)this;
        goto LABEL_36;
    }
    v3 = (int)this;
    v10 = 1;
LABEL_38:
    if (**(_BYTE**)(v5 + 8) == 42)
    {
        *(_BYTE*)(v5 + 80) = 1;
        *(_BYTE*)(v5 + 81) = 0;
    }
    else
    {
        *(_BYTE*)(v5 + 80) = 0;
        *(_BYTE*)(v5 + 81) = 1;
    }
LABEL_41:
    if (*(_DWORD*)(v5 + 4) == -267452414)
        v10 = v10 && sub_404950(v3, v5);
    else
        *(_DWORD*)(v5 + 76) = 0;
    if (!*(_DWORD*)(v5 + 48) || !*(_DWORD*)(v5 + 40))
    {
        *(_BYTE*)(v5 + 81) = 0;
        *(_BYTE*)(v5 + 80) = 0;
    }
    if (v10)
    {
        if (!sub_4057E0((FILE**)v3, &v20))
            return 0;
        v15 = v20;
        result = 1;
        if (v20 > 0)
        {
            v16 = 0;
            do
            {
                if (result)
                {
                    v17 = sub_4046C0(Buffer, ArgList + 1);
                    v15 = v20;
                    result = v17 != 0;
                }
                ++v16;
            } while (v16 < v15);
        }
    }
    else
    {
        if (v5)
        {
            sub_4229D0("*%s FAILED TO LOAD", *(const char**)(v5 + 8));
            return 0;
        }
        sub_4229D0(aUnknownFailedT);
        return 0;
    }
    return result;
}

//----- (00404950) --------------------------------------------------------
bool __thiscall sub_404950(int this, int a2)
{
    int v2; // edi
    int v3; // ebp
    int v4; // eax
    bool v5; // bl
    bool v6; // al
    int v7; // edx
    int v8; // ecx
    float* v9; // eax
    int* v10; // eax
    int v11; // eax
    int* v12; // esi
    bool v13; // bl
    _DWORD* v14; // ebp
    int v15; // eax
    int v16; // esi
    bool v17; // al
    bool v18; // al
    bool v19; // al
    int v20; // ecx
    float* v21; // eax
    float* v22; // ebp
    int v23; // eax
    int v24; // ebx
    unsigned int v25; // esi
    int v26; // edx
    int v27; // eax
    int v28; // ecx
    int v29; // edx
    int v30; // ebx
    int v32; // [esp+5Ch] [ebp-38h]
    float v33; // [esp+60h] [ebp-34h] BYREF
    float v34; // [esp+64h] [ebp-30h] BYREF
    int v35; // [esp+68h] [ebp-2Ch] BYREF
    int v36; // [esp+6Ch] [ebp-28h] BYREF
    _DWORD* v37; // [esp+70h] [ebp-24h]
    float* v38; // [esp+74h] [ebp-20h] BYREF
    float* v39; // [esp+78h] [ebp-1Ch]
    float Buffer; // [esp+7Ch] [ebp-18h] BYREF
    float v41; // [esp+80h] [ebp-14h] BYREF
    float v42; // [esp+84h] [ebp-10h] BYREF
    int v43; // [esp+88h] [ebp-Ch] BYREF
    int v44; // [esp+8Ch] [ebp-8h] BYREF
    int v45; // [esp+90h] [ebp-4h] BYREF

    v2 = a2;
    v32 = this;
    *(_BYTE*)(a2 + 82) = 0;
    *(_BYTE*)(v2 + 83) = 0;
    if (*(int*)(this + 24) >= 5)
    {
        if (!sub_405820((FILE**)this, (FILE**)0xBEEDDEEB))
            goto LABEL_48;
        this = v32;
    }
    if (!sub_4057E0((FILE**)this, (void*)(v2 + 40)))
        goto LABEL_48;
    if (*(int*)(v2 + 40) > 0)
    {
        if (*(_BYTE*)(v2 + 80))
            sub_4263E0((_DWORD*)(v2 + 84), 2);
        else
            sub_4263E0((_DWORD*)(v2 + 84), 1049426);
        if ((*(int(__stdcall**)(_DWORD, int, int, _DWORD, int, int))(**(_DWORD**)ArgList + 92))(
            *(_DWORD*)ArgList,
            *(_DWORD*)(v2 + 168) * *(_DWORD*)(v2 + 40),
            *(_BYTE*)(v2 + 80) != 0 ? 512 : 8,
            *(_DWORD*)(v2 + 84),
            (*(_BYTE*)(v2 + 80) != 0) + 1,
            v2 + 36))
        {
            goto LABEL_48;
        }
        v3 = 0;
        v37 = (_DWORD*)(v2 + 84);
        v4 = *(_DWORD*)(v2 + 36);
        Buffer = 0.0;
        v41 = 0.0;
        v42 = 0.0;
        v43 = 0;
        v44 = 0;
        v45 = 0;
        v39 = 0;
        v5 = 1;
        (*(void(__stdcall**)(int, _DWORD, _DWORD, float**, _DWORD))(*(_DWORD*)v4 + 44))(v4, 0, 0, &v38, 0);
        v39 = v38;
        if (*(int*)(v2 + 40) > 0)
        {
            while (1)
            {
                v6 = v5
                    && sub_4057E0((FILE**)v32, &Buffer)
                    && sub_4057E0((FILE**)v32, &v41)
                    && sub_4057E0((FILE**)v32, &v42)
                    && sub_4057E0((FILE**)v32, &v43)
                    && sub_4057E0((FILE**)v32, &v44)
                    && sub_4057E0((FILE**)v32, &v45);
                v7 = *(_DWORD*)(v32 + 24);
                v8 = -1;
                a2 = -1;
                if (v7 >= 4)
                    break;
            LABEL_32:
                v5 = v6 && sub_4057E0((FILE**)v32, &v33) && sub_4057E0((FILE**)v32, &v34);
                v9 = v39;
                *v39 = Buffer;
                v9[1] = v41;
                v9[2] = v42;
                if (!*(_BYTE*)(v2 + 80))
                {
                    v10 = (int*)((char*)v39 + v37[1]);
                    *v10 = v43;
                    v10[1] = v44;
                    v10[2] = v45;
                    *(float*)((char*)v39 + v37[7]) = Buffer;
                    *(float*)((char*)v39 + v37[7] + 4) = v41;
                    *(float*)((char*)v39 + v37[7] + 8) = v42;
                    *(float*)((char*)v39 + v37[5]) = v33;
                    *(float*)((char*)v39 + v37[5] + 4) = v34;
                    *(float*)((char*)v39 + v37[6]) = v33;
                    *(float*)((char*)v39 + v37[6] + 4) = v34;
                    *(_DWORD*)((char*)v39 + v37[2]) = a2;
                }
                v11 = *(_DWORD*)(v2 + 40);
                ++v3;
                v39 = (float*)((char*)v39 + v37[21]);
                if (v3 >= v11)
                    goto LABEL_40;
            }
            if (v6)
            {
                if (sub_4057E0((FILE**)v32, &a2))
                {
                    v8 = a2;
                    v6 = 1;
                    goto LABEL_26;
                }
                v8 = a2;
            }
            v6 = 0;
        LABEL_26:
            if (!*(_BYTE*)(v2 + 82) && v8 != -1)
                *(_BYTE*)(v2 + 82) = 1;
            if (!*(_BYTE*)(v2 + 83) && (v8 & 0xFF000000) != 0xFF000000)
                *(_BYTE*)(v2 + 83) = 1;
            goto LABEL_32;
        }
    LABEL_40:
        sub_46C967(v38, *(_DWORD*)(v2 + 40), *(_DWORD*)(v2 + 84), (float*)(v2 + 60), (float*)(v2 + 72));
        (*(void(__stdcall**)(_DWORD))(**(_DWORD**)(v2 + 36) + 48))(*(_DWORD*)(v2 + 36));
        if (!v5)
            goto LABEL_48;
    }
    v12 = (int*)(v2 + 48);
    if (!sub_4057E0((FILE**)v32, (void*)(v2 + 48)))
        goto LABEL_48;
    v13 = 1;
    if (*v12 <= 0)
    {
    LABEL_49:
        v16 = v32;
        goto LABEL_50;
    }
    v14 = (_DWORD*)(v2 + 44);
    if ((*(int(__stdcall**)(_DWORD, int, int, int, int, int))(**(_DWORD**)ArgList + 96))(
        *(_DWORD*)ArgList,
        6 * *v12,
        *(_BYTE*)(v2 + 80) != 0 ? 512 : 8,
        101,
        (*(_BYTE*)(v2 + 80) != 0) + 1,
        v2 + 44))
    {
    LABEL_48:
        v13 = 0;
        goto LABEL_49;
    }
    v13 = 1;
    (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD, int*, _DWORD))(*(_DWORD*)*v14 + 44))(*v14, 0, 0, &a2, 0);
    v15 = *(_DWORD*)(v2 + 48);
    v16 = v32;
    v34 = 0.0;
    if (v15 > 0)
    {
        do
        {
            v17 = v13 && sub_4057E0((FILE**)v32, &v33);
            *(_WORD*)a2 = LOWORD(v33);
            a2 += 4;
            v18 = v17 && sub_4057E0((FILE**)v32, &v33);
            *(_WORD*)a2 = LOWORD(v33);
            a2 -= 2;
            v19 = v18 && sub_4057E0((FILE**)v32, &v33);
            *(_WORD*)a2 = LOWORD(v33);
            a2 += 4;
            v13 = v19 && sub_4057E0((FILE**)v32, &v36);
            v20 = *(_DWORD*)(v2 + 48);
            ++LODWORD(v34);
        } while (SLODWORD(v34) < v20);
    }
    (*(void(__stdcall**)(_DWORD))(*(_DWORD*)*v14 + 48))(*v14);
LABEL_50:
    if (*(int*)(v16 + 24) >= 5)
        v13 = v13 && sub_405820((FILE**)v16, (FILE**)0xBEEDDEED);
    *(_DWORD*)(v2 + 76) = 2;
    v35 = -1;
    if (!v13 || !sub_4057E0((FILE**)v16, &v35))
        return 0;
    v21 = (float*)sub_4044D0((_DWORD*)v16, v35);
    v22 = v21;
    *(_DWORD*)(v2 + 52) = v21;
    if (v21 && (v23 = *((_DWORD*)v21 + 21)) != 0 && *(_BYTE*)(v23 + 24) || *(_BYTE*)(v2 + 83))
        *(_DWORD*)(v2 + 76) = 4;
    if (!*(_BYTE*)(v2 + 80) && !*(_BYTE*)(v2 + 82))
    {
        v24 = *(_DWORD*)(v2 + 36);
        if (v24)
        {
            if (v22)
            {
                v25 = (unsigned __int8)(__int64)(v22[3] * 255.0)
                    | (((unsigned __int8)(__int64)(v22[2] * 255.0)
                        | ((((unsigned int)(__int64)(v22[4] * 255.0) << 8) | (unsigned __int8)(__int64)(v22[1] * 255.0)) << 8)) << 8);
                v43 = v2 + 84;
                v45 = 0;
                (*(void(__stdcall**)(int, _DWORD, _DWORD, int*, _DWORD))(*(_DWORD*)v24 + 44))(v24, 0, 0, &v44, 0);
                v26 = *(_DWORD*)(v2 + 40);
                v27 = v44;
                v28 = 0;
                v45 = v44;
                if (v26 > 0)
                {
                    v29 = v43;
                    do
                    {
                        *(_DWORD*)(*(_DWORD*)(v29 + 8) + v27) = v25;
                        v29 = v43;
                        v27 = *(_DWORD*)(v43 + 84) + v45;
                        v30 = *(_DWORD*)(v2 + 40);
                        ++v28;
                        v45 = v27;
                    } while (v28 < v30);
                }
                (*(void(__stdcall**)(_DWORD))(**(_DWORD**)(v2 + 36) + 48))(*(_DWORD*)(v2 + 36));
                v16 = v32;
            }
        }
    }
    return sub_405820((FILE**)v16, (FILE**)0xBEED9393);
}

//----- (00404F60) --------------------------------------------------------
_BYTE* __thiscall sub_404F60(_DWORD* this, int a2, void* a3, float* a4)
{
    int v4; // esi
    int v5; // eax
    int v6; // ebx
    _BYTE* result; // eax
    double v8; // st7
    float v9; // [esp+Ch] [ebp-248h] BYREF
    int v10; // [esp+10h] [ebp-244h]
    _DWORD v11[16]; // [esp+14h] [ebp-240h] BYREF
    _BYTE v12[64]; // [esp+54h] [ebp-200h] BYREF
    _BYTE v13[64]; // [esp+94h] [ebp-1C0h] BYREF
    _BYTE v14[64]; // [esp+D4h] [ebp-180h] BYREF
    _BYTE v15[64]; // [esp+114h] [ebp-140h] BYREF
    _BYTE v16[64]; // [esp+154h] [ebp-100h] BYREF
    _BYTE v17[64]; // [esp+194h] [ebp-C0h] BYREF
    float v18[16]; // [esp+1D4h] [ebp-80h] BYREF
    _BYTE v19[64]; // [esp+214h] [ebp-40h] BYREF

    v4 = this[1] + 172 * a2;
    sub_406BE0(v11);
    v9 = 1.0;
    if (*(_BYTE*)v4)
    {
        v5 = *(_DWORD*)(v4 + 28);
        if (v5 >= 0)
            sub_404F60(v5, v11, &v9);
    }
    v6 = *(_DWORD*)(v4 + 16);
    sub_46C107(v18, (float*)(v6 + 20));
    sub_46BE02((int)v16, *(_DWORD*)(v6 + 8), *(_DWORD*)(v6 + 12), *(_DWORD*)(v6 + 16));
    v10 = *(_DWORD*)(v6 + 36);
    sub_46BDA2((int)v14, v10, v10, v10);
    sub_46B97C(v12, v14, v18);
    qmemcpy(v13, v12, sizeof(v13));
    sub_46B97C(v15, v13, v16);
    qmemcpy(v17, v15, sizeof(v17));
    result = sub_46B97C(v19, v17, v11);
    v8 = v9;
    qmemcpy(a3, v19, 0x40u);
    *a4 = v8 * *(float*)(v6 + 36);
    return result;
}

//----- (004050B0) --------------------------------------------------------
int __thiscall sub_4050B0(_DWORD* this)
{
    _DWORD* v1; // edi
    int result; // eax
    int* v3; // ebp
    int v4; // ebx
    int v5; // esi
    int v6; // esi
    int v7; // eax
    void* v8; // eax
    int v9; // edx
    int v10; // eax
    int v11; // [esp+8h] [ebp-Ch]
    int v12; // [esp+Ch] [ebp-8h]

    v1 = this;
    v12 = 0;
    result = this[7];
    if (result > 0)
    {
        v3 = (int*)(this[8] + 12);
        do
        {
            v4 = v1[1];
            v5 = 0;
            if ((int)v1[2] <= 0)
            {
            LABEL_6:
                sub_4229D0("**No match for node %s", (const char*)*(v3 - 1));
                if (*v3 > 1)
                    sub_4229D0(
                        "WARNING: can't find match for animation object '%s'; it will NOT be visible",
                        (const char*)*(v3 - 1));
            }
            else
            {
                while (_strcmpi(*(const char**)(v4 + 8), (const char*)*(v3 - 1)))
                {
                    v4 += 172;
                    if (++v5 >= v1[2])
                        goto LABEL_6;
                }
                v6 = *(_DWORD*)(v4 + 12);
                v7 = *v3 + v6;
                *(_DWORD*)(v4 + 12) = v7;
                v8 = sub_488DD7(*(LPVOID*)(v4 + 16), 40 * v7);
                v9 = 0;
                if (v8)
                {
                    *(_DWORD*)(v4 + 16) = v8;
                    v11 = 0;
                    if (*v3 > 0)
                    {
                        v10 = 40 * v6;
                        do
                        {
                            qmemcpy((void*)(v10 + *(_DWORD*)(v4 + 16)), (const void*)(v3[1] + v9), 0x28u);
                            v9 += 40;
                            v10 += 40;
                            ++v11;
                        } while (v11 < *v3);
                        v1 = this;
                    }
                }
            }
            v3 += 43;
            result = ++v12;
        } while (v12 < v1[7]);
    }
    return result;
}

//----- (004051C0) --------------------------------------------------------
int __usercall sub_4051C0@<eax>(_DWORD* a1@<ecx>, int a2@<ebp>, int a3@<edi>)
{
    float v3; // esi
    int result; // eax
    int v5; // ecx
    int v6; // edx
    int v7; // ebx
    int v8; // edi
    int v9; // ebp
    int v10; // ebp
    double v11; // st7
    int v12; // esi
    int v13; // eax
    int v14; // eax
    int v15; // ecx
    float* v16; // eax
    double v17; // st7
    double v18; // st7
    double v19; // st7
    float* v20; // ecx
    float* v21; // eax
    float v22; // edi
    float* v23; // ecx
    float* v24; // eax
    int v25; // ecx
    int v26; // ecx
    int v27; // eax
    float v30; // [esp+30h] [ebp-190h] BYREF
    float v31; // [esp+34h] [ebp-18Ch]
    float v32; // [esp+38h] [ebp-188h]
    float v33; // [esp+3Ch] [ebp-184h] BYREF
    float v34; // [esp+40h] [ebp-180h]
    float v35; // [esp+44h] [ebp-17Ch]
    int v36; // [esp+48h] [ebp-178h] BYREF
    int v37; // [esp+4Ch] [ebp-174h]
    int v38; // [esp+50h] [ebp-170h]
    float* v39; // [esp+54h] [ebp-16Ch]
    int v40; // [esp+58h] [ebp-168h]
    int v41; // [esp+5Ch] [ebp-164h] BYREF
    float* v42; // [esp+60h] [ebp-160h]
    float* v43; // [esp+64h] [ebp-15Ch]
    float v44; // [esp+6Ch] [ebp-154h] BYREF
    float v45; // [esp+70h] [ebp-150h]
    float v46; // [esp+74h] [ebp-14Ch]
    float v47; // [esp+78h] [ebp-148h] BYREF
    float v48; // [esp+7Ch] [ebp-144h]
    float v49; // [esp+80h] [ebp-140h]
    int v50; // [esp+84h] [ebp-13Ch]
    int v51; // [esp+88h] [ebp-138h]
    float v52; // [esp+8Ch] [ebp-134h]
    float v53; // [esp+98h] [ebp-128h]
    float v54; // [esp+9Ch] [ebp-124h] BYREF
    float v55[3]; // [esp+A0h] [ebp-120h] BYREF
    float v56[3]; // [esp+ACh] [ebp-114h] BYREF
    float v57; // [esp+B8h] [ebp-108h] BYREF
    float v58; // [esp+BCh] [ebp-104h]
    float v59[16]; // [esp+C0h] [ebp-100h] BYREF
    float v60[16]; // [esp+100h] [ebp-C0h] BYREF
    float v61[16]; // [esp+140h] [ebp-80h] BYREF
    float v62[16]; // [esp+180h] [ebp-40h] BYREF

    v3 = *(float*)&a1;
    v48 = *(float*)&a1;
    sub_406BE0(v59);
    sub_406BE0(v60);
    sub_406BE0(v61);
    sub_406BE0(v62);
    result = *(_DWORD*)(LODWORD(v3) + 8);
    v5 = 0;
    v38 = 0;
    if (result > 0)
    {
        v6 = 0;
        v50 = 0;
        do
        {
            v7 = *(_DWORD*)(LODWORD(v3) + 4) + v6;
            if (*(_BYTE*)(v7 + 81))
            {
                v8 = v5 + 1;
                v42 = (float*)(v5 + 1);
                if (v5 + 1 < result)
                {
                    v9 = v6 + 172;
                    v51 = v6 + 172;
                    do
                    {
                        v10 = *(_DWORD*)(LODWORD(v3) + 4) + v9;
                        if (v7 != v10 && *(_BYTE*)(v10 + 81))
                        {
                            sub_404F60((_DWORD*)LODWORD(v3), v5, v59, &v57);
                            sub_404F60((_DWORD*)LODWORD(v3), v8, v60, &v54);
                            qmemcpy(v61, v59, sizeof(v61));
                            sub_46B9FD(v61, 0, v61);
                            qmemcpy(v62, v60, sizeof(v62));
                            sub_46B9FD(v62, 0, v62);
                            sub_408A30(v55, (_DWORD*)(v7 + 60));
                            sub_46C5C5(v55, v55, v59);
                            v58 = v57 * *(float*)(v7 + 72);
                            sub_408A30(v56, (_DWORD*)(v10 + 60));
                            sub_46C5C5(v56, v56, v60);
                            v11 = v54 * *(float*)(v10 + 72);
                            v34 = v56[0] - v55[0];
                            v52 = v56[1] - v55[1];
                            v49 = v56[2] - v55[2];
                            if ((v11 + v58) * (v11 + v58) >= v49 * v49 + v52 * v52 + v34 * v34)
                            {
                                v12 = 0;
                                LODWORD(v35) = v7 + 84;
                                v13 = *(_DWORD*)(v7 + 36);
                                v37 = 0;
                                (*(void(__stdcall**)(int, _DWORD, _DWORD, int*, _DWORD, int))(*(_DWORD*)v13 + 44))(
                                    v13,
                                    0,
                                    0,
                                    &v36,
                                    0,
                                    a3);
                                v35 = 0.0;
                                v38 = v37;
                                if (*(int*)(v7 + 40) > 0)
                                {
                                    do
                                    {
                                        v40 = v10 + 84;
                                        v14 = *(_DWORD*)(v10 + 36);
                                        v42 = 0;
                                        (*(void(__stdcall**)(int, _DWORD, _DWORD, int*, _DWORD, int))(*(_DWORD*)v14 + 44))(
                                            v14,
                                            0,
                                            0,
                                            &v41,
                                            0,
                                            a2);
                                        v15 = *(_DWORD*)(v10 + 40);
                                        v16 = v42;
                                        v43 = v42;
                                        if (v15 > 0)
                                        {
                                            do
                                            {
                                                v47 = 0.0;
                                                v48 = 0.0;
                                                v49 = 0.0;
                                                v44 = 0.0;
                                                v45 = 0.0;
                                                v46 = 0.0;
                                                v47 = *v39;
                                                v48 = v39[1];
                                                v49 = v39[2];
                                                v44 = *v16;
                                                v45 = v16[1];
                                                v46 = v16[2];
                                                sub_46C5C5(&v47, &v47, &v59[2]);
                                                sub_46C5C5(&v44, &v44, &v60[2]);
                                                v17 = v47 - v44;
                                                if (v17 < 0.0000099999997 && v17 > -0.0000099999997)
                                                {
                                                    v18 = v48 - v45;
                                                    if (v18 < 0.0000099999997 && v18 > -0.0000099999997)
                                                    {
                                                        v19 = v49 - v46;
                                                        if (v19 < 0.0000099999997 && v19 > -0.0000099999997)
                                                        {
                                                            v30 = 0.0;
                                                            v31 = 0.0;
                                                            v32 = 0.0;
                                                            v20 = (float*)((char*)v39 + *(_DWORD*)(v37 + 4));
                                                            v30 = *v20;
                                                            v31 = v20[1];
                                                            v32 = v20[2];
                                                            sub_46B976(&v30, &v30, &v59[2]);
                                                            v33 = 0.0;
                                                            v34 = 0.0;
                                                            v35 = 0.0;
                                                            v21 = (float*)((char*)v43 + *(_DWORD*)(v41 + 4));
                                                            v33 = *v21;
                                                            v34 = v21[1];
                                                            v35 = v21[2];
                                                            sub_46B976(&v33, &v33, &v60[2]);
                                                            v53 = (v33 + v30) * 0.5;
                                                            v22 = v53;
                                                            v30 = v53;
                                                            v54 = (v34 + v31) * 0.5;
                                                            v31 = v54;
                                                            v55[0] = (v35 + v32) * 0.5;
                                                            v32 = v55[0];
                                                            sub_46B976(&v30, &v30, &v61[2]);
                                                            v23 = (float*)((char*)v39 + *(_DWORD*)(v37 + 4));
                                                            *v23 = v30;
                                                            v23[1] = v31;
                                                            v23[2] = v32;
                                                            v34 = v54;
                                                            v35 = v55[0];
                                                            v33 = v22;
                                                            sub_46B976(&v33, &v33, &v62[2]);
                                                            v24 = (float*)((char*)v43 + *(_DWORD*)(v41 + 4));
                                                            *v24 = v33;
                                                            v24[1] = v34;
                                                            v24[2] = v35;
                                                        }
                                                    }
                                                }
                                                v25 = *(_DWORD*)(v10 + 40);
                                                v16 = (float*)((char*)v43 + *(_DWORD*)(v41 + 84));
                                                ++v12;
                                                v43 = v16;
                                            } while (v12 < v25);
                                            v12 = 0;
                                        }
                                        a2 = *(_DWORD*)(v10 + 36);
                                        (*(void (**)(void))(*(_DWORD*)a2 + 48))();
                                        v26 = *(_DWORD*)(v7 + 40);
                                        v38 += *(_DWORD*)(v36 + 84);
                                        ++LODWORD(v35);
                                    } while (SLODWORD(v35) < v26);
                                }
                                a3 = *(_DWORD*)(v7 + 36);
                                (*(void (**)(void))(*(_DWORD*)a3 + 48))();
                            }
                            v8 = (int)v42;
                            v3 = v48;
                        }
                        v27 = *(_DWORD*)(LODWORD(v3) + 8);
                        v5 = v38;
                        ++v8;
                        v9 = v51 + 172;
                        v42 = (float*)v8;
                        v51 += 172;
                    } while (v8 < v27);
                    v6 = v50;
                }
            }
            result = *(_DWORD*)(LODWORD(v3) + 8);
            ++v5;
            v6 += 172;
            v38 = v5;
            v50 = v6;
        } while (v5 < result);
    }
    return result;
}
// 4051C0: could not find valid save-restore pair for ebp
// 4051C0: could not find valid save-restore pair for edi

//----- (00405770) --------------------------------------------------------
bool __thiscall sub_405770(FILE** this, unsigned int Buffer)
{
    _DWORD* v2; // edi
    void* v5; // eax
    size_t v6; // edx

    v2 = (_DWORD*)Buffer;
    Buffer = 0;
    *v2 = 0;
    if (sub_4898CA(&Buffer, 4u, 1u, this[5]) != 1)
        return 0;
    v5 = operator new(Buffer);
    v6 = Buffer;
    *v2 = v5;
    return sub_4898CA(v5, v6, 1u, this[5]) == 1;
}

//----- (004057E0) --------------------------------------------------------
BOOL __thiscall sub_4057E0(FILE** this, void* Buffer)
{
    return sub_4898CA(Buffer, 4u, 1u, this[5]) == 1;
}

//----- (00405800) --------------------------------------------------------
BOOL __thiscall sub_405800(FILE** this, void* Buffer)
{
    return sub_4898CA(Buffer, 1u, 1u, this[5]) == 1;
}

//----- (00405820) --------------------------------------------------------
BOOL __thiscall sub_405820(FILE** this, FILE** a2)
{
    FILE** Buffer; // [esp+0h] [ebp-4h] BYREF

    Buffer = this;
    return sub_4057E0(this, &Buffer) && Buffer == a2;
}

//----- (00405850) --------------------------------------------------------
char __thiscall sub_405850(int this, int Buffer)
{
    int v2; // edi
    double v4; // st7
    double v5; // st7
    char result; // al
    double v7; // st7
    float v8; // [esp+8h] [ebp-2Ch] BYREF
    float v9; // [esp+Ch] [ebp-28h] BYREF
    float v10; // [esp+10h] [ebp-24h] BYREF
    float v11; // [esp+14h] [ebp-20h] BYREF
    float v12; // [esp+18h] [ebp-1Ch] BYREF
    float v13; // [esp+1Ch] [ebp-18h] BYREF
    int v14; // [esp+20h] [ebp-14h] BYREF
    float v15; // [esp+24h] [ebp-10h]
    float v16; // [esp+28h] [ebp-Ch]
    float v17; // [esp+2Ch] [ebp-8h]
    float v18; // [esp+30h] [ebp-4h]

    v2 = Buffer;
    if (!sub_4057E0((FILE**)this, (void*)(Buffer + 4))
        || !sub_4057E0((FILE**)this, &Buffer)
        || !sub_4057E0((FILE**)this, &v8)
        || !sub_4057E0((FILE**)this, &v9)
        || !sub_4057E0((FILE**)this, &v10)
        || !sub_4057E0((FILE**)this, &v11)
        || !sub_4057E0((FILE**)this, &v12)
        || !sub_4057E0((FILE**)this, &v13)
        || !sub_4057E0((FILE**)this, &v14))
    {
        return 0;
    }
    v16 = v8;
    v17 = v9;
    v15 = -v10;
    v4 = v11;
    *(_DWORD*)(v2 + 8) = Buffer;
    *(float*)(v2 + 12) = v16;
    v16 = -v4;
    v5 = v12;
    *(float*)(v2 + 16) = v17;
    result = 1;
    v17 = -v5;
    v7 = v13;
    *(float*)(v2 + 20) = v15;
    v18 = v7;
    *(float*)(v2 + 24) = v16;
    *(float*)(v2 + 28) = v17;
    *(float*)(v2 + 32) = v18;
    *(_DWORD*)(v2 + 36) = v14;
    *(_DWORD*)v2 = *(_DWORD*)(this + 52);
    return result;
}

//----- (004059A0) --------------------------------------------------------
bool __thiscall sub_4059A0(FILE** this, unsigned int Buffer)
{
    return sub_405770(this, Buffer) && sub_4057E0(this, (void*)(Buffer + 4));
}

//----- (004059D0) --------------------------------------------------------
int __thiscall sub_4059D0(_DWORD* this, int a2)
{
    return *(_DWORD*)(this[1] + 172 * a2 + 20);
}

//----- (004059F0) --------------------------------------------------------
int __thiscall sub_4059F0(_DWORD* this, int a2, int a3)
{
    if (a3 < sub_4059D0(this, a2))
        return *(_DWORD*)(this[1] + 172 * a2 + 24) + 8 * a3;
    else
        return 0;
}

//----- (00405A30) --------------------------------------------------------
int __thiscall sub_405A30(_DWORD* this, char* String1, int a3, char a4)
{
    int v5; // ebp
    unsigned int v6; // kr04_4
    int i; // edi
    int v9; // edi
    int k; // ebx
    int v11; // eax
    int j; // ebx
    int v13; // eax
    int v14; // ecx
    size_t MaxCount; // [esp+10h] [ebp-4h]

    v5 = a3;
    v6 = strlen(String1) + 1;
    MaxCount = v6 - 1;
    if (a3 == -1)
    {
        v5 = 0;
        if ((int)this[2] > 0)
        {
            for (i = 0; _strnicmp(String1, *(const char**)(this[1] + i + 8), MaxCount); i += 172)
            {
                if (++v5 >= this[2])
                    return -1;
            }
            return v5;
        }
        return -1;
    }
    if (!a4)
    {
        v9 = a3 + 1;
        if (a3 + 1 < this[2])
        {
            for (j = 172 * v9; ; j += 172)
            {
                v13 = j + this[1];
                if (!*(_BYTE*)v13)
                    break;
                v14 = *(_DWORD*)(v13 + 28);
                if (v14 < a3)
                    break;
                if (v14 == a3 && !_strnicmp(String1, *(const char**)(v13 + 8), MaxCount))
                    return v9;
                if (++v9 >= this[2])
                    return -1;
            }
        }
        return -1;
    }
    if (_strnicmp(String1, *(const char**)(this[1] + 172 * a3 + 8), v6 - 1))
    {
        v9 = a3 + 1;
        if (a3 + 1 < this[2])
        {
            for (k = 172 * v9; ; k += 172)
            {
                v11 = this[1] + k;
                if (!*(_BYTE*)v11 || *(_DWORD*)(v11 + 28) < a3)
                    break;
                if (!_strcmpi(String1, *(const char**)(v11 + 8)))
                    return v9;
                if (++v9 >= this[2])
                    return -1;
            }
        }
        return -1;
    }
    return v5;
}

//----- (00405BB0) --------------------------------------------------------
int __thiscall sub_405BB0(_DWORD* this, int a2)
{
    int v2; // eax
    char v3; // cl
    int v4; // eax

    v2 = this[1];
    v3 = *(_BYTE*)(v2 + 172 * a2);
    v4 = v2 + 172 * a2;
    if (v3)
        return *(_DWORD*)(v4 + 28);
    else
        return -1;
}

//----- (00405BE0) --------------------------------------------------------
char __thiscall sub_405BE0(_DWORD* this, int a2)
{
    return *(_BYTE*)(this[1] + 172 * a2 + 81);
}

//----- (00405C00) --------------------------------------------------------
char __thiscall sub_405C00(_DWORD* this, int a2)
{
    return *(_BYTE*)(this[1] + 172 * a2 + 80);
}

//----- (00405C20) --------------------------------------------------------
int __thiscall sub_405C20(_DWORD* this, int a2)
{
    return *(_DWORD*)(this[1] + 172 * a2 + 8);
}

//----- (00405C40) --------------------------------------------------------
int __stdcall sub_405C40(int a1, int a2, int a3)
{
    char v3; // bl
    int v4; // eax
    int v5; // esi
    int v6; // edx
    int v7; // eax
    int v8; // ecx
    int v9; // eax
    int v10; // eax
    char v12; // [esp+Fh] [ebp-45h]
    float v13[17]; // [esp+10h] [ebp-44h] BYREF

    v3 = 0;
    v12 = 0;
    v4 = *(_DWORD*)(a1 + 52);
    if (!v4)
    {
    LABEL_28:
        sub_41BEF0((_DWORD*)dword_520A50, a2, 0, -1, -1);
        goto LABEL_29;
    }
    v5 = a3;
    if (a3 && (v6 = *(_DWORD*)(a3 + 92)) != 0 && *(_BYTE*)(v6 + 78))
    {
        qmemcpy(v13, (const void*)(v4 + 4), sizeof(v13));
        if (*(float*)(v6 + 80) <= (double)v13[3])
            v13[3] = *(float*)(v6 + 80);
        if (*(float*)(v6 + 80) <= (double)v13[7])
            v13[7] = *(float*)(v6 + 80);
        if (*(float*)(v6 + 80) <= (double)v13[11])
            v13[11] = *(float*)(v6 + 80);
        if (*(float*)(v6 + 80) <= (double)v13[15])
            v13[15] = *(float*)(v6 + 80);
        (*(void(__stdcall**)(_DWORD, float*))(**(_DWORD**)ArgList + 168))(*(_DWORD*)ArgList, v13);
        v5 = a3;
        v12 = 1;
    }
    else
    {
        (*(void(__stdcall**)(_DWORD, int))(**(_DWORD**)ArgList + 168))(*(_DWORD*)ArgList, v4 + 4);
    }
    v7 = *(_DWORD*)(a1 + 52);
    v8 = *(_DWORD*)(v7 + 84);
    if (!v8)
    {
        if (*(_BYTE*)(a1 + 83))
            v12 = 1;
        goto LABEL_28;
    }
    if (*(_BYTE*)(a1 + 83) || *(_BYTE*)(v8 + 24))
    {
        v5 = a3;
        v12 = 1;
    }
    if (*(_BYTE*)(v7 + 80))
        v3 = 1;
    if (v5 && (v9 = *(_DWORD*)(v5 + 92)) != 0 && *(_BYTE*)(v9 + 84))
        sub_41BEF0((_DWORD*)dword_520A50, a2, *(_DWORD*)(v9 + 88), v3 != 0, 0);
    else
        sub_41BEF0((_DWORD*)dword_520A50, a2, v8, v3 != 0, 0);
LABEL_29:
    if (*(_BYTE*)(a1 + 56))
        v10 = 2;
    else
        v10 = v12 != 0;
    return sub_41BC00((_DWORD*)dword_520A50, -1, v10, 1, 0, 1, -1, *(_BYTE*)(a1 + 82) == 0);
}
// 520A50: using guessed type int dword_520A50;

//----- (00405DF0) --------------------------------------------------------
int __thiscall sub_405DF0(void* this, _DWORD* a2, int a3)
{
    (**(void(__thiscall***)(void*, _DWORD*, _DWORD, int))this)(this, a2, 0, a3);
    return sub_406000(a2, a3);
}

//----- (00405E20) --------------------------------------------------------
int __stdcall sub_405E20(int a1, int a2, int a3, int a4)
{
    int v4; // eax
    double v5; // st7
    double v6; // st7
    int v8; // [esp+8h] [ebp-A4h]
    int v9; // [esp+Ch] [ebp-A0h]
    float v10; // [esp+10h] [ebp-9Ch]
    int v11; // [esp+20h] [ebp-8Ch]
    float v12; // [esp+24h] [ebp-88h]
    _BYTE v13[64]; // [esp+28h] [ebp-84h] BYREF
    _DWORD v14[17]; // [esp+68h] [ebp-44h] BYREF

    v4 = *(_DWORD*)(a1 + 52);
    if (v4)
    {
        qmemcpy(v14, (const void*)(v4 + 4), sizeof(v14));
        v14[3] = *(_DWORD*)(a2 + 28);
        v14[7] = v14[3];
        (*(void(__stdcall**)(_DWORD, _DWORD*))(**(_DWORD**)ArgList + 168))(*(_DWORD*)ArgList, v14);
    }
    qmemcpy(v13, (const void*)(a3 + 16), sizeof(v13));
    *(float*)&v9 = -*(float*)(a2 + 8);
    *(float*)&v8 = -*(float*)(a2 + 4);
    sub_40E880(v13, v8, v9, 0);
    v10 = -*(float*)(a2 + 20);
    sub_40E850(v13, v10);
    sub_40E880(v13, *(_DWORD*)(a2 + 16), *(_DWORD*)(a2 + 16), 0);
    v5 = *(float*)(a2 + 16);
    if (v5 == 0.0)
        v12 = 1.0;
    else
        v12 = 1.0 / v5;
    v6 = *(float*)(a2 + 16);
    if (v6 == 0.0)
    {
        sub_40E8B0(v13, 1065353216, SLODWORD(v12), 0);
    }
    else
    {
        *(float*)&v11 = 1.0 / v6;
        sub_40E8B0(v13, v11, SLODWORD(v12), 0);
    }
    sub_40E880(v13, -1090519040, -1082130432, 1065353216);
    sub_40E8B0(v13, 1065353216, -1082130432, 1065353216);
    sub_40E880(v13, 0, 1056964608, 0);
    sub_41BEF0((_DWORD*)dword_520A50, a4, *(_DWORD*)a2, 1, 1);
    sub_41BC00((_DWORD*)dword_520A50, 1, (*(_BYTE*)(a2 + 24) != 0) + 1, 0, 0, 1, -1, 1);
    (*(void(__stdcall**)(_DWORD, int, int, int))(**(_DWORD**)ArgList + 252))(*(_DWORD*)ArgList, a4, 11, 2);
    (*(void(__stdcall**)(_DWORD, int, int, int))(**(_DWORD**)ArgList + 252))(*(_DWORD*)ArgList, a4, 24, 2);
    return (*(int(__stdcall**)(_DWORD, int, _BYTE*))(**(_DWORD**)ArgList + 148))(*(_DWORD*)ArgList, a4 + 16, v13);
}
// 520A50: using guessed type int dword_520A50;

//----- (00406000) --------------------------------------------------------
int __stdcall sub_406000(_DWORD* a1, int a2)
{
    int v2; // eax
    char v3; // cl
    int v4; // eax

    if (a2 && (v2 = *(_DWORD*)(a2 + 92)) != 0)
    {
        v3 = *(_BYTE*)(v2 + 76);
    }
    else
    {
        v4 = a1[13];
        v3 = 0;
        if (v4)
            v3 = *(_BYTE*)(v4 + 73) != 0;
    }
    sub_41BC00((_DWORD*)dword_520A50, a1[19] == 1, -1, -1, 0, (v3 != 0) + 1, -1, -1);
    if ((*(int(__stdcall**)(_DWORD, _DWORD))(**(_DWORD**)ArgList + 304))(*(_DWORD*)ArgList, a1[21]))
        sub_4229D0(aSetstreamsourc);
    if ((*(int(__stdcall**)(_DWORD, _DWORD, _DWORD, _DWORD))(**(_DWORD**)ArgList + 332))(
        *(_DWORD*)ArgList,
        0,
        a1[9],
        a1[42]))
    {
        sub_4229D0(aSetstreamsourc);
    }
    if ((*(int(__stdcall**)(_DWORD, _DWORD, _DWORD))(**(_DWORD**)ArgList + 340))(*(_DWORD*)ArgList, a1[11], 0))
        sub_4229D0(aSetindicesFail);
    (*(void(__stdcall**)(_DWORD, int, _DWORD, _DWORD, _DWORD, _DWORD))(**(_DWORD**)ArgList + 284))(
        *(_DWORD*)ArgList,
        4,
        0,
        a1[10],
        0,
        a1[12]);
    *(float*)dword_520A20 = *(float*)dword_520A20 + 1.0;
    return a1[12];
}
// 520A20: using guessed type int dword_520A20;
// 520A50: using guessed type int dword_520A50;

//----- (00406110) --------------------------------------------------------
int __userpurge sub_406110@<eax>(_DWORD* a1@<ecx>, int a2@<esi>, int a3, float* a4, int a5, char a6)
{
    int v7; // edi
    int v8; // ebx
    int v10; // edi
    double v11; // st7
    float v12; // edx
    double v13; // st7
    int v14; // eax
    double v15; // st7
    int v16; // edi
    double v17; // st7
    double v18; // st7
    float* v19; // eax
    float v21; // [esp-10h] [ebp-58h]
    float v22; // [esp-Ch] [ebp-54h]
    float v23; // [esp-8h] [ebp-50h]
    float v24; // [esp-4h] [ebp-4Ch]
    float v25; // [esp+0h] [ebp-48h]
    float v27; // [esp+4h] [ebp-44h]
    int v28; // [esp+18h] [ebp-30h]
    float v29; // [esp+1Ch] [ebp-2Ch] BYREF
    float v30; // [esp+20h] [ebp-28h]
    float v31; // [esp+24h] [ebp-24h]
    float v32; // [esp+28h] [ebp-20h] BYREF
    float v33; // [esp+2Ch] [ebp-1Ch]
    float v34; // [esp+30h] [ebp-18h]
    float v35; // [esp+34h] [ebp-14h] BYREF
    float v36; // [esp+38h] [ebp-10h]
    float v37; // [esp+3Ch] [ebp-Ch]
    float v38; // [esp+40h] [ebp-8h] BYREF
    float v39; // [esp+44h] [ebp-4h]
    float retaddr; // [esp+48h] [ebp+0h]
    int v41; // [esp+50h] [ebp+8h]
    int v42; // [esp+58h] [ebp+10h]

    v7 = 0;
    v8 = a1[1] + 172 * a3;
    if (!*(_BYTE*)(v8 + 81))
        return 0;
    if (a4)
        (*(void(__stdcall**)(_DWORD, int, float*))(**(_DWORD**)ArgList + 148))(*(_DWORD*)ArgList, 256, a4 + 4);
    if (byte_4F5AF8)
        v7 = sub_41F3D0(
            *(float*)(v8 + 60),
            *(float*)(v8 + 64),
            *(float*)(v8 + 68),
            *(float*)(v8 + 72),
            COERCE_FLOAT(200),
            COERCE_FLOAT(200),
            COERCE_FLOAT(200),
            255);
    v10 = (*(int(__thiscall**)(_DWORD*, int, float*, int))(*a1 + 4))(a1, v8, a4, a2) + v7;
    v41 = v10;
    if (a6)
    {
        if (byte_4A4DB0)
        {
            if (!*(_BYTE*)(v8 + 57))
            {
                v11 = *a4 - a4[3];
                v12 = a4[2];
                v39 = a4[1];
                v35 = *a4;
                v38 = v11;
                v13 = v39 - a4[3];
                v36 = v39;
                v37 = v12;
                v14 = 0;
                v39 = v13;
                v15 = v12 - a4[3];
                v32 = 0.0;
                v33 = 0.0;
                v34 = 0.0;
                v29 = 0.0;
                v30 = 0.0;
                v31 = 0.0;
                retaddr = v15;
                v42 = 0;
                v35 = v35 + a4[3];
                v36 = v36 + a4[3];
                v37 = v12 + a4[3];
                if (v28 > 0)
                {
                    do
                    {
                        v16 = *(_DWORD*)(*(_DWORD*)(dword_520970 + 136) + 4 * v14);
                        if (*(_BYTE*)(v16 + 32))
                        {
                            if (*(float*)(v16 + 28) > 0.0)
                            {
                                v32 = *(float*)(v16 + 4);
                                v33 = *(float*)(v16 + 8);
                                v34 = *(float*)(v16 + 12);
                                v32 = v32 - *(float*)(v16 + 16);
                                v17 = v33 - *(float*)(v16 + 16);
                                v34 = -3.4028235e38;
                                v33 = v17;
                                v29 = *(float*)(v16 + 4);
                                v30 = *(float*)(v16 + 8);
                                v31 = *(float*)(v16 + 12);
                                v29 = v29 + *(float*)(v16 + 16);
                                v18 = v30 + *(float*)(v16 + 16);
                                v31 = 3.4028235e38;
                                v30 = v18;
                                if (sub_40CC10(&v38, &v35, &v32, &v29))
                                {
                                    v27 = v31;
                                    v25 = v30;
                                    v24 = v29;
                                    v23 = v34;
                                    v22 = v33;
                                    v21 = v32;
                                    v19 = (float*)sub_408F30((_DWORD*)dword_520970);
                                    if (sub_402170(v19, v21, v22, v23, v24, v25, v27))
                                    {
                                        sub_405E20(v8, v16, (int)a4, 0);
                                        v41 += sub_406000((_DWORD*)v8, (int)a4);
                                    }
                                }
                            }
                        }
                        v14 = ++v42;
                    } while (v42 < v28);
                    v10 = v41;
                }
            }
        }
    }
    (*(void(__stdcall**)(_DWORD, _DWORD, int))(**(_DWORD**)ArgList + 252))(*(_DWORD*)ArgList, 0, 11);
    (*(void(__stdcall**)(_DWORD, _DWORD, int, _DWORD))(**(_DWORD**)ArgList + 252))(*(_DWORD*)ArgList, 0, 24, 0);
    return v10;
}
// 406110: could not find valid save-restore pair for esi
// 406274: variable 'v28' is possibly undefined
// 4A4DB0: using guessed type char byte_4A4DB0;
// 4F5AF8: using guessed type char byte_4F5AF8;
// 520970: using guessed type int dword_520970;

//----- (004063E0) --------------------------------------------------------
float* __thiscall sub_4063E0(_DWORD* this, int a2, void* a3, float* a4, float a5, int a6)
{
    int v6; // ebp
    int v7; // edx
    bool v8; // c0
    bool v9; // c3
    float* v10; // edx
    int v11; // ecx
    bool v12; // c0
    float* v13; // ecx
    int v14; // ebx
    float* v15; // ecx
    float* v16; // edx
    int v17; // edi
    float* v18; // esi
    double v19; // st7
    float* result; // eax
    float v21; // [esp+0h] [ebp-1A4h]
    int v22; // [esp+4h] [ebp-1A0h]
    int v23; // [esp+8h] [ebp-19Ch]
    int v24; // [esp+Ch] [ebp-198h]
    int v25; // [esp+10h] [ebp-194h]
    int v26[4]; // [esp+14h] [ebp-190h] BYREF
    float v27[16]; // [esp+24h] [ebp-180h] BYREF
    _BYTE v28[64]; // [esp+64h] [ebp-140h] BYREF
    _BYTE v29[64]; // [esp+A4h] [ebp-100h] BYREF
    _BYTE v30[64]; // [esp+E4h] [ebp-C0h] BYREF
    _BYTE v31[64]; // [esp+124h] [ebp-80h] BYREF
    _BYTE v32[64]; // [esp+164h] [ebp-40h] BYREF

    v6 = this[1] + 172 * a2;
    v7 = this[12];
    v8 = a5 < (double)*(float*)(v7 + 4 * a6);
    v9 = a5 == *(float*)(v7 + 4 * a6);
    v10 = (float*)(v7 + 4 * a6);
    if (!v8 && !v9)
        a5 = *v10;
    v11 = this[11];
    v12 = a5 < (double)*(float*)(v11 + 4 * a6);
    v13 = (float*)(v11 + 4 * a6);
    if (v12)
        a5 = *v13;
    v14 = *(_DWORD*)(v6 + 12);
    v15 = 0;
    v16 = 0;
    v17 = 0;
    if (v14 <= 0)
    {
    LABEL_15:
        v16 = *(float**)(v6 + 16);
        v15 = v16;
        goto LABEL_16;
    }
    v18 = *(float**)(v6 + 16);
    while (*(_DWORD*)v18 != a6)
    {
    LABEL_10:
        ++v17;
        v18 += 10;
        if (v17 >= v14)
            goto LABEL_13;
    }
    if (v18[1] <= (double)a5)
    {
        v15 = v18;
        if (v18[1] == a5)
            goto LABEL_13;
        goto LABEL_10;
    }
    v16 = (float*)(*(_DWORD*)(v6 + 16) + 40 * v17);
LABEL_13:
    if (v15)
    {
    LABEL_16:
        if (!v16)
            v16 = v15;
        goto LABEL_18;
    }
    if (!v16)
        goto LABEL_15;
LABEL_18:
    v21 = 0.0;
    if (byte_4A1D46 && v15[1] != v16[1])
    {
        v19 = v16[1] - v15[1];
        if (v19 == 0.0)
            v21 = 0.0;
        else
            v21 = (a5 - v15[1]) / v19;
    }
    *(float*)&v23 = (v16[2] - v15[2]) * v21 + v15[2];
    *(float*)&v24 = (v16[3] - v15[3]) * v21 + v15[3];
    *(float*)&v25 = (v16[4] - v15[4]) * v21 + v15[4];
    *(float*)&v22 = (1.0 - v21) * v15[9] + v21 * v16[9];
    sub_46C3AA((float*)v26, v15 + 5, v16 + 5, v21);
    sub_46C107(v27, (float*)v26);
    sub_46BE02((int)v28, v23, v24, v25);
    sub_46BDA2((int)v29, v22, v22, v22);
    sub_46B97C(v31, v29, v27);
    qmemcpy(v30, v31, sizeof(v30));
    sub_46B97C(v32, v30, v28);
    result = a4;
    qmemcpy(a3, v32, 0x40u);
    *a4 = *(float*)&v22;
    return result;
}
// 4A1D46: using guessed type char byte_4A1D46;

//----- (00406620) --------------------------------------------------------
int __thiscall sub_406620(_DWORD* this, int a2, _BYTE* a3, float* a4, float a5, int a6)
{
    int v6; // ebp
    int result; // eax
    int v9; // esi
    _BYTE v10[64]; // [esp+10h] [ebp-40h] BYREF

    v6 = a6;
    sub_4063E0(this, a2, a3, a4, a5, a6);
    for (result = this[1] + 172 * a2; *(_BYTE*)result; result = this[1] + 172 * v9)
    {
        v9 = *(_DWORD*)(result + 28);
        if (v9 == -1)
            break;
        sub_4063E0(this, v9, v10, (float*)&a6, a5, v6);
        sub_46B97C(a3, a3, v10);
    }
    return result;
}

//----- (004066C0) --------------------------------------------------------
float* __userpurge sub_4066C0@<eax>(
    _DWORD* a1@<ecx>,
    int a2@<esi>,
    _DWORD* a3,
    float* a4,
    float* a5,
    float* a6,
    float* a7,
    float* a8)
{
    float* result; // eax
    int v11; // ebx
    char* v12; // esi
    float* v13; // eax
    int v14; // edx
    int v15; // ecx
    double v16; // st7
    double v17; // st7
    double v18; // st7
    double v19; // st7
    double v20; // st7
    double v21; // st7
    int v22; // ecx
    int v23; // eax
    bool v24; // zf
    float v26[2]; // [esp+18h] [ebp-5Ch] BYREF
    float v27; // [esp+20h] [ebp-54h] BYREF
    float v28; // [esp+24h] [ebp-50h]
    float v29; // [esp+28h] [ebp-4Ch]
    int v30; // [esp+2Ch] [ebp-48h] BYREF
    int v31; // [esp+30h] [ebp-44h]
    int v32; // [esp+34h] [ebp-40h] BYREF
    float v33[15]; // [esp+38h] [ebp-3Ch] BYREF
    float* v34; // [esp+8Ch] [ebp+18h]

    *a3 = 2139095039;
    result = a6;
    v11 = 0;
    *a4 = -3.4028235e38;
    *a5 = 3.4028235e38;
    *a6 = -3.4028235e38;
    *a7 = 3.4028235e38;
    *a8 = -3.4028235e38;
    if ((int)a1[2] > 0)
    {
        v34 = 0;
        do
        {
            v12 = (char*)v34 + a1[1];
            if (*((int*)v12 + 10) > 0)
            {
                sub_406620(a1, v11, &v32, v26, 0.0, 0);
                v31 = 0;
                LODWORD(v29) = v12 + 84;
                (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD, int*, _DWORD, int))(**((_DWORD**)v12 + 9) + 44))(
                    *((_DWORD*)v12 + 9),
                    0,
                    0,
                    &v30,
                    0,
                    a2);
                v13 = (float*)v31;
                v32 = v31;
                v14 = *((_DWORD*)v12 + 10);
                v15 = v14 - 1;
                v27 = 0.0;
                v28 = 0.0;
                v29 = 0.0;
                if (v14)
                {
                    LODWORD(v26[0]) = v14;
                    do
                    {
                        v27 = *v13;
                        v28 = v13[1];
                        v29 = v13[2];
                        sub_46C5C5(&v27, &v27, v33);
                        if (*a4 >= (double)v27)
                            v16 = v27;
                        else
                            v16 = *a4;
                        *a4 = v16;
                        if (*a5 <= (double)v27)
                            v17 = v27;
                        else
                            v17 = *a5;
                        *a5 = v17;
                        if (*a6 >= (double)v28)
                            v18 = v28;
                        else
                            v18 = *a6;
                        *a6 = v18;
                        if (*a7 <= (double)v28)
                            v19 = v28;
                        else
                            v19 = *a7;
                        *a7 = v19;
                        if (*v34 >= (double)v29)
                            v20 = v29;
                        else
                            v20 = *v34;
                        *v34 = v20;
                        if (*a8 <= (double)v29)
                            v21 = v29;
                        else
                            v21 = *a8;
                        v22 = v30;
                        v23 = v32;
                        *a8 = v21;
                        v13 = (float*)(*(_DWORD*)(v22 + 84) + v23);
                        v15 = LODWORD(v26[0]) - 1;
                        v24 = LODWORD(v26[0]) == 1;
                        v32 = (int)v13;
                        --LODWORD(v26[0]);
                    } while (!v24);
                }
                a2 = *((_DWORD*)v12 + 9);
                (*(void(__fastcall**)(int))(*(_DWORD*)a2 + 48))(v15);
            }
            result = (float*)a1[2];
            ++v11;
            v34 += 43;
        } while (v11 < (int)result);
    }
    return result;
}
// 4066C0: could not find valid save-restore pair for esi

//----- (004068D0) --------------------------------------------------------
_DWORD* __thiscall sub_4068D0(_DWORD* this)
{
    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
    *((_BYTE*)this + 16) = 1;
    *this = &off_4990C8;
    this[5] = 0;
    byte_4A1D44 = sub_422BA0(AppName, KeyName, 1) != 0;
    byte_4A1D45 = sub_422BA0(AppName, aWeldnormals, 1) != 0;
    return this;
}
// 4990C8: using guessed type _UNKNOWN *off_4990C8;
// 4A1D44: using guessed type char byte_4A1D44;
// 4A1D45: using guessed type char byte_4A1D45;

//----- (00406980) --------------------------------------------------------
int __thiscall sub_406980(_DWORD* this)
{
    int result; // eax
    int v2; // edx

    result = this[5];
    *this = &off_4990C8;
    if (result)
    {
        do
        {
            v2 = *(_DWORD*)(result + 580);
            *(_DWORD*)(result + 584) = 0;
            *(_DWORD*)(result + 580) = 0;
            result = v2;
        } while (v2);
    }
    this[5] = 0;
    *this = &off_499040;
    return result;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 4990C8: using guessed type _UNKNOWN *off_4990C8;

//----- (004069C0) --------------------------------------------------------
char* __userpurge sub_4069C0@<eax>(int a1@<ecx>, int a2@<ebp>, char* String1)
{
    int v4; // esi
    _DWORD* v5; // eax
    char* v6; // esi

    v4 = *(_DWORD*)(a1 + 20);
    if (v4)
    {
        while (_strcmpi(String1, (const char*)(v4 + 60)))
        {
            v4 = *(_DWORD*)(v4 + 580);
            if (!v4)
                goto LABEL_4;
        }
        ++ * (_DWORD*)(v4 + 56);
        return (char*)v4;
    }
    else
    {
    LABEL_4:
        v5 = operator new(0x24Cu);
        if (v5)
            v6 = (char*)sub_403B10(v5);
        else
            v6 = 0;
        *((_DWORD*)v6 + 146) = a1;
        *((_DWORD*)v6 + 145) = *(_DWORD*)(a1 + 20);
        *(_DWORD*)(a1 + 20) = v6;
        sub_403D90(v6, String1);
        sub_403E30((int)v6, a2);
        return v6;
    }
}

//----- (00406A50) --------------------------------------------------------
int __thiscall sub_406A50(_DWORD* this, int a2)
{
    int result; // eax
    int v3; // esi
    int v4; // edx

    result = this[5];
    v3 = 0;
    if (result)
    {
        while (1)
        {
            v4 = *(_DWORD*)(result + 580);
            if (result == a2)
                break;
            v3 = result;
            result = *(_DWORD*)(result + 580);
            if (!v4)
                return result;
        }
        if (v3)
            *(_DWORD*)(v3 + 580) = v4;
        else
            this[5] = v4;
    }
    return result;
}

//----- (00406A90) --------------------------------------------------------
_DWORD* __cdecl sub_406A90(int a1, char a2)
{
    _DWORD* v2; // eax

    v2 = operator new(0x34u);
    if (v2)
        return sub_406B00(v2, a1, a2);
    else
        return 0;
}

//----- (00406B00) --------------------------------------------------------
_DWORD* __thiscall sub_406B00(_DWORD* this, int a2, char a3)
{
    int v4; // ecx
    int v5; // edi
    void* v6; // eax
    void* v7; // edi
    int v8; // eax

    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
    *((_BYTE*)this + 16) = 1;
    *this = &off_499040;
    v4 = *(_DWORD*)(a2 + 8);
    this[6] = 0;
    this[5] = v4;
    v5 = this[5];
    this[7] = a2;
    this[9] = 0;
    *((_BYTE*)this + 40) = a3;
    this[11] = 0;
    *((_BYTE*)this + 48) = 0;
    *this = &off_4990E8;
    this[8] = **(_DWORD**)(a2 + 44);
    v6 = operator new(96 * v5);
    if (v6)
        v7 = v6;
    else
        v7 = 0;
    v8 = this[5];
    this[6] = v7;
    memset(v7, 0, 4 * ((unsigned int)(96 * v8) >> 2));
    return this;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 4990E8: using guessed type _UNKNOWN *off_4990E8;

//----- (00406BE0) --------------------------------------------------------
_DWORD* __cdecl sub_406BE0(_DWORD* a1)
{
    _DWORD* result; // eax

    result = a1;
    a1[14] = 0;
    a1[13] = 0;
    a1[12] = 0;
    a1[11] = 0;
    a1[9] = 0;
    a1[8] = 0;
    a1[7] = 0;
    a1[6] = 0;
    a1[4] = 0;
    a1[3] = 0;
    a1[2] = 0;
    a1[1] = 0;
    a1[15] = 1065353216;
    a1[10] = 1065353216;
    a1[5] = 1065353216;
    *a1 = 1065353216;
    return result;
}

//----- (00406C20) --------------------------------------------------------
void __thiscall sub_406C20(void* this)
{
    int v2; // ebx
    int v3; // edi

    *(_DWORD*)this = &off_4990E8;
    v2 = 0;
    if (*((int*)this + 5) > 0)
    {
        v3 = 0;
        do
        {
            if (*(_DWORD*)(*((_DWORD*)this + 6) + v3 + 88))
                sub_409A00(dword_520970, *(void**)(*((_DWORD*)this + 6) + v3 + 88));
            ++v2;
            v3 += 96;
        } while (v2 < *((_DWORD*)this + 5));
    }
    sub_4885A6(*((LPVOID*)this + 6));
    *((_DWORD*)this + 6) = 0;
    *(_DWORD*)this = &off_499040;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 4990E8: using guessed type _UNKNOWN *off_4990E8;
// 520970: using guessed type int dword_520970;

//----- (00406CB0) --------------------------------------------------------
int __thiscall sub_406CB0(int this, int a2)
{
    float* v3; // edi
    int v4; // eax
    int v6; // [esp-4h] [ebp-10h]
    char v7; // [esp+0h] [ebp-Ch]

    v6 = *(_DWORD*)(a2 + 40);
    v3 = (float*)(*(_DWORD*)(this + 24) + 96 * v6);
    sub_406F00((float*)this, v6);
    LOBYTE(v4) = *(_BYTE*)(this + 40);
    return sub_406110(*(_DWORD**)(this + 28), this, *(_DWORD*)(a2 + 40), v3, v4, v7);
}
// 406CD9: variable 'v4' is possibly undefined
// 406CD9: variable 'v7' is possibly undefined

//----- (00406CF0) --------------------------------------------------------
int __thiscall sub_406CF0(int this, float a2)
{
    int result; // eax
    int i; // edi
    float v5; // [esp+0h] [ebp-Ch]

    v5 = a2 * *(float*)(this + 36);
    sub_406D30(this, v5);
    result = *(_DWORD*)(this + 20);
    for (i = 0; i < result; ++i)
    {
        sub_406DF0(this, i);
        result = *(_DWORD*)(this + 20);
    }
    return result;
}

//----- (00406D30) --------------------------------------------------------
void __thiscall sub_406D30(int this, float a2)
{
    double v2; // st7
    double v3; // st6
    char v4; // al
    int v5; // esi
    int v6; // edx
    int v7; // edx
    int v8; // esi
    int v9; // edx
    _DWORD* v10; // edi
    int v11; // eax
    bool v12; // c0
    int* v13; // edx
    double v14; // st7

    v2 = *(float*)(this + 32);
    v3 = a2 + v2;
    v4 = *(_BYTE*)(this + 48);
    *(float*)(this + 32) = v3;
    if (v4)
    {
        v5 = *(_DWORD*)(this + 28);
        v6 = 4 * *(_DWORD*)(this + 44);
        if (v3 > *(float*)(*(_DWORD*)(v5 + 48) + v6))
            *(_DWORD*)(this + 32) = *(_DWORD*)(*(_DWORD*)(v5 + 44) + v6);
        if (*(float*)(this + 32) < (double)*(float*)(*(_DWORD*)(v5 + 44) + v6))
        {
            v7 = *(_DWORD*)(*(_DWORD*)(v5 + 48) + v6);
        LABEL_10:
            *(_DWORD*)(this + 32) = v7;
        }
    }
    else
    {
        v8 = *(_DWORD*)(this + 28);
        v9 = 4 * *(_DWORD*)(this + 44);
        v10 = (_DWORD*)(*(_DWORD*)(v8 + 48) + v9);
        if (v3 > *(float*)v10)
            *(_DWORD*)(this + 32) = *v10;
        v11 = *(_DWORD*)(v8 + 44);
        v12 = *(float*)(this + 32) < (double)*(float*)(v9 + v11);
        v13 = (int*)(v11 + v9);
        if (v12)
        {
            v7 = *v13;
            goto LABEL_10;
        }
    }
    v14 = v2 - *(float*)(this + 32);
    if (v14 >= 0.0000099999997 || v14 <= -0.0000099999997)
        sub_407120((_DWORD*)this, 0);
}

//----- (00406DF0) --------------------------------------------------------
int __thiscall sub_406DF0(int this, int a2)
{
    int v3; // esi
    int v4; // ebx
    char v5; // al
    _DWORD* v6; // eax
    int v7; // ecx
    int v8; // ecx
    int result; // eax
    _DWORD* v10; // ecx

    v3 = *(_DWORD*)(this + 24) + 96 * a2;
    v4 = *(_DWORD*)(*(_DWORD*)(this + 28) + 4) + 172 * a2;
    v5 = *(_BYTE*)(v3 + 84);
    if (v5 && *(_DWORD*)(v3 + 88))
    {
        sub_409A00(dword_520970, *(void**)(v3 + 88));
        *(_DWORD*)(v3 + 88) = 0;
        goto LABEL_11;
    }
    if (!*(_BYTE*)(v4 + 81) || v5)
    {
    LABEL_11:
        result = *(_DWORD*)(v3 + 88);
        if (!result)
            return result;
        goto LABEL_12;
    }
    if (!*(_DWORD*)(v3 + 88))
    {
        v6 = sub_409960((_DWORD*)dword_520970, this);
        *(_DWORD*)(v3 + 88) = v6;
        v7 = *(_DWORD*)(v4 + 52);
        if (v7)
            v8 = *(_DWORD*)(v7 + 84);
        else
            v8 = 0;
        v6[9] = v8;
        *(_DWORD*)(*(_DWORD*)(v3 + 88) + 12) = *(_DWORD*)(v4 + 76);
        *(float*)(*(_DWORD*)(v3 + 88) + 40) = *(float*)&a2;
        goto LABEL_11;
    }
LABEL_12:
    sub_406F00((float*)this, a2);
    if (*(_DWORD*)(v4 + 76) == 1)
    {
        sub_4085B0(this, a2, *(_DWORD*)(v3 + 88) + 16);
        *(_DWORD*)(*(_DWORD*)(v3 + 88) + 28) = 0;
    }
    else
    {
        v10 = (_DWORD*)(*(_DWORD*)(v3 + 88) + 16);
        *v10 = *(_DWORD*)v3;
        v10[1] = *(_DWORD*)(v3 + 4);
        v10[2] = *(_DWORD*)(v3 + 8);
        *(_DWORD*)(*(_DWORD*)(v3 + 88) + 28) = 1;
    }
    result = *(_DWORD*)(v3 + 12);
    *(_DWORD*)(*(_DWORD*)(v3 + 88) + 32) = result;
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (00406F00) --------------------------------------------------------
char __thiscall sub_406F00(float* this, int a2)
{
    int v4; // ecx
    float* v5; // esi
    int v6; // eax
    int v7; // ebp
    float* v8; // edi
    char v9; // cl
    _BYTE* v10; // ebp
    _BYTE* v12; // [esp+10h] [ebp-4h]
    int v13; // [esp+18h] [ebp+4h]
    float v14; // [esp+18h] [ebp+4h]

    v4 = *(_DWORD*)(*((_DWORD*)this + 7) + 4);
    v12 = (_BYTE*)(v4 + 172 * a2);
    v5 = (float*)(*((_DWORD*)this + 6) + 96 * a2);
    v6 = a2;
    v7 = *((_DWORD*)v5 + 23);
    if (a2 <= -1)
        return v6;
    while (1)
    {
        v13 = v4 + 172 * v6;
        if (!*(_BYTE*)(96 * v6 + *((_DWORD*)this + 6) + 85))
            break;
        if (v7 && *(_BYTE*)v7)
            LOBYTE(v6) = *(_BYTE*)(v7 + 1);
        else
            LOBYTE(v6) = *(_BYTE*)v13;
        if ((_BYTE)v6)
        {
            v6 = *(_DWORD*)(v13 + 28);
            if (v6 > -1)
                continue;
        }
        return v6;
    }
    if (!v7)
        goto LABEL_15;
    if (*(_BYTE*)(v7 + 68))
    {
        v8 = v5 + 4;
        v5[18] = 0.0;
        v5[17] = 0.0;
        v5[16] = 0.0;
        v5[15] = 0.0;
        v5[13] = 0.0;
        v5[12] = 0.0;
        v5[11] = 0.0;
        v5[10] = 0.0;
        v5[8] = 0.0;
        v5[7] = 0.0;
        v5[6] = 0.0;
        v5[5] = 0.0;
        v5[19] = 1.0;
        v5[14] = 1.0;
        v5[9] = 1.0;
        v5[4] = 1.0;
        goto LABEL_19;
    }
    if (*(_BYTE*)(v7 + 70))
        v14 = *(float*)(v7 + 72);
    else
        LABEL_15:
    v14 = this[8];
    v8 = v5 + 4;
    sub_4063E0(*((_DWORD**)this + 7), a2, v5 + 4, v5 + 20, v14, *((_DWORD*)this + 11));
    if (!v7)
        goto LABEL_23;
    if (*(_BYTE*)(v7 + 69))
    {
        *v8 = 1.0;
        v5[5] = 0.0;
        v5[6] = 0.0;
        v5[8] = 0.0;
        v5[9] = 1.0;
        v5[10] = 0.0;
        v5[12] = 0.0;
        v5[13] = 0.0;
        v5[14] = 1.0;
    }
LABEL_19:
    if (*(_BYTE*)(v7 + 2))
        sub_46B97C(v8, (_BYTE*)(v7 + 4), v8);
    if (*(_BYTE*)v7)
    {
        v9 = *(_BYTE*)(v7 + 1);
        v10 = v12;
        goto LABEL_24;
    }
LABEL_23:
    v10 = v12;
    v9 = *v12;
LABEL_24:
    if (v9 && *((int*)v10 + 7) >= 0)
    {
        sub_406F00(*((float*)v10 + 7));
        sub_46B97C(v8, v8, (_BYTE*)(96 * *((_DWORD*)v10 + 7) + *((_DWORD*)this + 6) + 16));
        v5[20] = *(float*)(96 * *((_DWORD*)v10 + 7) + *((_DWORD*)this + 6) + 80) * v5[20];
    }
    if (_strcmpi(*((const char**)v10 + 2), aSky08) && _strcmpi(*((const char**)v10 + 2), aCloud08))
        _strcmpi(*((const char**)v10 + 2), aMesh05);
    sub_46C5C5(v5, (float*)v10 + 15, v8);
    v5[3] = v5[20] * *((float*)v10 + 18);
    LOBYTE(v6) = dword_520A78;
    *(float*)dword_520A78 = *(float*)dword_520A78 + 1.0;
    *((_BYTE*)v5 + 85) = 1;
    return v6;
}
// 520A78: using guessed type int dword_520A78;

//----- (00407120) --------------------------------------------------------
int __thiscall sub_407120(_DWORD* this, int a2)
{
    int result; // eax
    int v3; // edx
    int v4; // esi

    *(_BYTE*)(96 * a2 + this[6] + 85) = 0;
    result = a2 + 1;
    if (a2 + 1 < this[5])
    {
        v3 = 96 * result;
        v4 = 172 * result;
        do
        {
            if (*(_DWORD*)(v4 + *(_DWORD*)(this[7] + 4) + 28) < a2)
                break;
            ++result;
            v4 += 172;
            *(_BYTE*)(v3 + this[6] + 85) = 0;
            v3 += 96;
        } while (result < this[5]);
    }
    return result;
}

//----- (00407190) --------------------------------------------------------
void* __thiscall sub_407190(_DWORD* this, int a2, char a3)
{
    int v3; // esi
    void* v4; // edx
    int v5; // ebp
    int v6; // eax

    if (a2 < 0 || a2 > this[5])
        return 0;
    v3 = this[6] + 96 * a2;
    v4 = *(void**)(v3 + 92);
    v5 = *(_DWORD*)(this[7] + 4) + 172 * a2;
    if (!v4)
    {
        if (a3)
        {
            v4 = operator new(0x5Cu);
            *(_DWORD*)(v3 + 92) = v4;
            memset(v4, 0, 0x5Cu);
            *((_DWORD*)v4 + 15) = 0;
            *((_DWORD*)v4 + 14) = 0;
            *((_DWORD*)v4 + 13) = 0;
            *((_DWORD*)v4 + 12) = 0;
            *((_DWORD*)v4 + 10) = 0;
            *((_DWORD*)v4 + 9) = 0;
            *((_DWORD*)v4 + 8) = 0;
            *((_DWORD*)v4 + 7) = 0;
            *((_DWORD*)v4 + 5) = 0;
            *((_DWORD*)v4 + 4) = 0;
            *((_DWORD*)v4 + 3) = 0;
            *((_DWORD*)v4 + 2) = 0;
            *((_DWORD*)v4 + 16) = 1065353216;
            *((_DWORD*)v4 + 11) = 1065353216;
            *((_DWORD*)v4 + 6) = 1065353216;
            *((_DWORD*)v4 + 1) = 1065353216;
            *((_BYTE*)v4 + 76) = 0;
            *((_BYTE*)v4 + 77) = 1;
            v6 = *(_DWORD*)(v5 + 52);
            if (v6)
            {
                if (*(_BYTE*)(v6 + 73))
                    *((_BYTE*)v4 + 76) = 1;
            }
        }
    }
    return v4;
}

//----- (00407250) --------------------------------------------------------
int __thiscall sub_407250(_DWORD* this)
{
    int v2; // ebp
    int v3; // ebx
    int v4; // esi

    v2 = 0;
    if ((int)this[5] > 0)
    {
        v3 = 0;
        do
        {
            v4 = v3 + this[6];
            if (*(_DWORD*)(v4 + 92))
            {
                sub_4885A6(*(LPVOID*)(v4 + 92));
                *(_DWORD*)(v4 + 92) = 0;
            }
            ++v2;
            v3 += 96;
        } while (v2 < this[5]);
    }
    return sub_407120(this, 0);
}

//----- (004072A0) --------------------------------------------------------
char __thiscall sub_4072A0(_DWORD* this, int a2, int a3, char a4)
{
    _BYTE* v5; // esi
    int v6; // eax
    int v7; // esi
    int v8; // ebx

    v5 = sub_407190(this, a2, 1);
    sub_407120(this, a2);
    v5[70] = 1;
    *((_DWORD*)v5 + 18) = a3;
    LOBYTE(v6) = a4;
    if (a4)
    {
        v6 = this[5];
        v7 = a2 + 1;
        if (a2 + 1 < v6)
        {
            v8 = 172 * v7;
            do
            {
                v6 = *(_DWORD*)(this[7] + 4);
                if (*(_DWORD*)(v6 + v8 + 28) < a2)
                    break;
                sub_4072A0(v7, a3, 0);
                v6 = this[5];
                ++v7;
                v8 += 172;
            } while (v7 < v6);
        }
    }
    return v6;
}

//----- (00407320) --------------------------------------------------------
double __thiscall sub_407320(_DWORD* this, int a2)
{
    float* v2; // eax

    v2 = (float*)sub_407190(this, a2, 0);
    if (v2 && *((_BYTE*)v2 + 70))
        return v2[18];
    else
        return 0.0;
}

//----- (00407350) --------------------------------------------------------
char __thiscall sub_407350(_DWORD* this, int a2)
{
    _BYTE* v3; // eax

    v3 = sub_407190(this, a2, 1);
    if (v3 && *v3)
        return v3[1];
    else
        return *(_BYTE*)(*(_DWORD*)(this[7] + 4) + 172 * a2);
}

//----- (00407390) --------------------------------------------------------
int __thiscall sub_407390(_DWORD* this, int a2, char a3)
{
    *((_BYTE*)sub_407190(this, a2, 1) + 68) = a3;
    return sub_407120(this, a2);
}

//----- (004073C0) --------------------------------------------------------
int __thiscall sub_4073C0(_DWORD* this, int a2, char a3)
{
    *((_BYTE*)sub_407190(this, a2, 1) + 69) = a3;
    return sub_407120(this, a2);
}

//----- (004073F0) --------------------------------------------------------
int __thiscall sub_4073F0(_DWORD* this, int a2, const void* a3)
{
    char* v4; // eax

    v4 = (char*)sub_407190(this, a2, 1);
    v4[2] = 1;
    qmemcpy(v4 + 4, a3, 0x40u);
    return sub_407120(this, a2);
}

//----- (00407430) --------------------------------------------------------
char* __thiscall sub_407430(_DWORD* this, int a2, char* a3)
{
    char* result; // eax

    result = (char*)sub_407190(this, a2, 1);
    result[2] = 1;
    qmemcpy(a3, result + 4, 0x40u);
    return result;
}

//----- (00407460) --------------------------------------------------------
int __thiscall sub_407460(_DWORD* this, int a2)
{
    _BYTE* v3; // eax

    v3 = sub_407190(this, a2, 1);
    v3[2] = 1;
    qmemcpy(v3 + 4, (const void*)(this[6] + 96 * a2 + 16), 0x40u);
    *v3 = 1;
    v3[1] = 0;
    return sub_407120(this, a2);
}

//----- (004074B0) --------------------------------------------------------
int __thiscall sub_4074B0(_DWORD* this, int a2)
{
    _BYTE* v3; // eax

    v3 = sub_407190(this, a2, 1);
    v3[2] = 1;
    *((_DWORD*)v3 + 15) = 0;
    *((_DWORD*)v3 + 14) = 0;
    *((_DWORD*)v3 + 13) = 0;
    *((_DWORD*)v3 + 12) = 0;
    *((_DWORD*)v3 + 10) = 0;
    *((_DWORD*)v3 + 9) = 0;
    *((_DWORD*)v3 + 8) = 0;
    *((_DWORD*)v3 + 7) = 0;
    *((_DWORD*)v3 + 5) = 0;
    *((_DWORD*)v3 + 4) = 0;
    *((_DWORD*)v3 + 3) = 0;
    *((_DWORD*)v3 + 2) = 0;
    *((_DWORD*)v3 + 16) = 1065353216;
    *((_DWORD*)v3 + 11) = 1065353216;
    *((_DWORD*)v3 + 6) = 1065353216;
    *((_DWORD*)v3 + 1) = 1065353216;
    return sub_407120(this, a2);
}

//----- (00407510) --------------------------------------------------------
int __thiscall sub_407510(_DWORD* this, int a2, float a3)
{
    _BYTE* v4; // edi

    v4 = sub_407190(this, a2, 1);
    v4[2] = 1;
    sub_46BE62((float*)byte_4F5AB8, a3);
    sub_46B97C(v4 + 4, v4 + 4, byte_4F5AB8);
    return sub_407120(this, a2);
}
// 4F5AB8: using guessed type _BYTE byte_4F5AB8[64];

//----- (00407560) --------------------------------------------------------
int __thiscall sub_407560(_DWORD* this, int a2, float a3)
{
    _BYTE* v4; // edi

    v4 = sub_407190(this, a2, 1);
    v4[2] = 1;
    sub_46BEE6((float*)byte_4F5AB8, a3);
    sub_46B97C(v4 + 4, v4 + 4, byte_4F5AB8);
    return sub_407120(this, a2);
}
// 4F5AB8: using guessed type _BYTE byte_4F5AB8[64];

//----- (004075B0) --------------------------------------------------------
int __thiscall sub_4075B0(_DWORD* this, int a2, float a3)
{
    _BYTE* v4; // edi

    v4 = sub_407190(this, a2, 1);
    v4[2] = 1;
    sub_46BF69((float*)byte_4F5AB8, a3);
    sub_46B97C(v4 + 4, v4 + 4, byte_4F5AB8);
    return sub_407120(this, a2);
}
// 4F5AB8: using guessed type _BYTE byte_4F5AB8[64];

//----- (00407600) --------------------------------------------------------
int __thiscall sub_407600(_DWORD* this, int a2, int a3, int a4, int a5)
{
    _BYTE* v6; // edi

    v6 = sub_407190(this, a2, 1);
    v6[2] = 1;
    sub_46BE02((int)byte_4F5AB8, a3, a4, a5);
    sub_46B97C(v6 + 4, v6 + 4, byte_4F5AB8);
    return sub_407120(this, a2);
}
// 4F5AB8: using guessed type _BYTE byte_4F5AB8[64];

//----- (00407650) --------------------------------------------------------
_BYTE* __thiscall sub_407650(_DWORD* this, int a2, char a3)
{
    _BYTE* result; // eax

    result = sub_407190(this, a2, 1);
    result[76] = a3;
    return result;
}

//----- (00407670) --------------------------------------------------------
_BYTE* __thiscall sub_407670(_DWORD* this, int a2, char a3)
{
    _BYTE* result; // eax

    result = sub_407190(this, a2, 1);
    result[77] = a3;
    return result;
}

//----- (00407690) --------------------------------------------------------
int __thiscall sub_407690(int this, int a2, _DWORD* a3)
{
    int result; // eax

    if (a2 < 0 || a2 >= *(_DWORD*)(this + 20))
    {
        result = (int)a3;
        a3[14] = 0;
        a3[13] = 0;
        a3[12] = 0;
        a3[11] = 0;
        a3[9] = 0;
        a3[8] = 0;
        a3[7] = 0;
        a3[6] = 0;
        a3[4] = 0;
        a3[3] = 0;
        a3[2] = 0;
        a3[1] = 0;
        a3[15] = 1065353216;
        a3[10] = 1065353216;
        a3[5] = 1065353216;
        *a3 = 1065353216;
    }
    else
    {
        sub_406F00((float*)this, a2);
        result = 96 * a2;
        qmemcpy(a3, (const void*)(96 * a2 + *(_DWORD*)(this + 24) + 16), 0x40u);
    }
    return result;
}

//----- (00407710) --------------------------------------------------------
char __thiscall sub_407710(float* this, int a2, int a3, int a4, int a5, int a6, int a7, int* a8, float* a9)
{
    float* v9; // edi
    int v10; // eax
    int v11; // esi
    int v12; // ebp
    int* v13; // esi
    int v14; // ebx
    int v15; // eax
    int v16; // esi
    int v17; // eax
    int v18; // edi
    int v19; // ebp
    unsigned __int16 v20; // cx
    unsigned __int16 v21; // dx
    int v22; // eax
    char v24; // [esp+31h] [ebp-C9h]
    int v25; // [esp+32h] [ebp-C8h]
    int v26; // [esp+36h] [ebp-C4h]
    int v27; // [esp+3Ah] [ebp-C0h] BYREF
    int v28; // [esp+3Eh] [ebp-BCh]
    int v29; // [esp+42h] [ebp-B8h]
    int v30; // [esp+46h] [ebp-B4h] BYREF
    int* v31; // [esp+4Ah] [ebp-B0h]
    int v32; // [esp+4Eh] [ebp-ACh]
    int v33; // [esp+52h] [ebp-A8h]
    int v34; // [esp+56h] [ebp-A4h] BYREF
    int v35; // [esp+5Ah] [ebp-A0h]
    int v36; // [esp+5Eh] [ebp-9Ch]
    int v37; // [esp+62h] [ebp-98h] BYREF
    int v38; // [esp+66h] [ebp-94h]
    int v39; // [esp+6Ah] [ebp-90h]
    int v40; // [esp+6Eh] [ebp-8Ch] BYREF
    int v41; // [esp+72h] [ebp-88h]
    int v42; // [esp+76h] [ebp-84h]
    float v43[3]; // [esp+7Ah] [ebp-80h] BYREF
    float v44[3]; // [esp+86h] [ebp-74h] BYREF
    float* v45; // [esp+92h] [ebp-68h]
    int v46[3]; // [esp+96h] [ebp-64h] BYREF
    int v47[3]; // [esp+A2h] [ebp-58h] BYREF
    int v48[3]; // [esp+AEh] [ebp-4Ch] BYREF
    float v49[16]; // [esp+BAh] [ebp-40h] BYREF

    v9 = this;
    v47[0] = a2;
    v48[0] = a5;
    v10 = *((_DWORD*)this + 5);
    v47[1] = a3;
    v47[2] = a4;
    v11 = 0;
    v12 = 0;
    v45 = this;
    v48[1] = a6;
    v48[2] = a7;
    v28 = 0;
    if (v10 <= 0)
        return 0;
    v26 = 0;
    v32 = 0;
    while (1)
    {
        v13 = (int*)(*((_DWORD*)v9 + 6) + v11);
        v14 = v26 + *(_DWORD*)(*((_DWORD*)v9 + 7) + 4);
        v33 = v14;
        if (v13)
        {
            v15 = v13[23];
            if (v15)
                break;
        }
        if (*(_BYTE*)(v14 + 80))
            goto LABEL_9;
    LABEL_20:
        v22 = *((_DWORD*)v9 + 5);
        ++v12;
        v11 = v32 + 96;
        v28 = v12;
        v32 += 96;
        v26 += 172;
        if (v12 >= v22)
            return 0;
    }
    if (!*(_BYTE*)(v14 + 80) || !*(_BYTE*)(v15 + 77))
        goto LABEL_20;
LABEL_9:
    sub_406F00(v9, v12);
    v46[0] = *v13;
    v46[1] = v13[1];
    v46[2] = v13[2];
    if (!sub_40C6F0((float*)v47, (float*)v48, (float*)v46))
        goto LABEL_20;
    qmemcpy(v49, v13 + 4, sizeof(v49));
    v16 = 0;
    sub_46B9FD(v49, 0, v49);
    LODWORD(v43[0]) = a2;
    LODWORD(v43[1]) = a3;
    LODWORD(v43[2]) = a4;
    LODWORD(v44[0]) = a5;
    LODWORD(v44[1]) = a6;
    LODWORD(v44[2]) = a7;
    sub_46C5C5(v43, v43, v49);
    sub_46C5C5(v44, v44, v49);
    v24 = 0;
    (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD, int*, _DWORD))(**(_DWORD**)(v14 + 44) + 44))(
        *(_DWORD*)(v14 + 44),
        0,
        0,
        &v27,
        0);
    v29 = v14 + 84;
    v17 = *(_DWORD*)(v14 + 36);
    v31 = 0;
    (*(void(__stdcall**)(int, _DWORD, _DWORD, int*, _DWORD))(*(_DWORD*)v17 + 44))(v17, 0, 0, &v30, 0);
    v18 = v27;
    v19 = v30;
    v34 = 0;
    v35 = 0;
    v36 = 0;
    v40 = 0;
    v41 = 0;
    v42 = 0;
    v37 = 0;
    v38 = 0;
    v39 = 0;
    v25 = 0;
    do
    {
        if (v25 >= *(_DWORD*)(v14 + 48))
            break;
        v20 = *(_WORD*)(v16 + v18 + 2);
        v21 = *(_WORD*)(v16 + v18 + 4);
        v31 = (int*)(v19 + *(_DWORD*)(v29 + 84) * *(unsigned __int16*)(v16 + v18));
        v34 = *v31;
        v35 = v31[1];
        v36 = v31[2];
        v31 = (int*)(v19 + *(_DWORD*)(v29 + 84) * v20);
        v40 = *v31;
        v41 = v31[1];
        v42 = v31[2];
        v31 = (int*)(v19 + *(_DWORD*)(v29 + 84) * v21);
        v37 = *v31;
        v38 = v31[1];
        v39 = v31[2];
        if (sub_40C910(v43, v44, (float*)&v34, (float*)&v40, (float*)&v37, a9))
        {
            v18 = v27;
            v19 = v30;
            v24 = 1;
        }
        else
        {
            v18 = v27;
            v19 = v30;
            v24 = 0;
        }
        v14 = v33;
        v16 += 6;
        ++v25;
    } while (!v24);
    *(float*)dword_520A58 = (double)*(int*)(v14 + 48) + *(float*)dword_520A58;
    (*(void(__stdcall**)(_DWORD))(**(_DWORD**)(v14 + 44) + 48))(*(_DWORD*)(v14 + 44));
    (*(void(__stdcall**)(_DWORD))(**(_DWORD**)(v14 + 36) + 48))(*(_DWORD*)(v14 + 36));
    if (!v24)
    {
        v9 = v45;
        v12 = v28;
        goto LABEL_20;
    }
    *a8 = v28;
    return 1;
}
// 4079A7: conditional instruction was optimized away because %var_CC@3.1==0
// 520A58: using guessed type int dword_520A58;

//----- (00407A90) --------------------------------------------------------
BOOL __userpurge sub_407A90@<eax>(
    int a1@<ecx>,
    int a2@<ebx>,
    int a3@<esi>,
    int a4,
    int a5,
    int a6,
    int a7,
    int a8,
    int a9,
    int* a10,
    _DWORD* a11,
    int a12,
    float* a13)
{
    int v13; // edi
    int v14; // edx
    int v15; // ecx
    int v16; // eax
    int v17; // esi
    int* v18; // esi
    int v19; // ebx
    char v20; // cl
    int v21; // ebx
    int v22; // eax
    int v23; // edi
    int v24; // ebp
    int v25; // esi
    unsigned __int16 v26; // cx
    unsigned __int16 v27; // dx
    bool v28; // cc
    int v32; // [esp+36h] [ebp-E4h]
    int v33; // [esp+3Ah] [ebp-E0h]
    int v34; // [esp+3Eh] [ebp-DCh] BYREF
    int v35; // [esp+42h] [ebp-D8h]
    int v36; // [esp+46h] [ebp-D4h]
    int v37; // [esp+4Eh] [ebp-CCh]
    int v38; // [esp+52h] [ebp-C8h] BYREF
    int* v39; // [esp+56h] [ebp-C4h]
    int v40; // [esp+5Ah] [ebp-C0h] BYREF
    int v41; // [esp+5Eh] [ebp-BCh]
    int v42; // [esp+62h] [ebp-B8h]
    int v43; // [esp+66h] [ebp-B4h]
    int v44; // [esp+6Ah] [ebp-B0h]
    int v45; // [esp+6Eh] [ebp-ACh]
    int v46; // [esp+72h] [ebp-A8h]
    int v47; // [esp+76h] [ebp-A4h]
    int v48; // [esp+82h] [ebp-98h] BYREF
    int v49; // [esp+86h] [ebp-94h]
    int v50; // [esp+8Ah] [ebp-90h]
    int v51; // [esp+8Eh] [ebp-8Ch] BYREF
    int v52; // [esp+92h] [ebp-88h]
    int v53; // [esp+96h] [ebp-84h]
    int v54; // [esp+9Ah] [ebp-80h] BYREF
    int v55; // [esp+9Eh] [ebp-7Ch] BYREF
    int v56; // [esp+A2h] [ebp-78h]
    int v57; // [esp+A6h] [ebp-74h] BYREF
    int v58[3]; // [esp+B6h] [ebp-64h] BYREF
    int v59[3]; // [esp+C2h] [ebp-58h] BYREF
    int v60[3]; // [esp+CEh] [ebp-4Ch] BYREF
    float v61[16]; // [esp+DAh] [ebp-40h] BYREF

    v13 = a1;
    v59[2] = a6;
    v59[0] = a4;
    v59[1] = a5;
    v58[2] = a9;
    v14 = *(_DWORD*)(a1 + 20);
    v58[0] = a7;
    v58[1] = a8;
    v15 = -1;
    v16 = 0;
    v32 = v13;
    v41 = -1;
    v45 = 0;
    v46 = 0;
    v47 = 0;
    v44 = 2139095039;
    v33 = 0;
    if (v14 <= 0)
        return v15 != -1;
    v17 = 0;
    v35 = 0;
    v43 = 0;
    do
    {
        v18 = (int*)(*(_DWORD*)(v13 + 24) + v17);
        v19 = *(_DWORD*)(*(_DWORD*)(v13 + 28) + 4);
        v20 = *(_BYTE*)(v19 + v35 + 80);
        v21 = v35 + v19;
        v42 = v21;
        if (v20)
        {
            sub_406F00((float*)v13, v16);
            v60[0] = *v18;
            v60[1] = v18[1];
            v60[2] = v18[2];
            if (sub_40C6F0((float*)v59, (float*)v58, (float*)v60))
            {
                qmemcpy(v61, v18 + 4, sizeof(v61));
                sub_46B9FD(v61, 0, v61);
                v38 = a4;
                v39 = (int*)a5;
                v40 = a6;
                v55 = a7;
                v56 = a8;
                v57 = a9;
                sub_46C5C5((float*)&v38, (float*)&v38, v61);
                sub_46C5C5((float*)&v55, (float*)&v55, v61);
                (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD, int*, _DWORD, int, int))(**(_DWORD**)(v21 + 44) + 44))(
                    *(_DWORD*)(v21 + 44),
                    0,
                    0,
                    &v34,
                    0,
                    a3,
                    a2);
                v22 = *(_DWORD*)(v21 + 36);
                v37 = v21 + 84;
                v39 = 0;
                (*(void(__stdcall**)(int, _DWORD, _DWORD, int*, _DWORD))(*(_DWORD*)v22 + 44))(v22, 0, 0, &v38, 0);
                v23 = v36;
                v33 = 0;
                v24 = v38;
                v51 = 0;
                v52 = 0;
                v53 = 0;
                v48 = 0;
                v49 = 0;
                v50 = 0;
                v54 = 0;
                v55 = 0;
                v56 = 0;
                v25 = 0;
                while (1)
                {
                    if (v33 >= *(_DWORD*)(v21 + 48))
                    {
                    LABEL_13:
                        *(float*)dword_520A58 = (double)*(int*)(v21 + 48) + *(float*)dword_520A58;
                        a2 = *(_DWORD*)(v21 + 44);
                        (*(void (**)(void))(*(_DWORD*)a2 + 48))();
                        a3 = *(_DWORD*)(v21 + 36);
                        (*(void (**)(void))(*(_DWORD*)a3 + 48))();
                        v13 = v32;
                        goto LABEL_14;
                    }
                    v26 = *(_WORD*)(v25 + v23 + 2);
                    v27 = *(_WORD*)(v25 + v23 + 4);
                    v39 = (int*)(v24 + *(_DWORD*)(v37 + 84) * *(unsigned __int16*)(v25 + v23));
                    v51 = *v39;
                    v52 = v39[1];
                    v53 = v39[2];
                    v39 = (int*)(v24 + *(_DWORD*)(v37 + 84) * v26);
                    v48 = *v39;
                    v49 = v39[1];
                    v50 = v39[2];
                    v39 = (int*)(v24 + *(_DWORD*)(v37 + 84) * v27);
                    v54 = *v39;
                    v55 = v39[1];
                    v56 = v39[2];
                    if (HIBYTE(v32))
                        goto LABEL_11;
                    if (sub_40C910((float*)&v40, (float*)&v57, (float*)&v51, (float*)&v48, (float*)&v54, a13))
                        break;
                    v23 = v36;
                    v24 = v38;
                    HIBYTE(v32) = 0;
                LABEL_12:
                    v21 = v44;
                    v25 += 6;
                    ++v33;
                    if (HIBYTE(v32))
                        goto LABEL_13;
                }
                v23 = v36;
                v24 = v38;
            LABEL_11:
                HIBYTE(v32) = 1;
                goto LABEL_12;
            }
        }
    LABEL_14:
        v16 = v33 + 1;
        v17 = v43 + 96;
        v28 = ++v33 < *(_DWORD*)(v13 + 20);
        v43 += 96;
        v35 += 172;
    } while (v28);
    v15 = v41;
    if (v41 != -1)
    {
        *a10 = v41;
        *a11 = v45;
        a11[1] = v46;
        a11[2] = v47;
    }
    return v15 != -1;
}
// 407A90: could not find valid save-restore pair for ebx
// 407A90: could not find valid save-restore pair for esi
// 407DFC: conditional instruction was optimized away because %var_E9.1==0
// 520A58: using guessed type int dword_520A58;

//----- (00407F00) --------------------------------------------------------
bool __thiscall sub_407F00(int this, int a2, int* a3, float a4, int* a5, float* a6)
{
    int v7; // ecx
    int v8; // esi
    int v9; // ebx
    int v10; // edi
    float v11; // edx
    float v12; // eax
    int v13; // eax
    int v14; // eax
    unsigned __int16 v15; // dx
    int v16; // ecx
    int v17; // edx
    int v18; // ecx
    int v19; // ecx
    char v21; // [esp+31h] [ebp-99h]
    int v22; // [esp+32h] [ebp-98h] BYREF
    float v23; // [esp+36h] [ebp-94h]
    float v24; // [esp+3Ah] [ebp-90h]
    int v25; // [esp+3Eh] [ebp-8Ch] BYREF
    int v26; // [esp+42h] [ebp-88h]
    int v27; // [esp+46h] [ebp-84h]
    int v28; // [esp+4Ah] [ebp-80h] BYREF
    int* v29; // [esp+4Eh] [ebp-7Ch]
    int v30; // [esp+52h] [ebp-78h] BYREF
    int v31; // [esp+56h] [ebp-74h]
    int v32; // [esp+5Ah] [ebp-70h]
    int v33; // [esp+5Eh] [ebp-6Ch] BYREF
    int v34; // [esp+62h] [ebp-68h]
    int v35; // [esp+66h] [ebp-64h]
    int v36; // [esp+6Ah] [ebp-60h] BYREF
    int v37; // [esp+6Eh] [ebp-5Ch]
    int v38; // [esp+72h] [ebp-58h]
    int v39; // [esp+76h] [ebp-54h] BYREF
    int v40; // [esp+7Ah] [ebp-50h]
    int v41; // [esp+7Eh] [ebp-4Ch]
    int v42; // [esp+82h] [ebp-48h] BYREF
    int v43; // [esp+86h] [ebp-44h]
    float v44[16]; // [esp+8Ah] [ebp-40h] BYREF

    sub_406F00((float*)this, a2);
    v7 = *(_DWORD*)(*(_DWORD*)(this + 28) + 4);
    v8 = *(_DWORD*)(this + 24) + 96 * a2;
    v22 = *(int*)v8;
    v23 = *(float*)(v8 + 4);
    v9 = v7 + 172 * a2;
    v24 = *(float*)(v8 + 8);
    v43 = v9;
    if (!sub_40CC80())
        return 0;
    qmemcpy(v44, (const void*)(v8 + 16), sizeof(v44));
    v10 = 0;
    sub_46B9FD(v44, 0, v44);
    v11 = *((float*)a3 + 1);
    v12 = *((float*)a3 + 2);
    v22 = *a3;
    v23 = v11;
    v24 = v12;
    sub_46C5C5((float*)&v22, (float*)&v22, v44);
    v21 = 0;
    (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD, int*, _DWORD))(**(_DWORD**)(v9 + 44) + 44))(
        *(_DWORD*)(v9 + 44),
        0,
        0,
        &v42,
        0);
    v27 = v9 + 84;
    v13 = *(_DWORD*)(v9 + 36);
    v29 = 0;
    (*(void(__stdcall**)(int, _DWORD, _DWORD, int*, _DWORD))(*(_DWORD*)v13 + 44))(v13, 0, 0, &v28, 0);
    v30 = 0;
    v31 = 0;
    v32 = 0;
    *a6 = -1.0;
    v14 = *(_DWORD*)(v9 + 48);
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v39 = 0;
    v40 = 0;
    v41 = 0;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    v26 = 0;
    if (v14 > 0)
    {
        do
        {
            v15 = *(_WORD*)(v10 + v42 + 4);
            v16 = *(unsigned __int16*)(v10 + v42 + 2);
            v29 = (int*)(v28 + *(_DWORD*)(v27 + 84) * *(unsigned __int16*)(v10 + v42));
            v30 = *v29;
            v31 = v29[1];
            v32 = v29[2];
            v29 = (int*)(v28 + *(_DWORD*)(v27 + 84) * v16);
            v33 = *v29;
            v34 = v29[1];
            v35 = v29[2];
            v29 = (int*)(v28 + *(_DWORD*)(v27 + 84) * v15);
            v39 = *v29;
            v40 = v29[1];
            v41 = v29[2];
            if (sub_40CCD0((float*)&v22, a4, (float*)&v30, (float*)&v33, (float*)&v39, (float*)&v36, (float*)&v25))
            {
                if (*(float*)&v25 > (double)*a6)
                {
                    *a6 = *(float*)&v25;
                    v17 = v37;
                    *a5 = v36;
                    v18 = v38;
                    v21 = 1;
                    a5[1] = v17;
                    a5[2] = v18;
                }
            }
            v9 = v43;
            v10 += 6;
            v19 = *(_DWORD*)(v43 + 48);
            ++v26;
        } while (v26 < v19);
    }
    *(float*)dword_520A58 = (double)*(int*)(v9 + 48) + *(float*)dword_520A58;
    (*(void(__stdcall**)(_DWORD))(**(_DWORD**)(v9 + 44) + 48))(*(_DWORD*)(v9 + 44));
    (*(void(__stdcall**)(_DWORD))(**(_DWORD**)(v9 + 36) + 48))(*(_DWORD*)(v9 + 36));
    return v21 != 0;
}
// 520A58: using guessed type int dword_520A58;

//----- (004081A0) --------------------------------------------------------
double __thiscall sub_4081A0(int this, int a2, float a3, float a4)
{
    int v4; // esi
    int v5; // ebp
    char v6; // dl
    int v7; // ebx
    float* v8; // esi
    double v10; // st7
    double v11; // st6
    float v12; // ecx
    bool v13; // al
    double v14; // st7
    int v15; // eax
    int v16; // eax
    _DWORD* v17; // esi
    unsigned __int16 v18; // dx
    int v19; // ecx
    int v20; // [esp+18h] [ebp-114h]
    float v21; // [esp+2Ch] [ebp-100h]
    int v22; // [esp+2Ch] [ebp-100h]
    float v23; // [esp+30h] [ebp-FCh]
    float v24; // [esp+30h] [ebp-FCh]
    int v25; // [esp+34h] [ebp-F8h]
    _DWORD* v26; // [esp+38h] [ebp-F4h] BYREF
    int* v27; // [esp+3Ch] [ebp-F0h]
    int v28; // [esp+40h] [ebp-ECh] BYREF
    float v29; // [esp+44h] [ebp-E8h]
    float v30; // [esp+48h] [ebp-E4h]
    float v31[2]; // [esp+4Ch] [ebp-E0h] BYREF
    float v32; // [esp+54h] [ebp-D8h]
    int v33; // [esp+58h] [ebp-D4h]
    int v34; // [esp+5Ch] [ebp-D0h]
    float v35; // [esp+60h] [ebp-CCh]
    int v36; // [esp+64h] [ebp-C8h] BYREF
    int v37; // [esp+68h] [ebp-C4h]
    int v38; // [esp+6Ch] [ebp-C0h]
    int v39; // [esp+70h] [ebp-BCh] BYREF
    int v40; // [esp+74h] [ebp-B8h]
    int v41; // [esp+78h] [ebp-B4h]
    float v42; // [esp+7Ch] [ebp-B0h]
    float v43; // [esp+80h] [ebp-ACh]
    float v44; // [esp+84h] [ebp-A8h]
    int v45; // [esp+88h] [ebp-A4h] BYREF
    int v46; // [esp+8Ch] [ebp-A0h]
    int v47; // [esp+90h] [ebp-9Ch]
    int v48; // [esp+94h] [ebp-98h]
    int v49; // [esp+98h] [ebp-94h] BYREF
    const void* v50; // [esp+9Ch] [ebp-90h]
    float v51[3]; // [esp+A0h] [ebp-8Ch] BYREF
    float v52[16]; // [esp+ACh] [ebp-80h] BYREF
    float v53[16]; // [esp+ECh] [ebp-40h] BYREF

    v33 = LODWORD(a3);
    v42 = a3;
    *(float*)&v34 = a4;
    v43 = a4;
    v4 = *(_DWORD*)(this + 28);
    v31[0] = 0.0;
    v31[1] = 0.0;
    v32 = 0.0;
    v39 = 0;
    v40 = 0;
    v41 = 0;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    v45 = 0;
    v46 = 0;
    v47 = 0;
    v5 = *(_DWORD*)(v4 + 4) + 172 * a2;
    v6 = *(_BYTE*)(v5 + 80);
    v7 = 0;
    v8 = (float*)(*(_DWORD*)(this + 24) + 96 * a2);
    v35 = 0.0;
    v44 = 0.0;
    v48 = v5;
    if (!v6)
        return -3.4028235e38;
    sub_406F00((float*)this, a2);
    v10 = v8[2];
    v11 = *v8 - a3;
    v12 = v8[2];
    v29 = v8[1];
    v30 = v12;
    v23 = v11;
    v21 = v29 - a4;
    v13 = v8[3] * v8[3] >= (v12 - v10) * (v12 - v10) + v23 * v23 + v21 * v21;
    v14 = v8[3] * 1.1;
    v24 = -3.4028235e38;
    v35 = v14 + v8[2];
    v44 = v8[2] - v14;
    if (v13)
    {
        v50 = v8 + 4;
        qmemcpy(v52, v8 + 4, sizeof(v52));
        sub_46B9FD(v52, 0, v52);
        v28 = v33;
        v29 = *(float*)&v34;
        v30 = v35;
        v51[0] = v42;
        v51[1] = v43;
        v51[2] = v44;
        sub_46C5C5((float*)&v28, (float*)&v28, v52);
        sub_46C5C5(v51, v51, v52);
        (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD, int*, _DWORD))(**(_DWORD**)(v5 + 44) + 44))(
            *(_DWORD*)(v5 + 44),
            0,
            0,
            &v49,
            0);
        v25 = v5 + 84;
        v15 = *(_DWORD*)(v5 + 36);
        v27 = 0;
        (*(void(__stdcall**)(int, _DWORD, _DWORD, _DWORD**, _DWORD))(*(_DWORD*)v15 + 44))(v15, 0, 0, &v26, 0);
        v16 = *(_DWORD*)(v5 + 48);
        v17 = v26;
        v27 = v26;
        v22 = 0;
        if (v16 > 0)
        {
            while (1)
            {
                v18 = *(_WORD*)(v7 + v49 + 4);
                v19 = *(unsigned __int16*)(v7 + v49 + 2);
                v27 = (_DWORD*)((char*)v17 + *(_DWORD*)(v25 + 84) * *(unsigned __int16*)(v7 + v49));
                v39 = *v27;
                v40 = v27[1];
                v41 = v27[2];
                v27 = (_DWORD*)((char*)v17 + *(_DWORD*)(v25 + 84) * v19);
                v36 = *v27;
                v37 = v27[1];
                v38 = v27[2];
                v27 = (_DWORD*)((char*)v17 + *(_DWORD*)(v25 + 84) * v18);
                v45 = *v27;
                v46 = v27[1];
                v47 = v27[2];
                if (sub_40C910((float*)&v28, v51, (float*)&v39, (float*)&v36, (float*)&v45, v31))
                {
                    qmemcpy(v53, v50, sizeof(v53));
                    sub_46C5C5(v31, v31, v53);
                    if (v24 <= (double)v32)
                        v24 = v32;
                }
                v5 = v48;
                v7 += 6;
                if (++v22 >= *(_DWORD*)(v48 + 48))
                    break;
                v17 = v26;
            }
        }
        *(float*)dword_520A58 = (double)v22 + *(float*)dword_520A58;
        (*(void(__stdcall**)(_DWORD))(**(_DWORD**)(v5 + 44) + 48))(*(_DWORD*)(v5 + 44));
        (*(void(__stdcall**)(int))(**(_DWORD**)(v5 + 36) + 48))(v20);
    }
    return v24;
}
// 408525: variable 'v20' is possibly undefined
// 520A58: using guessed type int dword_520A58;

//----- (00408540) --------------------------------------------------------
int __thiscall sub_408540(_DWORD* this, int a2)
{
    int result; // eax
    int v3; // esi
    int v4; // edx
    int v5; // eax

    result = this[5];
    v3 = 0;
    if (result > 0)
    {
        v4 = 0;
        do
        {
            v5 = v4 + *(_DWORD*)(this[7] + 4);
            if (*(_BYTE*)(v5 + 81))
                *(_DWORD*)(v5 + 76) = a2;
            result = this[5];
            ++v3;
            v4 += 172;
        } while (v3 < result);
    }
    return result;
}

//----- (00408580) --------------------------------------------------------
int __thiscall sub_408580(_DWORD* this, int a2, int a3)
{
    int result; // eax

    result = *(_DWORD*)(this[7] + 4) + 172 * a2;
    if (*(_BYTE*)(result + 81))
        *(_DWORD*)(result + 76) = a3;
    return result;
}

//----- (004085B0) --------------------------------------------------------
float* __thiscall sub_4085B0(int this, int a2, int a3)
{
    int v4; // eax

    sub_406F00((float*)this, a2);
    v4 = *(_DWORD*)(this + 24) + 96 * a2;
    *(_DWORD*)(a3 + 8) = 0;
    *(_DWORD*)(a3 + 4) = 0;
    *(_DWORD*)a3 = 0;
    return sub_46C5C5((float*)a3, (float*)a3, (float*)(v4 + 16));
}

//----- (004085F0) --------------------------------------------------------
_DWORD* __thiscall sub_4085F0(int this, int a2, _DWORD* a3, _DWORD* a4)
{
    _DWORD* result; // eax
    _DWORD* v6; // eax

    sub_406F00((float*)this, a2);
    result = a3;
    if (a3)
        *a3 = *(_DWORD*)(96 * a2 + *(_DWORD*)(this + 24) + 12);
    if (a4)
    {
        v6 = (_DWORD*)(*(_DWORD*)(this + 24) + 96 * a2);
        *a4 = *v6;
        a4[1] = v6[1];
        result = (_DWORD*)v6[2];
        a4[2] = result;
    }
    return result;
}

//----- (00408640) --------------------------------------------------------
int __thiscall sub_408640(_DWORD* this, int a2, char a3)
{
    int result; // eax

    result = 96 * a2;
    *(_BYTE*)(96 * a2 + this[6] + 84) = a3 == 0;
    return result;
}

//----- (00408660) --------------------------------------------------------
bool __thiscall sub_408660(_DWORD* this, int a2)
{
    return *(_BYTE*)(96 * a2 + this[6] + 84) == 0;
}

//----- (00408680) --------------------------------------------------------
char __thiscall sub_408680(int this, int a2, float* a3, float* a4, float* a5, float* a6, float* a7, float* a8)
{
    int v9; // edi
    int v10; // esi
    float* v12; // eax
    int v13; // edx
    int v14; // esi
    double v15; // st7
    double v16; // st7
    double v17; // st7
    double v18; // st7
    double v19; // st7
    double v20; // st7
    int v21; // ecx
    float* v22; // eax
    float v23; // [esp+14h] [ebp-18h] BYREF
    float v24; // [esp+18h] [ebp-14h]
    float v25; // [esp+1Ch] [ebp-10h]
    int v26; // [esp+20h] [ebp-Ch]
    float* v27; // [esp+24h] [ebp-8h] BYREF
    float* v28; // [esp+28h] [ebp-4h]
    float* v29; // [esp+34h] [ebp+8h]

    *a3 = 3.4028235e38;
    *a4 = -3.4028235e38;
    *a5 = 3.4028235e38;
    *a6 = -3.4028235e38;
    *a7 = 3.4028235e38;
    *a8 = -3.4028235e38;
    v9 = *(_DWORD*)(*(_DWORD*)(this + 28) + 4) + 172 * a2;
    v10 = *(_DWORD*)(this + 24) + 96 * a2;
    if (*(int*)(v9 + 40) <= 0)
        return 0;
    sub_406F00((float*)this, a2);
    v28 = 0;
    v26 = v9 + 84;
    (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD, float**, _DWORD))(**(_DWORD**)(v9 + 36) + 44))(
        *(_DWORD*)(v9 + 36),
        0,
        0,
        &v27,
        0);
    v12 = v27;
    v28 = v27;
    v13 = *(_DWORD*)(v9 + 40);
    v23 = 0.0;
    v24 = 0.0;
    v25 = 0.0;
    if (v13)
    {
        v29 = (float*)(v10 + 16);
        v14 = v13;
        do
        {
            v23 = *v12;
            v24 = v12[1];
            v25 = v12[2];
            sub_46C5C5(&v23, &v23, v29);
            if (*a3 >= (double)v23)
                v15 = v23;
            else
                v15 = *a3;
            *a3 = v15;
            if (*a4 <= (double)v23)
                v16 = v23;
            else
                v16 = *a4;
            *a4 = v16;
            if (*a5 >= (double)v24)
                v17 = v24;
            else
                v17 = *a5;
            *a5 = v17;
            if (*a6 <= (double)v24)
                v18 = v24;
            else
                v18 = *a6;
            *a6 = v18;
            if (*a7 >= (double)v25)
                v19 = v25;
            else
                v19 = *a7;
            *a7 = v19;
            if (*a8 <= (double)v25)
                v20 = v25;
            else
                v20 = *a8;
            v21 = v26;
            v22 = v28;
            *a8 = v20;
            v12 = (float*)((char*)v22 + *(_DWORD*)(v21 + 84));
            --v14;
            v28 = v12;
        } while (v14);
    }
    (*(void(__stdcall**)(_DWORD))(**(_DWORD**)(v9 + 36) + 48))(*(_DWORD*)(v9 + 36));
    return 1;
}

//----- (00408860) --------------------------------------------------------
int __thiscall sub_408860(_DWORD* this, int a2)
{
    int v2; // edx
    int result; // eax

    v2 = this[7];
    this[11] = a2;
    result = *(_DWORD*)(*(_DWORD*)(v2 + 44) + 4 * a2);
    this[8] = result;
    return result;
}

//----- (00408880) --------------------------------------------------------
int __thiscall sub_408880(_DWORD* this)
{
    return this[11];
}

//----- (00408890) --------------------------------------------------------
int __thiscall sub_408890(_DWORD** this)
{
    return sub_403F40(this[7]);
}

//----- (004088A0) --------------------------------------------------------
BOOL __thiscall sub_4088A0(int this)
{
    double v1; // st7

    v1 = *(float*)(this + 32) - *(float*)(*(_DWORD*)(*(_DWORD*)(this + 28) + 44) + 4 * *(_DWORD*)(this + 44));
    return v1 < 0.001 && v1 > -0.001;
}

//----- (004088E0) --------------------------------------------------------
BOOL __thiscall sub_4088E0(int this)
{
    double v1; // st7

    v1 = *(float*)(this + 32) - *(float*)(*(_DWORD*)(*(_DWORD*)(this + 28) + 48) + 4 * *(_DWORD*)(this + 44));
    return v1 < 0.001 && v1 > -0.001;
}

//----- (00408920) --------------------------------------------------------
double __thiscall sub_408920(int this)
{
    double v1; // st7

    v1 = *(float*)(this + 36);
    if (v1 == 0.0)
        return 0.0;
    else
        return (*(float*)(*(_DWORD*)(*(_DWORD*)(this + 28) + 48) + 4 * *(_DWORD*)(this + 44))
            - *(float*)(*(_DWORD*)(*(_DWORD*)(this + 28) + 44) + 4 * *(_DWORD*)(this + 44)))
        / v1;
}

//----- (00408960) --------------------------------------------------------
int __thiscall sub_408960(_DWORD* this, float a2)
{
    int v3; // edi
    int result; // eax
    int v5; // ebp
    float* v6; // eax
    int v7; // ecx

    v3 = 0;
    result = this[5];
    if (result > 0)
    {
        v5 = 0;
        do
        {
            v6 = (float*)sub_407190(this, v3, 1);
            *((_BYTE*)v6 + 78) = 1;
            v6[20] = a2;
            v7 = *(_DWORD*)(this[6] + v5 + 88);
            if (v7)
            {
                if (a2 == 1.0)
                    *(_DWORD*)(v7 + 12) = 2;
                else
                    *(_DWORD*)(v7 + 12) = 4;
            }
            result = this[5];
            ++v3;
            v5 += 96;
        } while (v3 < result);
    }
    return result;
}

//----- (004089D0) --------------------------------------------------------
int __thiscall sub_4089D0(_DWORD* this, int a2, int a3)
{
    int v4; // edi
    int result; // eax
    int v6; // ebp
    int v7; // eax
    _BYTE* v8; // eax

    v4 = 0;
    result = this[5];
    if (result > 0)
    {
        v6 = 0;
        do
        {
            v7 = *(_DWORD*)(*(_DWORD*)(this[7] + 4) + v6 + 52);
            if (v7)
            {
                if (*(_DWORD*)(v7 + 84) == a2)
                {
                    v8 = sub_407190(this, v4, 1);
                    v8[84] = 1;
                    *((_DWORD*)v8 + 22) = a3;
                }
            }
            result = this[5];
            ++v4;
            v6 += 172;
        } while (v4 < result);
    }
    return result;
}

//----- (00408A30) --------------------------------------------------------
int __thiscall sub_408A30(_DWORD* this, _DWORD* a2)
{
    int result; // eax

    *this = *a2;
    this[1] = a2[1];
    result = a2[2];
    this[2] = result;
    return result;
}

//----- (00408A50) --------------------------------------------------------
_DWORD* __thiscall sub_408A50(_DWORD* this)
{
    INT v2; // eax
    _DWORD* result; // eax

    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
    *((_BYTE*)this + 16) = 1;
    this[7] = 0;
    this[8] = 0;
    this[9] = 0;
    *((_BYTE*)this + 40) = 1;
    this[11] = 0;
    this[12] = 0;
    this[13] = 0;
    *((_BYTE*)this + 56) = 1;
    this[22] = 0;
    this[23] = 0;
    this[24] = 0;
    this[26] = 0;
    this[27] = 0;
    this[28] = 0;
    this[34] = 0;
    this[35] = 0;
    this[36] = 0;
    *((_BYTE*)this + 148) = 1;
    this[38] = 0;
    this[39] = 0;
    this[40] = 0;
    *((_BYTE*)this + 164) = 1;
    *this = &off_499114;
    v2 = sub_422BA0(AppName, aMousespeed, 100);
    *(_DWORD*)&dword_4A1EC4 = v2;
    if (v2 < 100)
    {
        if (v2 <= 10)
            *(_DWORD*)&dword_4A1EC4 = 10;
        return this;
    }
    else
    {
        result = this;
        *(_DWORD*)&dword_4A1EC4 = 100;
    }
    return result;
}
// 499114: using guessed type _UNKNOWN *off_499114;

//----- (00408B70) --------------------------------------------------------
void __thiscall sub_408B70(void* this)
{
    int i; // edi
    void* v3; // eax
    int j; // edi
    void* v5; // eax
    int k; // edi
    void* v7; // eax
    int m; // edi
    void* v9; // eax

    *(_DWORD*)this = &off_499114;
    if (*((_BYTE*)this + 164))
    {
        for (i = 0; i < *((_DWORD*)this + 39); ++i)
            sub_4885A6(*(LPVOID*)(*((_DWORD*)this + 38) + 4 * i));
    }
    memset(*((void**)this + 38), 0, 4 * *((_DWORD*)this + 39));
    v3 = (void*)*((_DWORD*)this + 38);
    *((_DWORD*)this + 39) = 0;
    sub_488CEE(v3);
    *((_DWORD*)this + 40) = 0;
    *((_DWORD*)this + 38) = 0;
    if (*((_BYTE*)this + 148))
    {
        for (j = 0; j < *((_DWORD*)this + 35); ++j)
            sub_4885A6(*(LPVOID*)(*((_DWORD*)this + 34) + 4 * j));
    }
    memset(*((void**)this + 34), 0, 4 * *((_DWORD*)this + 35));
    v5 = (void*)*((_DWORD*)this + 34);
    *((_DWORD*)this + 35) = 0;
    sub_488CEE(v5);
    *((_DWORD*)this + 36) = 0;
    *((_DWORD*)this + 34) = 0;
    if (*((_BYTE*)this + 56))
    {
        for (k = 0; k < *((_DWORD*)this + 12); ++k)
            sub_4885A6(*(LPVOID*)(*((_DWORD*)this + 11) + 4 * k));
    }
    memset(*((void**)this + 11), 0, 4 * *((_DWORD*)this + 12));
    v7 = (void*)*((_DWORD*)this + 11);
    *((_DWORD*)this + 12) = 0;
    sub_488CEE(v7);
    *((_DWORD*)this + 13) = 0;
    *((_DWORD*)this + 11) = 0;
    if (*((_BYTE*)this + 40))
    {
        for (m = 0; m < *((_DWORD*)this + 8); ++m)
            sub_4885A6(*(LPVOID*)(*((_DWORD*)this + 7) + 4 * m));
    }
    memset(*((void**)this + 7), 0, 4 * *((_DWORD*)this + 8));
    v9 = (void*)*((_DWORD*)this + 7);
    *((_DWORD*)this + 8) = 0;
    sub_488CEE(v9);
    *((_DWORD*)this + 9) = 0;
    *((_DWORD*)this + 7) = 0;
    *(_DWORD*)this = &off_499040;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 499114: using guessed type _UNKNOWN *off_499114;

//----- (00408D20) --------------------------------------------------------
char __thiscall sub_408D20(int this)
{
    void* v2; // eax
    int v3; // eax
    _DWORD* v4; // eax
    _DWORD* v5; // eax
    _DWORD* v6; // eax
    _DWORD* v7; // eax
    _DWORD* v8; // eax
    _DWORD* v9; // eax
    _DWORD* v10; // eax
    _DWORD* v11; // eax

    *(_DWORD*)(this + 84) = 0;
    *(_DWORD*)(this + 120) = 0;
    *(_DWORD*)(this + 124) = 0;
    *(_DWORD*)(this + 128) = 0;
    *(_DWORD*)(this + 132) = 0;
    *(_BYTE*)(this + 20) = 0;
    *(_DWORD*)(this + 24) = 1065353216;
    *(_DWORD*)(this + 60) = timeGetTime();
    *(_DWORD*)(this + 72) = 0;
    *(_DWORD*)(this + 76) = 0;
    *(_BYTE*)(this + 80) = 0;
    *(_BYTE*)(this + 81) = 0;
    *(_BYTE*)(this + 82) = 0;
    *(_DWORD*)(this + 84) = 0;
    *(_BYTE*)(this + 100) = 0;
    v2 = operator new(0x24u);
    if (v2)
        v3 = sub_422290((int)v2);
    else
        v3 = 0;
    *(_DWORD*)(this + 124) = v3;
    sub_428680((_DWORD*)this, v3);
    v4 = operator new(0x3Cu);
    if (v4)
        v5 = sub_4215C0(v4);
    else
        v5 = 0;
    *(_DWORD*)(this + 132) = v5;
    sub_428680((_DWORD*)this, (int)v5);
    sub_421810(*(_DWORD*)(this + 132), off_4A03E0[0], (int)&off_4A03E4[1], 0);
    sub_421810(*(_DWORD*)(this + 132), off_4A03E4[0], (int)&unk_4A0E68, (int)&unk_4A18E8);
    v6 = operator new(0x18u);
    if (v6)
        v7 = sub_4068D0(v6);
    else
        v7 = 0;
    *(_DWORD*)(this + 128) = v7;
    sub_428680((_DWORD*)this, (int)v7);
    v8 = operator new(0x30u);
    if (v8)
        v9 = sub_4132B0(v8);
    else
        v9 = 0;
    *(_DWORD*)(this + 116) = v9;
    sub_4133C0(v9);
    sub_413550(*(_DWORD*)(this + 116));
    sub_428680((_DWORD*)this, *(_DWORD*)(this + 116));
    v10 = operator new(0x6Cu);
    if (v10)
        v11 = sub_41D9C0(v10);
    else
        v11 = 0;
    *(_DWORD*)(this + 120) = v11;
    sub_428680((_DWORD*)this, (int)v11);
    return 1;
}
// 4A03E0: using guessed type char *off_4A03E0[2];
// 4A03E4: using guessed type char *off_4A03E4[128];

//----- (00408EF0) --------------------------------------------------------
int __thiscall sub_408EF0(int this, int a2)
{
    int v3; // ecx
    int result; // eax

    v3 = *(_DWORD*)(this + 84);
    if (v3)
        result = (*(int(__thiscall**)(int, _DWORD))(*(_DWORD*)v3 + 32))(v3, 0);
    *(_DWORD*)(this + 84) = a2;
    if (a2)
        result = (*(int(__thiscall**)(int, int))(*(_DWORD*)a2 + 32))(a2, 1);
    *(_BYTE*)(this + 100) = 0;
    *(_DWORD*)(this + 104) = 0;
    *(_DWORD*)(this + 108) = 0;
    *(_DWORD*)(this + 112) = 0;
    return result;
}

//----- (00408F30) --------------------------------------------------------
int __thiscall sub_408F30(_DWORD* this)
{
    return this[21];
}

//----- (00408F40) --------------------------------------------------------
int __stdcall sub_408F40(int a1)
{
    return *(char*)(dword_520A00 + a1 + 20);
}
// 520A00: using guessed type int dword_520A00;

//----- (00408F60) --------------------------------------------------------
char __stdcall sub_408F60(int a1)
{
    return *(_BYTE*)(dword_520A00 + a1 + 288);
}
// 520A00: using guessed type int dword_520A00;

//----- (00408F80) --------------------------------------------------------
double __thiscall sub_408F80(float* this, int a2)
{
    return (double)*(int*)(dword_520A00 + 4 * a2 + 276) * this[6] * (double)*(int*)&dword_4A1EC4 * 0.02;
}
// 520A00: using guessed type int dword_520A00;

//----- (00408FB0) --------------------------------------------------------
float* __thiscall sub_408FB0(float* this)
{
    DWORD Time; // eax
    int v3; // ecx
    double v4; // st7
    char v6; // c0
    char v7; // al
    float v8; // eax
    float* result; // eax
    double v10; // st7
    double v11; // st7
    int* v12; // eax
    float v13; // [esp-4h] [ebp-10h]

    Time = timeGetTime();
    v3 = Time - *((_DWORD*)this + 15);
    *((_DWORD*)this + 15) = Time;
    v4 = (double)v3 * 0.001;
    this[17] = v4;
    if (!v6)
        v4 = 0.2;
    this[17] = v4;
    v7 = *((_BYTE*)this + 20);
    this[19] = v4 + this[19];
    if (v7)
        this[16] = 0.0;
    else
        this[16] = v4 * this[6];
    v8 = *this;
    v13 = this[16];
    this[18] = v13 + this[18];
    (*(void(__thiscall**)(float*, float))(LODWORD(v8) + 16))(this, COERCE_FLOAT(LODWORD(v13)));
    result = (float*)*((_DWORD*)this + 21);
    if (result)
    {
        if (*((_BYTE*)this + 100))
        {
            this[26] = result[8];
            this[27] = result[9];
            this[28] = result[10];
            this[26] = this[26] - this[22];
            this[27] = this[27] - this[23];
            this[28] = this[28] - this[24];
            if (this[16] > 0.0000099999997)
            {
                if (this[16] == 0.0)
                {
                    this[26] = 0.0;
                    this[27] = 0.0;
                    this[28] = 0.0;
                }
                else
                {
                    v10 = this[16];
                    if (v10 == 0.0)
                        v11 = 0.0;
                    else
                        v11 = 1.0 / v10;
                    this[26] = v11 * this[26];
                    this[27] = v11 * this[27];
                    this[28] = v11 * this[28];
                }
            }
        }
        else
        {
            *((_BYTE*)this + 100) = 1;
        }
        v12 = (int*)(*((_DWORD*)this + 21) + 32);
        *((_DWORD*)this + 22) = *v12;
        *((_DWORD*)this + 23) = v12[1];
        result = (float*)v12[2];
        *((_DWORD*)this + 24) = result;
    }
    return result;
}
// 408FE1: variable 'v6' is possibly undefined

//----- (004090F0) --------------------------------------------------------
int __thiscall sub_4090F0(int this)
{
    int v2; // edi
    float* v3; // ecx
    float* v4; // ecx
    int v5; // ebx
    int v6; // esi
    float* v7; // ecx
    float* v8; // eax
    double v9; // st7
    float* v10; // ecx
    int v11; // kr00_4
    int v12; // edi
    int v13; // esi
    int v14; // edx
    int v15; // eax
    int v16; // ecx
    int v17; // edi
    int v18; // ebx
    int v19; // eax
    int v20; // esi
    int v21; // eax
    int v22; // eax
    int v23; // eax
    int v24; // edx
    int v25; // eax
    float v27; // [esp+1Ch] [ebp-7Ch]
    BOOL v28; // [esp+20h] [ebp-78h]
    char v29; // [esp+33h] [ebp-65h]
    int v30; // [esp+34h] [ebp-64h]
    int v31; // [esp+38h] [ebp-60h]
    int v32; // [esp+3Ch] [ebp-5Ch]
    _DWORD v33[16]; // [esp+58h] [ebp-40h] BYREF

    v2 = 0;
    v3 = *(float**)(this + 84);
    if (v3)
        sub_401550(v3);
    v4 = *(float**)(this + 84);
    v30 = 0;
    if (v4)
    {
        if (*(_BYTE*)(this + 82))
            sub_401EC0(v4);
        else
            sub_401600(v4);
    }
    v5 = *(_DWORD*)(this + 32);
    if (v5 > 0)
    {
        do
        {
            v6 = *(_DWORD*)(*(_DWORD*)(this + 28) + 4 * v2);
            if (*(_DWORD*)v6 && sub_428650(*(_DWORD*)v6))
            {
                if (*(_DWORD*)(v6 + 12) != 5 && (v7 = *(float**)(this + 84)) != 0 && *(_DWORD*)(v6 + 28) == 1)
                {
                    v27 = *(float*)(v6 + 32) * *(float*)(v6 + 32);
                    *(_BYTE*)(v6 + 8) = sub_402110(v7, (float*)(v6 + 16), v27);
                }
                else
                {
                    *(_BYTE*)(v6 + 8) = 1;
                }
            }
            else
            {
                *(_BYTE*)(v6 + 8) = 0;
            }
            if (!*(_BYTE*)(v6 + 8))
                goto LABEL_23;
            if (*(_DWORD*)(v6 + 12) == 1)
            {
                v8 = *(float**)(this + 84);
                if (!v8)
                    goto LABEL_22;
                v9 = *(float*)(v6 + 16) - v8[8];
                *(float*)(v6 + 4) = (*(float*)(v6 + 24) - v8[10]) * (*(float*)(v6 + 24) - v8[10])
                    + (*(float*)(v6 + 20) - v8[9]) * (*(float*)(v6 + 20) - v8[9])
                    + v9 * v9;
            }
            else
            {
                v10 = *(float**)(this + 84);
                if (!v10)
                {
                LABEL_22:
                    *(_DWORD*)(v6 + 4) = 0;
                    goto LABEL_23;
                }
                *(float*)(v6 + 4) = sub_4022C0(v10, *(float*)(v6 + 16), *(float*)(v6 + 20), *(float*)(v6 + 24));
            }
        LABEL_23:
            ++v2;
        } while (v2 < v5);
    }
    v11 = *(_DWORD*)(this + 32);
    if (v11 / 2 > 0)
    {
        v12 = v11 / 2;
        do
        {
            v13 = rand() % *(_DWORD*)(this + 32);
            v14 = rand() % *(_DWORD*)(this + 32);
            v15 = *(_DWORD*)(this + 28);
            --v12;
            v16 = *(_DWORD*)(v15 + 4 * v13);
            *(_DWORD*)(v15 + 4 * v13) = *(_DWORD*)(v15 + 4 * v14);
            *(_DWORD*)(*(_DWORD*)(this + 28) + 4 * v14) = v16;
        } while (v12);
    }
    qsort(*(void**)(this + 28), *(_DWORD*)(this + 32), 4u, (_CoreCrtNonSecureSearchSortCompareFunction)sub_4096B0);
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v29 = 0;
    v32 = *(_DWORD*)(this + 32);
    v31 = 0;
    if (v32 <= 0)
        return v30;
    do
    {
        v20 = *(_DWORD*)(*(_DWORD*)(this + 28) + 4 * v19);
        if (!*(_BYTE*)(v20 + 8))
            goto LABEL_63;
        sub_41BC00((_DWORD*)dword_520A50, -1, -1, -1, -1, -1, *(_BYTE*)(this + 80) != 0, -1);
        if (v18)
        {
            if (*(_DWORD*)(v20 + 12) == 5 && *(_DWORD*)(v20 + 36) == v18 && *(_BYTE*)(v20 + 44) == v29)
                goto LABEL_37;
            v18 = 0;
            v30 += sub_4204A0();
        }
        if (*(_DWORD*)(v20 + 12) == 5)
        {
            v21 = *(_DWORD*)(v20 + 36);
            if (v21)
            {
                sub_41FA20(v21, *(_BYTE*)(v20 + 44));
                v18 = *(_DWORD*)(v20 + 36);
                v29 = *(_BYTE*)(v20 + 44);
            }
        }
    LABEL_37:
        v22 = *(_DWORD*)(v20 + 12);
        if (v17 == v22)
            goto LABEL_51;
        if (v22 != 1)
        {
            switch (v22)
            {
            case 2:
                (*(void(__stdcall**)(_DWORD, int, bool, BOOL))(**(_DWORD**)ArgList + 200))(
                    *(_DWORD*)ArgList,
                    28,
                    byte_4A4DE0 != 0,
                    v28);
                (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 7, 1);
                v23 = *(_DWORD*)ArgList;
                v24 = **(_DWORD**)ArgList;
                v28 = byte_4A4DB1 != 0;
                break;
            case 3:
            case 4:
            case 5:
                (*(void(__stdcall**)(_DWORD, int, bool))(**(_DWORD**)ArgList + 200))(
                    *(_DWORD*)ArgList,
                    28,
                    byte_4A4DE0 != 0);
                (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 7, 1);
                (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 26, 0);
                goto LABEL_50;
            case 6:
                (*(void(__stdcall**)(_DWORD, int, _DWORD, BOOL))(**(_DWORD**)ArgList + 200))(
                    *(_DWORD*)ArgList,
                    28,
                    0,
                    v28);
                (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 7, 0);
                v23 = *(_DWORD*)ArgList;
                v28 = 0;
                v24 = **(_DWORD**)ArgList;
                break;
            default:
                goto LABEL_50;
            }
            (*(void(__stdcall**)(int, int))(v24 + 200))(v23, 26);
            goto LABEL_50;
        }
        (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 28, 0);
        (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 7, 0);
        (*(void(__stdcall**)(_DWORD, int, bool))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 26, byte_4A4DB1 != 0);
    LABEL_50:
        v22 = *(_DWORD*)(v20 + 12);
        v17 = v22;
    LABEL_51:
        if (v22 == 5)
        {
            if (!*(_DWORD*)(v20 + 36))
                goto LABEL_63;
            if (*(_BYTE*)(v20 + 60))
            {
                v25 = sub_41FBB0(
                    *(_DWORD*)(v20 + 16),
                    *(_DWORD*)(v20 + 20),
                    *(_DWORD*)(v20 + 24),
                    *(float*)(v20 + 48),
                    *(float*)(v20 + 52),
                    *(_DWORD*)(v20 + 56),
                    *(float*)(v20 + 80),
                    *(float*)(v20 + 84),
                    *(float*)(v20 + 88),
                    *(float*)(v20 + 92),
                    *(float*)(v20 + 64),
                    *(float*)(v20 + 68),
                    *(float*)(v20 + 72),
                    *(float*)(v20 + 76));
            }
            else if (*(_BYTE*)(v20 + 96))
            {
                v25 = sub_420350(
                    (_DWORD*)(v20 + 100),
                    (_DWORD*)(v20 + 124),
                    (_DWORD*)(v20 + 136),
                    (_DWORD*)(v20 + 112),
                    *(_DWORD*)(v20 + 56));
            }
            else
            {
                v25 = sub_41FBB0(
                    *(_DWORD*)(v20 + 16),
                    *(_DWORD*)(v20 + 20),
                    *(_DWORD*)(v20 + 24),
                    *(float*)(v20 + 48),
                    *(float*)(v20 + 52),
                    *(_DWORD*)(v20 + 56),
                    *(float*)(v20 + 80),
                    *(float*)(v20 + 84),
                    *(float*)(v20 + 88),
                    *(float*)(v20 + 92),
                    1.0,
                    1.0,
                    0.0,
                    0.0);
            }
        }
        else
        {
            if (*(_BYTE*)(this + 81) && *(_DWORD*)(v20 + 28) == 1)
            {
                memset(&v33[11], 0, 16);
                memset(&v33[6], 0, 16);
                memset(&v33[1], 0, 16);
                v33[15] = 1065353216;
                v33[10] = 1065353216;
                v33[5] = 1065353216;
                v33[0] = 1065353216;
                (*(void(__stdcall**)(_DWORD, int, _DWORD*))(**(_DWORD**)ArgList + 148))(*(_DWORD*)ArgList, 256, v33);
                v30 += sub_41F3D0(
                    *(float*)(v20 + 16),
                    *(float*)(v20 + 20),
                    *(float*)(v20 + 24),
                    *(float*)(v20 + 32),
                    COERCE_FLOAT(200),
                    COERCE_FLOAT(200),
                    COERCE_FLOAT(200),
                    255);
            }
            v25 = (*(int(__stdcall**)(int))(**(_DWORD**)v20 + 20))(v20);
        }
        v30 += v25;
    LABEL_63:
        v19 = ++v31;
    } while (v31 < v32);
    if (v18)
        return sub_4204A0() + v30;
    return v30;
}
// 40936A: variable 'v28' is possibly undefined
// 4A4DB1: using guessed type char byte_4A4DB1;
// 4A4DE0: using guessed type char byte_4A4DE0;
// 520A50: using guessed type int dword_520A50;

//----- (004096B0) --------------------------------------------------------
int __cdecl sub_4096B0(int* a1, int* a2)
{
    int v2; // ecx
    int v3; // edx
    int v4; // eax
    int v5; // esi
    int v6; // esi
    unsigned int v8; // eax
    unsigned int v9; // esi
    unsigned int v10; // eax
    unsigned int v11; // esi
    unsigned int v12; // eax
    unsigned int v13; // esi

    v2 = *a1;
    v3 = *a2;
    v4 = *(_DWORD*)(*a1 + 12);
    if (v4 != 4 && v4 != 5 || (v5 = *(_DWORD*)(v3 + 12), v5 != 4) && v5 != 5)
    {
        v6 = *(_DWORD*)(v3 + 12);
        if (v4 < v6)
            return -1;
        if (v4 > v6)
            return 1;
    }
    switch (v4)
    {
    case 1:
        if (*(float*)(v2 + 4) < (double)*(float*)(v3 + 4))
            return 1;
        if (*(float*)(v2 + 4) > (double)*(float*)(v3 + 4))
            return -1;
        return (v2 - v3) / 148;
    case 2:
        v8 = *(_DWORD*)(v2 + 36);
        v9 = *(_DWORD*)(v3 + 36);
        if (v8 < v9)
            return 1;
        if (v8 > v9)
            return -1;
        if (*(float*)(v2 + 4) > (double)*(float*)(v3 + 4))
            return 1;
        if (*(float*)(v2 + 4) < (double)*(float*)(v3 + 4))
            return -1;
        break;
    case 3:
        if (*(float*)(v2 + 24) > (double)*(float*)(v3 + 24))
            return 1;
        if (*(float*)(v2 + 24) < (double)*(float*)(v3 + 24))
            return -1;
        return (v2 - v3) / 148;
    case 4:
    case 5:
        if (*(float*)(v2 + 4) < (double)*(float*)(v3 + 4))
            return -1;
        if (*(float*)(v2 + 4) > (double)*(float*)(v3 + 4))
            return 1;
        v12 = *(_DWORD*)(v2 + 36);
        v13 = *(_DWORD*)(v3 + 36);
        if (v12 < v13)
            return 1;
        if (v12 > v13)
            return -1;
        break;
    case 6:
        if (*(float*)(v2 + 24) > (double)*(float*)(v3 + 24))
            return 1;
        if (*(float*)(v2 + 24) < (double)*(float*)(v3 + 24))
            return -1;
        v10 = *(_DWORD*)(v2 + 36);
        v11 = *(_DWORD*)(v3 + 36);
        if (v10 < v11)
            return 1;
        if (v10 > v11)
            return -1;
        break;
    default:
        return (v2 - v3) / 148;
    }
    return (v2 - v3) / 148;
}

//----- (00409850) --------------------------------------------------------
int __thiscall sub_409850(int this, int** a2)
{
    int v3; // eax
    int v4; // ecx
    int*** v5; // edi
    int*** v6; // edx
    int v7; // ecx
    int v8; // eax
    int v9; // ecx
    int v10; // eax
    char* v11; // eax
    int v12; // edi
    int v13; // ecx
    int result; // eax

    if (a2 && *a2)
    {
        sub_422230(*a2);
        *a2 = 0;
    }
    v3 = 0;
    memset(a2, 0, 0x24u);
    v4 = *(_DWORD*)(this + 140);
    if (v4 > 0)
    {
        v5 = *(int****)(this + 136);
        v6 = v5;
        while (*v6 != a2)
        {
            ++v3;
            ++v6;
            if (v3 >= v4)
                goto LABEL_11;
        }
        v7 = v4 - 1;
        *(_DWORD*)(this + 140) = v7;
        if (v3 != v7)
        {
            memcpy(&v5[v3], &v5[v3 + 1], 4 * (v7 + 0x3FFFFFFF * v3));
            *(_DWORD*)(*(_DWORD*)(this + 136) + 4 * *(_DWORD*)(this + 140)) = 0;
        }
    }
LABEL_11:
    v8 = *(_DWORD*)(this + 160);
    v9 = *(_DWORD*)(this + 156) + 1;
    *(_DWORD*)(this + 156) = v9;
    if (v9 > v8)
    {
        v10 = v8 + 8;
        *(_DWORD*)(this + 160) = v10;
        v11 = (char*)sub_488DD7(*(LPVOID*)(this + 152), 4 * v10);
        if (v11)
        {
            v12 = *(_DWORD*)(this + 156);
            v13 = *(_DWORD*)(this + 160) - v12;
            *(_DWORD*)(this + 152) = v11;
            memset(&v11[4 * v12], 0, 4 * v13);
        }
    }
    result = *(_DWORD*)(this + 156);
    *(_DWORD*)(*(_DWORD*)(this + 152) + 4 * result - 4) = a2;
    return result;
}

//----- (00409960) --------------------------------------------------------
_DWORD* __thiscall sub_409960(_DWORD* this, int a2)
{
    int v3; // eax
    int v4; // eax
    _DWORD* v5; // ebx
    int v6; // eax
    int v7; // ecx
    void* v8; // ecx
    int v9; // eax
    char* v10; // eax
    int v11; // edi
    int v12; // ecx

    v3 = this[12];
    if (v3 <= 0)
    {
        v5 = operator new(0x94u);
        memset(v5, 0, 0x94u);
    }
    else
    {
        v4 = v3 - 1;
        v5 = *(_DWORD**)(this[11] + 4 * v4);
        this[12] = v4;
    }
    *v5 = a2;
    v6 = this[9];
    v7 = this[8] + 1;
    this[8] = v7;
    if (v7 > v6)
    {
        v8 = (void*)this[7];
        v9 = v6 + 8;
        this[9] = v9;
        v10 = (char*)sub_488DD7(v8, 4 * v9);
        if (v10)
        {
            v11 = this[8];
            v12 = this[9] - v11;
            this[7] = v10;
            memset(&v10[4 * v11], 0, 4 * v12);
        }
    }
    *(_DWORD*)(this[7] + 4 * this[8] - 4) = v5;
    return v5;
}

//----- (00409A00) --------------------------------------------------------
int __thiscall sub_409A00(int this, void* a2)
{
    int v3; // eax
    int v4; // ecx
    void** v5; // edi
    void** v6; // edx
    int v7; // ecx
    int v8; // eax
    int v9; // ecx
    int v10; // eax
    char* v11; // eax
    int v12; // edi
    int v13; // ecx
    int result; // eax

    v3 = 0;
    memset(a2, 0, 0x94u);
    v4 = *(_DWORD*)(this + 32);
    if (v4 > 0)
    {
        v5 = *(void***)(this + 28);
        v6 = v5;
        while (*v6 != a2)
        {
            ++v3;
            ++v6;
            if (v3 >= v4)
                goto LABEL_8;
        }
        v7 = v4 - 1;
        *(_DWORD*)(this + 32) = v7;
        if (v3 != v7)
        {
            memcpy(&v5[v3], &v5[v3 + 1], 4 * (v7 + 0x3FFFFFFF * v3));
            *(_DWORD*)(*(_DWORD*)(this + 28) + 4 * *(_DWORD*)(this + 32)) = 0;
        }
    }
LABEL_8:
    v8 = *(_DWORD*)(this + 52);
    v9 = *(_DWORD*)(this + 48) + 1;
    *(_DWORD*)(this + 48) = v9;
    if (v9 > v8)
    {
        v10 = v8 + 8;
        *(_DWORD*)(this + 52) = v10;
        v11 = (char*)sub_488DD7(*(LPVOID*)(this + 44), 4 * v10);
        if (v11)
        {
            v12 = *(_DWORD*)(this + 48);
            v13 = *(_DWORD*)(this + 52) - v12;
            *(_DWORD*)(this + 44) = v11;
            memset(&v11[4 * v12], 0, 4 * v13);
        }
    }
    result = *(_DWORD*)(this + 48);
    *(_DWORD*)(*(_DWORD*)(this + 44) + 4 * result - 4) = a2;
    return result;
}

//----- (00409AD0) --------------------------------------------------------
_BYTE* __thiscall sub_409AD0(int* this, int a2, unsigned int a3)
{
    return sub_421980(this[33], a2, a3);
}

//----- (00409AF0) --------------------------------------------------------
_DWORD* __thiscall sub_409AF0(_DWORD** this, char* String1, char a3)
{
    return sub_422400(this[31], String1, a3);
}

//----- (00409B10) --------------------------------------------------------
_DWORD* __thiscall sub_409B10(_DWORD* this)
{
    _DWORD* result; // eax

    result = this;
    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
    *((_BYTE*)this + 16) = 1;
    this[5] = 0;
    this[6] = 0;
    this[7] = 0;
    this[8] = 0;
    this[9] = 0;
    this[12] = 0;
    this[13] = 0;
    this[14] = 0;
    this[15] = 0;
    *this = &off_49914C;
    return result;
}
// 49914C: using guessed type _UNKNOWN *off_49914C;

//----- (00409B70) --------------------------------------------------------
int __thiscall sub_409B70(_DWORD* this)
{
    int v2; // eax
    int result; // eax

    *this = &off_49914C;
    v2 = this[12];
    if (v2)
    {
        (*(void(__stdcall**)(int))(*(_DWORD*)v2 + 8))(v2);
        this[12] = 0;
    }
    result = this[13];
    if (result)
    {
        result = (*(int(__stdcall**)(_DWORD))(*(_DWORD*)result + 8))(this[13]);
        this[13] = 0;
    }
    *this = &off_499040;
    return result;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 49914C: using guessed type _UNKNOWN *off_49914C;

//----- (00409BE0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char __userpurge sub_409BE0@<al>(
    int a1@<ecx>,
    int a2@<ebx>,
    int a3@<ebp>,
    int a4@<edi>,
    int a5@<esi>,
    float a6,
    float a7,
    float a8,
    float a9,
    float a10,
    int a11,
    float a12,
    float a13,
    int a14)
{
    double v15; // st6
    int v16; // edi
    double v17; // st7
    __int64 v18; // rax
    _DWORD* v19; // ebp
    _DWORD* v21; // edi
    int i; // eax
    int v23; // eax
    int v24; // eax
    int v25; // eax
    int v26; // eax
    int v27; // eax
    int v31; // [esp+50h] [ebp-4h]
    float retaddr; // [esp+54h] [ebp+0h] BYREF
    int j; // [esp+58h] [ebp+4h]
    int k; // [esp+58h] [ebp+4h]
    int m; // [esp+58h] [ebp+4h]
    int n; // [esp+58h] [ebp+4h]
    _WORD* v37; // [esp+64h] [ebp+10h]
    _WORD* v38; // [esp+64h] [ebp+10h]

    *(float*)(a1 + 64) = a10;
    *(float*)(a1 + 28) = a7;
    *(float*)(a1 + 20) = retaddr;
    *(float*)(a1 + 24) = a6;
    *(float*)(a1 + 32) = a8;
    *(float*)(a1 + 36) = a9;
    if (a9 == 0.0)
        v15 = 0.0;
    else
        v15 = (a8 - a7) / a9;
    v16 = (__int64)(v15 + 1.0);
    *(_DWORD*)(a1 + 40) = v16;
    if (a9 == 0.0)
        v17 = 0.0;
    else
        v17 = (a6 - retaddr) / a9;
    v18 = (__int64)(v17 + 1.0);
    *(_DWORD*)(a1 + 44) = v18;
    LODWORD(v18) = 2 * (v16 + v18);
    v19 = (_DWORD*)(a1 + 48);
    *(_DWORD*)(a1 + 56) = v18;
    *(_DWORD*)(a1 + 60) = v18;
    if ((*(int(__stdcall**)(_DWORD, _DWORD, int, int, int, int))(**(_DWORD**)ArgList + 92))(
        *(_DWORD*)ArgList,
        16 * v18,
        8,
        66,
        1,
        a1 + 48) < 0)
        return 0;
    v21 = (_DWORD*)(a1 + 52);
    if ((*(int(__stdcall**)(_DWORD, int, int, int, int, int))(**(_DWORD**)ArgList + 96))(
        *(_DWORD*)ArgList,
        2 * *(_DWORD*)(a1 + 60),
        8,
        101,
        1,
        a1 + 52) < 0)
        return 0;
    (*(void(__stdcall**)(_DWORD, _DWORD, int, float*, _DWORD, int, int, int, int))(*(_DWORD*)*v21 + 44))(
        *v21,
        0,
        2 * *(_DWORD*)(a1 + 60),
        &retaddr,
        0,
        a4,
        a5,
        a3,
        a2);
    for (i = 0; i < *(_DWORD*)(a1 + 40); LODWORD(a9) = v37 + 1)
    {
        *(_WORD*)LODWORD(a9) = i;
        v37 = (_WORD*)(LODWORD(a9) + 2);
        *v37 = *(_WORD*)(a1 + 40) + i++;
    }
    v23 = 2 * *(_DWORD*)(a1 + 40);
    if (v23 < v23 + *(_DWORD*)(a1 + 44))
    {
        do
        {
            *(_WORD*)LODWORD(a9) = v23;
            v38 = (_WORD*)(LODWORD(a9) + 2);
            *v38 = *(_WORD*)(a1 + 44) + v23;
            LODWORD(a9) = v38 + 1;
            ++v23;
        } while (v23 < *(_DWORD*)(a1 + 44) + 2 * *(_DWORD*)(a1 + 40));
    }
    (*(void(__stdcall**)(_DWORD, int))(*(_DWORD*)*v21 + 48))(*v21, v31);
    if ((*(int(__cdecl**)(_DWORD, _DWORD, _DWORD, int*, _DWORD))(*(_DWORD*)*v19 + 44))(*v19, 0, 0, &a14, 0) < 0)
        return 0;
    v24 = 0;
    for (j = 0; v24 < *(_DWORD*)(a1 + 40); j = v24)
    {
        *(float*)LODWORD(a9) = (double)j * *(float*)(a1 + 36) + *(float*)(a1 + 20);
        *(_DWORD*)(LODWORD(a9) + 4) = *(_DWORD*)(a1 + 32);
        *(_DWORD*)(LODWORD(a9) + 8) = 0;
        *(_DWORD*)(LODWORD(a9) + 12) = *(_DWORD*)(a1 + 64);
        ++v24;
        LODWORD(a9) += 16;
    }
    v25 = 0;
    for (k = 0; v25 < *(_DWORD*)(a1 + 40); k = v25)
    {
        *(float*)LODWORD(a9) = (double)k * *(float*)(a1 + 36) + *(float*)(a1 + 20);
        *(_DWORD*)(LODWORD(a9) + 4) = *(_DWORD*)(a1 + 28);
        *(_DWORD*)(LODWORD(a9) + 8) = 0;
        *(_DWORD*)(LODWORD(a9) + 12) = *(_DWORD*)(a1 + 64);
        ++v25;
        LODWORD(a9) += 16;
    }
    v26 = 0;
    for (m = 0; v26 < *(_DWORD*)(a1 + 44); m = v26)
    {
        *(_DWORD*)LODWORD(a9) = *(_DWORD*)(a1 + 24);
        *(float*)(LODWORD(a9) + 4) = (double)m * *(float*)(a1 + 36) + *(float*)(a1 + 28);
        *(_DWORD*)(LODWORD(a9) + 8) = 0;
        *(_DWORD*)(LODWORD(a9) + 12) = *(_DWORD*)(a1 + 64);
        ++v26;
        LODWORD(a9) += 16;
    }
    v27 = 0;
    for (n = 0; v27 < *(_DWORD*)(a1 + 44); n = v27)
    {
        *(_DWORD*)LODWORD(a9) = *(_DWORD*)(a1 + 20);
        *(float*)(LODWORD(a9) + 4) = (double)n * *(float*)(a1 + 36) + *(float*)(a1 + 28);
        *(_DWORD*)(LODWORD(a9) + 8) = 0;
        *(_DWORD*)(LODWORD(a9) + 12) = *(_DWORD*)(a1 + 64);
        ++v27;
        LODWORD(a9) += 16;
    }
    (*(void(__stdcall**)(_DWORD))(*(_DWORD*)*v19 + 48))(*v19);
    sub_409960((_DWORD*)dword_520970, a1)[3] = 2;
    return 1;
}
// 409D6D: positive sp value 4 has been found
// 409BE0: could not find valid save-restore pair for ebx
// 409BE0: could not find valid save-restore pair for ebp
// 409BE0: could not find valid save-restore pair for edi
// 409BE0: could not find valid save-restore pair for esi
// 409D6A: variable 'v31' is possibly undefined
// 520970: using guessed type int dword_520970;

//----- (00409EF0) --------------------------------------------------------
int __thiscall sub_409EF0(_DWORD* this, int a2)
{
    _DWORD v4[16]; // [esp+4h] [ebp-40h] BYREF

    memset(&v4[11], 0, 16);
    memset(&v4[6], 0, 16);
    memset(&v4[1], 0, 16);
    v4[15] = 1065353216;
    v4[10] = 1065353216;
    v4[5] = 1065353216;
    v4[0] = 1065353216;
    (*(void(__stdcall**)(_DWORD, int, _DWORD*))(**(_DWORD**)ArgList + 148))(*(_DWORD*)ArgList, 256, v4);
    sub_41BC00((_DWORD*)dword_520A50, 1, 0, 1, 0, 1, 1, 1);
    sub_41BEF0((_DWORD*)dword_520A50, 0, 0, -1, -1);
    sub_41BEF0((_DWORD*)dword_520A50, 1, 0, -1, -1);
    (*(void(__stdcall**)(_DWORD, int))(**(_DWORD**)ArgList + 304))(*(_DWORD*)ArgList, 66);
    (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD, int))(**(_DWORD**)ArgList + 332))(*(_DWORD*)ArgList, 0, this[12], 16);
    (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD))(**(_DWORD**)ArgList + 340))(*(_DWORD*)ArgList, this[13], 0);
    (*(void(__stdcall**)(_DWORD, int, _DWORD, _DWORD, _DWORD, _DWORD))(**(_DWORD**)ArgList + 284))(
        *(_DWORD*)ArgList,
        2,
        0,
        this[14],
        0,
        this[15] >> 1);
    *(float*)dword_520A20 = *(float*)dword_520A20 + 1.0;
    return this[10] + this[11];
}
// 520A20: using guessed type int dword_520A20;
// 520A50: using guessed type int dword_520A50;

//----- (0040A050) --------------------------------------------------------
void sub_40A050()
{
    sub_40A060();
    JUMPOUT(0x40A070);
}
// 40A055: control flows out of bounds to 40A070

//----- (0040A060) --------------------------------------------------------
char* sub_40A060()
{
    byte_4F5B00 = 0;
    dword_4F5B04 = fopen(File, aW);
    sub_4282E0(dword_4F5B04 != 0, "failed to open error log file %s", File);
    return &byte_4F5B00;
}
// 4F5B00: using guessed type char byte_4F5B00;

//----- (0040A0F0) --------------------------------------------------------
char sub_40A0F0()
{
    char result; // al

    result = byte_4F5B00;
    if (byte_4F5B00)
    {
        ShellExecuteA(0, Operation, File, 0, 0, 10);
        sub_4281B0(aIniFileErrorsS);
    }
    return result;
}
// 4F5B00: using guessed type char byte_4F5B00;

//----- (0040A120) --------------------------------------------------------
char sub_40A120(char a1, char* Format, ...)
{
    char result; // al
    char Buffer[512]; // [esp+0h] [ebp-200h] BYREF
    va_list va; // [esp+20Ch] [ebp+Ch] BYREF

    va_start(va, Format);
    result = a1;
    if (!a1)
    {
        byte_4F5B00 = 1;
        if (_vsnprintf(Buffer, 0x1FEu, Format, va) == -1)
            Buffer[510] = 0;
        strcat(Buffer, asc_4A1F30);
        fputs(Buffer, dword_4F5B04);
        return fflush(dword_4F5B04);
    }
    return result;
}
// 4F5B00: using guessed type char byte_4F5B00;

//----- (0040A1D0) --------------------------------------------------------
int __thiscall sub_40A1D0(int this, char* FileName)
{
    FILE* v3; // eax
    FILE* v4; // esi
    int v6; // edi
    unsigned int v7; // edi
    void* v8; // eax
    int v9; // ebx
    int i; // ecx
    char* v11; // edx
    char v12; // al
    signed int v13; // esi
    signed int v14; // edi
    int j; // eax
    _BYTE* v16; // ecx
    unsigned int v17; // edx
    int v18; // ebx
    int v19; // esi
    int v20; // edi
    int v21; // ecx
    char v22; // al
    char v23; // al
    char v24; // al
    int v25; // ecx
    int v26; // edi
    unsigned int v27; // esi
    int v28; // edx
    int v29; // edx
    int v30; // ecx
    int v31; // eax
    int v32; // eax
    unsigned int v33; // edx
    int v34; // eax
    int v35; // edx
    int v36; // esi
    char v37; // cl
    char v38; // cl
    bool v39; // zf
    int v40; // ecx
    char v41; // al
    int v42; // eax
    int v44; // eax
    _BYTE* n; // ecx
    int v46; // ecx
    char v47; // al
    int v48; // eax
    int v50; // eax
    _BYTE* ii; // ecx
    int v52; // ecx
    int v53; // eax
    int v54; // edi
    int v55; // esi
    unsigned int v56; // edx
    int v57; // edx
    int v58; // eax
    int v59; // ecx
    char jj; // al
    int v61; // [esp+10h] [ebp-48h]
    unsigned int v62; // [esp+10h] [ebp-48h]
    int v63; // [esp+18h] [ebp-40h]
    int k; // [esp+1Ch] [ebp-3Ch]
    int m; // [esp+1Ch] [ebp-3Ch]
    int v66[3]; // [esp+28h] [ebp-30h] BYREF
    _BYTE v67[8]; // [esp+34h] [ebp-24h] BYREF
    LPVOID v68; // [esp+3Ch] [ebp-1Ch]
    int v69; // [esp+40h] [ebp-18h]
    int v70; // [esp+44h] [ebp-14h]
    int v71; // [esp+54h] [ebp-4h]
    char FileNamea; // [esp+5Ch] [ebp+4h]
    bool FileNameb; // [esp+5Ch] [ebp+4h]
    bool FileNamec; // [esp+5Ch] [ebp+4h]

    *(_BYTE*)this = (_BYTE)FileName;
    *(_DWORD*)(this + 4) = 0;
    *(_DWORD*)(this + 8) = 0;
    *(_DWORD*)(this + 12) = 0;
    strcpy((char*)(this + 16), FileName);
    v71 = 0;
    *(_DWORD*)(this + 276) = 0;
    *(_DWORD*)(this + 280) = 0;
    v3 = fopen(FileName, Mode);
    v4 = v3;
    if (!v3)
        sub_4281B0("Can't open ini file '%s'", FileName);
    fseek(v3, 0, 2);
    v6 = ftell(v4);
    fseek(v4, 0, 0);
    v7 = v6 + 1;
    v8 = operator new(v7);
    *(_DWORD*)(this + 276) = v8;
    sub_4898CA(v8, 1u, v7 - 1, v4);
    *(_BYTE*)(*(_DWORD*)(this + 276) + v7 - 1) = 0;
    fclose(v4);
    v9 = v7 - 1;
    for (i = 0; i < v9; ++i)
    {
        v11 = (char*)(*(_DWORD*)(this + 276) + i);
        v12 = *v11;
        if ((*v11 < 32 || v12 == 127) && v12 != 13 && v12 != 10)
            *v11 = 32;
    }
    v13 = 0;
    FileNamea = 0;
    if (v9 > 0)
    {
        v14 = v7 - 2;
        while (1)
        {
            if (v13 < v14)
            {
                if (!strncmp((const char*)(v13 + *(_DWORD*)(this + 276)), asc_4A1F3C, 2u))
                    FileNamea = 1;
                if (!strncmp((const char*)(v13 + *(_DWORD*)(this + 276)), asc_4A1F38, 2u))
                    break;
            }
            if (!FileNamea)
                goto LABEL_18;
            *(_BYTE*)(*(_DWORD*)(this + 276) + v13) = 32;
        LABEL_24:
            if (++v13 >= v9)
                goto LABEL_25;
        }
        FileNamea = 0;
        strncpy((char*)(v13 + *(_DWORD*)(this + 276)), asc_4A1DF8, 2u);
    LABEL_18:
        if (v13 < v14 && !strncmp((const char*)(v13 + *(_DWORD*)(this + 276)), asc_4A1F34, 2u))
        {
            for (j = v13; j < v9; *v16 = 32)
            {
                v16 = (_BYTE*)(j + *(_DWORD*)(this + 276));
                if (*v16 == 13)
                    break;
                if (!*v16)
                    break;
                ++j;
            }
        }
        goto LABEL_24;
    }
LABEL_25:
    v17 = 0;
    v18 = 0;
LABEL_26:
    v19 = *(_DWORD*)(this + 276);
    v20 = v18;
    v21 = 0;
    while (1)
    {
        v22 = *(_BYTE*)(v19 + v18);
        switch (v22)
        {
        case 0:
            return this;
        case 91:
            v21 = 1;
            break;
        case 61:
            v21 = 2;
            break;
        case 13:
            v21 = 3;
            break;
        }
        ++v18;
        if (v21)
        {
            if (v21 == 1)
            {
                v23 = *(_BYTE*)(v19 + v18);
                for (k = v18; v23 != 93; v23 = *(_BYTE*)(v19 + v18++ + 1))
                {
                    if (v23 == 13)
                        break;
                    if (!v23)
                        break;
                }
                v24 = *(_BYTE*)(v19 + v18);
                *(_BYTE*)(v19 + v18) = 0;
                v25 = *(_DWORD*)(this + 4);
                FileNameb = v24 == 0;
                ++v18;
                if (v25)
                {
                    v26 = (*(_DWORD*)(this + 8) - v25) / 24;
                    v17 = 0;
                    v61 = v26;
                }
                else
                {
                    v26 = 0;
                    v61 = 0;
                }
                v68 = 0;
                v67[4] = v24 == 0;
                v69 = 0;
                v70 = 0;
                LOBYTE(v71) = 1;
                v27 = v26 + 1;
                if (v25)
                    v17 = (*(_DWORD*)(this + 8) - v25) / 24;
                if (v17 >= v27)
                {
                    if (v25)
                    {
                        if (v27 < (*(_DWORD*)(this + 8) - v25) / 24)
                            sub_40BB60((_DWORD*)this, (_DWORD*)(v25 + 24 * v27), *(_DWORD*)(this + 8));
                        v26 = v61;
                    }
                }
                else
                {
                    if (v25)
                        v28 = (*(_DWORD*)(this + 8) - v25) / 24;
                    else
                        v28 = 0;
                    sub_40B840((_DWORD*)this, *(_DWORD*)(this + 8), v27 - v28, (int)v67);
                }
                LOBYTE(v71) = 0;
                sub_4885A6(v68);
                v29 = k + *(_DWORD*)(this + 276);
                v30 = *(_DWORD*)(this + 4);
                v68 = 0;
                v69 = 0;
                v70 = 0;
                v31 = 24 * v26;
                *(_DWORD*)(v31 + v30) = v29;
                *(_BYTE*)(v31 + *(_DWORD*)(this + 4) + 20) = 0;
                *(_DWORD*)(this + 280) = v26;
                if (FileNameb)
                    return this;
            }
            else if (v21 == 2)
            {
                v32 = *(_DWORD*)(this + 4);
                v33 = v32 ? (*(_DWORD*)(this + 8) - v32) / 24 : 0;
                if (*(_DWORD*)(this + 280) < v33)
                {
                    *(_BYTE*)(v19 + v18 - 1) = 0;
                    v34 = *(_DWORD*)(this + 276);
                    v35 = v20;
                    v36 = v18;
                    v37 = *(_BYTE*)(v34 + v18);
                    v63 = v20;
                    for (m = v18; v37 != 13; v37 = *(_BYTE*)(v34 + v18++ + 1))
                    {
                        if (!v37)
                            break;
                    }
                    v38 = *(_BYTE*)(v34 + v18);
                    *(_BYTE*)(v34 + v18) = 0;
                    v39 = v38 == 0;
                    v40 = *(_DWORD*)(this + 276);
                    FileNamec = v39;
                    ++v18;
                    if (*(_BYTE*)(v40 + v20) == 32)
                    {
                        do
                            v41 = *(_BYTE*)(v40 + v35++ + 1);
                        while (v41 == 32);
                        v63 = v35;
                    }
                    v42 = v35;
                    if (*(_BYTE*)(v40 + v35))
                    {
                        while (*(_BYTE*)(v40 + v42++ + 1))
                            ;
                    }
                    v44 = v42 - 1;
                    for (n = (_BYTE*)(v44 + v40); *n == 32; n = (_BYTE*)(v44 + *(_DWORD*)(this + 276)))
                    {
                        *n = 0;
                        --v44;
                    }
                    v46 = *(_DWORD*)(this + 276);
                    if (*(_BYTE*)(v46 + v36) == 32)
                    {
                        do
                            v47 = *(_BYTE*)(v46 + v36++ + 1);
                        while (v47 == 32);
                        m = v36;
                    }
                    v48 = v36;
                    if (*(_BYTE*)(v46 + v36))
                    {
                        while (*(_BYTE*)(v46 + v48++ + 1))
                            ;
                    }
                    v50 = v48 - 1;
                    for (ii = (_BYTE*)(v50 + v46); *ii == 32; ii = (_BYTE*)(*(_DWORD*)(this + 276) + v50))
                    {
                        *ii = 0;
                        --v50;
                    }
                    v53 = *(_DWORD*)(*(_DWORD*)(this + 4) + 24 * *(_DWORD*)(this + 280) + 8);
                    v54 = v53 ? (*(_DWORD*)(*(_DWORD*)(this + 4) + 24 * *(_DWORD*)(this + 280) + 12) - v53) / 12 : 0;
                    v55 = *(_DWORD*)(*(_DWORD*)(this + 4) + 24 * *(_DWORD*)(this + 280) + 8);
                    v62 = v54 + 1;
                    v56 = v55 ? (*(_DWORD*)(*(_DWORD*)(this + 4) + 24 * *(_DWORD*)(this + 280) + 12) - v55) / 12 : 0;
                    if (v56 >= v62)
                    {
                        if (v55 && v62 < (*(_DWORD*)(*(_DWORD*)(this + 4) + 24 * *(_DWORD*)(this + 280) + 12) - v55) / 12)
                            *(_DWORD*)(*(_DWORD*)(this + 4) + 24 * *(_DWORD*)(this + 280) + 12) = v55 + 12 * v62;
                    }
                    else
                    {
                        v57 = v55 ? (*(_DWORD*)(*(_DWORD*)(this + 4) + 24 * *(_DWORD*)(this + 280) + 12) - v55) / 12 : 0;
                        v52 = *(_DWORD*)(this + 4) + 24 * *(_DWORD*)(this + 280) + 4;
                        sub_45C920((_DWORD*)v52, *(char**)(v52 + 8), v62 - v57, v66);
                    }
                    v58 = 12 * v54;
                    *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 4) + 24 * *(_DWORD*)(this + 280) + 8) + v58) = v63 + *(_DWORD*)(this + 276);
                    *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 4) + 24 * *(_DWORD*)(this + 280) + 8) + v58 + 4) = m + *(_DWORD*)(this + 276);
                    *(_BYTE*)(*(_DWORD*)(*(_DWORD*)(this + 4) + 24 * *(_DWORD*)(this + 280) + 8) + v58 + 8) = 0;
                    if (FileNamec)
                        return this;
                }
            }
            v59 = *(_DWORD*)(this + 276);
            for (jj = *(_BYTE*)(v59 + v18); jj != 10; jj = *(_BYTE*)(v59 + v18++ + 1))
            {
                if (!jj)
                    break;
            }
            if (*(_BYTE*)(v59 + v18) == 10)
            {
                ++v18;
                v17 = 0;
                goto LABEL_26;
            }
            return this;
        }
    }
}
// 40A402: conditional instruction was optimized away because ecx.4==0
// 40A5E7: conditional instruction was optimized away because al.1==20
// 40A62F: conditional instruction was optimized away because al.1==20

//----- (0040A800) --------------------------------------------------------
int __thiscall sub_40A800(int this)
{
    int result; // eax

    sub_4885A6(*(LPVOID*)(this + 8));
    result = 0;
    *(_DWORD*)(this + 8) = 0;
    *(_DWORD*)(this + 12) = 0;
    *(_DWORD*)(this + 16) = 0;
    return result;
}

//----- (0040A830) --------------------------------------------------------
int __thiscall sub_40A830(int this)
{
    int v1; // ebx
    int v3; // esi
    unsigned int v4; // esi
    int j; // edi
    int v6; // ecx
    int v7; // eax
    int v8; // eax
    int* v9; // eax
    int v10; // ebx
    int v11; // edi
    int* m; // esi
    bool v13; // zf
    int result; // eax
    unsigned int i; // [esp+10h] [ebp-Ch]
    int* k; // [esp+10h] [ebp-Ch]
    int v17; // [esp+14h] [ebp-8h]
    int v18; // [esp+18h] [ebp-4h]

    v1 = 0;
    for (i = 0; ; ++i)
    {
        v3 = *(_DWORD*)(this + 4);
        if (!v3 || i >= (*(_DWORD*)(this + 8) - v3) / 24)
            break;
        if (*(_BYTE*)(v1 + v3 + 20))
        {
            v4 = 0;
            for (j = 0; ; j += 12)
            {
                v6 = v1 + *(_DWORD*)(this + 4);
                v7 = *(_DWORD*)(v6 + 8);
                if (!v7 || v4 >= (*(_DWORD*)(v6 + 12) - v7) / 12)
                    break;
                sub_40A120(
                    *(_BYTE*)(*(_DWORD*)(v6 + 8) + j + 8),
                    "entry %s=%s is not used by %s, see %s",
                    *(const char**)(*(_DWORD*)(v6 + 8) + j),
                    *(const char**)(*(_DWORD*)(v6 + 8) + j + 4),
                    *(const char**)v6,
                    (const char*)(this + 16));
                ++v4;
            }
        }
        v1 += 24;
    }
    sub_4885A6(*(LPVOID*)(this + 276));
    v8 = *(_DWORD*)(this + 4);
    v18 = *(_DWORD*)(this + 8);
    v17 = v8;
    if (v8 != v18)
    {
        v9 = (int*)(v8 + 8);
        for (k = v9; ; v9 = k)
        {
            v10 = v9[1];
            v11 = *v9;
            for (m = v9 - 1; v11 != v10; v11 += 12)
                nullsub_4(v11);
            sub_4885A6((LPVOID)m[1]);
            m[1] = 0;
            m[2] = 0;
            m[3] = 0;
            v13 = v17 + 24 == v18;
            v17 += 24;
            k += 6;
            if (v13)
                break;
        }
    }
    sub_4885A6(*(LPVOID*)(this + 4));
    result = 0;
    *(_DWORD*)(this + 4) = 0;
    *(_DWORD*)(this + 8) = 0;
    *(_DWORD*)(this + 12) = 0;
    return result;
}

//----- (0040A980) --------------------------------------------------------
int __thiscall sub_40A980(_DWORD* this)
{
    int result; // eax

    result = this[1];
    if (result)
        return (this[2] - result) / 24;
    return result;
}

//----- (0040A9B0) --------------------------------------------------------
char __thiscall sub_40A9B0(int this, unsigned int a2)
{
    int v3; // eax
    unsigned int v4; // edx
    char result; // al

    v3 = *(_DWORD*)(this + 4);
    if (v3)
        v4 = (*(_DWORD*)(this + 8) - v3) / 24;
    else
        v4 = 0;
    result = sub_40A120(a2 < v4, "category not found, see %s", (const char*)(this + 16));
    *(_DWORD*)(this + 280) = a2;
    return result;
}

//----- (0040AA00) --------------------------------------------------------
int __thiscall sub_40AA00(_DWORD* this, int a2)
{
    return *(_DWORD*)(this[1] + 24 * this[70]);
}

//----- (0040AA20) --------------------------------------------------------
int __thiscall sub_40AA20(_DWORD* this, int a2)
{
    int result; // eax

    result = 3 * this[70];
    *(_BYTE*)(this[1] + 24 * this[70] + 20) = 1;
    return result;
}

//----- (0040AA40) --------------------------------------------------------
int __thiscall sub_40AA40(int this, char* String2)
{
    unsigned int v2; // ebx
    int i; // ebp
    int v5; // edi
    int v6; // eax
    unsigned int v7; // edx
    int result; // eax

    v2 = 0;
    for (i = 0; ; i += 24)
    {
        v5 = *(_DWORD*)(this + 4);
        if (!v5
            || v2 >= (*(_DWORD*)(this + 8) - v5) / 24
            || !_strcmpi(*(const char**)(v5 + i), String2) && !*(_BYTE*)(*(_DWORD*)(this + 4) + i + 20))
        {
            break;
        }
        ++v2;
    }
    v6 = *(_DWORD*)(this + 4);
    *(_DWORD*)(this + 280) = v2;
    if (v6)
        v7 = (*(_DWORD*)(this + 8) - v6) / 24;
    else
        v7 = 0;
    sub_40A120(v2 < v7, "could not find category %s, see file %s", String2, (const char*)(this + 16));
    result = 3 * *(_DWORD*)(this + 280);
    *(_BYTE*)(*(_DWORD*)(this + 4) + 24 * *(_DWORD*)(this + 280) + 20) = 1;
    return result;
}

//----- (0040AAF0) --------------------------------------------------------
bool __thiscall sub_40AAF0(_DWORD* this, char* String2, char a3)
{
    int v4; // esi
    unsigned int v5; // edx
    unsigned int v6; // eax
    unsigned int v8; // ebp
    int i; // ebx
    int v10; // esi

    if (a3)
    {
        v4 = this[1];
        if (v4)
            v5 = (this[2] - v4) / 24;
        else
            v5 = 0;
        v6 = this[70] + 1;
        return v6 < v5 && !_strcmpi(*(const char**)(v4 + 24 * v6), String2);
    }
    else
    {
        v8 = 0;
        for (i = 0; ; i += 24)
        {
            v10 = this[1];
            if (!v10 || v8 >= (this[2] - v10) / 24)
                break;
            if (!_strcmpi(*(const char**)(i + v10), String2) && !*(_BYTE*)(this[1] + i + 20))
                return 1;
            ++v8;
        }
        return 0;
    }
}

//----- (0040ABC0) --------------------------------------------------------
bool __thiscall sub_40ABC0(_DWORD* this, char* String2, char a3)
{
    int v4; // esi
    int v5; // eax
    unsigned int v6; // edx
    unsigned int v7; // eax
    unsigned int v9; // ebp
    int i; // ebx
    int v11; // edx
    int v12; // eax
    int v13; // esi

    if (a3)
    {
        v4 = this[1] + 24 * this[70];
        v5 = *(_DWORD*)(v4 + 8);
        if (v5)
            v6 = (*(_DWORD*)(v4 + 12) - v5) / 12;
        else
            v6 = 0;
        v7 = this[71] + 1;
        return v7 < v6 && !_strcmpi(*(const char**)(*(_DWORD*)(v4 + 8) + 12 * v7), String2);
    }
    else
    {
        v9 = 0;
        for (i = 0; ; i += 12)
        {
            v11 = this[1];
            v12 = *(_DWORD*)(v11 + 24 * this[70] + 8);
            v13 = v11 + 24 * this[70];
            if (!v12 || v9 >= (*(_DWORD*)(v13 + 12) - v12) / 12)
                break;
            if (!_strcmpi(*(const char**)(i + *(_DWORD*)(v13 + 8)), String2)
                && !*(_BYTE*)(*(_DWORD*)(this[1] + 24 * this[70] + 8) + i + 8))
            {
                return 1;
            }
            ++v9;
        }
        return 0;
    }
}

//----- (0040ACC0) --------------------------------------------------------
char __thiscall sub_40ACC0(_DWORD* this, char* String2, char* a3)
{
    unsigned int v4; // ebp
    int i; // ebx
    int v6; // edi
    int v7; // eax

    v4 = this[71] + 1;
    for (i = 12 * v4; ; i += 12)
    {
        v6 = this[1] + 24 * this[70];
        v7 = *(_DWORD*)(v6 + 8);
        if (!v7 || v4 >= (*(_DWORD*)(v6 + 12) - v7) / 12)
            break;
        if (!_strcmpi(*(const char**)(i + *(_DWORD*)(v6 + 8)), String2)
            && !*(_BYTE*)(*(_DWORD*)(this[1] + 24 * this[70] + 8) + i + 8))
        {
            return 1;
        }
        if (!_strcmpi(*(const char**)(i + *(_DWORD*)(this[1] + 24 * this[70] + 8)), a3))
            break;
        ++v4;
    }
    return 0;
}

//----- (0040AD80) --------------------------------------------------------
bool __thiscall sub_40AD80(void* this, char* String2)
{
    const char* v2; // eax

    v2 = (const char*)sub_40B6E0((int)this, String2, 0);
    return v2 && strstr(v2, asc_4A1FC8) != 0;
}

//----- (0040ADB0) --------------------------------------------------------
unsigned int __thiscall sub_40ADB0(_DWORD* this)
{
    unsigned int v1; // edi
    int i; // ebx
    int v3; // esi
    unsigned int result; // eax
    signed int v5; // kr00_4

    v1 = 0;
    for (i = 0; ; i += 12)
    {
        v3 = this[1] + 24 * this[70];
        result = *(_DWORD*)(v3 + 8);
        if (!result)
            break;
        v5 = *(_DWORD*)(v3 + 12) - result;
        result = (unsigned int)((unsigned __int64)(715827883LL * v5) >> 32) >> 31;
        if (v1 >= v5 / 12)
            break;
        ++v1;
        *(_BYTE*)(*(_DWORD*)(v3 + 8) + i + 8) = 0;
    }
    return result;
}

//----- (0040AE00) --------------------------------------------------------
int __thiscall sub_40AE00(_DWORD* this, char* String2)
{
    int v2; // ebp
    unsigned int i; // edi
    int v5; // esi
    int v6; // eax
    int v8; // [esp+10h] [ebp-4h]

    v2 = 0;
    v8 = 0;
    for (i = 0; ; ++i)
    {
        v5 = this[1] + 24 * this[70];
        v6 = *(_DWORD*)(v5 + 8);
        if (!v6 || i >= (*(_DWORD*)(v5 + 12) - v6) / 12)
            break;
        if (!_strcmpi(*(const char**)(*(_DWORD*)(v5 + 8) + v2), String2))
            ++v8;
        v2 += 12;
    }
    return v8;
}

//----- (0040AE70) --------------------------------------------------------
char __thiscall sub_40AE70(_DWORD* this, char* String2)
{
    unsigned int v2; // ebp
    int i; // ebx
    int v5; // esi
    int v6; // eax

    v2 = 0;
    for (i = 0; ; i += 12)
    {
        v5 = this[1] + 24 * this[70];
        v6 = *(_DWORD*)(v5 + 8);
        if (!v6 || v2 >= (*(_DWORD*)(v5 + 12) - v6) / 12)
            break;
        if (!_strcmpi(*(const char**)(i + *(_DWORD*)(v5 + 8)), String2)
            && *(_BYTE*)(*(_DWORD*)(this[1] + 24 * this[70] + 8) + i + 8))
        {
            return 1;
        }
        ++v2;
    }
    return 0;
}

//----- (0040AF00) --------------------------------------------------------
char* __thiscall sub_40AF00(const char* this, char* ArgList, char** a3)
{
    char* result; // eax
    char* v5; // esi
    char v6; // al
    char v7; // al

    result = (char*)sub_40B6E0((int)this, ArgList, 1);
    v5 = result;
    if (result)
    {
        v6 = *result;
        v7 = *v5 >= 48 && v6 <= 57 || v6 == 45 || v6 == 43;
        sub_40A120(v7, "%s = %s, integer expected, see %s", ArgList, v5, this + 16);
        result = (char*)sub_48A1BB(v5);
        *a3 = result;
    }
    return result;
}

//----- (0040AF60) --------------------------------------------------------
float* __thiscall sub_40AF60(const char* this, char* ArgList, float* a3)
{
    float* result; // eax
    const char* v5; // esi
    char v6; // al
    char v7; // al
    double v8; // st7

    result = (float*)sub_40B6E0((int)this, ArgList, 1);
    v5 = (const char*)result;
    if (result)
    {
        v6 = *(_BYTE*)result;
        v7 = *v5 >= 48 && v6 <= 57 || v6 == 45 || v6 == 43 || v6 == 46;
        sub_40A120(v7, "%s = %s, float expected, see %s", ArgList, v5, this + 16);
        v8 = atof(v5);
        result = a3;
        *a3 = v8;
    }
    return result;
}

//----- (0040AFC0) --------------------------------------------------------
int __thiscall sub_40AFC0(void* this, char* String2, _DWORD* a3)
{
    int result; // eax

    result = sub_40B6E0((int)this, String2, 1);
    if (result)
        *a3 = result;
    return result;
}

//----- (0040AFE0) --------------------------------------------------------
char* __thiscall sub_40AFE0(void* this, char* String2, char** a3)
{
    char* result; // eax
    char* v4; // esi
    unsigned int v5; // kr04_4

    result = (char*)sub_40B6E0((int)this, String2, 1);
    v4 = result;
    if (result)
    {
        v5 = strlen(result) + 1;
        result = (char*)operator new(v5);
        *a3 = result;
        qmemcpy(result, v4, v5);
    }
    return result;
}

//----- (0040B030) --------------------------------------------------------
char __thiscall sub_40B030(char* this, char* ArgList, float* a3)
{
    char* v3; // ebx
    int v4; // ebp
    char result; // al
    int v6; // edi
    char v7; // al
    char* v8; // esi
    const char* v9; // ebx
    char v10; // al
    bool v11; // cc
    int v12; // [esp+10h] [ebp-8h]

    v3 = this;
    v4 = sub_40B6E0((int)this, ArgList, 1);
    result = (char)a3;
    v6 = 0;
    *a3 = 0.0;
    a3[1] = 0.0;
    a3[2] = 0.0;
    if (v4)
    {
        v12 = 0;
        while (1)
        {
            while (1)
            {
                v7 = *(_BYTE*)(v6 + v4);
                v8 = (char*)(v6 + v4);
                if (v7 >= 48 && v7 <= 57)
                    break;
                if (v7 == 46 || v7 == 45 || !v7)
                    break;
                ++v6;
            }
            v9 = v3 + 16;
            sub_40A120(v7 != 0, "failed to get Vector element, see entry %s, in file %s", ArgList, v9);
            result = *v8;
            if (!*v8)
                break;
            *a3 = atof((const char*)(v6 + v4));
            while (1)
            {
                v10 = *(_BYTE*)(v6 + v4);
                if ((v10 < 48 || v10 > 57) && v10 != 46 && v10 != 45 && v10)
                    break;
                ++v6;
            }
            sub_40A120(*(_BYTE*)(v6 + v4) != 0, "failed to get Vector element, see entry %s, in file %s", ArgList, v9);
            result = *(_BYTE*)(v6 + v4);
            if (!result)
                break;
            result = v12 + 1;
            v11 = ++v12 < 3;
            ++a3;
            if (!v11)
                break;
            v3 = this;
        }
    }
    return result;
}

//----- (0040B130) --------------------------------------------------------
char __thiscall sub_40B130(const char* this, char* ArgList, _BYTE* a3)
{
    const char* v4; // eax
    const char* v5; // esi
    char v6; // al

    v4 = (const char*)sub_40B6E0((int)this, ArgList, 1);
    v5 = v4;
    if (v4)
    {
        v6 = !_strcmpi(v4, aTrue) || !_strcmpi(v5, aFalse);
        sub_40A120(v6, "%s = %s, expected true/false, see %s", ArgList, v5, this + 16);
        LOBYTE(v4) = _strcmpi(v5, aTrue) == 0;
        *a3 = (_BYTE)v4;
    }
    return (char)v4;
}

//----- (0040B1B0) --------------------------------------------------------
void __thiscall sub_40B1B0(const char* this, char* ArgList, float* a3)
{
    sub_40B1F0(this, ArgList, a3, a3 + 1);
}

//----- (0040B1D0) --------------------------------------------------------
void __thiscall sub_40B1D0(const char* this, char* ArgList, float* a3, float* a4)
{
    sub_40B1F0(this, ArgList, a3, a4);
}

//----- (0040B1F0) --------------------------------------------------------
void __thiscall sub_40B1F0(const char* this, char* ArgList, float* a3, float* a4)
{
    const char* v5; // esi
    int i; // edi
    char v7; // al
    const char* v8; // ebp
    char v9; // al
    char v10; // al
    const char* v11; // edi

    v5 = (const char*)sub_40B6E0((int)this, ArgList, 1);
    *a3 = 0.0;
    *a4 = 0.0;
    if (v5)
    {
        for (i = 0; ; ++i)
        {
            v7 = v5[i];
            if (v7 >= 48 && v7 <= 57)
                break;
            if (v7 == 46 || v7 == 45 || !v7)
                break;
        }
        v8 = this + 16;
        sub_40A120(v5[i] != 0, "%s = %s, expected [integer, integer], see %s", ArgList, v5, this + 16);
        if (v5[i])
        {
            *a3 = atof(&v5[i]);
            while (1)
            {
                v9 = v5[i];
                if ((v9 < 48 || v9 > 57) && v9 != 46 && v9 != 45 && v9)
                    break;
                ++i;
            }
            sub_40A120(v5[i] != 0, "%s = %s, expected [integer, integer], see %s", ArgList, v5, v8);
            if (v5[i])
            {
                while (1)
                {
                    v10 = v5[i];
                    if (v10 >= 48 && v10 <= 57)
                        break;
                    if (v10 == 46 || v10 == 45 || !v10)
                        break;
                    ++i;
                }
                v11 = &v5[i];
                sub_40A120(*v11 != 0, "%s = %s, expected [integer, integer], see %s", ArgList, v5, v8);
                if (*v11)
                    *a4 = atof(v11);
            }
        }
    }
}

//----- (0040B310) --------------------------------------------------------
char __thiscall sub_40B310(const char* this, char* ArgList, _DWORD* a3, const char** a4)
{
    int v5; // eax
    const char* v6; // esi
    int i; // edi
    char v8; // al
    const char* v9; // ebp
    char v10; // al
    char v11; // al
    const char* v12; // edi

    v5 = sub_40B6E0((int)this, ArgList, 1);
    v6 = (const char*)v5;
    *a3 = 0;
    *a4 = 0;
    if (v5)
    {
        for (i = 0; ; ++i)
        {
            v8 = v6[i];
            if (v8 >= 48 && v8 <= 57)
                break;
            if (v8 == 46 || v8 == 45 || !v8)
                break;
        }
        v9 = this + 16;
        sub_40A120(v6[i] != 0, "%s = %s, expected [integer, string], see %s", ArgList, v6, this + 16);
        LOBYTE(v5) = v6[i];
        if ((_BYTE)v5)
        {
            *a3 = sub_48A1BB((char*)&v6[i]);
            while (1)
            {
                v10 = v6[i];
                if ((v10 < 48 || v10 > 57) && v10 != 46 && v10 != 45 && v10)
                    break;
                ++i;
            }
            sub_40A120(v6[i] != 0, "%s = %s, expected [integer, string], see %s", ArgList, v6, v9);
            LOBYTE(v5) = v6[i];
            if ((_BYTE)v5)
            {
                while (1)
                {
                    v11 = v6[i];
                    if (v11 != 32 && v11 != 44)
                        break;
                    ++i;
                }
                v12 = &v6[i];
                sub_40A120(*v12 != 0, "%s = %s, expected [integer, string], see %s", ArgList, v6, v9);
                LOBYTE(v5) = *v12;
                if (*v12)
                    *a4 = v12;
            }
        }
    }
    return v5;
}
// 40B3E2: conditional instruction was optimized away because al.1 is in (==20|==2C)

//----- (0040B420) --------------------------------------------------------
char __thiscall sub_40B420(const char* this, char* ArgList, float* a3, const char** a4)
{
    int v5; // eax
    const char* v6; // esi
    int i; // edi
    char v8; // al
    const char* v9; // ebp
    char v10; // al
    char v11; // al
    const char* v12; // edi

    v5 = sub_40B6E0((int)this, ArgList, 1);
    v6 = (const char*)v5;
    *a3 = 0.0;
    *a4 = 0;
    if (v5)
    {
        for (i = 0; ; ++i)
        {
            v8 = v6[i];
            if (v8 >= 48 && v8 <= 57)
                break;
            if (v8 == 46 || v8 == 45 || !v8)
                break;
        }
        v9 = this + 16;
        sub_40A120(v6[i] != 0, "%s = %s, expected [float, string], see %s", ArgList, v6, this + 16);
        LOBYTE(v5) = v6[i];
        if ((_BYTE)v5)
        {
            *a3 = atof(&v6[i]);
            while (1)
            {
                v10 = v6[i];
                if ((v10 < 48 || v10 > 57) && v10 != 46 && v10 != 45 && v10)
                    break;
                ++i;
            }
            sub_40A120(v6[i] != 0, "%s = %s, expected [float, string], see %s", ArgList, v6, v9);
            LOBYTE(v5) = v6[i];
            if ((_BYTE)v5)
            {
                while (1)
                {
                    v11 = v6[i];
                    if (v11 != 32 && v11 != 44)
                        break;
                    ++i;
                }
                v12 = &v6[i];
                sub_40A120(*v12 != 0, "%s = %s, expected [float, string], see %s", ArgList, v6, v9);
                LOBYTE(v5) = *v12;
                if (*v12)
                    *a4 = v12;
            }
        }
    }
    return v5;
}
// 40B4F2: conditional instruction was optimized away because al.1 is in (==20|==2C)

//----- (0040B530) --------------------------------------------------------
char __thiscall sub_40B530(const char* this, char* ArgList, _DWORD* a3, _DWORD* a4, const char** a5)
{
    const char* v6; // esi
    char result; // al
    int i; // edi
    char v9; // al
    const char* v10; // ebp
    char v11; // al
    char v12; // al
    char v13; // al
    char v14; // al
    const char* v15; // edi

    v6 = (const char*)sub_40B6E0((int)this, ArgList, 1);
    result = (char)a5;
    *a3 = 0;
    *a4 = 0;
    *a5 = 0;
    if (v6)
    {
        for (i = 0; ; ++i)
        {
            v9 = v6[i];
            if (v9 >= 48 && v9 <= 57)
                break;
            if (v9 == 46 || v9 == 45 || !v9)
                break;
        }
        v10 = this + 16;
        sub_40A120(v6[i] != 0, "%s = %s, expected [integer, integer, string], see %s", ArgList, v6, this + 16);
        result = v6[i];
        if (result)
        {
            *a3 = sub_48A1BB((char*)&v6[i]);
            while (1)
            {
                v11 = v6[i];
                if ((v11 < 48 || v11 > 57) && v11 != 46 && v11 != 45 && v11)
                    break;
                ++i;
            }
            sub_40A120(v6[i] != 0, "%s = %s, expected [integer, integer, string], see %s", ArgList, v6, v10);
            result = v6[i];
            if (result)
            {
                while (1)
                {
                    v12 = v6[i];
                    if (v12 >= 48 && v12 <= 57)
                        break;
                    if (v12 == 46 || v12 == 45 || !v12)
                        break;
                    ++i;
                }
                sub_40A120(v6[i] != 0, "%s = %s, expected [integer, integer, string], see %s", ArgList, v6, v10);
                result = v6[i];
                if (result)
                {
                    *a4 = sub_48A1BB((char*)&v6[i]);
                    while (1)
                    {
                        v13 = v6[i];
                        if ((v13 < 48 || v13 > 57) && v13 != 46 && v13 != 45 && v13)
                            break;
                        ++i;
                    }
                    sub_40A120(v6[i] != 0, "%s = %s, expected [integer, integer, string], see %s", ArgList, v6, v10);
                    result = v6[i];
                    if (result)
                    {
                        while (1)
                        {
                            v14 = v6[i];
                            if (v14 != 32 && v14 != 44)
                                break;
                            ++i;
                        }
                        v15 = &v6[i];
                        sub_40A120(*v15 != 0, "%s = %s, expected [integer, integer, string], see %s", ArgList, v6, v10);
                        result = *v15;
                        if (*v15)
                            *a5 = v15;
                    }
                }
            }
        }
    }
    return result;
}
// 40B6A0: conditional instruction was optimized away because al.1 is in (==20|==2C)

//----- (0040B6E0) --------------------------------------------------------
int __thiscall sub_40B6E0(int this, char* String2, char a3)
{
    int v4; // eax
    unsigned int v5; // edx
    unsigned int v6; // ebx
    int i; // ebp
    int v8; // edx
    int v9; // eax
    int v10; // edi

    v4 = *(_DWORD*)(this + 4);
    if (v4)
        v5 = (*(_DWORD*)(this + 8) - v4) / 24;
    else
        v5 = 0;
    if (*(_DWORD*)(this + 280) >= v5)
        return 0;
    v6 = 0;
    for (i = 0; ; i += 12)
    {
        v8 = *(_DWORD*)(this + 4);
        v9 = *(_DWORD*)(v8 + 24 * *(_DWORD*)(this + 280) + 8);
        v10 = v8 + 24 * *(_DWORD*)(this + 280);
        if (!v9 || v6 >= (*(_DWORD*)(v10 + 12) - v9) / 12)
        {
            sub_40A120(
                0,
                "entry \"%s\" not found, see %s : %s",
                String2,
                *(const char**)(*(_DWORD*)(this + 4) + 24 * *(_DWORD*)(this + 280)),
                (const char*)(this + 16));
            return 0;
        }
        if (!_strcmpi(*(const char**)(*(_DWORD*)(v10 + 8) + i), String2)
            && !*(_BYTE*)(*(_DWORD*)(*(_DWORD*)(this + 4) + 24 * *(_DWORD*)(this + 280) + 8) + i + 8))
        {
            break;
        }
        ++v6;
    }
    if (a3)
    {
        *(_BYTE*)(*(_DWORD*)(*(_DWORD*)(this + 4) + 24 * *(_DWORD*)(this + 280) + 8) + 12 * v6 + 8) = 1;
        *(_DWORD*)(this + 284) = v6;
    }
    return *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 4) + 24 * *(_DWORD*)(this + 280) + 8) + 12 * v6 + 4);
}

//----- (0040B800) --------------------------------------------------------
int __thiscall sub_40B800(int* this)
{
    int v2; // ebx
    int i; // esi
    int result; // eax

    v2 = this[2];
    for (i = this[1]; i != v2; i += 24)
        sub_40A800(i);
    sub_4885A6((LPVOID)this[1]);
    result = 0;
    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
    return result;
}

//----- (0040B840) --------------------------------------------------------
unsigned int __thiscall sub_40B840(_DWORD* this, int a2, unsigned int a3, int a4)
{
    int v4; // esi
    unsigned int v5; // edi
    int v6; // ebx
    unsigned int v7; // ecx
    int v8; // edx
    unsigned int v9; // eax
    int v10; // ebp
    int j; // esi
    int k; // esi
    int v13; // esi
    int v14; // eax
    int v15; // ebp
    int v16; // ebp
    int m; // esi
    unsigned int result; // eax
    int v19; // ecx
    int v20; // kr00_4
    int v22; // ebp
    int v23; // esi
    unsigned int i; // edi
    int v25; // esi
    int v26; // edi
    int v27; // edi
    int v28; // ebp
    int v29; // edi
    int v30; // esi
    int v31; // edx
    unsigned int v32; // ebp
    int v33; // esi
    _DWORD* v34; // [esp+10h] [ebp-Ch]
    unsigned int v35; // [esp+14h] [ebp-8h]
    char* v36; // [esp+18h] [ebp-4h]
    int v37; // [esp+20h] [ebp+4h]
    int v38; // [esp+20h] [ebp+4h]
    int v39; // [esp+24h] [ebp+8h]

    v4 = this[2];
    v5 = a3;
    v34 = this;
    if ((this[3] - v4) / 24 >= a3)
    {
        result = (unsigned int)((unsigned __int64)(715827883LL * (v4 - a2)) >> 32) >> 31;
        if ((v4 - a2) / 24 >= a3)
        {
            if (a3)
            {
                result = 24 * a3;
                v27 = v4 - 24 * a3;
                v28 = this[2];
                if (v27 != v4)
                {
                    do
                    {
                        sub_40BBF0(v28, v27);
                        v27 += 24;
                        v28 += 24;
                    } while (v27 != v4);
                    this = v34;
                    result = 24 * a3;
                }
                v29 = this[2];
                v30 = v29 - result;
                if (a2 != v29 - result)
                {
                    do
                    {
                        v31 = *(_DWORD*)(v30 - 24);
                        v30 -= 24;
                        v29 -= 24;
                        *(_DWORD*)v29 = v31;
                        sub_40BCC0((int*)(v29 + 4), (int*)(v30 + 4));
                        *(_BYTE*)(v29 + 20) = *(_BYTE*)(v30 + 20);
                    } while (v30 != a2);
                    this = v34;
                    result = 24 * a3;
                }
                v32 = result + a2;
                v33 = a2;
                if (a2 != result + a2)
                {
                    do
                    {
                        *(_DWORD*)v33 = *(_DWORD*)a4;
                        sub_40BCC0((int*)(v33 + 4), (int*)(a4 + 4));
                        *(_BYTE*)(v33 + 20) = *(_BYTE*)(a4 + 20);
                        v33 += 24;
                    } while (v33 != v32);
                    this = v34;
                    result = 24 * a3;
                }
                this[2] += result;
            }
        }
        else
        {
            v22 = a2;
            v38 = 24 * a3;
            if (a2 != v4)
            {
                v39 = a2 + 24 * a3;
                do
                {
                    sub_40BBF0(v39, v22);
                    v22 += 24;
                    v39 += 24;
                } while (v22 != v4);
                this = v34;
            }
            v23 = this[2];
            for (i = v5 - (v23 - a2) / 24; i; --i)
            {
                sub_40BBF0(v23, a4);
                v23 += 24;
            }
            result = (unsigned int)v34;
            v25 = a2;
            v26 = v34[2];
            if (a2 != v26)
            {
                do
                {
                    *(_DWORD*)v25 = *(_DWORD*)a4;
                    sub_40BCC0((int*)(v25 + 4), (int*)(a4 + 4));
                    *(_BYTE*)(v25 + 20) = *(_BYTE*)(a4 + 20);
                    v25 += 24;
                } while (v25 != v26);
                result = (unsigned int)v34;
            }
            *(_DWORD*)(result + 8) += v38;
        }
    }
    else
    {
        v6 = this[1];
        if (!v6 || (v7 = (v4 - v6) / 24, a3 >= v7))
            v7 = a3;
        if (v6)
            v8 = (v4 - v6) / 24;
        else
            v8 = 0;
        v9 = v8 + v7;
        v35 = v8 + v7;
        if ((int)(v8 + v7) < 0)
            v9 = 0;
        v36 = (char*)operator new(24 * v9);
        v10 = (int)v36;
        for (j = v34[1]; j != a2; v10 += 24)
        {
            sub_40BBF0(v10, j);
            j += 24;
        }
        for (k = v10; a3; --a3)
        {
            sub_40BBF0(k, a4);
            k += 24;
        }
        v13 = a2;
        v14 = v10 + 24 * v5;
        v15 = v34[2];
        if (a2 != v15)
        {
            v37 = v14;
            do
            {
                sub_40BBF0(v37, v13);
                v13 += 24;
                v37 += 24;
            } while (v13 != v15);
        }
        v16 = v34[2];
        for (m = v34[1]; m != v16; m += 24)
            sub_40A800(m);
        sub_4885A6((LPVOID)v34[1]);
        result = v34[1];
        v34[3] = &v36[24 * v35];
        if (result)
        {
            v19 = v34[2];
            v34[1] = v36;
            v20 = v19 - result;
            result = (unsigned int)((unsigned __int64)(715827883LL * (int)(v19 - result)) >> 32) >> 31;
            v5 += v20 / 24;
        }
        else
        {
            v34[1] = v36;
        }
        v34[2] = &v36[24 * v5];
    }
    return result;
}

//----- (0040BB60) --------------------------------------------------------
_DWORD* __thiscall sub_40BB60(_DWORD* this, _DWORD* a2, int a3)
{
    _DWORD* result; // eax
    int v4; // ebp
    int v5; // esi
    _DWORD* v6; // ebx
    int* v7; // edi
    int v8; // ecx
    char v9; // cl
    _DWORD* v10; // edi
    int v11; // esi
    _DWORD* v12; // [esp+10h] [ebp-4h]
    int i; // [esp+1Ch] [ebp+8h]

    result = a2;
    v4 = this[2];
    v5 = a3;
    v12 = this;
    v6 = a2;
    if (a3 != v4)
    {
        v7 = a2 + 1;
        v8 = a3 - (_DWORD)a2;
        for (i = a3 - (_DWORD)a2; ; v8 = i)
        {
            *v6 = *(_DWORD*)v5;
            sub_40BCC0(v7, (int*)((char*)v7 + v8));
            v9 = *(_BYTE*)(v5 + 20);
            v5 += 24;
            *((_BYTE*)v7 + 16) = v9;
            v6 += 6;
            v7 += 6;
            if (v5 == v4)
                break;
        }
        this = v12;
        result = a2;
    }
    v10 = (_DWORD*)this[2];
    v11 = (int)v6;
    if (v6 == v10)
    {
        this[2] = v6;
    }
    else
    {
        do
        {
            sub_40A800(v11);
            v11 += 24;
        } while ((_DWORD*)v11 != v10);
        result = a2;
        v12[2] = v6;
    }
    return result;
}

//----- (0040BBF0) --------------------------------------------------------
void __cdecl sub_40BBF0(int a1, int a2)
{
    int v2; // edi
    int v3; // eax
    int v4; // edx
    int v5; // eax
    _DWORD* v6; // eax
    _DWORD* v7; // edx
    _DWORD* v8; // ecx
    _DWORD* i; // eax

    v2 = a1;
    if (a1)
    {
        *(_DWORD*)a1 = *(_DWORD*)a2;
        *(_BYTE*)(a1 + 4) = *(_BYTE*)(a2 + 4);
        v3 = *(_DWORD*)(a2 + 8);
        if (v3)
            v4 = (*(_DWORD*)(a2 + 12) - v3) / 12;
        else
            v4 = 0;
        v5 = v4;
        if (v4 < 0)
            v5 = 0;
        v6 = operator new(12 * v5);
        *(_DWORD*)(a1 + 8) = v6;
        v7 = *(_DWORD**)(a2 + 12);
        v8 = v6;
        for (i = *(_DWORD**)(a2 + 8); i != v7; v8 += 3)
        {
            if (v8)
            {
                *v8 = *i;
                v8[1] = i[1];
                v8[2] = i[2];
                v2 = a1;
            }
            i += 3;
        }
        *(_DWORD*)(v2 + 12) = v8;
        *(_DWORD*)(v2 + 16) = v8;
        *(_BYTE*)(v2 + 20) = *(_BYTE*)(a2 + 20);
    }
}

//----- (0040BCC0) --------------------------------------------------------
int* __thiscall sub_40BCC0(int* this, int* a2)
{
    int* v2; // ebp
    _DWORD* v3; // edi
    unsigned int v4; // ebx
    _DWORD* v5; // ecx
    unsigned int v6; // edx
    _DWORD* v7; // edx
    _DWORD* v8; // eax
    _DWORD* v9; // edi
    _DWORD* v10; // ebx
    int v11; // eax
    int v12; // ecx
    int* result; // eax
    unsigned int v14; // ebx
    unsigned int v15; // edx
    int v16; // edx
    _DWORD* v17; // eax
    _DWORD* v18; // edx
    _DWORD* v19; // edi
    _DWORD* v20; // ebx
    _DWORD* v21; // edi
    _DWORD* v22; // ecx
    _DWORD* j; // eax
    int v24; // eax
    int v25; // eax
    int v26; // edx
    int v27; // eax
    _DWORD* v28; // eax
    _DWORD* v29; // edx
    _DWORD* v30; // ecx
    _DWORD* i; // eax

    v2 = this;
    if (this == a2)
        return v2;
    v3 = (_DWORD*)a2[1];
    if (v3)
        v4 = (a2[2] - (int)v3) / 12;
    else
        v4 = 0;
    v5 = (_DWORD*)this[1];
    if (v5)
        v6 = (v2[2] - (int)v5) / 12;
    else
        v6 = 0;
    if (v4 <= v6)
    {
        v7 = (_DWORD*)a2[2];
        v8 = (_DWORD*)a2[1];
        if (v3 != v7)
        {
            do
            {
                v9 = v8;
                v10 = v5;
                v8 += 3;
                v5 += 3;
                *v10 = *v9;
                v10[1] = v9[1];
                v10[2] = v9[2];
            } while (v8 != v7);
            v2 = this;
        }
        v11 = a2[1];
        if (v11)
            v12 = v2[1] + 12 * ((a2[2] - v11) / 12);
        else
            v12 = v2[1];
        result = v2;
        v2[2] = v12;
        return result;
    }
    if (v3)
        v14 = (a2[2] - (int)v3) / 12;
    else
        v14 = 0;
    if (v5)
        v15 = (v2[3] - (int)v5) / 12;
    else
        v15 = 0;
    if (v14 > v15)
    {
        sub_4885A6((LPVOID)v2[1]);
        v25 = a2[1];
        if (v25)
            v26 = (a2[2] - v25) / 12;
        else
            v26 = 0;
        v27 = v26;
        if (v26 < 0)
            v27 = 0;
        v28 = operator new(12 * v27);
        v2[1] = (int)v28;
        v29 = (_DWORD*)a2[2];
        v30 = v28;
        for (i = (_DWORD*)a2[1]; i != v29; v30 += 3)
        {
            if (v30)
            {
                *v30 = *i;
                v30[1] = i[1];
                v30[2] = i[2];
            }
            i += 3;
        }
        v2[2] = (int)v30;
        v2[3] = (int)v30;
        return v2;
    }
    if (v5)
        v16 = (v2[2] - (int)v5) / 12;
    else
        v16 = 0;
    v17 = (_DWORD*)a2[1];
    v18 = &v3[3 * v16];
    if (v3 != v18)
    {
        do
        {
            v19 = v17;
            v20 = v5;
            v17 += 3;
            v5 += 3;
            *v20 = *v19;
            v20[1] = v19[1];
            v20[2] = v19[2];
        } while (v17 != v18);
        v2 = this;
    }
    v21 = (_DWORD*)a2[2];
    v22 = (_DWORD*)v2[2];
    for (j = v18; j != v21; v22 += 3)
    {
        if (v22)
        {
            *v22 = *j;
            v22[1] = j[1];
            v2 = this;
            v22[2] = j[2];
        }
        j += 3;
    }
    v24 = a2[1];
    if (v24)
        v2[2] = v2[1] + 12 * ((a2[2] - v24) / 12);
    else
        v2[2] = v2[1];
    return v2;
}

//----- (0040BF40) --------------------------------------------------------
int sub_40BF40()
{
    sub_40BF50();
    return atexit(sub_40BF70);
}

//----- (0040BF50) --------------------------------------------------------
_DWORD* sub_40BF50()
{
    return sub_40BF80(dword_4F5B08);
}
// 4F5B08: using guessed type _DWORD dword_4F5B08[80];

//----- (0040BF70) --------------------------------------------------------
void __cdecl sub_40BF70()
{
    sub_40BFD0(&unk_4F5B08);
}
// 40BFD0: using guessed type int __thiscall sub_40BFD0(_DWORD);

//----- (0040BF80) --------------------------------------------------------
_DWORD* __thiscall sub_40BF80(_DWORD* this)
{
    this[1] = 0;
    *this = 0;
    this[2] = 0;
    this[3] = 0;
    memset(this + 5, 0, 0x100u);
    this[69] = 0;
    this[70] = 0;
    this[71] = 0;
    this[72] = 0;
    return this;
}

//----- (0040BFE0) --------------------------------------------------------
_DWORD* __thiscall sub_40BFE0(int this, _DWORD* a2, int a3, int a4, char a5)
{
    int v6; // eax
    _DWORD* v7; // esi
    char* v8; // eax
    char* v9; // eax
    char* v10; // edx
    int v12; // [esp+Ch] [ebp-1Ch] BYREF
    char* Source; // [esp+10h] [ebp-18h]
    int v14; // [esp+14h] [ebp-14h] BYREF
    char* v15; // [esp+18h] [ebp-10h]
    int v16; // [esp+24h] [ebp-4h]

    v12 = 0;
    v6 = DirectInputCreateA(a3, 768, this + 8, 0);
    if (v6 >= 0)
    {
        sub_40C130((_DWORD**)this, &v12, a4, a5);
        v16 = 0;
        if (v12)
        {
            v7 = a2;
            *a2 = v12;
            v8 = Source;
            if (Source)
            {
                a2[1] = _strdup(Source);
                v8 = Source;
            }
            sub_488CEE(v8);
        }
        else
        {
            sub_4229D0(aInitializedKey);
            sub_40C1F0(this, &v14, a4, a5);
            LOBYTE(v16) = 1;
            if (v14)
            {
                v7 = a2;
                *a2 = v14;
                v9 = v15;
                if (v15)
                {
                    a2[1] = _strdup(v15);
                    v9 = v15;
                }
                sub_488CEE(v9);
                sub_488CEE(Source);
            }
            else
            {
                sub_4229D0(aInitializedMou);
                v10 = v15;
                *(_BYTE*)(this + 292) = 1;
                v7 = a2;
                *a2 = 0;
                a2[1] = 0;
                sub_488CEE(v10);
                sub_488CEE(Source);
            }
        }
    }
    else
    {
        v7 = a2;
        sub_403A30(a2, v6, aCanTRegisterWi);
    }
    return v7;
}

//----- (0040C130) --------------------------------------------------------
_DWORD* __thiscall sub_40C130(_DWORD** this, _DWORD* a2, int a3, char a4)
{
    _DWORD* v4; // esi
    int v5; // eax
    _DWORD* result; // eax
    int v7; // esi
    char* v8; // [esp+14h] [ebp-24h]
    _DWORD v9[5]; // [esp+24h] [ebp-14h] BYREF

    v4 = this + 3;
    v5 = (*(int(__stdcall**)(_DWORD*, void*, _DWORD**, _DWORD))(*this[2] + 12))(this[2], &unk_499E24, this + 3, 0);
    if (v5 < 0)
    {
        v8 = aCanTObtainKeyb;
    LABEL_7:
        sub_403A30(a2, v5, v8);
        return a2;
    }
    v5 = (*(int(__stdcall**)(_DWORD, void*))(*(_DWORD*)*v4 + 44))(*v4, &unk_499D94);
    if (v5 < 0)
    {
        v8 = aCanTSetDirecti;
        goto LABEL_7;
    }
    v5 = (*(int(__stdcall**)(_DWORD, int, int))(*(_DWORD*)*v4 + 52))(*v4, a3, 6 - (a4 != 0));
    if (v5 < 0)
    {
        v8 = aCanTSetKeyboar;
        goto LABEL_7;
    }
    v7 = *v4;
    v9[0] = 20;
    v9[1] = 16;
    v9[2] = 0;
    v9[3] = 0;
    v9[4] = 16;
    (*(void(__stdcall**)(int, int, _DWORD*))(*(_DWORD*)v7 + 24))(v7, 1, v9);
    result = a2;
    *a2 = 0;
    a2[1] = 0;
    return result;
}

//----- (0040C1F0) --------------------------------------------------------
_DWORD* __thiscall sub_40C1F0(int this, _DWORD* a2, int a3, char a4)
{
    _DWORD* v5; // esi
    int v6; // eax
    _DWORD* result; // eax
    char* v8; // [esp+18h] [ebp-14h]
    _DWORD v9[2]; // [esp+24h] [ebp-8h] BYREF

    v9[0] = 0;
    v5 = (_DWORD*)(this + 16);
    v6 = (*(int(__stdcall**)(_DWORD, void*, int, _DWORD))(**(_DWORD**)(this + 8) + 12))(
        *(_DWORD*)(this + 8),
        &unk_499E34,
        this + 16,
        0);
    if (v6 < 0)
    {
        v8 = aCouldnTObtainM;
    LABEL_7:
        sub_403A30(a2, v6, v8);
        return a2;
    }
    v6 = (*(int(__stdcall**)(_DWORD, void*))(*(_DWORD*)*v5 + 44))(*v5, &unk_499DAC);
    if (v6 < 0)
    {
        v8 = aCouldnTSetMous;
        goto LABEL_7;
    }
    v6 = (*(int(__stdcall**)(_DWORD, int, int))(*(_DWORD*)*v5 + 52))(*v5, a3, 6 - (a4 != 0));
    if (v6 < 0)
    {
        v8 = aCouldnTSetCoop;
        goto LABEL_7;
    }
    sub_40C4C0((_DWORD*)this, v9);
    sub_488CEE((LPVOID)v9[1]);
    result = a2;
    *a2 = 0;
    a2[1] = 0;
    return result;
}

//----- (0040C2B0) --------------------------------------------------------
_DWORD* __thiscall sub_40C2B0(int this, _DWORD* a2)
{
    _DWORD* result; // eax
    int v4; // [esp+4h] [ebp-8h] BYREF
    LPVOID lpMem; // [esp+8h] [ebp-4h]

    v4 = 0;
    sub_40C310((_DWORD*)this, &v4);
    sub_488CEE(lpMem);
    sub_40C4C0((_DWORD*)this, &v4);
    sub_488CEE(lpMem);
    result = a2;
    *(_BYTE*)(this + 292) = 0;
    *a2 = 0;
    a2[1] = 0;
    return result;
}

//----- (0040C310) --------------------------------------------------------
_DWORD* __thiscall sub_40C310(_DWORD* this, _DWORD* a2)
{
    int v3; // eax
    void* v4; // edi
    int v5; // eax
    int v6; // eax
    int v7; // esi
    _DWORD* result; // eax
    int v9; // eax
    int* v10; // edi
    int v11; // esi
    int v12; // ebx
    bool v13; // zf
    unsigned int v14; // [esp+20h] [ebp-10Ch] BYREF
    unsigned int v15; // [esp+24h] [ebp-108h]
    int v16; // [esp+28h] [ebp-104h]
    _BYTE v17[256]; // [esp+2Ch] [ebp-100h] BYREF

    v3 = this[3];
    v16 = 0;
    if (v3)
    {
        v4 = this + 5;
        while (1)
        {
            v5 = (*(int(__stdcall**)(_DWORD, int, _DWORD*))(*(_DWORD*)this[3] + 36))(this[3], 256, this + 5);
            if (v5 < 0)
                break;
            if (!v5)
            {
                v6 = this[3];
                v14 = 16;
                if ((*(int(__stdcall**)(int, int, _BYTE*, unsigned int*, _DWORD))(*(_DWORD*)v6 + 40))(
                    v6,
                    16,
                    v17,
                    &v14,
                    0))
                {
                    sub_4229D0(aKeyboardLost);
                    memset(v4, 0, 0x100u);
                    v7 = (*(int(__stdcall**)(_DWORD))(*(_DWORD*)this[3] + 28))(this[3]);
                    if (v7 < 0)
                    {
                        sub_4229D0(aCouldnTAcquire);
                        sub_403A30(a2, v7, aCouldnTAcquire);
                        return a2;
                    }
                    sub_4229D0(aRecquiredKeybo);
                }
                else if (*((_BYTE*)this + 292))
                {
                    memset(v4, 0, 0x100u);
                }
                else
                {
                    v15 = 0;
                    if (v14)
                    {
                        v10 = (int*)v17;
                        do
                        {
                            v11 = *this;
                            v12 = *v10;
                            v13 = *this == 0;
                            LOBYTE(v16) = (v10[1] & 0x80) != 0;
                            if (!v13)
                            {
                                do
                                {
                                    if (!(*(int(__cdecl**)(_DWORD, int, int))v11)(*(_DWORD*)(v11 + 4), v12, v16))
                                        break;
                                    v11 = *(_DWORD*)(v11 + 8);
                                } while (v11);
                            }
                            v10 += 4;
                            ++v15;
                        } while (v15 < v14);
                    }
                }
                goto LABEL_20;
            }
        }
        memset(v4, 0, 0x100u);
        v9 = (*(int(__stdcall**)(_DWORD))(*(_DWORD*)this[3] + 28))(this[3]);
        if (v9 < 0)
        {
            sub_403A30(a2, v9, aCouldnTAcquire);
            return a2;
        }
        sub_4229D0(aReacquiredKeyb);
    }
LABEL_20:
    result = a2;
    *a2 = 0;
    a2[1] = 0;
    return result;
}

//----- (0040C4C0) --------------------------------------------------------
_DWORD* __thiscall sub_40C4C0(_DWORD* this, _DWORD* a2)
{
    int v3; // ebp
    int v4; // eax
    _DWORD* v5; // ebx
    int v6; // edi
    _DWORD* result; // eax
    char v8; // cl
    int v9; // edi
    int v10; // ebx
    int v11; // ecx
    int v12; // edx
    char v13; // [esp+13h] [ebp-1Dh]
    _DWORD v14[2]; // [esp+14h] [ebp-1Ch] BYREF
    _DWORD* v15; // [esp+1Ch] [ebp-14h]
    _DWORD v16[4]; // [esp+20h] [ebp-10h] BYREF

    v3 = 0;
    v4 = this[4];
    v5 = this + 69;
    this[71] = 0;
    this[70] = 0;
    v15 = this + 69;
    this[69] = 0;
    if (v4)
    {
        v13 = 0;
        if ((*(int(__stdcall**)(_DWORD, int, _DWORD*))(*(_DWORD*)this[4] + 36))(this[4], 16, v16))
        {
            v13 = 1;
            v6 = (*(int(__stdcall**)(_DWORD))(*(_DWORD*)this[4] + 28))(this[4]);
            this[72] = 0;
            *v5 = 0;
            v5[1] = 0;
            v5[2] = 0;
            if (v6 < 0)
            {
                sub_403A30(a2, v6, aCanTAcquireMou);
                return a2;
            }
            sub_4229D0(aReacquiredMous);
            sub_40C4C0(v14);
            sub_488CEE((LPVOID)v14[1]);
        }
        do
        {
            v8 = *((_BYTE*)this + v3 + 288);
            LOBYTE(v14[0]) = *((_BYTE*)&v16[3] + v3) >> 7;
            if (LOBYTE(v14[0]) != v8)
            {
                *((_BYTE*)this + v3 + 288) = v14[0];
                v9 = this[1];
                if (v9)
                {
                    v10 = v14[0];
                    do
                    {
                        if (!(*(int(__cdecl**)(_DWORD, int, int))v9)(*(_DWORD*)(v9 + 4), v3, v10))
                            break;
                        v9 = *(_DWORD*)(v9 + 8);
                    } while (v9);
                    v5 = v15;
                }
            }
            ++v3;
        } while (v3 < 4);
        if (!v13)
        {
            v11 = v16[1];
            v12 = v16[2];
            *v5 = v16[0];
            this[70] = v11;
            this[71] = v12;
        }
    }
    result = a2;
    *a2 = 0;
    a2[1] = 0;
    return result;
}
// 40C561: conditional instruction was optimized away because edi.4>=0
// 40C565: conditional instruction was optimized away because edi.4>=0

//----- (0040C630) --------------------------------------------------------
_DWORD* __thiscall sub_40C630(_DWORD* this, int a2, int a3)
{
    _DWORD* result; // eax

    result = operator new(0xCu);
    *result = a2;
    result[1] = a3;
    result[2] = *this;
    *this = result;
    return result;
}

//----- (0040C660) --------------------------------------------------------
_DWORD* __thiscall sub_40C660(_DWORD* this, int a2, int a3)
{
    _DWORD* result; // eax

    result = operator new(0xCu);
    *result = a2;
    result[1] = a3;
    result[2] = this[1];
    this[1] = result;
    return result;
}

//----- (0040C690) --------------------------------------------------------
int __thiscall sub_40C690(_DWORD* this)
{
    int v2; // eax
    int v3; // eax
    int result; // eax

    v2 = this[3];
    if (v2)
    {
        (*(void(__stdcall**)(int))(*(_DWORD*)v2 + 32))(v2);
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)this[3] + 8))(this[3]);
        this[3] = 0;
    }
    v3 = this[4];
    if (v3)
    {
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)v3 + 32))(this[4]);
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)this[4] + 8))(this[4]);
        this[4] = 0;
    }
    result = this[2];
    if (result)
    {
        result = (*(int(__stdcall**)(_DWORD))(*(_DWORD*)result + 8))(this[2]);
        this[2] = 0;
    }
    return result;
}

//----- (0040C6F0) --------------------------------------------------------
bool __cdecl sub_40C6F0(float* a1, float* a2, float* a3)
{
    unsigned __int8 v6; // c0
    unsigned __int8 v7; // c3
    bool result; // al
    unsigned __int8 v10; // c0
    unsigned __int8 v11; // c3
    double v12; // st7
    double v13; // st5
    double v14; // st4
    double v15; // st3
    unsigned __int8 v17; // c0
    unsigned __int8 v18; // c3
    float v19; // [esp+4h] [ebp-1Ch]
    int v20; // [esp+24h] [ebp+4h]
    float v21; // [esp+28h] [ebp+8h]
    int v22; // [esp+2Ch] [ebp+Ch]
    float v24; // [esp+30h] [ebp+10h]
    float v25; // [esp+30h] [ebp+10h]

    *(float*)&v22 = *a3 - *a1;
    v19 = a3[1] - a1[1];
    *(float*)&v20 = a3[2] - a1[2];
    if (v6 | v7)
        return 1;
    if (v10 | v11)
        return 1;
    v12 = a2[2] - a1[2];
    v13 = a2[1] - a1[1];
    v14 = *a2 - *a1;
    v15 = v14 * v14 + v13 * v13 + v12 * v12;
    result = 0;
    if (v15 != 0.0)
    {
        v21 = v13;
        v24 = v14;
        v25 = (v24 * *(float*)&v22 + v12 * *(float*)&v20 + v21 * v19) / v15;
        if (v25 >= 0.0 && v25 <= 1.0 && v17 | v18)
            return 1;
    }
    return result;
}
// 40C73E: variable 'v6' is possibly undefined
// 40C73E: variable 'v7' is possibly undefined
// 40C77A: variable 'v10' is possibly undefined
// 40C77A: variable 'v11' is possibly undefined
// 40C8F4: variable 'v17' is possibly undefined
// 40C8F4: variable 'v18' is possibly undefined

//----- (0040C910) --------------------------------------------------------
char __cdecl sub_40C910(float* a1, float* a2, float* a3, float* a4, float* a5, float* a6)
{
    double v6; // st7
    float v7; // eax
    double v8; // st7
    float* v9; // ecx
    char result; // al
    double v11; // st7
    double v12; // st6
    float v13; // [esp+4h] [ebp-Ch] BYREF
    float v14; // [esp+8h] [ebp-8h]
    float v15; // [esp+Ch] [ebp-4h]

    v13 = *a2;
    v6 = v13 - *a1;
    v14 = a2[1];
    v7 = a2[2];
    v13 = v6;
    v8 = v14 - a1[1];
    v15 = v7;
    v14 = v8;
    v15 = v7 - a1[2];
    if (!sub_40C9E0(a1, &v13, a3, a4, a5, (float*)&a2) || *(float*)&a2 < 0.0 || *(float*)&a2 > 1.0)
        return 0;
    v9 = a6;
    result = 1;
    if (a6)
    {
        v11 = v15 * *(float*)&a2 + a1[2];
        v12 = v14 * *(float*)&a2 + a1[1];
        *a6 = v13 * *(float*)&a2 + *a1;
        v9[1] = v12;
        v9[2] = v11;
    }
    return result;
}

//----- (0040C9E0) --------------------------------------------------------
char __cdecl sub_40C9E0(float* a1, float* a2, float* a3, float* a4, float* a5, float* a6)
{
    double v7; // st7
    double v8; // st6
    double v9; // st5
    double v10; // st4
    char result; // al
    double v12; // st4
    double v13; // st7
    double v14; // st7
    float v15; // [esp+0h] [ebp-30h]
    float v16; // [esp+4h] [ebp-2Ch]
    float v17; // [esp+8h] [ebp-28h]
    float v18; // [esp+Ch] [ebp-24h]
    float v19; // [esp+10h] [ebp-20h]
    float v20; // [esp+14h] [ebp-1Ch]
    float v21; // [esp+18h] [ebp-18h]
    float v22; // [esp+1Ch] [ebp-14h]
    float v23; // [esp+20h] [ebp-10h]
    float v24; // [esp+24h] [ebp-Ch]
    float v25; // [esp+28h] [ebp-8h]
    float v26; // [esp+2Ch] [ebp-4h]
    float v27; // [esp+3Ch] [ebp+Ch]
    float v28; // [esp+40h] [ebp+10h]

    v18 = *a4 - *a3;
    v19 = a4[1] - a3[1];
    v20 = a4[2] - a3[2];
    v21 = *a5 - *a3;
    v22 = a5[1] - a3[1];
    v23 = a5[2] - a3[2];
    v7 = v23 * a2[1] - v22 * a2[2];
    v8 = v21 * a2[2] - v23 * *a2;
    v9 = v22 * *a2 - v21 * a2[1];
    v10 = v9 * v20 + v8 * v19 + v18 * v7;
    if (v10 > -0.0000099999997 && v10 < 0.0000099999997)
        return 0;
    v27 = 1.0 / v10;
    v15 = *a1 - *a3;
    v16 = a1[1] - a3[1];
    v12 = a1[2] - a3[2];
    v17 = v12;
    v28 = (v12 * v9 + v16 * v8 + v15 * v7) * v27;
    if (v28 < 0.0)
        return 0;
    if (v28 > 1.0)
        return 0;
    v24 = v16 * v20 - v17 * v19;
    v25 = v17 * v18 - v20 * v15;
    v13 = v19 * v15 - v16 * v18;
    v26 = v13;
    v14 = (v13 * a2[2] + v25 * a2[1] + v24 * *a2) * v27;
    if (v14 < 0.0 || v14 + v28 > 1.0)
        return 0;
    result = 1;
    *a6 = (v25 * v22 + v26 * v23 + v24 * v21) * v27;
    return result;
}

//----- (0040CC10) --------------------------------------------------------
BOOL __cdecl sub_40CC10(float* a1, float* a2, float* a3, float* a4)
{
    return *a1 <= (double)*a4
        && *a2 >= (double)*a3
        && a1[1] <= (double)a4[1]
        && a2[1] >= (double)a3[1]
        && a1[2] <= (double)a4[2]
        && a2[2] >= (double)a3[2];
}

//----- (0040CC80) --------------------------------------------------------
BOOL __cdecl sub_40CC80()
{
    char v1; // c0

    return v1 == 0;
}
// 40CCC3: variable 'v1' is possibly undefined

//----- (0040CCD0) --------------------------------------------------------
char __cdecl sub_40CCD0(float* a1, float a2, float* a3, float* a4, float* a5, float* a6, float* a7)
{
    double v8; // st7
    double v9; // st6
    double v10; // st5
    double v11; // st7
    unsigned __int8 v13; // c0
    unsigned __int8 v14; // c3
    double v15; // st7
    long double v16; // st6
    double v17; // st6
    double v18; // st7
    double v19; // st7
    double v20; // st6
    double v21; // rt0
    double v22; // st6
    double v23; // st7
    double v24; // st6
    double v26; // st7
    char v27; // c0
    double v28; // st7
    double v29; // st6
    double v30; // st7
    double v31; // st6
    double v32; // st6
    double v33; // st7
    double v34; // st6
    char result; // al
    float v36; // [esp+0h] [ebp-34h]
    float v37; // [esp+4h] [ebp-30h]
    float v38; // [esp+8h] [ebp-2Ch]
    float v39; // [esp+Ch] [ebp-28h]
    float v40; // [esp+Ch] [ebp-28h]
    float v41; // [esp+Ch] [ebp-28h]
    float v42; // [esp+Ch] [ebp-28h]
    float v43; // [esp+10h] [ebp-24h]
    float v44; // [esp+10h] [ebp-24h]
    float v45; // [esp+14h] [ebp-20h]
    float v46; // [esp+14h] [ebp-20h]
    float v47; // [esp+14h] [ebp-20h]
    float v48; // [esp+18h] [ebp-1Ch]
    float v49; // [esp+18h] [ebp-1Ch]
    float v50; // [esp+18h] [ebp-1Ch]
    float v51; // [esp+1Ch] [ebp-18h]
    float v52; // [esp+1Ch] [ebp-18h]
    float v53; // [esp+20h] [ebp-14h]
    float v54; // [esp+20h] [ebp-14h]
    float v55; // [esp+24h] [ebp-10h]
    float v56; // [esp+24h] [ebp-10h]
    float v57; // [esp+28h] [ebp-Ch]
    float v58; // [esp+2Ch] [ebp-8h]
    float v59; // [esp+30h] [ebp-4h]
    int v60; // [esp+38h] [ebp+4h]
    int v61; // [esp+40h] [ebp+Ch]
    float v62; // [esp+40h] [ebp+Ch]
    int v63; // [esp+44h] [ebp+10h]
    float v64; // [esp+44h] [ebp+10h]
    int v65; // [esp+48h] [ebp+14h]

    v51 = *a4 - *a3;
    v53 = a4[1] - a3[1];
    v55 = a4[2] - a3[2];
    v43 = *a5 - *a3;
    v45 = a5[1] - a3[1];
    v48 = a5[2] - a3[2];
    v8 = *a3 - *a1;
    v9 = a3[1] - a1[1];
    v10 = a3[2] - a1[2];
    v37 = v55 * v55 + v53 * v53 + v51 * v51;
    v38 = v48 * v55 + v45 * v53 + v43 * v51;
    v36 = v48 * v48 + v45 * v45 + v43 * v43;
    *(float*)&v65 = v10 * v55 + v9 * v53 + v8 * v51;
    *(float*)&v61 = v10 * v48 + v9 * v45 + v8 * v43;
    *(float*)&v60 = v8 * v8 + v10 * v10 + v9 * v9;
    v39 = fabs(v36 * v37 - v38 * v38);
    *(float*)&v63 = *(float*)&v61 * v38 - *(float*)&v65 * v36;
    v11 = *(float*)&v65 * v38 - *(float*)&v61 * v37;
    if (!(v13 | v14))
    {
        if (*(float*)&v63 >= 0.0)
        {
            v26 = *(float*)&v61;
            if (v27)
            {
                v28 = v26 + v38;
                v29 = *(float*)&v65 + v37;
                v41 = v29;
                if (v29 <= v28)
                {
                    v15 = 0.0;
                    if (v41 <= 0.0)
                        goto LABEL_7;
                    if (*(float*)&v65 >= 0.0)
                    {
                        v16 = *(float*)&v60;
                        v64 = 0.0;
                        goto LABEL_43;
                    }
                    goto LABEL_34;
                }
                v30 = v41 - v28;
                v31 = v37 - (v38 + v38) + v36;
                if (v30 >= v31)
                {
                    v15 = 1.0;
                    v64 = 0.0;
                    v16 = *(float*)&v61 + *(float*)&v61 + *(float*)&v60 + v36;
                    goto LABEL_43;
                }
                v15 = v30 / v31;
                v64 = 1.0 - v15;
                goto LABEL_41;
            }
            v33 = v26 + v36 - v38 - *(float*)&v65;
            v42 = v33;
            if (v33 <= 0.0)
            {
                v64 = 0.0;
                goto LABEL_13;
            }
            v23 = v37 - (v38 + v38) + v36;
            if (v42 < v23)
            {
                v22 = v42;
                goto LABEL_40;
            }
        }
        else
        {
            v40 = *(float*)&v65 + v38;
            v18 = *(float*)&v61 + v36;
            if (v18 <= v40)
            {
                v64 = 0.0;
                if (v18 <= 0.0)
                    goto LABEL_13;
                if (*(float*)&v61 >= 0.0)
                {
                    v15 = 0.0;
                    v16 = *(float*)&v60;
                    goto LABEL_43;
                }
                goto LABEL_25;
            }
            v19 = v18 - v40;
            v20 = v37 - (v38 + v38) + v36;
            if (v19 < v20)
            {
                v21 = v20;
                v22 = v19;
                v23 = v21;
            LABEL_40:
                v64 = v22 / v23;
                v15 = 1.0 - v64;
                goto LABEL_41;
            }
        }
        v15 = 0.0;
        v64 = 1.0;
        v16 = *(float*)&v65 + *(float*)&v65 + *(float*)&v60 + v37;
        goto LABEL_43;
    }
    if (*(float*)&v63 >= 0.0)
    {
        if (v11 < 0.0)
        {
            v15 = 0.0;
            if (*(float*)&v65 >= 0.0)
            {
                v16 = *(float*)&v60;
                v64 = 0.0;
                goto LABEL_43;
            }
            goto LABEL_6;
        }
        v17 = 1.0 / v39;
        v64 = v17 * *(float*)&v63;
        v15 = v11 * v17;
    LABEL_41:
        v24 = (v15 * v36 + v64 * v38 + *(float*)&v61 + *(float*)&v61) * v15
            + (v15 * v38 + v64 * v37 + *(float*)&v65 + *(float*)&v65) * v64;
        goto LABEL_42;
    }
    if (v11 >= 0.0)
    {
        v64 = 0.0;
        if (*(float*)&v61 >= 0.0)
        {
            v15 = 0.0;
            v16 = *(float*)&v60;
            goto LABEL_43;
        }
    }
    else
    {
        if (*(float*)&v65 < 0.0)
        {
            v15 = 0.0;
        LABEL_6:
            if (-*(float*)&v65 >= v37)
            {
            LABEL_7:
                v64 = 1.0;
                v16 = *(float*)&v65 + *(float*)&v65 + *(float*)&v60 + v37;
                goto LABEL_43;
            }
        LABEL_34:
            v32 = -(*(float*)&v65 / v37);
            v64 = v32;
            v24 = v32 * *(float*)&v65;
            goto LABEL_42;
        }
        v64 = 0.0;
        if (*(float*)&v61 >= 0.0)
        {
            v15 = 0.0;
            v16 = *(float*)&v60;
            goto LABEL_43;
        }
    }
    if (-*(float*)&v61 >= v36)
    {
    LABEL_13:
        v15 = 1.0;
        v16 = *(float*)&v61 + *(float*)&v61 + *(float*)&v60 + v36;
        goto LABEL_43;
    }
LABEL_25:
    v15 = -(*(float*)&v61 / v36);
    v24 = v15 * *(float*)&v61;
LABEL_42:
    v16 = v24 + *(float*)&v60;
LABEL_43:
    v34 = fabs(v16);
    if (v34 >= a2 * a2)
        return 0;
    v59 = v48;
    v57 = v43 * v15;
    v58 = v45 * v15;
    v46 = v53 * v64;
    v49 = v55 * v64;
    v52 = *a3 + v51 * v64;
    v54 = a3[1] + v46;
    v56 = a3[2] + v49;
    v44 = v52 + v57;
    *a6 = v44;
    v47 = v54 + v58;
    a6[1] = v47;
    v50 = v56 + v15 * v59;
    a6[2] = v50;
    result = 1;
    v62 = v34;
    *a7 = 1.0 - sqrt(v62) / a2;
    return result;
}
// 40CE79: variable 'v13' is possibly undefined
// 40CE79: variable 'v14' is possibly undefined
// 40D067: variable 'v27' is possibly undefined

//----- (0040D330) --------------------------------------------------------
bool __cdecl sub_40D330(float* a1, float* a2, float* a3, float* a4, float* a5, float* a6)
{
    float v7; // [esp+8h] [ebp-60h]
    float v8; // [esp+Ch] [ebp-5Ch]
    float v9; // [esp+10h] [ebp-58h]
    float v10; // [esp+14h] [ebp-54h]
    float v11; // [esp+18h] [ebp-50h]
    float v12; // [esp+1Ch] [ebp-4Ch]
    float v13; // [esp+20h] [ebp-48h]
    float v14; // [esp+24h] [ebp-44h]
    float v15; // [esp+28h] [ebp-40h]
    float v16; // [esp+2Ch] [ebp-3Ch]
    float v17; // [esp+30h] [ebp-38h]
    float v18; // [esp+34h] [ebp-34h]
    float v19; // [esp+38h] [ebp-30h]
    float v20; // [esp+3Ch] [ebp-2Ch]
    float v21; // [esp+40h] [ebp-28h]
    float v22; // [esp+44h] [ebp-24h]
    float v23; // [esp+48h] [ebp-20h]
    float v24; // [esp+4Ch] [ebp-1Ch]
    float v25; // [esp+50h] [ebp-18h]
    float v26; // [esp+54h] [ebp-14h]
    float v27; // [esp+58h] [ebp-10h]
    float v28; // [esp+5Ch] [ebp-Ch]
    float v29; // [esp+60h] [ebp-8h]
    float v30; // [esp+64h] [ebp-4h]

    v7 = *a4 - *a1;
    v8 = a4[1] - a1[1];
    v9 = a4[2] - a1[2];
    v22 = a5[2] * a2[2] + a5[1] * a2[1] + *a2 * *a5;
    v23 = a5[5] * a2[2] + a5[4] * a2[1] + *a2 * a5[3];
    v24 = a5[8] * a2[2] + a5[7] * a2[1] + *a2 * a5[6];
    v10 = v9 * a2[2] + v8 * a2[1] + v7 * *a2;
    v13 = fabs(v22);
    v14 = fabs(v23);
    v15 = fabs(v24);
    if (v15 * a6[2] + v14 * a6[1] + v13 * *a6 + *a3 < fabs(v10))
        return 0;
    v25 = a2[5] * a5[2] + a2[4] * a5[1] + a2[3] * *a5;
    v26 = a5[5] * a2[5] + a5[4] * a2[4] + a2[3] * a5[3];
    v27 = a5[8] * a2[5] + a5[7] * a2[4] + a5[6] * a2[3];
    v11 = v9 * a2[5] + v8 * a2[4] + v7 * a2[3];
    v16 = fabs(v25);
    v17 = fabs(v26);
    v18 = fabs(v27);
    if (v18 * a6[2] + v17 * a6[1] + v16 * *a6 + a3[1] < fabs(v11))
        return 0;
    v28 = a2[8] * a5[2] + a2[7] * a5[1] + a2[6] * *a5;
    v29 = a5[5] * a2[8] + a5[4] * a2[7] + a5[3] * a2[6];
    v30 = a5[8] * a2[8] + a5[7] * a2[7] + a2[6] * a5[6];
    v12 = v9 * a2[8] + v8 * a2[7] + v7 * a2[6];
    v19 = fabs(v28);
    v20 = fabs(v29);
    v21 = fabs(v30);
    if (v21 * a6[2] + v20 * a6[1] + v19 * *a6 + a3[2] < fabs(v12))
        return 0;
    if (v19 * a3[2] + v16 * a3[1] + v13 * *a3 + *a6 < fabs(v9 * a5[2] + v8 * a5[1] + v7 * *a5))
        return 0;
    if (v20 * a3[2] + v17 * a3[1] + v14 * *a3 + a6[1] < fabs(v9 * a5[5] + v8 * a5[4] + v7 * a5[3]))
        return 0;
    if (v21 * a3[2] + v18 * a3[1] + v15 * *a3 + a6[2] < fabs(v9 * a5[8] + v8 * a5[7] + v7 * a5[6]))
        return 0;
    if (v14 * a6[2] + v15 * a6[1] + v19 * a3[1] + v16 * a3[2] < fabs(v12 * v25 - v28 * v11))
        return 0;
    if (v20 * a3[1] + v17 * a3[2] + v13 * a6[2] + v15 * *a6 < fabs(v12 * v26 - v29 * v11))
        return 0;
    if (v13 * a6[1] + v14 * *a6 + v21 * a3[1] + v18 * a3[2] < fabs(v12 * v27 - v30 * v11))
        return 0;
    if (v17 * a6[2] + v18 * a6[1] + v19 * *a3 + v13 * a3[2] < fabs(v28 * v10 - v12 * v22))
        return 0;
    if (v20 * *a3 + v14 * a3[2] + v16 * a6[2] + v18 * *a6 < fabs(v29 * v10 - v12 * v23))
        return 0;
    if (v16 * a6[1] + v17 * *a6 + v21 * *a3 + v15 * a3[2] < fabs(v30 * v10 - v12 * v24))
        return 0;
    if (v16 * *a3 + v13 * a3[1] + v20 * a6[2] + v21 * a6[1] < fabs(v11 * v22 - v25 * v10))
        return 0;
    if (v19 * a6[2] + v21 * *a6 + v17 * *a3 + v14 * a3[1] >= fabs(v11 * v23 - v26 * v10))
        return v18 * *a3 + v15 * a3[1] + v19 * a6[1] + v20 * *a6 >= fabs(v11 * v24 - v27 * v10);
    return 0;
}

//----- (0040D900) --------------------------------------------------------
bool __cdecl sub_40D900(float* a1, float a2, float* a3, float* a4, float* a5)
{
    float v5; // edx
    float v6; // eax
    float* v7; // ebx
    double v8; // st7
    float v9; // ebp
    double v10; // st6
    float v11; // ebp
    float v12; // edx
    double v13; // st7
    float v14; // edx
    double v16; // st7
    float v17; // eax
    double v18; // st7
    float v19; // edx
    float v20; // eax
    float v21; // ecx
    double v22; // st7
    float v23; // eax
    float v24; // ecx
    double v25; // st7
    float v26; // eax
    float v27; // ecx
    float v28; // edx
    float v29; // eax
    double v30; // st7
    float v31; // ecx
    double v32; // st7
    float v33; // edx
    float v34; // eax
    float* v35; // eax
    float* v36; // eax
    float v37; // [esp+0h] [ebp-74h]
    float v38; // [esp+0h] [ebp-74h]
    float v39; // [esp+0h] [ebp-74h]
    float v40; // [esp+0h] [ebp-74h]
    float v41; // [esp+0h] [ebp-74h]
    float v42; // [esp+0h] [ebp-74h]
    float v43; // [esp+14h] [ebp-60h] BYREF
    float v44; // [esp+18h] [ebp-5Ch]
    float v45; // [esp+1Ch] [ebp-58h]
    float v46; // [esp+20h] [ebp-54h] BYREF
    float v47; // [esp+24h] [ebp-50h]
    float v48; // [esp+28h] [ebp-4Ch]
    float v49; // [esp+2Ch] [ebp-48h] BYREF
    float v50; // [esp+30h] [ebp-44h]
    float v51; // [esp+34h] [ebp-40h]
    float v52; // [esp+38h] [ebp-3Ch] BYREF
    float v53; // [esp+3Ch] [ebp-38h]
    float v54; // [esp+40h] [ebp-34h]
    float v55; // [esp+44h] [ebp-30h] BYREF
    float v56; // [esp+48h] [ebp-2Ch]
    float v57; // [esp+4Ch] [ebp-28h]
    float v58; // [esp+50h] [ebp-24h] BYREF
    float v59; // [esp+54h] [ebp-20h]
    float v60; // [esp+58h] [ebp-1Ch]
    float v61; // [esp+5Ch] [ebp-18h] BYREF
    float v62; // [esp+60h] [ebp-14h]
    float v63; // [esp+64h] [ebp-10h]
    float v64; // [esp+68h] [ebp-Ch] BYREF
    float v65; // [esp+6Ch] [ebp-8h]
    float v66; // [esp+70h] [ebp-4h]
    float v67; // [esp+7Ch] [ebp+8h]

    v5 = a3[1];
    v52 = *a3;
    v6 = a3[2];
    v67 = a2 * a2;
    v53 = v5;
    v54 = v6;
    sub_40E530(&v52, a1);
    v51 = v54;
    v7 = a4 + 3;
    v8 = a5[1];
    v49 = v52;
    v50 = v53;
    v9 = a4[3];
    v55 = v52;
    v43 = v9;
    v10 = v9;
    v11 = a4[4];
    v56 = v53;
    v12 = a4[5];
    v57 = v54;
    v43 = v10 * v8;
    v61 = v43;
    v44 = v11 * v8;
    v62 = v44;
    v45 = v12 * v8;
    v63 = v45;
    v13 = *a5;
    v43 = *a4;
    v14 = a4[2];
    v44 = a4[1];
    v43 = v43 * v13;
    v58 = v43;
    v44 = v44 * v13;
    v59 = v44;
    v45 = v14 * v13;
    v60 = v45;
    sub_40E510(&v55, &v58);
    v43 = v55;
    v45 = v57;
    v44 = v56;
    sub_40E510(&v43, &v61);
    v46 = v43;
    v47 = v44;
    v48 = v45;
    if (v43 * v43 + v44 * v44 + v45 * v45 < v67)
        return 1;
    v16 = a5[1];
    v55 = *v7;
    v17 = a4[5];
    v56 = a4[4];
    v37 = v16;
    v57 = v17;
    sub_40E550(&v55, v37);
    v64 = v55;
    v65 = v56;
    v18 = *a5;
    v19 = *a4;
    v66 = v57;
    v20 = a4[1];
    v52 = v19;
    v21 = a4[2];
    v53 = v20;
    v54 = v21;
    v38 = -v18;
    sub_40E550(&v52, v38);
    v61 = v52;
    v63 = v54;
    v58 = v49;
    v62 = v53;
    v60 = v51;
    v59 = v50;
    sub_40E510(&v58, &v61);
    v43 = v58;
    v44 = v59;
    v45 = v60;
    sub_40E510(&v43, &v64);
    v48 = v45;
    v46 = v43;
    v47 = v44;
    if (v43 * v43 + v44 * v44 + v45 * v45 < v67)
        return 1;
    v22 = -a5[1];
    v23 = a4[4];
    v58 = *v7;
    v24 = a4[5];
    v59 = v23;
    v60 = v24;
    v39 = v22;
    sub_40E550(&v58, v39);
    v61 = v58;
    v62 = v59;
    v25 = *a5;
    v26 = *a4;
    v63 = v60;
    v27 = a4[1];
    v55 = v26;
    v56 = v27;
    v40 = v25;
    v57 = a4[2];
    sub_40E550(&v55, v40);
    v64 = v55;
    v65 = v56;
    v52 = v49;
    v66 = v57;
    v53 = v50;
    v54 = v51;
    sub_40E510(&v52, &v64);
    v43 = v52;
    v44 = v53;
    v45 = v54;
    sub_40E510(&v43, &v61);
    v47 = v44;
    v46 = v43;
    v48 = v45;
    if (v43 * v43 + v44 * v44 + v45 * v45 < v67)
        return 1;
    v28 = *v7;
    v29 = a4[4];
    v30 = -a5[1];
    v60 = a4[5];
    v41 = v30;
    v58 = v28;
    v59 = v29;
    sub_40E550(&v58, v41);
    v66 = v60;
    v31 = a4[2];
    v64 = v58;
    v32 = *a5;
    v33 = *a4;
    v65 = v59;
    v34 = a4[1];
    v57 = v31;
    v42 = -v32;
    v55 = v33;
    v56 = v34;
    sub_40E550(&v55, v42);
    v61 = v55;
    v62 = v56;
    v63 = v57;
    v35 = sub_40E570(&v49, &v43, &v61);
    v36 = sub_40E570(v35, &v52, &v64);
    v46 = *v36;
    v47 = v36[1];
    v48 = v36[2];
    return sub_40E5D0(&v46) < v67;
}

//----- (0040DD90) --------------------------------------------------------
double __cdecl sub_40DD90(float* a1, float* a2, float* a3, float* a4)
{
    double v4; // st7
    double v5; // st6
    double v6; // st5
    long double v7; // st7
    long double v8; // st6
    double v9; // st6
    double v10; // st6
    double v12; // st6
    double v14; // st6
    char v15; // c0
    double v16; // st6
    double v17; // st6
    double v18; // st6
    double v20; // st6
    char v21; // c0
    char v23; // c0
    unsigned __int8 v25; // c0
    unsigned __int8 v26; // c3
    double v27; // st6
    double v28; // st5
    char v30; // c0
    double v31; // st4
    double v32; // st6
    float v33; // [esp+4h] [ebp-28h]
    float v34; // [esp+8h] [ebp-24h]
    float v35; // [esp+8h] [ebp-24h]
    float v36; // [esp+Ch] [ebp-20h]
    float v37; // [esp+10h] [ebp-1Ch]
    float v38; // [esp+10h] [ebp-1Ch]
    float v39; // [esp+14h] [ebp-18h]
    float v40; // [esp+18h] [ebp-14h]
    float v41; // [esp+1Ch] [ebp-10h]
    float v42; // [esp+20h] [ebp-Ch]
    float v43; // [esp+24h] [ebp-8h]
    float v44; // [esp+28h] [ebp-4h]
    float v45; // [esp+30h] [ebp+4h]
    float v46; // [esp+34h] [ebp+8h]
    float v47; // [esp+38h] [ebp+Ch]
    float v48; // [esp+3Ch] [ebp+10h]

    v42 = *a1 - *a3;
    v43 = a1[1] - a3[1];
    v44 = a1[2] - a3[2];
    v4 = *a2 - *a1;
    v5 = a2[1] - a1[1];
    v6 = a2[2] - a1[2];
    v39 = *a4 - *a3;
    v40 = a4[1] - a3[1];
    v41 = a4[2] - a3[2];
    v47 = v6 * v6 + v5 * v5 + v4 * v4;
    v33 = -(v41 * v6 + v40 * v5 + v39 * v4);
    v46 = v41 * v41 + v40 * v40 + v39 * v39;
    v45 = v6 * v44 + v5 * v43 + v4 * v42;
    v7 = v44 * v44 + v43 * v43 + v42 * v42;
    v8 = fabs(v46 * v47 - v33 * v33);
    v37 = v8;
    if (v8 < 0.0000099999997)
    {
        if (!(v25 | v26))
        {
            if (v45 >= 0.0)
                return fabs(v7);
            if (-v45 > v47)
            {
                v27 = -(v41 * v44 + v40 * v43 + v39 * v42);
                v28 = v45 + v47;
                if (-v28 < v33)
                    return fabs(v7 + (v27 + v33 + v27 + v33 + -(v28 / v33) * v46) * -(v28 / v33) + v45 + v45 + v47);
                else
                    return fabs(v7 + v27 + v45 + v33 + v27 + v45 + v33 + v46 + v47);
            }
            goto LABEL_45;
        }
        v14 = v45;
        if (!v30)
            return fabs(v7 + v14 + v14 + v47);
        if (v14 <= 0.0)
            goto LABEL_45;
        v20 = -(v41 * v44 + v40 * v43 + v39 * v42);
        if (-v33 > v45)
        {
            v31 = v20 + v20;
            v32 = -(v45 / v33);
            v7 = v7 + (v32 * v46 + v31) * v32;
            return fabs(v7);
        }
        return fabs(v7 + v20 + v20 + v46);
    }
    v9 = -(v41 * v44 + v40 * v43 + v39 * v42);
    v48 = v9;
    v34 = v9 * v33 - v45 * v46;
    v36 = v45 * v33 - v48 * v47;
    if (v34 < 0.0)
    {
        if (v36 < 0.0)
        {
            if (v45 < 0.0)
                goto LABEL_10;
        }
        else if (v36 > (double)v37)
        {
            v12 = v45 + v33;
            if (v12 < 0.0)
            {
            LABEL_31:
                if (-v12 < v47)
                    return fabs(v7 + -(v12 / v47) * v12 + v48 + v48 + v46);
                else
                    return fabs(v7 + v12 + v48 + v12 + v48 + v46 + v47);
            }
            if (v48 >= 0.0)
                return fabs(v7);
            v20 = v48;
            if (!v21)
                return fabs(v7 + v20 + v20 + v46);
            return fabs(v7 + -(v20 / v46) * v48);
        }
        if (v48 >= 0.0)
            return fabs(v7);
        v20 = v48;
        if (!v23)
            return fabs(v7 + v20 + v20 + v46);
        return fabs(v7 + -(v20 / v46) * v48);
    }
    if (v34 <= (double)v37)
    {
        if (v36 >= 0.0)
        {
            if (v36 <= (double)v37)
            {
                v10 = 1.0 / v37;
                v35 = v10 * v34;
                return fabs(
                    v7
                    + (v10 * v36 * v46 + v35 * v33 + v48 + v48) * (v10 * v36)
                    + (v10 * v36 * v33 + v35 * v47 + v45 + v45) * v35);
            }
            v12 = v45 + v33;
            if (v12 >= 0.0)
                return fabs(v7 + v48 + v48 + v46);
            goto LABEL_31;
        }
        if (v45 < 0.0)
        {
        LABEL_10:
            v14 = v45;
            if (!v15)
                return fabs(v7 + v14 + v14 + v47);
            return fabs(v7 + -(v14 / v47) * v45);
        }
        return fabs(v7);
    }
    if (v36 < 0.0)
    {
        if (-v45 >= v47)
        {
            v16 = v48 + v33;
            if (v16 >= 0.0)
                return fabs(v7 + v45 + v45 + v47);
            goto LABEL_25;
        }
        if (v45 >= 0.0)
            return fabs(v7);
    LABEL_45:
        v14 = v45;
        return fabs(v7 + -(v14 / v47) * v45);
    }
    if (v36 <= (double)v37 || (v17 = v45 + v33, v38 = v17, -v17 > v47))
    {
        v16 = v48 + v33;
        if (v16 >= 0.0)
            return fabs(v7 + v45 + v45 + v47);
    LABEL_25:
        if (-v16 < v46)
            return fabs(v7 + -(v16 / v46) * v16 + v45 + v45 + v47);
        else
            return fabs(v7 + v16 + v45 + v16 + v45 + v46 + v47);
    }
    if (v38 < 0.0)
        v18 = -(v38 / v47) * v38 + v48 + v48;
    else
        v18 = v48 + v48;
    return fabs(v7 + v18 + v46);
}
// 40E027: variable 'v15' is possibly undefined
// 40E237: variable 'v21' is possibly undefined
// 40E296: variable 'v23' is possibly undefined
// 40E2C8: variable 'v25' is possibly undefined
// 40E2C8: variable 'v26' is possibly undefined
// 40E39B: variable 'v30' is possibly undefined

//----- (0040E420) --------------------------------------------------------
double __cdecl sub_40E420(float* a1, float* a2, float* a3)
{
    double v3; // st7
    double v4; // st7
    double v5; // st3
    float v7; // [esp+0h] [ebp-24h]
    float v8; // [esp+4h] [ebp-20h]
    float v9; // [esp+8h] [ebp-1Ch]
    float v10; // [esp+10h] [ebp-14h]
    float v11; // [esp+14h] [ebp-10h]

    v7 = *a3 - *a1;
    v8 = a3[1] - a1[1];
    v3 = a3[2] - a1[2];
    v9 = v3;
    v4 = v3 * a2[2] + v8 * a2[1] + v7 * *a2;
    if (v4 <= 0.0)
        return 3.4028235e38;
    v10 = a2[1] * v4;
    v11 = a2[2] * v4;
    v5 = v7 - *a2 * v4;
    return (v9 - v11) * (v9 - v11) + (v8 - v10) * (v8 - v10) + v5 * v5;
}

//----- (0040E510) --------------------------------------------------------
float* __thiscall sub_40E510(float* this, float* a2)
{
    float* result; // eax

    result = a2;
    *this = *a2 + *this;
    this[1] = a2[1] + this[1];
    this[2] = a2[2] + this[2];
    return result;
}

//----- (0040E530) --------------------------------------------------------
float* __thiscall sub_40E530(float* this, float* a2)
{
    float* result; // eax

    result = a2;
    *this = *this - *a2;
    this[1] = this[1] - a2[1];
    this[2] = this[2] - a2[2];
    return result;
}

//----- (0040E550) --------------------------------------------------------
void __thiscall sub_40E550(float* this, float a2)
{
    *this = a2 * *this;
    this[1] = a2 * this[1];
    this[2] = a2 * this[2];
}

//----- (0040E570) --------------------------------------------------------
float* __thiscall sub_40E570(float* this, float* a2, float* a3)
{
    float* result; // eax
    float v4; // [esp+0h] [ebp-Ch]
    float v5; // [esp+4h] [ebp-8h]
    float v6; // [esp+8h] [ebp-4h]

    v4 = *this + *a3;
    v5 = this[1] + a3[1];
    result = a2;
    v6 = this[2] + a3[2];
    *a2 = v4;
    a2[1] = v5;
    a2[2] = v6;
    return result;
}

//----- (0040E5D0) --------------------------------------------------------
double __thiscall sub_40E5D0(float* this)
{
    return *this * *this + this[1] * this[1] + this[2] * this[2];
}

//----- (0040E5F0) --------------------------------------------------------
void __thiscall sub_40E5F0(_DWORD* this)
{
    _DWORD* v2; // eax

    *this = 1;
    v2 = malloc(8u);
    this[1] = v2;
    *v2 = 0;
    *(_DWORD*)(this[1] + 4) = 0;
    *((_BYTE*)this + 8) = 1;
}

//----- (0040E620) --------------------------------------------------------
void __thiscall sub_40E620(LPVOID* this)
{
    sub_488CEE(this[1]);
    this[1] = 0;
    *this = 0;
}

//----- (0040E640) --------------------------------------------------------
long double __thiscall sub_40E640(int this, float a2, int a3, int a4)
{
    int v4; // edx
    double v5; // st7
    long double v6; // st7

    v4 = *(_DWORD*)(this + 4);
    v5 = *(float*)(v4 + 8 * a4) - *(float*)(v4 + 8 * a3);
    if (v5 == 0.0)
        v6 = 0.0;
    else
        v6 = (a2 - *(float*)(v4 + 8 * a3)) / v5;
    if (!*(_BYTE*)(this + 8) && v6 >= -0.0000099999997 && v6 - 1.0 <= 0.0000099999997)
        v6 = (1.0 - cos(v6 * 3.1415927)) * 0.5;
    return (1.0 - v6) * *(float*)(v4 + 8 * a3 + 4) + v6 * *(float*)(v4 + 8 * a4 + 4);
}

//----- (0040E6D0) --------------------------------------------------------
long double __thiscall sub_40E6D0(int* this, float a2)
{
    int v2; // esi
    int v4; // edx
    float* i; // edi
    double v6; // st7

    v2 = *this;
    if (*this == 1)
        return *(float*)(this[1] + 4);
    v4 = 0;
    if (v2 <= 0)
        return sub_40E640((int)this, a2, v2 - 2, v2 - 1);
    for (i = (float*)this[1]; ; i += 2)
    {
        v6 = *i - a2;
        if (v6 < 0.0000099999997 && v6 > -0.0000099999997)
            return *(float*)(this[1] + 8 * v4 + 4);
        if (v6 > 0.0000099999997)
            break;
        if (++v4 >= v2)
            return sub_40E640((int)this, a2, v2 - 2, v2 - 1);
    }
    if (v4)
        return sub_40E640((int)this, a2, v4 - 1, v4);
    else
        return sub_40E640((int)this, a2, 0, 1);
}

//----- (0040E780) --------------------------------------------------------
char __thiscall sub_40E780(LPVOID* this, FILE* Stream)
{
    FILE* v2; // ebp
    int v4; // edi

    v2 = Stream;
    sub_4898CA(this + 2, 1u, 1u, Stream);
    v4 = 0;
    Stream = 0;
    sub_4898CA(&Stream, 4u, 1u, v2);
    if (Stream != *this)
    {
        sub_4885A6(this[1]);
        this[1] = operator new(8 * (_DWORD)Stream);
        *this = Stream;
    }
    if ((int)*this <= 0)
        return 1;
    do
    {
        sub_4898CA((char*)this[1] + 8 * v4, 4u, 1u, v2);
        sub_4898CA((char*)this[1] + 8 * v4++ + 4, 4u, 1u, v2);
    } while (v4 < (int)*this);
    return 1;
}

//----- (0040E850) --------------------------------------------------------
_BYTE* __thiscall sub_40E850(_BYTE* this, float a2)
{
    sub_46BF69(flt_4F5C48, a2);
    return sub_46B97C(this, this, flt_4F5C48);
}
// 4F5C48: using guessed type float flt_4F5C48[16];

//----- (0040E880) --------------------------------------------------------
_BYTE* __thiscall sub_40E880(_BYTE* this, int a2, int a3, int a4)
{
    sub_46BE02((int)flt_4F5C48, a2, a3, a4);
    return sub_46B97C(this, this, flt_4F5C48);
}
// 4F5C48: using guessed type float flt_4F5C48[16];

//----- (0040E8B0) --------------------------------------------------------
_BYTE* __thiscall sub_40E8B0(_BYTE* this, int a2, int a3, int a4)
{
    sub_46BDA2((int)flt_4F5C48, a2, a3, a4);
    return sub_46B97C(this, this, flt_4F5C48);
}
// 4F5C48: using guessed type float flt_4F5C48[16];

//----- (0040E8E0) --------------------------------------------------------
int* __cdecl sub_40E8E0(int a1)
{
    int* v1; // esi

    EnterCriticalSection(lpCriticalSection);
    v1 = sub_40E910(a1);
    LeaveCriticalSection(lpCriticalSection);
    return v1;
}

//----- (0040E910) --------------------------------------------------------
int* __cdecl sub_40E910(int a1)
{
    int* v1; // eax
    signed int v2; // edi
    char v3; // dl
    _DWORD* v4; // esi
    unsigned int v5; // ecx
    bool v6; // zf
    char v7; // dl
    char v8; // dl
    char v9; // dl

    if (!dword_4F5C94)
        return 0;
    v1 = (int*)dword_4F5C88;
    v2 = (a1 + 7) & 0xFFFFFFF8;
    while ((*(_BYTE*)v1 & 1) != 0 || (int)((*v1 & 0xFFFFFFFC) - 4) <= v2)
    {
        if ((*(_BYTE*)v1 & 2) != 0)
            v1 = (int*)dword_4F5C8C;
        else
            v1 = (int*)((char*)v1 + (*v1 & 0xFFFFFFFC));
        if (v1 == (int*)dword_4F5C88)
            return 0;
    }
    if ((int)((*v1 & 0xFFFFFFFC) - v2 - 4) <= 24)
    {
        ++dword_4F5CA0;
        --dword_4F5C94;
        dword_4F5C9C += *v1 & 0xFFFFFFFC;
        dword_4F5C98 -= *v1 & 0xFFFFFFFC;
        *(_BYTE*)v1 |= 1u;
        dword_4F5C88 = (int)v1;
        return v1 + 1;
    }
    else
    {
        v3 = *(_BYTE*)v1;
        v4 = (int*)((char*)v1 + v2 + 4);
        dword_4F5C88 = (int)v4;
        v5 = (*v1 & 0xFFFFFFFC) - v2;
        *v4 &= 3u;
        *v4 |= v5 - 4;
        v6 = (v3 & 2) == 0;
        v7 = *(_BYTE*)dword_4F5C88;
        if (v6)
            v8 = v7 & 0xFD;
        else
            v8 = v7 | 2;
        *(_BYTE*)dword_4F5C88 = v8;
        *(_BYTE*)dword_4F5C88 &= ~1u;
        v9 = (v2 + 4) | *(_BYTE*)v1 & 3;
        *v1 = (v2 + 4) | *v1 & 3;
        *(_BYTE*)v1 = v9 & 0xFC | 1;
        ++dword_4F5CA0;
        dword_4F5C9C += *v1 & 0xFFFFFFFC;
        dword_4F5C98 -= *v1 & 0xFFFFFFFC;
        return v1 + 1;
    }
}
// 4F5C88: using guessed type int dword_4F5C88;
// 4F5C94: using guessed type int dword_4F5C94;
// 4F5C98: using guessed type int dword_4F5C98;
// 4F5C9C: using guessed type int dword_4F5C9C;
// 4F5CA0: using guessed type int dword_4F5CA0;

//----- (0040EA70) --------------------------------------------------------
unsigned int* __cdecl sub_40EA70(unsigned int* a1)
{
    unsigned int* result; // eax
    _BYTE* v2; // ecx
    unsigned int* v3; // ecx
    unsigned int v4; // edx
    unsigned int v5; // eax

    result = a1;
    if (a1)
    {
        result = a1 - 1;
        *((_BYTE*)a1 - 4) &= ~1u;
        --dword_4F5CA0;
        ++dword_4F5C94;
        dword_4F5C9C -= *(a1 - 1) & 0xFFFFFFFC;
        dword_4F5C98 += *(a1 - 1) & 0xFFFFFFFC;
        if ((*(_BYTE*)(a1 - 1) & 2) == 0)
        {
            v2 = (char*)result + (*result & 0xFFFFFFFC);
            if ((*v2 & 1) == 0)
            {
                if ((*v2 & 2) != 0)
                    *(_BYTE*)result = *((_BYTE*)a1 - 4) | 2;
                *result = *result & 3 | ((*(_DWORD*)v2 & 0xFFFFFFFC) + (*result & 0xFFFFFFFC));
                --dword_4F5C94;
            }
        }
        v3 = (unsigned int*)dword_4F5C8C;
        if (dword_4F5C8C != result)
        {
            v4 = *(_DWORD*)dword_4F5C8C;
            if ((char*)dword_4F5C8C + (*(_DWORD*)dword_4F5C8C & 0xFFFFFFFC) != (char*)result)
            {
                do
                {
                    v3 = (unsigned int*)((char*)v3 + (v4 & 0xFFFFFFFC));
                    v4 = *v3;
                } while ((unsigned int*)((char*)v3 + (*v3 & 0xFFFFFFFC)) != result);
            }
            if ((*(_BYTE*)v3 & 1) == 0)
            {
                if ((*(_BYTE*)result & 2) != 0)
                    *(_BYTE*)v3 |= 2u;
                v5 = *result;
                LOBYTE(v5) = v5 & 0xFC;
                *v3 = *v3 & 3 | ((*v3 & 0xFFFFFFFC) + v5);
                result = v3;
                --dword_4F5C94;
            }
        }
        dword_4F5C88 = (int)result;
    }
    return result;
}
// 4F5C88: using guessed type int dword_4F5C88;
// 4F5C94: using guessed type int dword_4F5C94;
// 4F5C98: using guessed type int dword_4F5C98;
// 4F5C9C: using guessed type int dword_4F5C9C;
// 4F5CA0: using guessed type int dword_4F5CA0;

//----- (0040EB70) --------------------------------------------------------
void __cdecl sub_40EB70(unsigned int* a1)
{
    EnterCriticalSection(lpCriticalSection);
    sub_40EA70(a1);
    LeaveCriticalSection(lpCriticalSection);
}

//----- (0040EBA0) --------------------------------------------------------
int sub_40EBA0()
{
    struct _RTL_CRITICAL_SECTION* v0; // esi
    _DWORD* v1; // eax

    v0 = (struct _RTL_CRITICAL_SECTION*)operator new(0x18u);
    InitializeCriticalSection(v0);
    lpCriticalSection = v0;
    v1 = malloc(0x200000u);
    dword_4F5C8C = v1;
    if (!v1)
        return -1;
    dword_4F5C88 = (int)v1;
    *v1 &= 3u;
    *v1 |= 0x1FFFFCu;
    dword_4F5C94 = 1;
    dword_4F5CA0 = 0;
    dword_4F5C98 = 0x200000;
    dword_4F5C9C = 0;
    *(_BYTE*)dword_4F5C88 &= ~1u;
    *(_BYTE*)dword_4F5C88 |= 2u;
    return 0;
}
// 4F5C88: using guessed type int dword_4F5C88;
// 4F5C94: using guessed type int dword_4F5C94;
// 4F5C98: using guessed type int dword_4F5C98;
// 4F5C9C: using guessed type int dword_4F5C9C;
// 4F5CA0: using guessed type int dword_4F5CA0;

//----- (0040EC30) --------------------------------------------------------
void sub_40EC30()
{
    sub_488CEE(dword_4F5C8C);
    dword_4F5C8C = 0;
    DeleteCriticalSection(lpCriticalSection);
}

//----- (0040EC60) --------------------------------------------------------
int __thiscall sub_40EC60(int this)
{
    void* v2; // eax
    int v3; // eax
    int v4; // ecx

    sub_401270(this);
    *(_DWORD*)(this + 392) = 0;
    *(_DWORD*)(this + 396) = 0;
    *(_DWORD*)(this + 400) = 0;
    *(_DWORD*)(this + 404) = 0;
    *(_DWORD*)(this + 408) = 0;
    *(_DWORD*)(this + 412) = 1128792064;
    *(_BYTE*)(this + 416) = 0;
    *(_DWORD*)this = &off_499184;
    v2 = operator new(0x40u);
    if (v2)
        v3 = sub_41F5B0((int)v2, 0, 0, 0, 0, 200, 200, 200, 255);
    else
        v3 = 0;
    *(_DWORD*)(this + 420) = v3;
    (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)v3 + 24))(v3, 0);
    v4 = *(_DWORD*)(this + 420);
    *(_DWORD*)(this + 20) = 1131413504;
    *(_DWORD*)(this + 24) = dword_4A4DB8;
    sub_428680((_DWORD*)this, v4);
    return this;
}
// 499184: using guessed type _UNKNOWN *off_499184;
// 4A4DB8: using guessed type int dword_4A4DB8;

//----- (0040ED60) --------------------------------------------------------
int __thiscall sub_40ED60(_DWORD* this)
{
    *this = &off_499184;
    return sub_4013F0(this);
}
// 499184: using guessed type _UNKNOWN *off_499184;

//----- (0040ED70) --------------------------------------------------------
int __thiscall sub_40ED70(_DWORD* this, int a2, int a3, int a4, int a5, int a6)
{
    int result; // eax

    this[98] = a2;
    this[99] = a3;
    this[100] = a4;
    result = a6;
    this[101] = a5;
    this[102] = a6;
    return result;
}

//----- (0040EDB0) --------------------------------------------------------
char __thiscall sub_40EDB0(int this, int a2)
{
    int v3; // ecx
    double v4; // st7
    double v5; // st7
    float* v6; // esi
    float v7; // eax
    float v8; // edx
    double v9; // st7
    double v10; // st7
    double v11; // st7
    double v12; // st7
    double v13; // st7
    double v14; // st6
    double v15; // st7
    double v16; // st6
    double v17; // st7
    float v18; // ecx
    float v19; // edx
    float v20; // eax
    int v21; // ecx
    int v22; // edx
    int v24; // [esp+0h] [ebp-9Ch]
    int v25; // [esp+0h] [ebp-9Ch]
    int v26; // [esp+0h] [ebp-9Ch]
    int v27; // [esp+0h] [ebp-9Ch]
    int v28; // [esp+4h] [ebp-98h]
    int v29; // [esp+4h] [ebp-98h]
    int v30; // [esp+4h] [ebp-98h]
    int v31; // [esp+4h] [ebp-98h]
    float v32; // [esp+8h] [ebp-94h]
    float v33; // [esp+8h] [ebp-94h]
    int v34; // [esp+8h] [ebp-94h]
    int v35; // [esp+8h] [ebp-94h]
    int v36; // [esp+8h] [ebp-94h]
    int v37; // [esp+8h] [ebp-94h]
    float v38; // [esp+14h] [ebp-88h]
    float v39; // [esp+14h] [ebp-88h]
    float v40; // [esp+14h] [ebp-88h]
    float v41; // [esp+18h] [ebp-84h]
    float v42; // [esp+18h] [ebp-84h]
    float v43; // [esp+18h] [ebp-84h]
    float v44; // [esp+18h] [ebp-84h]
    float v45; // [esp+1Ch] [ebp-80h] BYREF
    float v46; // [esp+20h] [ebp-7Ch]
    float v47; // [esp+24h] [ebp-78h]
    int v48; // [esp+28h] [ebp-74h] BYREF
    float v49; // [esp+2Ch] [ebp-70h]
    float v50; // [esp+30h] [ebp-6Ch]
    float v51; // [esp+34h] [ebp-68h] BYREF
    float v52; // [esp+38h] [ebp-64h]
    float v53; // [esp+3Ch] [ebp-60h]
    int v54; // [esp+40h] [ebp-5Ch] BYREF
    float v55; // [esp+44h] [ebp-58h]
    float v56; // [esp+48h] [ebp-54h]
    float v57; // [esp+4Ch] [ebp-50h]
    float v58; // [esp+50h] [ebp-4Ch] BYREF
    float v59; // [esp+54h] [ebp-48h]
    float v60; // [esp+58h] [ebp-44h]
    int v61[16]; // [esp+5Ch] [ebp-40h] BYREF
    int v62; // [esp+A0h] [ebp+4h]

    v41 = 0.0;
    v3 = dword_520970;
    v57 = 0.0;
    v62 = *(int*)(dword_520970 + 68);
    if (!*(_BYTE*)(dword_520970 + 296))
    {
        v38 = *(float*)(dword_520970 + 24);
        v4 = sub_408F80((float*)dword_520970, 0);
        if (v38 == 0.0)
            v41 = 0.0;
        else
            v41 = v4 / v38;
        v39 = *(float*)(dword_520970 + 24);
        v5 = sub_408F80((float*)dword_520970, 1);
        if (v39 == 0.0)
            v57 = 0.0;
        else
            v57 = v5 / v39;
        v3 = dword_520970;
    }
    v40 = 1.0;
    if (!*(_BYTE*)(v3 + 296))
    {
        if (sub_408F40(42) || sub_408F40(54))
            v40 = 2.5;
        if (sub_408F40(29) || sub_408F40(157))
            v40 = v40 * 20.0;
    }
    v45 = *(float*)(this + 392);
    v6 = (float*)(this + 32);
    v46 = *(float*)(this + 396);
    v7 = v46;
    v47 = *(float*)(this + 400);
    *(float*)(this + 32) = v45;
    v8 = v47;
    *(float*)(this + 36) = v7;
    *(float*)(this + 40) = v8;
    *(float*)&v48 = *(float*)(this + 44) - *(float*)(this + 32);
    v49 = *(float*)(this + 48) - *(float*)(this + 36);
    v50 = *(float*)(this + 52) - *(float*)(this + 40);
    sub_46B970(&v48, &v48);
    if (*(float*)&v48 < 0.0000099999997
        && *(float*)&v48 > -0.0000099999997
        && v49 < 0.0000099999997
        && v49 > -0.0000099999997)
    {
        if ((v9 = v50 - 1.0, v9 < 0.0000099999997) && v9 > -0.0000099999997
            || (v10 = v50 - -1.0, v10 < 0.0000099999997) && v10 > -0.0000099999997)
        {
            v50 = 0.0;
            *(float*)&v48 = 0.0;
            v49 = 1.0;
        }
    }
    v32 = v41 * -0.5 * 0.017453292;
    sub_401000((float*)&v48, v32);
    v47 = 0.0;
    v56 = 0.0;
    v45 = v49 - 0.0;
    *(float*)&v54 = v45;
    v46 = 0.0 - *(float*)&v48;
    v55 = v46;
    sub_46B970(&v54, &v54);
    v11 = v57;
    if (*(_BYTE*)(this + 416))
        v12 = v11 * 0.5 * 0.017453292;
    else
        v12 = v11 * -0.5 * 0.017453292;
    v33 = v12;
    sub_46BFED((int)v61, (int)&v54, v33);
    sub_46C5C5((float*)&v48, (float*)&v48, (float*)v61);
    v45 = v55 * v50 - v56 * v49;
    v13 = v56 * *(float*)&v48;
    v14 = *(float*)&v54 * v50;
    *(float*)(this + 56) = v45;
    v46 = v13 - v14;
    v15 = *(float*)&v54 * v49;
    v16 = v55 * *(float*)&v48;
    *(float*)(this + 60) = v46;
    v47 = v15 - v16;
    *(float*)(this + 64) = v47;
    sub_46B970(this + 56, this + 56);
    if (!*(_BYTE*)(dword_520970 + 296))
    {
        if (sub_408F40(17))
        {
            v42 = *(float*)(this + 412);
            v46 = v49 * v40;
            v47 = v50 * v40;
            v52 = v46 * v42;
            v53 = v47 * v42;
            v46 = v52 * *(float*)&v62;
            v47 = v53 * *(float*)&v62;
            *v6 = *(float*)&v48 * v40 * v42 * *(float*)&v62 + *v6;
            *(float*)(this + 36) = v46 + *(float*)(this + 36);
            *(float*)(this + 40) = v47 + *(float*)(this + 40);
        }
        if (sub_408F40(31))
        {
            v43 = *(float*)(this + 412);
            v52 = v49 * v40;
            v53 = v50 * v40;
            v46 = v52 * v43;
            v47 = v53 * v43;
            v52 = v46 * *(float*)&v62;
            v53 = v47 * *(float*)&v62;
            *v6 = *v6 - *(float*)&v48 * v40 * v43 * *(float*)&v62;
            *(float*)(this + 36) = *(float*)(this + 36) - v52;
            *(float*)(this + 40) = *(float*)(this + 40) - v53;
        }
        if (sub_408F40(30))
        {
            v44 = *(float*)(this + 412);
            v52 = v55 * v40;
            v53 = v56 * v40;
            v46 = v52 * v44;
            v47 = v53 * v44;
            v52 = v46 * *(float*)&v62;
            v53 = v47 * *(float*)&v62;
            *v6 = *v6 - *(float*)&v54 * v40 * v44 * *(float*)&v62;
            *(float*)(this + 36) = *(float*)(this + 36) - v52;
            *(float*)(this + 40) = *(float*)(this + 40) - v53;
        }
        if (sub_408F40(32))
        {
            *(float*)&v34 = v56 * v40;
            *(float*)&v28 = v55 * v40;
            *(float*)&v24 = *(float*)&v54 * v40;
            sub_40F4A0(&v51, v24, v28, v34);
            v17 = *(float*)(this + 412);
            *(float*)&v35 = v53 * v17;
            *(float*)&v29 = v52 * v17;
            *(float*)&v25 = v51 * v17;
            sub_40F4A0(&v45, v25, v29, v35);
            *(float*)&v36 = v47 * *(float*)&v62;
            *(float*)&v30 = v46 * *(float*)&v62;
            *(float*)&v26 = v45 * *(float*)&v62;
            sub_40F4A0(&v58, v26, v30, v36);
            *v6 = v58 + *v6;
            *(float*)(this + 36) = v59 + *(float*)(this + 36);
            *(float*)(this + 40) = v60 + *(float*)(this + 40);
        }
        if (sub_408F40(16))
            *(float*)(this + 40) = v40 * *(float*)(this + 412) * *(float*)&v62 + *(float*)(this + 40);
        if (sub_408F40(44))
            *(float*)(this + 40) = *(float*)(this + 40) - v40 * *(float*)(this + 412) * *(float*)&v62;
    }
    *(float*)&v37 = v50 + *(float*)(this + 40);
    *(float*)&v31 = v49 + *(float*)(this + 36);
    *(float*)&v27 = *(float*)&v48 + *v6;
    sub_40F4A0(&v58, v27, v31, v37);
    v18 = v59;
    v19 = v60;
    *(float*)(this + 44) = v58;
    v20 = *v6;
    *(float*)(this + 48) = v18;
    v21 = *(_DWORD*)(this + 36);
    *(float*)(this + 392) = v20;
    *(float*)(this + 52) = v19;
    v22 = *(_DWORD*)(this + 40);
    *(_DWORD*)(this + 396) = v21;
    *(_DWORD*)(this + 400) = v22;
    return sub_428620((_DWORD*)this, v62);
}
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);
// 520970: using guessed type int dword_520970;

//----- (0040F460) --------------------------------------------------------
char __thiscall sub_40F460(_BYTE* this, int a2, char a3)
{
    char result; // al

    result = dword_520970;
    if (!*(_BYTE*)(dword_520970 + 296))
    {
        result = a3;
        if (a3)
        {
            if (a2 == 23)
            {
                result = this[416];
                this[416] = result == 0;
            }
        }
    }
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (0040F4A0) --------------------------------------------------------
_DWORD* __thiscall sub_40F4A0(_DWORD* this, int a2, int a3, int a4)
{
    _DWORD* result; // eax

    result = this;
    *this = a2;
    this[1] = a3;
    this[2] = a4;
    return result;
}

//----- (0040F4C0) --------------------------------------------------------
int* __thiscall sub_40F4C0(_DWORD* this, int a2, unsigned int a3, _WORD* a4)
{
    int* result; // eax

    *this = 0;
    this[1] = a2;
    this[2] = a3;
    result = sub_40E8E0(a3);
    this[4] = result;
    *((_WORD*)this + 6) = *a4;
    qmemcpy(result, a4, a3);
    return result;
}

//----- (0040F510) --------------------------------------------------------
char* __thiscall sub_40F510(char* this)
{
    *((_DWORD*)this + 1) = 0;
    *((_DWORD*)this + 2) = 0;
    *((_DWORD*)this + 3) = 0;
    this[16] = 1;
    *(_DWORD*)this = &off_499040;
    *((_DWORD*)this + 7) = 0;
    *((_DWORD*)this + 8) = 0;
    *((_DWORD*)this + 9) = 0;
    *((_DWORD*)this + 10) = 0;
    InitializeCriticalSection((LPCRITICAL_SECTION)(this + 44));
    *((_DWORD*)this + 17) = 0;
    *((_DWORD*)this + 18) = 0;
    *((_DWORD*)this + 19) = 0;
    this[80] = 0;
    *((_DWORD*)this + 235) = 0;
    *((_DWORD*)this + 236) = 0;
    *(_DWORD*)this = &off_4991B0;
    dword_4F5CC4 = (int)this;
    *((_DWORD*)this + 6) = 0;
    *((_DWORD*)this + 23) = 0;
    *((_DWORD*)this + 24) = 0;
    *((_DWORD*)this + 22) = 0;
    *((_DWORD*)this + 21) = 0;
    *((_DWORD*)this + 25) = 0;
    *((_DWORD*)this + 26) = 4;
    this[108] = 1;
    this[938] = 0;
    this[937] = 0;
    this[936] = 0;
    *((_DWORD*)this + 237) = 0;
    *((_DWORD*)this + 238) = 0;
    this[140] = 0;
    this[400] = 0;
    this[660] = 0;
    InitializeCriticalSection((LPCRITICAL_SECTION)this + 40);
    InitializeCriticalSection((LPCRITICAL_SECTION)(this + 112));
    *((_DWORD*)this + 239) = 0;
    this[920] = 0;
    *((_DWORD*)this + 34) = 0;
    *((_DWORD*)this + 246) = 0;
    *((_DWORD*)this + 5) = 0;
    this[988] = 0;
    *((_DWORD*)this + 248) = 0;
    *((_DWORD*)this + 249) = -1;
    *((_DWORD*)this + 250) = 0;
    return this;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 4991B0: using guessed type _UNKNOWN *off_4991B0;
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (0040F620) --------------------------------------------------------
void __thiscall sub_40F620(char* this)
{
    void(__stdcall * v2)(LPCRITICAL_SECTION); // ebp
    int v3; // eax
    _DWORD* v4; // eax
    _DWORD* v5; // edi
    int i; // edi
    void* v7; // eax
    int v8; // edi
    int v9; // ebp
    _DWORD* v10; // eax
    _DWORD* v11; // edi

    *(_DWORD*)this = &off_4991B0;
    sub_411C50((int)this);
    if (*((_DWORD*)this + 246))
        CloseHandle(*((HANDLE*)this + 246));
    v2 = DeleteCriticalSection;
    DeleteCriticalSection((LPCRITICAL_SECTION)this + 40);
    DeleteCriticalSection((LPCRITICAL_SECTION)(this + 112));
    v3 = *((_DWORD*)this + 6);
    *((_DWORD*)this + 246) = 0;
    if (v3)
    {
        (*(void(__stdcall**)(int))(*(_DWORD*)v3 + 8))(v3);
        *((_DWORD*)this + 6) = 0;
    }
    dword_4F5CC4 = 0;
    v4 = (_DWORD*)*((_DWORD*)this + 5);
    *((_DWORD*)this + 6) = 0;
    if (v4)
    {
        do
        {
            v5 = (_DWORD*)v4[3];
            sub_4885A6(v4);
            v4 = v5;
        } while (v5);
    }
    sub_488CEE(*((LPVOID*)this + 236));
    if (this[80])
    {
        for (i = 0; i < *((_DWORD*)this + 18); ++i)
            sub_4885A6(*(LPVOID*)(*((_DWORD*)this + 17) + 4 * i));
    }
    memset(*((void**)this + 17), 0, 4 * *((_DWORD*)this + 18));
    v7 = (void*)*((_DWORD*)this + 17);
    *((_DWORD*)this + 18) = 0;
    sub_488CEE(v7);
    *((_DWORD*)this + 19) = 0;
    *((_DWORD*)this + 17) = 0;
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 44));
    v8 = *((_DWORD*)this + 8);
    if (v8)
    {
        do
        {
            v9 = *(_DWORD*)(v8 + 4);
            sub_4885A6(*(LPVOID*)v8);
            *(_DWORD*)v8 = 0;
            **((_DWORD**)this + 8) = 0;
            v8 = v9;
            *(_DWORD*)(*((_DWORD*)this + 8) + 4) = *((_DWORD*)this + 7);
            *((_DWORD*)this + 7) = *((_DWORD*)this + 8);
        } while (v9);
        v2 = DeleteCriticalSection;
    }
    *((_DWORD*)this + 9) = 0;
    *((_DWORD*)this + 8) = 0;
    LeaveCriticalSection((LPCRITICAL_SECTION)(this + 44));
    v10 = (_DWORD*)*((_DWORD*)this + 7);
    if (v10)
    {
        do
        {
            v11 = (_DWORD*)v10[1];
            sub_4885A6(v10);
            v10 = v11;
        } while (v11);
    }
    v2((LPCRITICAL_SECTION)(this + 44));
    *(_DWORD*)this = &off_499040;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 4991B0: using guessed type _UNKNOWN *off_4991B0;
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (0040F7B0) --------------------------------------------------------
_DWORD* __thiscall sub_40F7B0(int this, _DWORD* a2)
{
    int v3; // esi
    int v4; // edi
    int v5; // eax
    int v6; // eax
    _DWORD* v7; // esi
    _DWORD* result; // eax
    _DWORD* v9; // ebp
    int v10; // eax
    int v11; // esi
    char* v12; // [esp+38h] [ebp-2B4h]
    int v13; // [esp+4Ch] [ebp-2A0h] BYREF
    _DWORD v14[4]; // [esp+50h] [ebp-29Ch] BYREF
    _DWORD v15[6]; // [esp+60h] [ebp-28Ch] BYREF
    _DWORD v16[18]; // [esp+78h] [ebp-274h] BYREF
    _DWORD v17[9]; // [esp+C0h] [ebp-22Ch] BYREF
    WCHAR WideCharStr[260]; // [esp+E4h] [ebp-208h] BYREF

    v13 = 0;
    sub_411C50(this);
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 960));
    sub_4229D0(aStartsearchfor);
    v3 = *(_DWORD*)(this + 956);
    if (v3)
    {
        do
        {
            v4 = *(_DWORD*)(v3 + 276);
            sub_4885A6(*(LPVOID*)(v3 + 260));
            v5 = *(_DWORD*)(v3 + 264);
            if (v5)
            {
                (*(void(__stdcall**)(_DWORD))(*(_DWORD*)v5 + 8))(*(_DWORD*)(v3 + 264));
                *(_DWORD*)(v3 + 264) = 0;
            }
            v6 = *(_DWORD*)(v3 + 268);
            if (v6)
            {
                (*(void(__stdcall**)(_DWORD))(*(_DWORD*)v6 + 8))(*(_DWORD*)(v3 + 268));
                *(_DWORD*)(v3 + 268) = 0;
            }
            sub_4885A6((LPVOID)v3);
            v3 = v4;
        } while (v4);
    }
    *(_DWORD*)(this + 956) = 0;
    *(_DWORD*)(this + 984) = CreateEventA(0, 0, 0, 0);
    LeaveCriticalSection((LPCRITICAL_SECTION)(this + 960));
    v14[0] = 1402159760;
    v14[1] = 299000461;
    v14[2] = 1610616750;
    v14[3] = 286568599;
    sub_4229D0(aMpCreatingPeer);
    v7 = (_DWORD*)(this + 24);
    if (CoCreateInstance(&stru_499DF4, 0, 1u, &stru_499DE4, (LPVOID*)(this + 24)) < 0)
    {
        sub_4229D0(aCouldnTCreateD);
        sub_403A30(a2, 1, aCouldnTCreateD_0);
        return a2;
    }
    sub_4229D0(aMpCreatingPeer_0);
    sub_4229D0(aMpInitPeer);
    if ((*(int(__stdcall**)(_DWORD, int, int(__stdcall*)(int, unsigned int, float), _DWORD))(*(_DWORD*)*v7 + 12))(
        *v7,
        this,
        sub_410A90,
        0) < 0)
    {
        sub_4229D0(aCouldnTInitPee);
        sub_403A30(a2, 2, aCouldnTInitDpl);
        return a2;
    }
    sub_4229D0(aMpInitPeerDone);
    sub_4229D0(aMpCreatingHost);
    if (CoCreateInstance(&stru_499E14, 0, 1u, &stru_499E04, (LPVOID*)(this + 92)) < 0)
    {
        sub_403A30(a2, 3, aCouldnTCreateH);
        return a2;
    }
    sub_4229D0(aMpDoneCreating);
    sub_4229D0(aMpSetSp);
    if ((*(int(__stdcall**)(_DWORD, _DWORD*))(**(_DWORD**)(this + 92) + 52))(*(_DWORD*)(this + 92), v14) < 0)
    {
        v12 = aCouldnTSetHost;
    LABEL_37:
        sub_403A30(a2, 4, v12);
        return a2;
    }
    sub_4229D0(aMpDoneSettingS);
    sub_4229D0(aMpCreateDevice);
    v9 = (_DWORD*)(this + 96);
    if (CoCreateInstance(&stru_499E14, 0, 1u, &stru_499E04, (LPVOID*)(this + 96)) < 0)
    {
        sub_403A30(a2, 5, aCouldnTCreateD_1);
        return a2;
    }
    sub_4229D0(aMpDoneCreating_0);
    sub_4229D0(aMpSettingSp);
    if ((*(int(__stdcall**)(_DWORD, _DWORD*))(*(_DWORD*)*v9 + 52))(*v9, v14) < 0)
    {
        sub_403A30(a2, 6, aCouldnTSetDevi);
        return a2;
    }
    sub_4229D0(aMpDoneSettingS);
    sub_4229D0(aStartsearchfor_0);
    memset(v16, 0, sizeof(v16));
    v16[7] = dword_4A4DC4;
    v16[8] = dword_4A4DC8;
    v16[6] = dword_4A4DC0;
    v16[0] = 72;
    v16[9] = dword_4A4DCC;
    sub_428820(WideCharStr, (LPCCH)(this + 140), 0xFFFFFFFF);
    memset(v15, 0, sizeof(v15));
    v15[0] = 24;
    v15[1] = 1;
    v15[2] = WideCharStr;
    sub_4229D0(aMpSettingPeerI);
    if ((*(int(__stdcall**)(_DWORD, _DWORD*, _DWORD, _DWORD, unsigned int))(*(_DWORD*)*v7 + 80))(
        *v7,
        v15,
        0,
        0,
        0x80000000) < 0)
    {
        sub_403A30(a2, 9, aCouldnTSetPeer);
        return a2;
    }
    memset(v17, 0, sizeof(v17));
    v10 = *v7;
    v17[0] = 36;
    if ((*(int(__stdcall**)(int, _DWORD*, _DWORD*, _DWORD))(*(_DWORD*)v10 + 132))(v10, v14, v17, 0) < 0)
    {
        v12 = aIpxIsnTInstall;
        goto LABEL_37;
    }
    v11 = (*(int(__stdcall**)(_DWORD, _DWORD*, _DWORD, _DWORD, _DWORD, _DWORD, int, _DWORD, int, _DWORD, int*, _DWORD))(*(_DWORD*)*v7 + 100))(
        *v7,
        v16,
        *(_DWORD*)(this + 92),
        *v9,
        0,
        0,
        -1,
        0,
        -1,
        0,
        &v13,
        0);
    if (v11 < 0)
    {
        sub_411C50(this);
        switch (v11)
        {
        case -2146073824:
            v12 = aInvalideDevice;
            break;
        case -2146073792:
            v12 = aInvalidFlags;
            break;
        case -2146073744:
            v12 = aInvalidHostAdd;
            break;
        case -2147024809:
            v12 = aInvalidParam;
            break;
        case -2146074560:
            v12 = aAddressingErro;
            break;
        case -2146074096:
            v12 = aEnumQueryTooLa;
            break;
        default:
            v12 = aCanTEnumHosts;
            break;
        }
        goto LABEL_37;
    }
    sub_4229D0(aStartsearchfor_1);
    result = a2;
    *a2 = 0;
    a2[1] = 0;
    return result;
}
// 40FBD5: conditional instruction was optimized away because eax.4<0
// 4A4DC0: using guessed type int dword_4A4DC0;
// 4A4DC4: using guessed type int dword_4A4DC4;
// 4A4DC8: using guessed type int dword_4A4DC8;
// 4A4DCC: using guessed type int dword_4A4DCC;

//----- (0040FC90) --------------------------------------------------------
FILE* __thiscall sub_40FC90(struct _RTL_CRITICAL_SECTION* this)
{
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo; // eax
    struct _RTL_CRITICAL_SECTION* v3; // edi
    ULONG_PTR SpinCount; // esi
    ULONG_PTR v5; // edi
    int v6; // eax
    int v7; // eax

    DebugInfo = this[1].DebugInfo;
    if (DebugInfo)
        (*(void(__stdcall**)(PRTL_CRITICAL_SECTION_DEBUG, _DWORD, int))(*(_DWORD*)&DebugInfo->Type + 20))(
            DebugInfo,
            0,
            2);
    v3 = this + 40;
    EnterCriticalSection(this + 40);
    sub_4229D0(aStopsearchfori);
    SpinCount = this[39].SpinCount;
    if (SpinCount)
    {
        do
        {
            v5 = *(_DWORD*)(SpinCount + 276);
            sub_4885A6(*(LPVOID*)(SpinCount + 260));
            v6 = *(_DWORD*)(SpinCount + 264);
            if (v6)
            {
                (*(void(__stdcall**)(_DWORD))(*(_DWORD*)v6 + 8))(*(_DWORD*)(SpinCount + 264));
                *(_DWORD*)(SpinCount + 264) = 0;
            }
            v7 = *(_DWORD*)(SpinCount + 268);
            if (v7)
            {
                (*(void(__stdcall**)(_DWORD))(*(_DWORD*)v7 + 8))(*(_DWORD*)(SpinCount + 268));
                *(_DWORD*)(SpinCount + 268) = 0;
            }
            sub_4885A6((LPVOID)SpinCount);
            SpinCount = v5;
        } while (v5);
        v3 = this + 40;
    }
    this[39].SpinCount = 0;
    LeaveCriticalSection(v3);
    return sub_4229D0(aStopsearchfori_0);
}

//----- (0040FD50) --------------------------------------------------------
int __thiscall sub_40FD50(struct _RTL_CRITICAL_SECTION* this, char** a2, int a3)
{
    ULONG_PTR SpinCount; // edx
    int i; // esi
    char* v7; // ebx
    struct _RTL_CRITICAL_SECTION* lpCriticalSection; // [esp+10h] [ebp-4h]

    lpCriticalSection = this + 40;
    EnterCriticalSection(this + 40);
    SpinCount = this[39].SpinCount;
    for (i = 0; SpinCount; SpinCount = *(_DWORD*)(SpinCount + 276))
    {
        if (i >= a3)
            break;
        v7 = *a2;
        ++i;
        ++a2;
        strcpy(v7, (const char*)SpinCount);
    }
    LeaveCriticalSection(lpCriticalSection);
    return i;
}

//----- (0040FDD0) --------------------------------------------------------
_DWORD* __thiscall sub_40FDD0(int this, _DWORD* a2, char* String2)
{
    struct _RTL_CRITICAL_SECTION* v4; // ebp
    int v5; // esi
    int v6; // esi
    _DWORD* result; // eax
    char* v8; // [esp+14h] [ebp-18h]
    int v9; // [esp+28h] [ebp-4h] BYREF

    v9 = 0;
    v4 = (struct _RTL_CRITICAL_SECTION*)(this + 960);
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 960));
    v5 = *(_DWORD*)(this + 956);
    if (!v5)
    {
    LABEL_4:
        LeaveCriticalSection(v4);
        v8 = aHostNotFound;
    LABEL_13:
        sub_403A30(a2, 1, v8);
        return a2;
    }
    while (_strcmpi((const char*)v5, String2))
    {
        v5 = *(_DWORD*)(v5 + 276);
        if (!v5)
            goto LABEL_4;
    }
    v6 = (*(int(__stdcall**)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, int*, _DWORD))(**(_DWORD**)(this + 24) + 24))(
        *(_DWORD*)(this + 24),
        *(_DWORD*)(v5 + 260),
        *(_DWORD*)(v5 + 264),
        *(_DWORD*)(v5 + 268),
        0,
        0,
        0,
        0,
        0,
        0,
        &v9,
        0);
    LeaveCriticalSection(v4);
    if (v6 < 0)
    {
        if (v6 == -2146073072)
        {
            v8 = aSessionIsFull;
        }
        else if (v6 == -2146074016)
        {
            v8 = aHostRejectedTh;
        }
        else
        {
            v8 = aConnectionFail;
        }
        goto LABEL_13;
    }
    *(_BYTE*)(this + 936) = 0;
    *(_BYTE*)(this + 937) = 0;
    *(_BYTE*)(this + 938) = 1;
    *(_DWORD*)(this + 940) = 0;
    sub_488CEE(0);
    result = a2;
    *a2 = 0;
    a2[1] = 0;
    return result;
}
// 40FE20: conditional instruction was optimized away because esi.4!=0
// 40FE6D: conditional instruction was optimized away because esi.4<0

//----- (0040FEE0) --------------------------------------------------------
_DWORD* __thiscall sub_40FEE0(int this, _DWORD* a2)
{
    _DWORD* v3; // ebx
    _DWORD* result; // eax
    _DWORD* v5; // ebp
    int v6; // ecx
    size_t v7; // eax
    int v8; // ebx
    char* v9; // [esp+4h] [ebp-498h]
    _DWORD v10[5]; // [esp+18h] [ebp-484h] BYREF
    _DWORD v11[18]; // [esp+2Ch] [ebp-470h] BYREF
    _DWORD v12[6]; // [esp+74h] [ebp-428h] BYREF
    wchar_t String[260]; // [esp+8Ch] [ebp-410h] BYREF
    WCHAR WideCharStr[260]; // [esp+294h] [ebp-208h] BYREF

    v10[4] = 0;
    sub_411C50(this);
    v10[0] = 1402159760;
    v10[1] = 299000461;
    v10[2] = 1610616750;
    v10[3] = 286568599;
    sub_4229D0(aMpCreatingPeer);
    v3 = (_DWORD*)(this + 24);
    if (CoCreateInstance(&stru_499DF4, 0, 1u, &stru_499DE4, (LPVOID*)(this + 24)) < 0)
    {
        sub_4229D0(aCouldnTCreateD);
        v9 = aCouldnTCreateD_0;
    LABEL_27:
        sub_403A30(a2, 1, v9);
        return a2;
    }
    sub_4229D0(aMpCreatingPeer_0);
    sub_4229D0(aMpInitPeer);
    if ((*(int(__stdcall**)(_DWORD, int, int(__stdcall*)(int, unsigned int, float), _DWORD))(*(_DWORD*)*v3 + 12))(
        *v3,
        this,
        sub_410A90,
        0) < 0)
    {
        sub_4229D0(aCouldnTInitPee);
        sub_403A30(a2, 2, aCouldnTInitDpl);
        return a2;
    }
    sub_4229D0(aMpInitPeerDone);
    sub_4229D0(aMpCreateDevice);
    v5 = (_DWORD*)(this + 96);
    if (CoCreateInstance(&stru_499E14, 0, 1u, &stru_499E04, (LPVOID*)(this + 96)) < 0)
    {
        sub_403A30(a2, 5, aCouldnTCreateD_1);
        return a2;
    }
    sub_4229D0(aMpDoneCreating_0);
    sub_4229D0(aMpSettingSp);
    if ((*(int(__stdcall**)(_DWORD, _DWORD*))(*(_DWORD*)*v5 + 52))(*v5, v10) < 0)
    {
        sub_403A30(a2, 6, aCouldnTSetDevi);
        return a2;
    }
    sub_4229D0(aMpDoneSettingS);
    memset(v11, 0, sizeof(v11));
    v11[6] = dword_4A4DC0;
    v11[7] = dword_4A4DC4;
    v11[9] = dword_4A4DCC;
    memset(&v11[2], 0, 16);
    v11[8] = dword_4A4DC8;
    v6 = *(_DWORD*)(this + 104);
    v11[0] = 72;
    v11[10] = v6;
    sub_428820(WideCharStr, (LPCCH)(this + 140), 0xFFFFFFFF);
    memset(v12, 0, sizeof(v12));
    v12[0] = 24;
    v12[1] = 1;
    v12[2] = WideCharStr;
    sub_4229D0(aMpSettingPeerI);
    if ((*(int(__stdcall**)(_DWORD, _DWORD*, _DWORD, _DWORD, unsigned int))(*(_DWORD*)*v3 + 80))(
        *v3,
        v12,
        0,
        0,
        0x80000000) < 0)
    {
        sub_403A30(a2, 9, aCouldnTSetPeer);
        return a2;
    }
    if (strlen((const char*)(this + 400)))
    {
        sub_428820(String, (LPCCH)(this + 400), 0xFFFFFFFF);
        v7 = wcslen(String);
        v11[12] = operator new(2 * v7 + 2);
        wcscpy((wchar_t*)v11[12], String);
    }
    else
    {
        v11[12] = 0;
    }
    sub_4229D0(aMpHosting);
    v8 = (*(int(__stdcall**)(_DWORD, _DWORD*, int, int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD*)*v3 + 36))(
        *v3,
        v11,
        this + 96,
        1,
        0,
        0,
        0,
        0);
    if (v11[12])
    {
        sub_4885A6((LPVOID)v11[12]);
        v11[12] = 0;
    }
    if (*v5)
    {
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)*v5 + 8))(*v5);
        *v5 = 0;
    }
    if (v8 >= 0)
    {
        sub_4229D0(aMpDoneHostIng);
        *(_BYTE*)(this + 936) = 1;
        *(_BYTE*)(this + 937) = 0;
        sub_4229D0(aMpLaunchSucces);
        result = a2;
        *a2 = 0;
        a2[1] = 0;
    }
    else
    {
        if (*v5)
        {
            (*(void(__stdcall**)(_DWORD))(*(_DWORD*)*v5 + 8))(*v5);
            *v5 = 0;
        }
        switch (v8)
        {
        case -2146073824:
            v9 = aInvalidDeviceA;
            goto LABEL_27;
        case -2147024809:
            v9 = aInvalidParam;
            goto LABEL_27;
        case -2146074251:
            v9 = aDataTooLarge;
            goto LABEL_27;
        }
        sub_403A30(a2, 4, aCouldnTHost);
        return a2;
    }
    return result;
}
// 41021D: conditional instruction was optimized away because ebx.4<0
// 4A4DC0: using guessed type int dword_4A4DC0;
// 4A4DC4: using guessed type int dword_4A4DC4;
// 4A4DC8: using guessed type int dword_4A4DC8;
// 4A4DCC: using guessed type int dword_4A4DCC;

//----- (004102F0) --------------------------------------------------------
_DWORD* __thiscall sub_4102F0(int this, _DWORD* a2, const CHAR* lpMultiByteStr, int a4)
{
    _DWORD* v5; // ebx
    _DWORD* result; // eax
    _DWORD* v7; // ebp
    size_t v8; // eax
    int v9; // eax
    size_t v10; // eax
    int v11; // ebx
    int v12; // eax
    int v13; // eax
    int v14; // edi
    int v15; // eax
    char* v16; // [esp+72h] [ebp-508h]
    int v17; // [esp+8Ah] [ebp-4F0h] BYREF
    _DWORD v18[4]; // [esp+8Eh] [ebp-4ECh] BYREF
    _DWORD v19[6]; // [esp+9Eh] [ebp-4DCh] BYREF
    _DWORD v20[18]; // [esp+B6h] [ebp-4C4h] BYREF
    _DWORD v21[18]; // [esp+FEh] [ebp-47Ch] BYREF
    _DWORD v22[9]; // [esp+146h] [ebp-434h] BYREF
    wchar_t String[260]; // [esp+16Ah] [ebp-410h] BYREF
    WCHAR WideCharStr[260]; // [esp+372h] [ebp-208h] BYREF

    v17 = 0;
    sub_411C50(this);
    *(_DWORD*)(this + 984) = CreateEventA(0, 0, 0, 0);
    v18[0] = -335643744;
    v18[1] = 299000461;
    v18[2] = 1610616750;
    v18[3] = 286568599;
    sub_4229D0(aMpCreatingPeer);
    v5 = (_DWORD*)(this + 24);
    if (CoCreateInstance(&stru_499DF4, 0, 1u, &stru_499DE4, (LPVOID*)(this + 24)) < 0)
    {
        sub_4229D0(aCouldnTCreateD);
        sub_403A30(a2, 1, aCouldnTCreateD_0);
        return a2;
    }
    sub_4229D0(aMpCreatingPeer_0);
    sub_4229D0(aMpInitPeer);
    if ((*(int(__stdcall**)(_DWORD, int, int(__stdcall*)(int, unsigned int, float), _DWORD))(*(_DWORD*)*v5 + 12))(
        *v5,
        this,
        sub_410A90,
        0) < 0)
    {
        sub_4229D0(aCouldnTInitPee);
        sub_403A30(a2, 2, aCouldnTInitDpl);
        return a2;
    }
    sub_4229D0(aMpInitPeerDone);
    if (lpMultiByteStr)
    {
        sub_4229D0(aMpCreatingHost);
        if (CoCreateInstance(&stru_499E14, 0, 1u, &stru_499E04, (LPVOID*)(this + 92)) < 0)
        {
            sub_403A30(a2, 3, aCouldnTCreateH);
            return a2;
        }
        sub_4229D0(aMpDoneCreating);
        sub_4229D0(aMpSetSp);
        if ((*(int(__stdcall**)(_DWORD, _DWORD*))(**(_DWORD**)(this + 92) + 52))(*(_DWORD*)(this + 92), v18) < 0)
        {
            v16 = aCouldnTSetHost;
        LABEL_54:
            sub_403A30(a2, 4, v16);
            return a2;
        }
        sub_4229D0(aMpDoneSettingS);
    }
    sub_4229D0(aMpCreateDevice);
    v7 = (_DWORD*)(this + 96);
    if (CoCreateInstance(&stru_499E14, 0, 1u, &stru_499E04, (LPVOID*)(this + 96)) < 0)
    {
        sub_403A30(a2, 5, aCouldnTCreateD_1);
        return a2;
    }
    sub_4229D0(aMpDoneCreating_0);
    sub_4229D0(aMpSettingSp);
    if ((*(int(__stdcall**)(_DWORD, _DWORD*))(*(_DWORD*)*v7 + 52))(*v7, v18) < 0)
    {
        sub_403A30(a2, 6, aCouldnTSetDevi);
        return a2;
    }
    sub_4229D0(aMpDoneSettingS);
    if (lpMultiByteStr && strlen(lpMultiByteStr))
    {
        sub_4229D0(aMpSettingHosts);
        sub_428820(String, lpMultiByteStr, 0xFFFFFFFF);
        v8 = wcslen(String);
        if ((*(int(__stdcall**)(_DWORD, wchar_t*, wchar_t*, size_t, int))(**(_DWORD**)(this + 92) + 72))(
            *(_DWORD*)(this + 92),
            aHostname,
            String,
            2 * v8 + 2,
            1) < 0)
        {
            sub_403A30(a2, 7, aCouldnTSetHost_0);
            return a2;
        }
        sub_4229D0(aMpDoneSettingH);
    }
    sub_4229D0(aMpSettingPort);
    v17 = a4;
    if (lpMultiByteStr)
        v9 = *(_DWORD*)(this + 92);
    else
        v9 = *v7;
    if ((*(int(__stdcall**)(int, wchar_t*, int*, int, int))(*(_DWORD*)v9 + 72))(v9, aPort, &v17, 4, 2) < 0)
    {
        sub_403A30(a2, 8, aCouldnTSetHost_1);
        return a2;
    }
    sub_4229D0(aMpDoneSettingP);
    memset(v20, 0, sizeof(v20));
    v20[6] = dword_4A4DC0;
    v20[8] = dword_4A4DC8;
    v20[9] = dword_4A4DCC;
    v20[7] = dword_4A4DC4;
    memset(&v20[2], 0, 16);
    v20[0] = 72;
    sub_428820(WideCharStr, (LPCCH)(this + 140), 0xFFFFFFFF);
    memset(v19, 0, sizeof(v19));
    v19[2] = WideCharStr;
    v19[4] = strlen(byte_520A60);
    ++v19[4];
    v19[0] = 24;
    v19[1] = 3;
    v19[3] = byte_520A60;
    sub_4229D0(aMpSettingPeerI);
    if ((*(int(__stdcall**)(_DWORD, _DWORD*, _DWORD, _DWORD, unsigned int))(*(_DWORD*)*v5 + 80))(
        *v5,
        v19,
        0,
        0,
        0x80000000) < 0)
    {
        sub_403A30(a2, 9, aCouldnTSetPeer);
        return a2;
    }
    if (lpMultiByteStr)
    {
        memset(v22, 0, sizeof(v22));
        v13 = *v5;
        v22[0] = 36;
        if ((*(int(__stdcall**)(int, _DWORD*, _DWORD*, _DWORD))(*(_DWORD*)v13 + 132))(v13, v18, v22, 0) < 0)
        {
            v16 = aCouldnTGetspca;
            goto LABEL_54;
        }
        memset(v21, 0, sizeof(v21));
        v21[6] = dword_4A4DC0;
        v21[0] = 72;
        v21[7] = dword_4A4DC4;
        v21[8] = dword_4A4DC8;
        v21[9] = dword_4A4DCC;
        sub_4229D0(aMpEnumhosts);
        v14 = (*(int(__stdcall**)(_DWORD, _DWORD*, _DWORD, _DWORD, _DWORD, _DWORD, int, int, int, _DWORD, int*, _DWORD))(*(_DWORD*)*v5 + 100))(
            *v5,
            v21,
            *(_DWORD*)(this + 92),
            *v7,
            0,
            0,
            -1,
            500,
            5000,
            0,
            &v17,
            0);
        sub_4229D0(aMpDoneEnumhost);
        v15 = *(_DWORD*)(this + 92);
        if (v14 < 0)
        {
            if (v15)
            {
                (*(void(__stdcall**)(_DWORD))(*(_DWORD*)v15 + 8))(*(_DWORD*)(this + 92));
                *(_DWORD*)(this + 92) = 0;
            }
            if (*v7)
            {
                (*(void(__stdcall**)(_DWORD))(*(_DWORD*)*v7 + 8))(*v7);
                *v7 = 0;
            }
            (*(void(__stdcall**)(_DWORD, _DWORD, int))(*(_DWORD*)*v5 + 20))(*v5, 0, 2);
            if (v14 == -2146074560)
                v16 = aInvalidIpAddre;
            else
                v16 = aCanTEnumhosts;
            goto LABEL_54;
        }
        if (v15)
        {
            (*(void(__stdcall**)(_DWORD))(*(_DWORD*)v15 + 8))(*(_DWORD*)(this + 92));
            *(_DWORD*)(this + 92) = 0;
        }
        if (*v7)
        {
            (*(void(__stdcall**)(_DWORD))(*(_DWORD*)*v7 + 8))(*v7);
            *v7 = 0;
        }
        *(_BYTE*)(this + 936) = 0;
        *(_BYTE*)(this + 937) = 0;
        *(_BYTE*)(this + 938) = 1;
        *(_DWORD*)(this + 940) = 0;
        sub_488CEE(0);
        sub_4229D0(aMpLaunchSucces);
        result = a2;
        *a2 = 0;
        a2[1] = 0;
    }
    else
    {
        if (strlen((const char*)(this + 400)))
        {
            sub_428820(String, (LPCCH)(this + 400), 0xFFFFFFFF);
            v10 = wcslen(String);
            v20[12] = operator new(2 * v10 + 2);
            wcscpy((wchar_t*)v20[12], String);
        }
        else
        {
            v20[12] = 0;
        }
        sub_4229D0(aMpHosting);
        v11 = (*(int(__stdcall**)(_DWORD, _DWORD*, int, int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD*)*v5 + 36))(
            *v5,
            v20,
            this + 96,
            1,
            0,
            0,
            0,
            0);
        if (v20[12])
        {
            sub_4885A6((LPVOID)v20[12]);
            v20[12] = 0;
        }
        if (*v7)
        {
            (*(void(__stdcall**)(_DWORD))(*(_DWORD*)*v7 + 8))(*v7);
            *v7 = 0;
        }
        if (v11 < 0)
        {
            if (*v7)
            {
                (*(void(__stdcall**)(_DWORD))(*(_DWORD*)*v7 + 8))(*v7);
                *v7 = 0;
            }
            v16 = aCouldnTHost;
            goto LABEL_54;
        }
        sub_4229D0(aMpDoneHostIng);
        v12 = *(_DWORD*)(this + 92);
        if (v12)
        {
            (*(void(__stdcall**)(_DWORD))(*(_DWORD*)v12 + 8))(*(_DWORD*)(this + 92));
            *(_DWORD*)(this + 92) = 0;
        }
        if (*v7)
        {
            (*(void(__stdcall**)(_DWORD))(*(_DWORD*)*v7 + 8))(*v7);
            *v7 = 0;
        }
        *(_BYTE*)(this + 936) = lpMultiByteStr == 0;
        *(_BYTE*)(this + 937) = 0;
        sub_4229D0(aMpLaunchSucces);
        result = a2;
        *a2 = 0;
        a2[1] = 0;
    }
    return result;
}
// 4A2808: using guessed type wchar_t aPort[5];
// 4A2864: using guessed type wchar_t aHostname[9];
// 4A4DC0: using guessed type int dword_4A4DC0;
// 4A4DC4: using guessed type int dword_4A4DC4;
// 4A4DC8: using guessed type int dword_4A4DC8;
// 4A4DCC: using guessed type int dword_4A4DCC;

//----- (00410A90) --------------------------------------------------------
int __stdcall sub_410A90(int a1, unsigned int a2, float a3)
{
    return sub_410AB0(a1, a2, a3);
}

//----- (00410AB0) --------------------------------------------------------
int __thiscall sub_410AB0(int this, unsigned int a2, float a3)
{
    int v4; // eax
    void* v5; // ebx
    unsigned int v6; // eax
    const void* v7; // eax
    unsigned int v8; // ecx
    wchar_t* v9; // eax
    int v10; // eax
    int v11; // eax
    void* v12; // eax
    const void* v13; // esi
    float v14; // ecx
    int v15; // eax
    int v16; // eax
    int v17; // eax
    _DWORD* v18; // eax
    const char* v19; // eax
    void* v20; // edx
    _DWORD* v21; // eax
    const char* v22; // eax
    _DWORD* v23; // eax
    const char* v24; // eax
    int result; // eax
    float v26; // ecx
    int v27; // eax
    _DWORD* v28; // eax
    const char* v29; // eax
    _DWORD* v30; // eax
    const char* v31; // eax
    _DWORD* v32; // eax
    const char* v33; // eax
    _DWORD* v34; // eax
    const char* v35; // eax
    float v36; // ebx
    int v37; // edx
    struct _RTL_CRITICAL_SECTION* v38; // edx
    CHAR* v39; // eax
    CHAR* v40; // ebx
    float v41; // ecx
    int v42; // ecx
    struct _RTL_CRITICAL_SECTION* v43; // esi
    float v44; // edi
    int v45; // eax
    _DWORD* v46; // edi
    int* v47; // eax
    float v48; // esi
    int v49; // edi
    long double v50; // st7
    int* v51; // eax
    int v52; // ecx
    struct _RTL_CRITICAL_SECTION* lpCriticalSection; // [esp+54h] [ebp-4Ch]
    LPCRITICAL_SECTION lpCriticalSectiona; // [esp+54h] [ebp-4Ch]
    float lpCriticalSectionb; // [esp+54h] [ebp-4Ch]
    float v56; // [esp+58h] [ebp-48h]
    int v57[2]; // [esp+5Ch] [ebp-44h] BYREF
    int v58[2]; // [esp+64h] [ebp-3Ch] BYREF
    int v59[2]; // [esp+6Ch] [ebp-34h] BYREF
    int v60[2]; // [esp+74h] [ebp-2Ch] BYREF
    int v61[2]; // [esp+7Ch] [ebp-24h] BYREF
    int v62[2]; // [esp+84h] [ebp-1Ch] BYREF
    int v63[2]; // [esp+8Ch] [ebp-14h] BYREF
    char v64[4]; // [esp+94h] [ebp-Ch] BYREF
    _WORD v65[3]; // [esp+98h] [ebp-8h]

    v4 = *(_DWORD*)(this + 24);
    if (!v4)
        return 0;
    switch (a2)
    {
    case 0xFFFF0005:
        if (!*(_BYTE*)(this + 938))
            return 0;
        v26 = a3;
        *(_BYTE*)(this + 938) = 0;
        v27 = *(_DWORD*)(LODWORD(v26) + 12);
        if (v27 >= 0)
        {
            *(_BYTE*)(this + 936) = 0;
            *(_BYTE*)(this + 937) = 1;
            *(_DWORD*)(this + 940) = 1;
            sub_488CEE(0);
            return 0;
        }
        else
        {
            switch (v27)
            {
            case -2146073072:
                v28 = sub_403A30(v60, 2, aSessionIsFull);
                *(_DWORD*)(this + 940) = *v28;
                v29 = (const char*)v28[1];
                if (v29)
                    *(_DWORD*)(this + 944) = _strdup(v29);
                sub_488CEE((LPVOID)v60[1]);
                return 0;
            case -2146074016:
                v30 = sub_403A30(v61, 2, aHostRejectedTh);
                *(_DWORD*)(this + 940) = *v30;
                v31 = (const char*)v30[1];
                if (v31)
                    *(_DWORD*)(this + 944) = _strdup(v31);
                sub_488CEE((LPVOID)v61[1]);
                return 0;
            case -2146073200:
                v32 = sub_403A30(v62, 2, aPlayerNotReach);
                *(_DWORD*)(this + 940) = *v32;
                v33 = (const char*)v32[1];
                if (v33)
                    *(_DWORD*)(this + 944) = _strdup(v33);
                sub_488CEE((LPVOID)v62[1]);
                return 0;
            default:
                v34 = sub_403A30(v63, 2, aConnectionFail);
                *(_DWORD*)(this + 940) = *v34;
                v35 = (const char*)v34[1];
                if (v35)
                    *(_DWORD*)(this + 944) = _strdup(v35);
                sub_488CEE((LPVOID)v63[1]);
                return 0;
            }
        }
    case 0xFFFF0007:
        v36 = a3;
        v37 = *(_DWORD*)(LODWORD(a3) + 4);
        a2 = 0;
        result = (*(int(__stdcall**)(int, int, _DWORD, unsigned int*, _DWORD))(*(_DWORD*)v4 + 84))(v4, v37, 0, &a2, 0);
        if (result >= 0 || result == -2146074368)
        {
            v38 = (struct _RTL_CRITICAL_SECTION*)operator new(a2);
            memset(v38, 0, a2);
            v38->DebugInfo = (PRTL_CRITICAL_SECTION_DEBUG)24;
            lpCriticalSectiona = v38;
            result = (*(int(__stdcall**)(_DWORD, _DWORD, struct _RTL_CRITICAL_SECTION*, unsigned int*, _DWORD))(**(_DWORD**)(this + 24) + 84))(
                *(_DWORD*)(this + 24),
                *(_DWORD*)(LODWORD(v36) + 4),
                v38,
                &a2,
                0);
            if (result >= 0)
            {
                v39 = (CHAR*)operator new(0x2078u);
                if (v39)
                {
                    v40 = v39;
                    *((_DWORD*)v39 + 2062) = 0;
                    *((_DWORD*)v39 + 2063) = 0;
                    *((_DWORD*)v39 + 2064) = 0;
                    v39[8260] = 0;
                    *((_DWORD*)v39 + 2069) = 0;
                    *((_DWORD*)v39 + 2070) = 0;
                    *((_DWORD*)v39 + 2071) = 0;
                    v39[8288] = 0;
                    *((_DWORD*)v39 + 2073) = 0;
                    *((_DWORD*)v39 + 2074) = 0;
                    *((_DWORD*)v39 + 2075) = 0;
                    v39[8304] = 0;
                }
                else
                {
                    v40 = 0;
                }
                memset(v40, 0, 0x2078u);
                v41 = a3;
                *(_DWORD*)v40 = 1;
                v40[53] = 0;
                v40[52] = 0;
                *((_DWORD*)v40 + 2077) = 0;
                v42 = *(_DWORD*)(LODWORD(v41) + 4);
                *((_DWORD*)v40 + 2068) = 1;
                *((_DWORD*)v40 + 2067) = 1;
                *((_DWORD*)v40 + 2066) = 1;
                *((_DWORD*)v40 + 2) = v42;
                if (lpCriticalSectiona->LockSemaphore)
                    strcpy(v40 + 36, (const char*)lpCriticalSectiona->OwningThread);
                sub_428840(v40 + 12, (wchar_t*)lpCriticalSectiona->RecursionCount, 0x18u);
                if ((lpCriticalSectiona->SpinCount & 2) != 0)
                {
                    *(_DWORD*)(this + 84) = *(_DWORD*)(LODWORD(a3) + 4);
                    v40[53] = 1;
                }
                if ((lpCriticalSectiona->SpinCount & 4) != 0)
                {
                    *(_DWORD*)(this + 88) = *(_DWORD*)(LODWORD(a3) + 4);
                    v40[52] = 1;
                }
                if (lpCriticalSectiona)
                    sub_4885A6(lpCriticalSectiona);
                v43 = (struct _RTL_CRITICAL_SECTION*)(this + 112);
                LODWORD(a3) = this + 112;
                EnterCriticalSection((LPCRITICAL_SECTION)(this + 112));
                if (v40[52])
                {
                    strcpy((char*)(this + 920), v40 + 36);
                    v43 = (struct _RTL_CRITICAL_SECTION*)LODWORD(a3);
                }
                InterlockedIncrement((volatile LONG*)(this + 100));
                *((_DWORD*)v40 + 2077) = *(_DWORD*)(this + 136);
                *(_DWORD*)(this + 136) = v40;
                *(_DWORD*)&v65[1] = v40;
                ++*(_DWORD*)v40;
                sub_411820(this, 65281, (int)v64, 0xAu);
                LeaveCriticalSection(v43);
                return 0;
            }
        }
        return result;
    case 0xFFFF0009:
        v44 = a3;
        *(_DWORD*)&v65[1] = sub_411B60(this, *(_DWORD*)(LODWORD(a3) + 4));
        EnterCriticalSection((LPCRITICAL_SECTION)(this + 112));
        *(_BYTE*)(*(_DWORD*)&v65[1] + 4) = 1;
        LeaveCriticalSection((LPCRITICAL_SECTION)(this + 112));
        sub_411820(this, 65282, (int)v64, 0xAu);
        sub_411BB0(this, *(_DWORD*)(LODWORD(v44) + 4));
        return 0;
    case 0xFFFF000B:
        lpCriticalSection = (struct _RTL_CRITICAL_SECTION*)(this + 960);
        EnterCriticalSection((LPCRITICAL_SECTION)(this + 960));
        v5 = *(void**)(this + 956);
        v6 = *(_DWORD*)(LODWORD(a3) + 12);
        a2 = v6;
        if (!v5)
            goto LABEL_7;
        v7 = (const void*)(v6 + 8);
        break;
    case 0xFFFF000D:
        if (*(_DWORD*)(LODWORD(a3) + 4) != *(_DWORD*)(this + 84))
            return 0;
        *(_BYTE*)(this + 936) = 1;
        *(_BYTE*)(this + 937) = 0;
        return 0;
    case 0xFFFF000E:
        if (*(_BYTE*)(this + 108) && *(_DWORD*)(this + 100) < *(_DWORD*)(this + 104))
            return 0;
        return -2146074016;
    case 0xFFFF0011:
        v47 = sub_40E8E0(20);
        v48 = a3;
        v49 = (int)v47;
        sub_40F4C0(v47, *(_DWORD*)(LODWORD(a3) + 4), *(_DWORD*)(LODWORD(a3) + 16), *(_WORD**)(LODWORD(a3) + 12));
        if ((*(_BYTE*)(*(_DWORD*)(v49 + 16) + 2) & 8) == 0 && *(_DWORD*)(v49 + 4) != *(_DWORD*)(this + 84))
        {
            if (flt_4F5CBC > 0.0)
            {
                a3 = flt_4F5CB8;
                v56 = *(float*)(dword_520970 + 76);
                lpCriticalSectionb = flt_4F5CBC;
                if (flt_4F5CB8 == flt_4F5CBC)
                {
                    v50 = flt_4F5CB8;
                }
                else
                {
                    a2 = rand();
                    v50 = fabs((double)(int)a2 * 0.000030518509) * (lpCriticalSectionb - a3) + a3;
                }
                *(float*)v49 = v50 + v56;
            }
            if (flt_4F5CC0 > 0.0)
            {
                a3 = COERCE_FLOAT(rand());
                if (fabs((double)SLODWORD(a3) * 0.000030518509) < flt_4F5CC0)
                {
                    sub_4113D0(v49);
                    return 0;
                }
            }
        }
        EnterCriticalSection((LPCRITICAL_SECTION)(this + 44));
        v51 = *(int**)(this + 28);
        if (v51)
        {
            *(_DWORD*)(this + 28) = v51[1];
        }
        else
        {
            v51 = (int*)operator new(8u);
            *v51 = 0;
        }
        v51[1] = 0;
        *v51 = v49;
        v51[1] = 0;
        if (*(_DWORD*)(this + 32))
            *(_DWORD*)(*(_DWORD*)(this + 36) + 4) = v51;
        else
            *(_DWORD*)(this + 32) = v51;
        v52 = *(_DWORD*)(this + 40) + 1;
        *(_DWORD*)(this + 36) = v51;
        *(_DWORD*)(this + 40) = v52;
        LeaveCriticalSection((LPCRITICAL_SECTION)(this + 44));
        *(float*)dword_520A28 = *(float*)dword_520A28 + 1.0;
        *(float*)dword_520890 = (double)*(int*)(LODWORD(v48) + 16) + *(float*)dword_520890;
        return 0;
    case 0xFFFF0016:
        v45 = *(_DWORD*)(this + 100);
        v46 = (_DWORD*)(this + 100);
        *(_BYTE*)(this + 937) = 0;
        *(_BYTE*)(this + 936) = 0;
        if (v45)
        {
            do
                InterlockedDecrement((volatile LONG*)(this + 100));
            while (*v46);
        }
        *(_DWORD*)&v65[1] = 0;
        sub_411820(this, 65283, (int)v64, 0xAu);
        return 0;
    default:
        return 0;
    }
    while (memcmp(v7, (const void*)(*((_DWORD*)v5 + 65) + 8), 0x10u))
    {
        v5 = (void*)*((_DWORD*)v5 + 69);
        if (!v5)
        {
        LABEL_7:
            v5 = operator new(0x118u);
            memset(v5, 0, 0x118u);
            *((_DWORD*)v5 + 69) = *(_DWORD*)(this + 956);
            *(_DWORD*)(this + 956) = v5;
            break;
        }
    }
    v8 = a2;
    *((_DWORD*)v5 + 68) = 0;
    v9 = *(wchar_t**)(v8 + 48);
    if (v9)
        sub_428840((LPSTR)v5, v9, 0xFFFFFFFF);
    sub_4885A6(*((LPVOID*)v5 + 65));
    v10 = *((_DWORD*)v5 + 66);
    *((_DWORD*)v5 + 65) = 0;
    if (v10)
    {
        (*(void(__stdcall**)(int))(*(_DWORD*)v10 + 8))(v10);
        *((_DWORD*)v5 + 66) = 0;
    }
    v11 = *((_DWORD*)v5 + 67);
    if (v11)
    {
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)v11 + 8))(*((_DWORD*)v5 + 67));
        *((_DWORD*)v5 + 67) = 0;
    }
    v12 = operator new(0x48u);
    v13 = (const void*)a2;
    *((_DWORD*)v5 + 65) = v12;
    memset(v12, 0, 0x48u);
    qmemcpy(*((void**)v5 + 65), v13, 0x48u);
    v14 = a3;
    *(_DWORD*)(*((_DWORD*)v5 + 65) + 48) = 0;
    v15 = *(_DWORD*)(LODWORD(v14) + 4);
    if (v15)
        (*(void(__stdcall**)(int, int))(*(_DWORD*)v15 + 20))(v15, (int)v5 + 264);
    v16 = *(_DWORD*)(LODWORD(a3) + 8);
    if (v16)
        (*(void(__stdcall**)(int, int))(*(_DWORD*)v16 + 20))(v16, (int)v5 + 268);
    if (*(_DWORD*)(this + 984))
        SetEvent(*(HANDLE*)(this + 984));
    if (*(_BYTE*)(this + 938))
    {
        (*(void(__stdcall**)(_DWORD, _DWORD, int))(**(_DWORD**)(this + 24) + 20))(*(_DWORD*)(this + 24), 0, 2);
        v17 = (*(int(__stdcall**)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, float*, _DWORD))(**(_DWORD**)(this + 24) + 24))(
            *(_DWORD*)(this + 24),
            *((_DWORD*)v5 + 65),
            *((_DWORD*)v5 + 66),
            *((_DWORD*)v5 + 67),
            0,
            0,
            0,
            0,
            0,
            0,
            &a3,
            0);
        if (v17 < 0)
        {
            if (v17 == -2146073072)
            {
                v18 = sub_403A30(v57, 2, aSessionIsFull);
                *(_DWORD*)(this + 940) = *v18;
                v19 = (const char*)v18[1];
                if (v19)
                    *(_DWORD*)(this + 944) = _strdup(v19);
                v20 = (void*)v57[1];
            }
            else if (v17 == -2146074016)
            {
                v21 = sub_403A30(v58, 2, aHostRejectedTh);
                *(_DWORD*)(this + 940) = *v21;
                v22 = (const char*)v21[1];
                if (v22)
                    *(_DWORD*)(this + 944) = _strdup(v22);
                v20 = (void*)v58[1];
            }
            else
            {
                v23 = sub_403A30(v59, 2, aConnectionFail);
                *(_DWORD*)(this + 940) = *v23;
                v24 = (const char*)v23[1];
                if (v24)
                    *(_DWORD*)(this + 944) = _strdup(v24);
                v20 = (void*)v59[1];
            }
            sub_488CEE(v20);
            *(_BYTE*)(this + 938) = 0;
        }
    }
    LeaveCriticalSection(lpCriticalSection);
    return 0;
}
// 410C9E: conditional instruction was optimized away because eax.4<0
// 4F5CB8: using guessed type float flt_4F5CB8;
// 4F5CBC: using guessed type float flt_4F5CBC;
// 4F5CC0: using guessed type float flt_4F5CC0;
// 520890: using guessed type int dword_520890;
// 520970: using guessed type int dword_520970;
// 520A28: using guessed type int dword_520A28;

//----- (004113D0) --------------------------------------------------------
void __stdcall sub_4113D0(int a1)
{
    sub_40EB70(*(unsigned int**)(a1 + 16));
    sub_40EB70((unsigned int*)a1);
}

//----- (004113F0) --------------------------------------------------------
_BYTE* __thiscall sub_4113F0(_DWORD* this, int a2, __int16 a3, __int16 a4, char a5)
{
    _BYTE* result; // eax

    result = operator new(0x10u);
    result[8] = a5;
    *(_DWORD*)result = a2;
    *((_WORD*)result + 2) = a3;
    *((_WORD*)result + 3) = a4;
    *((_DWORD*)result + 3) = this[5];
    this[5] = result;
    return result;
}

//----- (00411430) --------------------------------------------------------
_DWORD* __thiscall sub_411430(_DWORD* this, int a2)
{
    _DWORD* v3; // edi
    _DWORD* result; // eax
    _DWORD* v5; // esi

    v3 = 0;
    result = (_DWORD*)this[5];
    while (result)
    {
        if (*result == a2)
        {
            v5 = (_DWORD*)result[3];
            if (v3)
                v3[3] = v5;
            else
                this[5] = v5;
            sub_4885A6(result);
            result = v5;
        }
        else
        {
            v3 = result;
            result = (_DWORD*)result[3];
        }
    }
    return result;
}

//----- (00411480) --------------------------------------------------------
bool __thiscall sub_411480(_DWORD* this, int** a2, int a3, _WORD* a4, int a5, int a6, int a7)
{
    int v7; // ebx
    _WORD* v9; // eax
    unsigned int v10; // ebp
    char v11; // cl
    int v12; // edx
    int v13; // esi
    unsigned int v14; // edx
    int v15; // edi
    int v16; // edx
    unsigned int v17; // edx
    unsigned int v18; // ecx
    int v19; // eax
    int v20; // eax
    int** v21; // esi
    int* v22; // ebx
    int v23; // edx
    int v24; // eax
    int* v25; // eax
    const void* v26; // esi
    int v27; // esi
    int** v28; // esi
    int* v29; // esi
    int v30; // edi
    int v31; // eax
    _DWORD* v32; // esi
    _DWORD* v33; // ecx
    int v34; // eax
    char* v35; // edx
    int v36; // edi
    int v37; // eax
    int v38; // eax
    int v39; // eax
    _DWORD* v40; // ecx
    bool v41; // zf
    int v42; // [esp+Ch] [ebp-3Ch]
    int v43; // [esp+Ch] [ebp-3Ch]
    int v45; // [esp+24h] [ebp-24h]
    int v46; // [esp+28h] [ebp-20h]
    int v47; // [esp+2Ch] [ebp-1Ch] BYREF
    unsigned int v48; // [esp+30h] [ebp-18h] BYREF
    int v49; // [esp+34h] [ebp-14h]
    int* v50[4]; // [esp+38h] [ebp-10h] BYREF

    v7 = (int)this;
    if (!this[6])
        return 0;
    v9 = a4;
    v10 = a5;
    *a4 = (_WORD)a2;
    *(_DWORD*)(v9 + 1) = 0;
    *(float*)dword_5209C0 = *(float*)dword_5209C0 + 1.0;
    *(float*)dword_520A08 = (double)a5 + *(float*)dword_520A08;
    v11 = a6;
    v12 = *(_DWORD*)(v9 + 1);
    v48 = v10;
    v13 = a6 & 1;
    v49 = (int)v9;
    if ((a6 & 1) != 0)
        v14 = v12 | 2;
    else
        v14 = v12 & 0xFFFFFFFD;
    *(_DWORD*)(v9 + 1) = v14;
    v15 = (v11 & 2) != 0 ? 128 : 64;
    a5 = v15;
    a6 = v11 & 4;
    v16 = *(_DWORD*)(v9 + 1);
    if ((v11 & 4) != 0)
        v17 = v16 | 4;
    else
        v17 = v16 & 0xFFFFFFFB;
    *(_DWORD*)(v9 + 1) = v17;
    v46 = v11 & 8;
    if ((v11 & 8) != 0)
    {
        v15 |= 0x20u;
        a5 = v15;
        v18 = v17 & 0xFFFFFFF7;
    }
    else
    {
        v18 = *(_DWORD*)(v9 + 1) | 8;
    }
    *(_DWORD*)(v9 + 1) = v18;
    if (v13)
    {
        if (a3)
        {
            v42 = a3;
            a3 = 1;
            v50[0] = sub_411B60(v7, v42);
        }
        else
        {
            a3 = sub_4118C0(v7, v50, 4);
        }
        v20 = a3;
        if (a3 <= 0)
        {
        LABEL_36:
            sub_411920(v7, v50, v20);
            return 1;
        }
        v21 = v50;
        v45 = a3;
        a2 = v50;
        while (1)
        {
            if ((*v21)[2] == *(_DWORD*)(v7 + 84) && v46)
                goto LABEL_34;
            v22 = sub_40E8E0(24);
            memset(v22, 0, 0x18u);
            if (a6)
                *v22 = (*v21)[2067]++;
            else
                *v22 = (*v21)[2068]++;
            v23 = a5;
            v24 = a7;
            v22[1] = 1056964608;
            v22[4] = v23;
            v22[5] = v24;
            v25 = sub_40E8E0(v10);
            v26 = a4;
            v22[2] = (int)v25;
            v22[3] = v10;
            qmemcpy(v25, v26, v10);
            v27 = a5;
            *(_DWORD*)(v22[2] + 2) = (16 * *v22) | *(_DWORD*)(v22[2] + 2) & 0xF;
            v43 = v27;
            v48 = v10;
            v28 = a2;
            v49 = v22[2];
            (*(void(__stdcall**)(_DWORD, int, unsigned int*, int, int, int*, int*, int))(*(_DWORD*)this[6] + 28))(
                this[6],
                (*a2)[2],
                &v48,
                1,
                v22[5],
                v22 + 2,
                &v47,
                v43);
            v29 = *v28;
            if (a6)
            {
                v30 = v29[2074];
                v31 = v29[2075];
                v32 = v29 + 2073;
                v32[1] = v30 + 1;
                if (v30 + 1 <= v31)
                    goto LABEL_33;
                v33 = (_DWORD*)*v32;
                v34 = v31 + 8;
                v32[2] = v34;
                v35 = (char*)sub_488DD7(v33, 4 * v34);
                if (!v35)
                    goto LABEL_33;
            }
            else
            {
                v36 = v29[2070];
                v37 = v29[2071];
                v32 = v29 + 2069;
                v32[1] = v36 + 1;
                if (v36 + 1 <= v37)
                    goto LABEL_33;
                v38 = v37 + 8;
                v32[2] = v38;
                v35 = (char*)sub_488DD7((LPVOID)*v32, 4 * v38);
                if (!v35)
                    goto LABEL_33;
            }
            *v32 = v35;
            memset(&v35[4 * v32[1]], 0, 4 * (v32[2] - v32[1]));
        LABEL_33:
            v39 = v32[1];
            v40 = (_DWORD*)*v32;
            v21 = a2;
            v40[v39 - 1] = v22;
            v7 = (int)this;
        LABEL_34:
            ++v21;
            v41 = v45 == 1;
            a2 = v21;
            --v45;
            if (v41)
            {
                v20 = a3;
                goto LABEL_36;
            }
        }
    }
    v19 = (*(int(__stdcall**)(_DWORD, int, unsigned int*, int, int, _WORD*, int***, int))(**(_DWORD**)(v7 + 24) + 28))(
        *(_DWORD*)(v7 + 24),
        a3,
        &v48,
        1,
        a7,
        v9,
        &a2,
        v15);
    return v19 == 1409038 || !v19;
}
// 5209C0: using guessed type int dword_5209C0;
// 520A08: using guessed type int dword_520A08;

//----- (004117A0) --------------------------------------------------------
bool __thiscall sub_4117A0(_DWORD* this, int** a2, _WORD* a3, int a4, int a5, int a6)
{
    return sub_411480(this, a2, 0, a3, a4, a5, a6);
}

//----- (004117D0) --------------------------------------------------------
bool __thiscall sub_4117D0(int this, int** a2, _WORD* a3, int a4, int a5, int a6)
{
    struct _RTL_CRITICAL_SECTION* v7; // edi
    bool v8; // bl

    v7 = (struct _RTL_CRITICAL_SECTION*)(this + 112);
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 112));
    v8 = sub_411480((_DWORD*)this, a2, *(_DWORD*)(this + 88), a3, a4, a5, a6);
    LeaveCriticalSection(v7);
    return v8;
}

//----- (00411820) --------------------------------------------------------
char __thiscall sub_411820(int this, __int16 a2, int a3, unsigned int a4)
{
    int* v5; // ebx
    int** v6; // eax
    int v7; // ecx

    *(_WORD*)a3 = a2;
    *(_DWORD*)(a3 + 2) = 0;
    *(_DWORD*)(a3 + 2) = 8;
    v5 = sub_40E8E0(20);
    sub_40F4C0(v5, *(_DWORD*)(this + 84), a4, (_WORD*)a3);
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 44));
    v6 = *(int***)(this + 28);
    if (v6)
    {
        *(_DWORD*)(this + 28) = v6[1];
    }
    else
    {
        v6 = (int**)operator new(8u);
        *v6 = 0;
    }
    v6[1] = 0;
    *v6 = v5;
    v6[1] = 0;
    if (*(_DWORD*)(this + 32))
        *(_DWORD*)(*(_DWORD*)(this + 36) + 4) = v6;
    else
        *(_DWORD*)(this + 32) = v6;
    v7 = *(_DWORD*)(this + 40) + 1;
    *(_DWORD*)(this + 36) = v6;
    *(_DWORD*)(this + 40) = v7;
    LeaveCriticalSection((LPCRITICAL_SECTION)(this + 44));
    return 1;
}

//----- (004118C0) --------------------------------------------------------
int __thiscall sub_4118C0(int this, _DWORD* a2, int a3)
{
    struct _RTL_CRITICAL_SECTION* v4; // ebx
    int v5; // eax
    int i; // edi

    v4 = (struct _RTL_CRITICAL_SECTION*)(this + 112);
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 112));
    v5 = *(_DWORD*)(this + 136);
    for (i = 0; v5; v5 = *(_DWORD*)(v5 + 8308))
    {
        if (i >= a3)
            break;
        if (!*(_BYTE*)(v5 + 4))
        {
            *a2++ = v5;
            ++*(_DWORD*)v5;
            ++i;
        }
    }
    LeaveCriticalSection(v4);
    return i;
}

//----- (00411920) --------------------------------------------------------
void __thiscall sub_411920(int this, int** a2, int a3)
{
    struct _RTL_CRITICAL_SECTION* v4; // ebx
    int* v5; // esi
    int* v6; // edx
    int v7; // eax
    int** v8; // ecx
    int v9; // eax
    int* v10; // ebx
    int* v11; // [esp+10h] [ebp-8h]
    struct _RTL_CRITICAL_SECTION* v12; // [esp+14h] [ebp-4h]

    v4 = (struct _RTL_CRITICAL_SECTION*)(this + 112);
    v12 = (struct _RTL_CRITICAL_SECTION*)(this + 112);
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 112));
    v5 = *(int**)(this + 136);
    v6 = 0;
    v11 = 0;
    if (v5)
    {
        while (1)
        {
            v7 = 0;
            if (a3 <= 0)
                goto LABEL_8;
            v8 = a2;
            while (*v8 != v5)
            {
                ++v7;
                ++v8;
                if (v7 >= a3)
                    goto LABEL_8;
            }
            v9 = *v5 - 1;
            *v5 = v9;
            if (v9 > 0)
            {
            LABEL_8:
                v11 = v5;
                v5 = (int*)v5[2077];
            }
            else
            {
                if (v6)
                    v6[2077] = v5[2077];
                else
                    *(_DWORD*)(this + 136) = v5[2077];
                v10 = v5;
                v5 = (int*)v5[2077];
                sub_4119F0((int)v10);
                sub_4885A6(v10);
                InterlockedDecrement((volatile LONG*)(this + 100));
            }
            if (!v5)
                break;
            v6 = v11;
        }
        v4 = v12;
    }
    memset(a2, 0, 4 * a3);
    LeaveCriticalSection(v4);
}
// 4119C7: conditional instruction was optimized away because ebx.4!=0

//----- (004119F0) --------------------------------------------------------
void __thiscall sub_4119F0(int this)
{
    int i; // edi
    void* v3; // eax
    int j; // edi
    void* v5; // eax
    int k; // edi
    void* v7; // eax

    if (*(_BYTE*)(this + 8304))
    {
        for (i = 0; i < *(_DWORD*)(this + 8296); ++i)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 8292) + 4 * i));
    }
    memset(*(void**)(this + 8292), 0, 4 * *(_DWORD*)(this + 8296));
    v3 = *(void**)(this + 8292);
    *(_DWORD*)(this + 8296) = 0;
    sub_488CEE(v3);
    *(_DWORD*)(this + 8300) = 0;
    *(_DWORD*)(this + 8292) = 0;
    if (*(_BYTE*)(this + 8288))
    {
        for (j = 0; j < *(_DWORD*)(this + 8280); ++j)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 8276) + 4 * j));
    }
    memset(*(void**)(this + 8276), 0, 4 * *(_DWORD*)(this + 8280));
    v5 = *(void**)(this + 8276);
    *(_DWORD*)(this + 8280) = 0;
    sub_488CEE(v5);
    *(_DWORD*)(this + 8284) = 0;
    *(_DWORD*)(this + 8276) = 0;
    if (*(_BYTE*)(this + 8260))
    {
        for (k = 0; k < *(_DWORD*)(this + 8252); ++k)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 8248) + 4 * k));
    }
    memset(*(void**)(this + 8248), 0, 4 * *(_DWORD*)(this + 8252));
    v7 = *(void**)(this + 8248);
    *(_DWORD*)(this + 8252) = 0;
    sub_488CEE(v7);
    *(_DWORD*)(this + 8256) = 0;
    *(_DWORD*)(this + 8248) = 0;
}

//----- (00411B60) --------------------------------------------------------
_DWORD* __thiscall sub_411B60(int this, int a2)
{
    struct _RTL_CRITICAL_SECTION* v3; // edi
    _DWORD* v4; // esi

    v3 = (struct _RTL_CRITICAL_SECTION*)(this + 112);
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 112));
    v4 = *(_DWORD**)(this + 136);
    if (v4)
    {
        while (v4[2] != a2)
        {
            v4 = (_DWORD*)v4[2077];
            if (!v4)
            {
                LeaveCriticalSection(v3);
                return 0;
            }
        }
        ++ * v4;
    }
    LeaveCriticalSection(v3);
    return v4;
}
// 411B9B: conditional instruction was optimized away because esi.4!=0

//----- (00411BB0) --------------------------------------------------------
void __thiscall sub_411BB0(int this, int a2)
{
    struct _RTL_CRITICAL_SECTION* v3; // ebx
    int* v4; // esi
    int* v5; // eax
    int v6; // ecx

    v3 = (struct _RTL_CRITICAL_SECTION*)(this + 112);
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 112));
    v4 = *(int**)(this + 136);
    v5 = 0;
    if (v4)
    {
        while (v4[2] != a2)
        {
            v5 = v4;
            v4 = (int*)v4[2077];
            if (!v4)
                goto LABEL_10;
        }
        v6 = *v4 - 1;
        *v4 = v6;
        if (v6 <= 0)
        {
            if (v5)
                v5[2077] = v4[2077];
            else
                *(_DWORD*)(this + 136) = v4[2077];
            InterlockedDecrement((volatile LONG*)(this + 100));
            sub_4119F0((int)v4);
            sub_4885A6(v4);
        }
    }
LABEL_10:
    LeaveCriticalSection(v3);
}
// 411BEF: conditional instruction was optimized away because esi.4!=0

//----- (00411C50) --------------------------------------------------------
FILE* __thiscall sub_411C50(int this)
{
    int v2; // eax
    int v3; // eax
    int v4; // eax

    sub_4229D0(aMpStartingDisc);
    if (*(_DWORD*)(this + 24))
    {
        if (*(_BYTE*)(this + 938))
        {
            *(_BYTE*)(this + 938) = 0;
            *(_DWORD*)(this + 940) = -1;
            sub_488CEE(0);
        }
        (*(void(__stdcall**)(_DWORD, _DWORD, int))(**(_DWORD**)(this + 24) + 20))(*(_DWORD*)(this + 24), 0, 2);
        (*(void(__stdcall**)(_DWORD, _DWORD))(**(_DWORD**)(this + 24) + 96))(*(_DWORD*)(this + 24), 0);
        ResetEvent(*(HANDLE*)(this + 984));
        CloseHandle(*(HANDLE*)(this + 984));
        v2 = *(_DWORD*)(this + 24);
        *(_DWORD*)(this + 984) = 0;
        if (v2)
        {
            (*(void(__stdcall**)(int))(*(_DWORD*)v2 + 8))(v2);
            *(_DWORD*)(this + 24) = 0;
        }
        *(_BYTE*)(this + 937) = 0;
        *(_BYTE*)(this + 936) = 0;
    }
    v3 = *(_DWORD*)(this + 92);
    if (v3)
    {
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)v3 + 8))(*(_DWORD*)(this + 92));
        *(_DWORD*)(this + 92) = 0;
    }
    v4 = *(_DWORD*)(this + 96);
    if (v4)
    {
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)v4 + 8))(*(_DWORD*)(this + 96));
        *(_DWORD*)(this + 96) = 0;
    }
    sub_411D20((_DWORD*)this);
    return sub_4229D0(aMpDisconnectFi);
}

//----- (00411D20) --------------------------------------------------------
int __thiscall sub_411D20(_DWORD* this)
{
    struct _RTL_CRITICAL_SECTION* v2; // ebx
    int* v3; // eax
    int v4; // edi
    int v5; // ecx
    int v6; // eax
    int v7; // eax
    int result; // eax
    int v9; // edi
    int v10; // eax
    int v11; // eax

    v2 = (struct _RTL_CRITICAL_SECTION*)(this + 11);
    while (1)
    {
        EnterCriticalSection(v2);
        v3 = (int*)this[8];
        if (!v3)
            break;
        v4 = *v3;
        v5 = v3[1];
        *v3 = 0;
        v3[1] = this[7];
        this[7] = v3;
        this[8] = v5;
        if (!v5)
            this[9] = 0;
        LeaveCriticalSection(v2);
        if (!v4)
            goto LABEL_12;
        if (*(_WORD*)(v4 + 12) == 0xFF00)
        {
            v6 = *(_DWORD*)(v4 + 16);
            if (v6)
            {
                v7 = *(_DWORD*)(v6 + 6);
                if (v7)
                    sub_411BB0((int)this, *(_DWORD*)(v7 + 8));
            }
        }
        sub_4113D0(v4);
    }
    LeaveCriticalSection(v2);
LABEL_12:
    while (1)
    {
        result = this[18];
        if (result <= 0)
            break;
        --result;
        v9 = *(_DWORD*)(this[17] + 4 * result);
        this[18] = result;
        if (!v9)
            break;
        if (*(_WORD*)(v9 + 12) == 0xFF00)
        {
            v10 = *(_DWORD*)(v9 + 16);
            if (v10)
            {
                v11 = *(_DWORD*)(v10 + 6);
                if (v11)
                    sub_411BB0((int)this, *(_DWORD*)(v11 + 8));
            }
        }
        sub_4113D0(v9);
    }
    return result;
}

//----- (00411DE0) --------------------------------------------------------
void __thiscall sub_411DE0(int this, char* a2)
{
    struct _RTL_CRITICAL_SECTION* v3; // ebx

    v3 = (struct _RTL_CRITICAL_SECTION*)(this + 112);
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 112));
    strcpy(a2, (const char*)(this + 920));
    LeaveCriticalSection(v3);
}

//----- (00411E30) --------------------------------------------------------
int sub_411E30()
{
    sub_411E40();
    return atexit(sub_411E70);
}

//----- (00411E40) --------------------------------------------------------
int sub_411E40()
{
    int result; // eax

    result = 0;
    byte_4F5CB4 = 1;
    Base = 0;
    NumOfElements = 0;
    dword_4F5CB0 = 0;
    return result;
}
// 4F5CB0: using guessed type int dword_4F5CB0;
// 4F5CB4: using guessed type char byte_4F5CB4;

//----- (00411E70) --------------------------------------------------------
void __cdecl sub_411E70()
{
    signed int i; // esi

    if (byte_4F5CB4)
    {
        for (i = 0; i < (int)NumOfElements; ++i)
            sub_4885A6(*((LPVOID*)Base + i));
    }
    memset(Base, 0, 4 * NumOfElements);
    NumOfElements = 0;
    sub_488CEE(Base);
    dword_4F5CB0 = 0;
    Base = 0;
}
// 4F5CB0: using guessed type int dword_4F5CB0;
// 4F5CB4: using guessed type char byte_4F5CB4;

//----- (00411EE0) --------------------------------------------------------
int __thiscall sub_411EE0(int this, _DWORD* a2, _DWORD* a3, _DWORD* a4)
{
    signed int i; // esi
    _DWORD* v6; // ebx
    unsigned int v7; // edi
    unsigned int v8; // kr04_4
    char* v9; // eax
    int v10; // edi
    bool v11; // cc
    int v12; // esi
    FILE* v13; // eax
    int v14; // eax
    int result; // eax

    if (!*(_BYTE*)(this + 988))
    {
        *(_BYTE*)(this + 988) = 1;
        sub_4229D0(aCheckingFileCh);
        *(_DWORD*)(this + 996) = -1;
        *(_DWORD*)(this + 992) = 0;
        *(_DWORD*)(this + 1000) = 0;
        if (byte_4F5CB4)
        {
            for (i = 0; i < (int)NumOfElements; ++i)
                sub_4885A6(*((LPVOID*)Base + i));
        }
        memset(Base, 0, 4 * NumOfElements);
        NumOfElements = 0;
        sub_488CEE(Base);
        dword_4F5CB0 = 0;
        Base = 0;
        sub_412140(".\\", aIni);
        sub_412140(".\\", aPf3);
        qsort(Base, NumOfElements, 4u, (_CoreCrtNonSecureSearchSortCompareFunction)sub_412120);
        v6 = operator new(0x108u);
        v8 = strlen(*(const char**)dword_522340) + 1;
        v7 = *(_DWORD*)dword_522340 + v8;
        qmemcpy(v6, *(const void**)dword_522340, 4 * (v8 >> 2));
        qmemcpy(&v6[v8 >> 2], (const void*)(v7 - v8 + 4 * (v8 >> 2)), v8 & 3);
        v6[65] = 0;
        if ((int)++NumOfElements > dword_4F5CB0)
        {
            dword_4F5CB0 += 8;
            v9 = (char*)sub_488DD7(Base, 4 * dword_4F5CB0);
            if (v9)
            {
                Base = v9;
                memset(&v9[4 * NumOfElements], 0, 4 * (dword_4F5CB0 - NumOfElements));
            }
        }
        v10 = 0;
        *((_DWORD*)Base + NumOfElements - 1) = v6;
        v11 = (int)NumOfElements <= 0;
        *(_DWORD*)(this + 992) = NumOfElements;
        if (!v11)
        {
            do
            {
                v12 = *((_DWORD*)Base + v10);
                v13 = sub_423340((char*)v12, *(_DWORD*)(this + 996));
                *(_DWORD*)(this + 996) = v13;
                sub_4229D0("0x%08x: %s", v13, (const char*)v12);
                v14 = *(_DWORD*)(this + 992);
                ++v10;
                *(_DWORD*)(this + 1000) += *(_DWORD*)(v12 + 260);
            } while (v10 < v14);
        }
    }
    sub_4229D0(
        "CHECKSUM: %d files, %ld bytes, 0x%08x is the checksum",
        *(_DWORD*)(this + 992),
        *(_DWORD*)(this + 1000),
        *(_DWORD*)(this + 996));
    *a2 = *(_DWORD*)(this + 992);
    *a3 = *(_DWORD*)(this + 996);
    result = *(_DWORD*)(this + 1000);
    *a4 = result;
    return result;
}
// 4F5CB0: using guessed type int dword_4F5CB0;
// 4F5CB4: using guessed type char byte_4F5CB4;
// 522340: using guessed type int dword_522340;

//----- (00412120) --------------------------------------------------------
int __cdecl sub_412120(const char** a1, const char** a2)
{
    return _strcmpi(*a1, *a2);
}

//----- (00412140) --------------------------------------------------------
int __stdcall sub_412140(const char* a1, const char* a2)
{
    void* v2; // ebp
    char* v3; // ebx
    char* v4; // eax
    CHAR FileName[260]; // [esp+10h] [ebp-21Ch] BYREF
    int v8[5]; // [esp+114h] [ebp-118h] BYREF
    char v9[260]; // [esp+128h] [ebp-104h] BYREF

    strcpy(FileName, a1);
    if (!FileName[0] || FileName[strlen(FileName) - 1] != 92)
        strcat(FileName, asc_4A1DC4);
    strcat(FileName, a2);
    v2 = (void*)_findfirst(FileName, (int)v8);
    if (v2 != (void*)-1)
    {
        do
        {
            v3 = (char*)operator new(0x108u);
            strcpy(v3, v9);
            *((_DWORD*)v3 + 65) = v8[4];
            if ((int)++NumOfElements > dword_4F5CB0)
            {
                dword_4F5CB0 += 8;
                v4 = (char*)sub_488DD7(Base, 4 * dword_4F5CB0);
                if (v4)
                {
                    Base = v4;
                    memset(&v4[4 * NumOfElements], 0, 4 * (dword_4F5CB0 - NumOfElements));
                }
            }
            *((_DWORD*)Base + NumOfElements - 1) = v3;
        } while (!_findnext(v2, (int)v8));
    }
    return _findclose((intptr_t)v2);
}
// 4F5CB0: using guessed type int dword_4F5CB0;

//----- (004122F0) --------------------------------------------------------
char __thiscall sub_4122F0(int this, int a2)
{
    double v3; // st7
    int v4; // edi
    int v5; // ebp
    int v6; // ebx
    int v7; // eax
    int v8; // eax
    int v9; // eax
    int* v10; // eax
    int v11; // ebx
    int v12; // ecx
    int v13; // eax
    int v14; // ecx
    void* v15; // ecx
    int v16; // eax
    char* v17; // eax
    int v18; // edi
    int v19; // ecx
    int v20; // ebp
    float** v21; // edx
    float* v22; // ebx
    int v23; // ecx
    int v24; // eax
    int v25; // edi
    int v26; // ecx
    double v27; // st7
    int v28; // eax
    int** v29; // ebx
    int v30; // eax
    int* v31; // edi
    _DWORD* v32; // edi
    int v33; // edx
    int v34; // ecx
    double v35; // st7
    int v36; // edx
    int v37; // eax
    int* v38; // ecx
    int v39; // eax
    int v41; // [esp+0h] [ebp-4Ch]
    int v42; // [esp+Ch] [ebp-40h]
    int v43; // [esp+20h] [ebp-2Ch]
    int v44; // [esp+24h] [ebp-28h]
    int v45; // [esp+28h] [ebp-24h]
    int v46; // [esp+2Ch] [ebp-20h]
    int v47; // [esp+30h] [ebp-1Ch] BYREF
    _DWORD v48[2]; // [esp+34h] [ebp-18h] BYREF
    int* v49[4]; // [esp+3Ch] [ebp-10h] BYREF

    v3 = *(float*)(this + 948) - *(float*)(dword_520970 + 68);
    *(float*)(this + 948) = v3;
    if (v3 < 0.0)
    {
        *(_DWORD*)(this + 948) = 1065353216;
        EnterCriticalSection((LPCRITICAL_SECTION)(this + 960));
        v4 = *(_DWORD*)(this + 956);
        v5 = 0;
        if (v4)
        {
            do
            {
                v6 = *(_DWORD*)(v4 + 276);
                v7 = *(_DWORD*)(v4 + 272) + 1;
                *(_DWORD*)(v4 + 272) = v7;
                if (v7 <= 3)
                {
                    v5 = v4;
                    v4 = v6;
                }
                else
                {
                    sub_4885A6(*(LPVOID*)(v4 + 260));
                    v8 = *(_DWORD*)(v4 + 264);
                    if (v8)
                    {
                        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)v8 + 8))(*(_DWORD*)(v4 + 264));
                        *(_DWORD*)(v4 + 264) = 0;
                    }
                    v9 = *(_DWORD*)(v4 + 268);
                    if (v9)
                    {
                        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)v9 + 8))(*(_DWORD*)(v4 + 268));
                        *(_DWORD*)(v4 + 268) = 0;
                    }
                    sub_4885A6((LPVOID)v4);
                    v4 = v6;
                    if (!v5)
                        *(_DWORD*)(this + 956) = v6;
                }
            } while (v6);
        }
        LeaveCriticalSection((LPCRITICAL_SECTION)(this + 960));
    }
    while (1)
    {
        EnterCriticalSection((LPCRITICAL_SECTION)(this + 44));
        v10 = *(int**)(this + 32);
        if (!v10)
            break;
        v11 = *v10;
        v12 = v10[1];
        *v10 = 0;
        v10[1] = *(_DWORD*)(this + 28);
        *(_DWORD*)(this + 28) = v10;
        *(_DWORD*)(this + 32) = v12;
        if (!v12)
            *(_DWORD*)(this + 36) = 0;
        LeaveCriticalSection((LPCRITICAL_SECTION)(this + 44));
        if (!v11)
            goto LABEL_22;
        v13 = *(_DWORD*)(this + 76);
        v14 = *(_DWORD*)(this + 72) + 1;
        *(_DWORD*)(this + 72) = v14;
        if (v14 > v13)
        {
            v15 = *(void**)(this + 68);
            v16 = v13 + 8;
            *(_DWORD*)(this + 76) = v16;
            v17 = (char*)sub_488DD7(v15, 4 * v16);
            if (v17)
            {
                v18 = *(_DWORD*)(this + 72);
                v19 = *(_DWORD*)(this + 76) - v18;
                *(_DWORD*)(this + 68) = v17;
                memset(&v17[4 * v18], 0, 4 * v19);
            }
        }
        *(_DWORD*)(*(_DWORD*)(this + 68) + 4 * *(_DWORD*)(this + 72) - 4) = v11;
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)(this + 44));
LABEL_22:
    v20 = 0;
    while (v20 < *(_DWORD*)(this + 72))
    {
        v21 = *(float***)(this + 68);
        v22 = v21[v20];
        if (*(float*)(dword_520970 + 76) < (double)*v22)
        {
            ++v20;
        }
        else
        {
            v23 = *(_DWORD*)(this + 72);
            v24 = 0;
            if (v23 > 0)
            {
                v25 = *(_DWORD*)(this + 68);
                while (*v21 != v22)
                {
                    ++v24;
                    ++v21;
                    if (v24 >= v23)
                        goto LABEL_28;
                }
                v26 = v23 - 1;
                *(_DWORD*)(this + 72) = v26;
                if (v24 != v26)
                {
                    memcpy((void*)(v25 + 4 * v24), (const void*)(v25 + 4 * v24 + 4), 4 * (v26 + 0x3FFFFFFF * v24));
                    *(_DWORD*)(*(_DWORD*)(this + 68) + 4 * *(_DWORD*)(this + 72)) = 0;
                }
            }
        LABEL_28:
            sub_412620((_DWORD*)this, (int)v22);
        }
    }
    v27 = *(float*)(this + 952) - *(float*)(dword_520970 + 68);
    *(float*)(this + 952) = v27;
    if (v27 < 0.0)
    {
        *(_DWORD*)(this + 952) = 1045220557;
        v28 = sub_4118C0(this, v49, 4);
        v46 = v28;
        if (v28 > 0)
        {
            v29 = v49;
            v45 = v28;
            do
            {
                v30 = 0;
                v44 = 0;
                do
                {
                    v31 = *v29;
                    if (v30)
                        v32 = v31 + 2073;
                    else
                        v32 = v31 + 2069;
                    v33 = 0;
                    v43 = 0;
                    if ((int)v32[1] > 0)
                    {
                        do
                        {
                            v34 = *(_DWORD*)(*v32 + 4 * v33);
                            v35 = *(float*)(v34 + 4) - *(float*)(dword_520970 + 68);
                            *(float*)(v34 + 4) = v35;
                            if (v35 < 0.0)
                            {
                                v36 = *(_DWORD*)(v34 + 12);
                                v37 = *(_DWORD*)(v34 + 8);
                                v42 = *(_DWORD*)(v34 + 16);
                                *(_DWORD*)(v34 + 4) = 1056964608;
                                v41 = *(_DWORD*)(v34 + 20);
                                v38 = *v29;
                                v48[1] = v37;
                                v39 = *(_DWORD*)(this + 24);
                                v48[0] = v36;
                                (*(void(__stdcall**)(int, int, _DWORD*, int, int, _DWORD, int*, int))(*(_DWORD*)v39 + 28))(
                                    v39,
                                    v38[2],
                                    v48,
                                    1,
                                    v41,
                                    0,
                                    &v47,
                                    v42);
                                v33 = v43;
                            }
                            v43 = ++v33;
                        } while (v33 < v32[1]);
                        v30 = v44;
                    }
                    v44 = ++v30;
                } while (v30 < 2);
                ++v29;
                --v45;
            } while (v45);
            v28 = v46;
        }
        sub_411920(this, v49, v28);
    }
    return sub_428620((_DWORD*)this, a2);
}
// 520970: using guessed type int dword_520970;

//----- (00412620) --------------------------------------------------------
void __thiscall sub_412620(_DWORD* this, int a2)
{
    int v2; // ebx
    unsigned int v3; // edi
    _DWORD* v4; // ebp
    int v5; // eax
    _DWORD* v6; // edx
    _DWORD* v7; // esi
    int v8; // ecx
    int v9; // eax
    _DWORD** v10; // edx
    int v11; // ebx
    int v12; // eax
    _DWORD* v13; // edx
    int v14; // ecx
    int* v15; // esi
    int v16; // ecx
    unsigned int v17; // eax
    int v18; // eax
    _DWORD* v19; // edi
    int v20; // eax
    _DWORD* v21; // ecx
    unsigned int v22; // eax
    int v23; // eax
    int v24; // ecx
    void* v25; // edx
    int v26; // eax
    char* v27; // eax
    int v28; // edi
    int v29; // ecx
    int v30; // ebx
    int v31; // ecx
    int v32; // edx
    int* v33; // eax
    int v34; // edi
    int v35; // ecx
    int v36; // eax
    _DWORD* v37; // ebx
    _DWORD* v38; // edx
    int v39; // ecx
    int v40; // [esp+Ch] [ebp-2Ch]
    _DWORD v42[2]; // [esp+24h] [ebp-14h] BYREF
    unsigned int v43; // [esp+2Ch] [ebp-Ch]
    _DWORD v44[2]; // [esp+30h] [ebp-8h] BYREF

    v2 = a2;
    v3 = *(_DWORD*)(a2 + 16);
    v4 = this;
    v43 = v3;
    v5 = *(_DWORD*)(v3 + 2);
    if ((v5 & 1) != 0)
    {
        v6 = sub_411B60((int)this, *(_DWORD*)(a2 + 4));
        v42[0] = v6;
        if (v6)
        {
            v7 = v6 + 2073;
            v43 = *(_DWORD*)(v3 + 2);
            if ((v43 & 4) == 0)
                v7 = v6 + 2069;
            v8 = v7[1];
            v9 = 0;
            if (v8 > 0)
            {
                v10 = (_DWORD**)*v7;
                while (**v10 != v43 >> 4)
                {
                    ++v9;
                    ++v10;
                    if (v9 >= v8)
                        goto LABEL_17;
                }
                v11 = *(_DWORD*)(*v7 + 4 * v9);
                v12 = 0;
                v13 = (_DWORD*)*v7;
                while (*v13 != v11)
                {
                    ++v12;
                    ++v13;
                    if (v12 >= v8)
                        goto LABEL_16;
                }
                v14 = v8 - 1;
                v7[1] = v14;
                if (v12 != v14)
                {
                    memcpy((void*)(*v7 + 4 * v12), (const void*)(*v7 + 4 * v12 + 4), 4 * (v14 + 0x3FFFFFFF * v12));
                    *(_DWORD*)(*v7 + 4 * v7[1]) = 0;
                }
            LABEL_16:
                sub_40EB70(*(unsigned int**)(v11 + 8));
                sub_40EB70((unsigned int*)v11);
            LABEL_17:
                v4 = this;
                v6 = (_DWORD*)v42[0];
                v2 = a2;
            }
            sub_411BB0((int)v4, v6[2]);
            sub_4113D0(v2);
            return;
        }
    LABEL_51:
        sub_4113D0(v2);
        return;
    }
    if ((v5 & 2) == 0)
    {
    LABEL_50:
        sub_4129B0(v4, v2);
        goto LABEL_51;
    }
    v15 = sub_411B60((int)this, *(_DWORD*)(a2 + 4));
    if (!v15)
        sub_4113D0(v2);
    v16 = *(_DWORD*)(v3 + 2);
    v17 = v16 & 0xFFFFFFF0 ^ (BYTE2(v42[0]) & 0xC | 1);
    LOWORD(v42[0]) = -35;
    *(_DWORD*)((char*)v42 + 2) = (((unsigned __int8)v17
        ^ (unsigned __int8)v16)
        & 8
        ^ (unsigned __int8)v17
        ^ (unsigned __int8)v16)
        & 4
        ^ ((unsigned __int8)v17
            ^ (unsigned __int8)v16)
        & 8
        ^ v17;
    v44[1] = v42;
    v18 = v4[6];
    v44[0] = 6;
    (*(void(__stdcall**)(int, int, _DWORD*, int, int, _DWORD, int*, int))(*(_DWORD*)v18 + 28))(
        v18,
        v15[2],
        v44,
        1,
        2000,
        0,
        &a2,
        144);
    v19 = v15 + 1038;
    if ((v42[0] & 0x40000) == 0)
        v19 = v15 + 14;
    v20 = 0;
    v21 = v19;
    do
    {
        if (*v21 == *(_DWORD*)((char*)v42 + 2) >> 4)
        {
            sub_411BB0((int)v4, v15[2]);
            sub_4113D0(v2);
            return;
        }
        ++v20;
        ++v21;
    } while (v20 < 1024);
    memcpy(v19 + 1, v19, 0xFFCu);
    v22 = v43;
    *v19 = *(_DWORD*)((char*)v42 + 2) >> 4;
    if ((*(_BYTE*)(v22 + 2) & 4) == 0)
    {
        sub_411BB0((int)v4, v15[2]);
        goto LABEL_50;
    }
    v23 = v15[2064];
    v24 = v15[2063] + 1;
    v15[2063] = v24;
    if (v24 > v23)
    {
        v25 = (void*)v15[2062];
        v26 = v23 + 8;
        v15[2064] = v26;
        v27 = (char*)sub_488DD7(v25, 4 * v26);
        if (v27)
        {
            v28 = v15[2063];
            v29 = v15[2064] - v28;
            v15[2062] = (int)v27;
            memset(&v27[4 * v28], 0, 4 * v29);
        }
    }
    *(_DWORD*)(v15[2062] + 4 * v15[2063] - 4) = v2;
    do
    {
        v30 = v15[2063];
        v31 = 0;
        if (v30 <= 0)
            break;
        v32 = v15[2066];
        v33 = (int*)v15[2062];
        while (1)
        {
            v34 = *v33;
            if (*(_DWORD*)(*(_DWORD*)(*v33 + 16) + 2) >> 4 == v32)
                break;
            ++v31;
            ++v33;
            if (v31 >= v30)
            {
                v4 = this;
                goto LABEL_46;
            }
        }
        v4 = this;
        v40 = *v33;
        v15[2066] = v32 + 1;
        sub_4129B0(this, v40);
        v35 = v15[2063];
        v36 = 0;
        if (v35 > 0)
        {
            v37 = (_DWORD*)v15[2062];
            v38 = v37;
            while (*v38 != v34)
            {
                ++v36;
                ++v38;
                if (v36 >= v35)
                    goto LABEL_45;
            }
            v39 = v35 - 1;
            v15[2063] = v39;
            if (v36 != v39)
            {
                memcpy(&v37[v36], &v37[v36 + 1], 4 * (v39 + 0x3FFFFFFF * v36));
                *(_DWORD*)(v15[2062] + 4 * v15[2063]) = 0;
            }
        }
    LABEL_45:
        sub_4113D0(v34);
    } while (v15[2063] > 0);
LABEL_46:
    sub_411BB0((int)v4, v15[2]);
}
// 4126A1: conditional instruction was optimized away because ecx.4>=1

//----- (004129B0) --------------------------------------------------------
void __thiscall sub_4129B0(_DWORD* this, int a2)
{
    _DWORD* v3; // esi
    bool i; // bl
    int v5; // eax

    v3 = (_DWORD*)this[5];
    for (i = (*(_WORD*)(a2 + 12) & 0xFF00) == 65280; v3; v3 = (_DWORD*)v3[3])
    {
        if ((*(_WORD*)(a2 + 12) & (_WORD)v3[1]) == *((_WORD*)v3 + 3) || i && *((_BYTE*)v3 + 8))
            (*(void(__thiscall**)(_DWORD, int))(*(_DWORD*)*v3 + 28))(*v3, a2);
    }
    if (i)
    {
        v5 = *(_DWORD*)(*(_DWORD*)(a2 + 16) + 6);
        if (v5)
            sub_411BB0((int)this, *(_DWORD*)(v5 + 8));
    }
}

//----- (00412A30) --------------------------------------------------------
void __thiscall sub_412A30(char* this)
{
    struct _RTL_CRITICAL_SECTION* v2; // ebp
    int v3; // edi
    int v4; // ebx
    _DWORD* v5; // esi
    _DWORD* v6; // edi

    v2 = (struct _RTL_CRITICAL_SECTION*)(this + 16);
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 16));
    v3 = *((_DWORD*)this + 1);
    if (v3)
    {
        do
        {
            v4 = *(_DWORD*)(v3 + 4);
            sub_4885A6(*(LPVOID*)v3);
            *(_DWORD*)v3 = 0;
            v3 = v4;
            **((_DWORD**)this + 1) = 0;
            *(_DWORD*)(*((_DWORD*)this + 1) + 4) = *(_DWORD*)this;
            *(_DWORD*)this = *((_DWORD*)this + 1);
        } while (v4);
    }
    *((_DWORD*)this + 2) = 0;
    *((_DWORD*)this + 1) = 0;
    LeaveCriticalSection(v2);
    v5 = *(_DWORD**)this;
    if (v5)
    {
        do
        {
            v6 = (_DWORD*)v5[1];
            sub_4885A6(v5);
            v5 = v6;
        } while (v6);
    }
    DeleteCriticalSection(v2);
}

//----- (00412AB0) --------------------------------------------------------
_DWORD* __thiscall sub_412AB0(_DWORD* this)
{
    _DWORD* v2; // ebp
    _DWORD* v3; // edi
    int v4; // ecx
    int v5; // eax
    char* v7; // [esp+34h] [ebp-28h]
    _DWORD v8[5]; // [esp+48h] [ebp-14h] BYREF

    v8[1] = this;
    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
    *((_BYTE*)this + 16) = 1;
    v2 = this + 29;
    this[7] = 1132396544;
    this[8] = 1132396544;
    v3 = this + 30;
    this[12] = 1065353216;
    this[13] = 1065353216;
    this[5] = 0;
    this[18] = -1082130432;
    this[19] = -1082130432;
    this[6] = 0;
    this[9] = 0;
    this[10] = 0;
    this[11] = 0;
    this[17] = 0;
    this[20] = 255;
    this[21] = 255;
    this[22] = 255;
    this[23] = 255;
    this[24] = 255;
    this[25] = 255;
    *((_BYTE*)this + 104) = 0;
    *((_BYTE*)this + 105) = 0;
    this[27] = 0;
    *((_BYTE*)this + 112) = 1;
    this[29] = 0;
    this[30] = 0;
    *this = &off_4991D4;
    v7 = (char*)(this + 30);
    v4 = **(_DWORD**)ArgList;
    v8[4] = 0;
    if ((*(int(__stdcall**)(_DWORD, int, int, int, int, char*))(v4 + 96))(*(_DWORD*)ArgList, 12, 8, 101, 1, v7))
        *v3 = 0;
    if ((*(int(__stdcall**)(_DWORD, int, int, int, int, _DWORD*))(**(_DWORD**)ArgList + 92))(
        *(_DWORD*)ArgList,
        112,
        8,
        324,
        1,
        v2))
    {
        v5 = *v3;
        *v2 = 0;
        if (v5)
        {
            (*(void(__stdcall**)(int))(*(_DWORD*)v5 + 8))(v5);
            *v3 = 0;
        }
    }
    if (*v3)
    {
        (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD, _DWORD*, _DWORD))(*(_DWORD*)*v3 + 44))(*v3, 0, 0, v8, 0);
        *(_WORD*)v8[0] = 0;
        *(_WORD*)(v8[0] + 2) = 1;
        *(_WORD*)(v8[0] + 4) = 2;
        *(_WORD*)(v8[0] + 6) = 1;
        *(_WORD*)(v8[0] + 8) = 3;
        *(_WORD*)(v8[0] + 10) = 2;
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)*v3 + 48))(*v3);
    }
    this[31] = 0;
    return this;
}
// 4991D4: using guessed type void *(__thiscall *off_4991D4)(std::ios_base *__hidden this, unsigned int);

//----- (00412CC0) --------------------------------------------------------
int __thiscall sub_412CC0(int this, int a2)
{
    double v3; // st7
    unsigned __int8 v5; // c0
    unsigned __int8 v6; // c3
    __int64 v7; // rax
    double v8; // st6
    double v9; // st7
    int result; // eax

    if (*(float*)(this + 72) >= 0.0)
    {
        v3 = *(float*)(dword_520970 + 68) + *(float*)(this + 68);
        *(float*)(this + 68) = v3;
        if (v5 | v6)
        {
            LODWORD(v7) = *(_DWORD*)(this + 80);
        }
        else if (v3 >= *(float*)(this + 76))
        {
            LODWORD(v7) = *(_DWORD*)(this + 84);
            *(_DWORD*)(this + 76) = -1082130432;
            *(_DWORD*)(this + 72) = -1082130432;
        }
        else
        {
            v8 = *(float*)(this + 76) - *(float*)(this + 72);
            if (v8 == 0.0)
                v9 = 0.0;
            else
                v9 = (v3 - *(float*)(this + 72)) / v8;
            v7 = (__int64)(((double)*(int*)(this + 84) - (double)*(int*)(this + 80)) * v9 + (double)*(int*)(this + 80));
        }
        sub_413180(this, v7, 0);
    }
    if (!*(_DWORD*)(this + 124))
        *(_DWORD*)(this + 124) = sub_409960((_DWORD*)dword_520970, this);
    *(_DWORD*)(*(_DWORD*)(this + 124) + 28) = 0;
    *(_DWORD*)(*(_DWORD*)(this + 124) + 12) = 6;
    *(_DWORD*)(*(_DWORD*)(this + 124) + 36) = *(_DWORD*)(this + 108);
    result = *(_DWORD*)(this + 36);
    *(_DWORD*)(*(_DWORD*)(this + 124) + 24) = result;
    return result;
}
// 412CEB: variable 'v5' is possibly undefined
// 412CEB: variable 'v6' is possibly undefined
// 520970: using guessed type int dword_520970;

//----- (00412DB0) --------------------------------------------------------
int __userpurge sub_412DB0@<eax>(int a1@<ecx>, int a2@<edi>, int a3)
{
    int result; // eax
    int v5; // edi
    _BYTE v7[4]; // [esp+14h] [ebp-4h] BYREF
    float* retaddr; // [esp+18h] [ebp+0h]

    result = *(_DWORD*)(a1 + 100);
    if (result)
    {
        v5 = (unsigned __int8)*(_DWORD*)(a1 + 96)
            | (((unsigned __int8)*(_DWORD*)(a1 + 92) | (((result << 8) | (unsigned __int8)*(_DWORD*)(a1 + 88)) << 8)) << 8);
        if (*(_BYTE*)(a1 + 112))
        {
            (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD, _BYTE*, _DWORD, int))(**(_DWORD**)(a1 + 116) + 44))(
                *(_DWORD*)(a1 + 116),
                0,
                0,
                v7,
                0,
                a2);
            *retaddr = *(float*)(a1 + 20);
            retaddr[1] = *(float*)(a1 + 24);
            if (*(float*)(a1 + 64) != 0.0)
                sub_4131D0((float*)a1, retaddr, retaddr + 1);
            retaddr[2] = *(float*)(a1 + 36);
            retaddr[3] = 1.0;
            *((_DWORD*)retaddr + 4) = v5;
            retaddr[5] = *(float*)(a1 + 40);
            retaddr[6] = *(float*)(a1 + 44);
            retaddr[7] = *(float*)(a1 + 28);
            retaddr[8] = *(float*)(a1 + 24);
            if (*(float*)(a1 + 64) != 0.0)
                sub_4131D0((float*)a1, retaddr + 7, retaddr + 8);
            retaddr[9] = *(float*)(a1 + 36);
            retaddr[10] = 1.0;
            *((_DWORD*)retaddr + 11) = v5;
            retaddr[12] = *(float*)(a1 + 48);
            retaddr[13] = *(float*)(a1 + 44);
            retaddr[14] = *(float*)(a1 + 20);
            retaddr[15] = *(float*)(a1 + 32);
            if (*(float*)(a1 + 64) != 0.0)
                sub_4131D0((float*)a1, retaddr + 14, retaddr + 15);
            retaddr[16] = *(float*)(a1 + 36);
            retaddr[17] = 1.0;
            *((_DWORD*)retaddr + 18) = v5;
            retaddr[19] = *(float*)(a1 + 40);
            retaddr[20] = *(float*)(a1 + 52);
            retaddr[21] = *(float*)(a1 + 28);
            retaddr[22] = *(float*)(a1 + 32);
            if (*(float*)(a1 + 64) != 0.0)
                sub_4131D0((float*)a1, retaddr + 21, retaddr + 22);
            retaddr[23] = *(float*)(a1 + 36);
            retaddr[24] = 1.0;
            *((_DWORD*)retaddr + 25) = v5;
            retaddr[26] = *(float*)(a1 + 48);
            retaddr[27] = *(float*)(a1 + 52);
            (*(void(__cdecl**)(_DWORD))(**(_DWORD**)(a1 + 116) + 48))(*(_DWORD*)(a1 + 116));
            *(_BYTE*)(a1 + 112) = 0;
        }
        sub_41BC00((_DWORD*)dword_520A50, 1, (*(_BYTE*)(a1 + 105) != 0) + 1, 1, 0, 1, -1, 0);
        (*(void(__stdcall**)(_DWORD, _DWORD, int, _DWORD))(**(_DWORD**)ArgList + 252))(*(_DWORD*)ArgList, 0, 11, 0);
        (*(void(__stdcall**)(_DWORD, _DWORD, int, _DWORD))(**(_DWORD**)ArgList + 252))(*(_DWORD*)ArgList, 0, 24, 0);
        sub_41BEF0((_DWORD*)dword_520A50, 0, *(_DWORD*)(a1 + 108), *(_BYTE*)(a1 + 104) != 0, 1);
        sub_41BEF0((_DWORD*)dword_520A50, 1, 0, -1, -1);
        (*(void(__stdcall**)(_DWORD, int))(**(_DWORD**)ArgList + 304))(*(_DWORD*)ArgList, 324);
        (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD, int))(**(_DWORD**)ArgList + 332))(
            *(_DWORD*)ArgList,
            0,
            *(_DWORD*)(a1 + 116),
            28);
        (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD))(**(_DWORD**)ArgList + 340))(
            *(_DWORD*)ArgList,
            *(_DWORD*)(a1 + 120),
            0);
        (*(void(__stdcall**)(_DWORD, int, _DWORD, int, _DWORD, int))(**(_DWORD**)ArgList + 284))(
            *(_DWORD*)ArgList,
            4,
            0,
            4,
            0,
            2);
        *(float*)dword_520A20 = *(float*)dword_520A20 + 1.0;
        return 2;
    }
    return result;
}
// 412DB0: could not find valid save-restore pair for ebx
// 412DB0: could not find valid save-restore pair for edi
// 520A20: using guessed type int dword_520A20;
// 520A50: using guessed type int dword_520A50;

//----- (00413090) --------------------------------------------------------
void __thiscall sub_413090(int this, float a2, float a3, float a4, float a5)
{
    double v6; // st7

    *(float*)(this + 20) = floor(a2) - 0.5;
    *(float*)(this + 24) = floor(a3) - 0.5;
    *(float*)(this + 28) = floor(a4) - 0.5;
    v6 = floor(a5);
    *(_DWORD*)(this + 64) = 0;
    *(_BYTE*)(this + 112) = 1;
    *(float*)(this + 32) = v6 - 0.5;
}

//----- (00413100) --------------------------------------------------------
int __thiscall sub_413100(int this, int a2, int a3, int a4)
{
    int result; // eax

    *(_DWORD*)(this + 56) = a2;
    result = a4;
    *(_DWORD*)(this + 60) = a3;
    *(_DWORD*)(this + 64) = a4;
    *(_BYTE*)(this + 112) = 1;
    return result;
}

//----- (00413120) --------------------------------------------------------
int __thiscall sub_413120(int this, int a2)
{
    int result; // eax

    result = a2;
    *(_BYTE*)(this + 112) = 1;
    *(_DWORD*)(this + 36) = a2;
    return result;
}

//----- (00413130) --------------------------------------------------------
int __thiscall sub_413130(int this, int a2, int a3, int a4, int a5)
{
    int result; // eax

    *(_DWORD*)(this + 40) = a2;
    result = a4;
    *(_DWORD*)(this + 44) = a3;
    *(_DWORD*)(this + 48) = a4;
    *(_DWORD*)(this + 52) = a5;
    *(_BYTE*)(this + 112) = 1;
    return result;
}

//----- (00413160) --------------------------------------------------------
int __thiscall sub_413160(int this, int a2, int a3, int a4)
{
    int result; // eax

    *(_DWORD*)(this + 88) = a2;
    result = a4;
    *(_DWORD*)(this + 92) = a3;
    *(_DWORD*)(this + 96) = a4;
    *(_BYTE*)(this + 112) = 1;
    return result;
}

//----- (00413180) --------------------------------------------------------
char __thiscall sub_413180(int this, int a2, char a3)
{
    char result; // al

    result = a3;
    *(_BYTE*)(this + 112) = 1;
    if (a3)
    {
        *(_DWORD*)(this + 72) = -1082130432;
        *(_DWORD*)(this + 76) = -1082130432;
        result = a2;
    }
    *(_DWORD*)(this + 100) = a2;
    return result;
}

//----- (004131B0) --------------------------------------------------------
_DWORD* __thiscall sub_4131B0(_DWORD* this, _DWORD* a2)
{
    _DWORD* result; // eax

    if (this[27])
        sub_422230();
    result = a2;
    this[27] = a2;
    if (a2)
        ++*a2;
    return result;
}
// 422230: using guessed type int sub_422230(void);

//----- (004131D0) --------------------------------------------------------
float* __thiscall sub_4131D0(float* this, float* a2, float* a3)
{
    float* result; // eax
    long double v4; // st7
    long double v5; // st7
    float v6; // [esp+4h] [ebp+4h]

    result = a2;
    *a2 = *a2 - this[14];
    v4 = *a3 - this[15];
    *a3 = v4;
    v6 = atan2(v4, *a2);
    v5 = sqrt(v4 * v4 + *result * *result);
    *result = cos(v6 + this[16]) * v5;
    *a3 = sin(v6 + this[16]) * v5;
    *result = *result + this[14];
    *a3 = this[15] + *a3;
    return result;
}

//----- (00413240) --------------------------------------------------------
int __thiscall sub_413240(_DWORD* this, int a2, int a3, int a4, int a5)
{
    int result; // eax

    this[18] = a2;
    result = a4;
    this[19] = a3;
    this[17] = 0;
    this[20] = a4;
    this[21] = a5;
    return result;
}

//----- (00413270) --------------------------------------------------------
void __thiscall sub_413270(float* this, int a2)
{
    sub_40E6D0((int*)(*(_DWORD*)this + 12 * a2 + 376), this[4]);
}

//----- (00413290) --------------------------------------------------------
void __thiscall sub_413290(int this, int a2)
{
    sub_40E6D0((int*)(*(_DWORD*)(this + 4) + 12 * a2 + 376), *(float*)(this + 8));
}

//----- (004132B0) --------------------------------------------------------
_DWORD* __thiscall sub_4132B0(_DWORD* this)
{
    _DWORD* result; // eax

    result = this;
    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
    *((_BYTE*)this + 16) = 1;
    *this = &off_4991F4;
    this[6] = 0;
    this[7] = 0;
    this[8] = 0;
    this[9] = 0;
    this[10] = 0;
    this[11] = 0;
    return result;
}
// 4991F4: using guessed type _UNKNOWN *off_4991F4;

//----- (00413300) --------------------------------------------------------
void __thiscall sub_413300(LPVOID* this)
{
    void* v2; // ecx
    _DWORD* v3; // esi
    _DWORD* v4; // ebx

    *this = &off_4991F4;
    sub_4885A6(this[6]);
    v2 = this[7];
    this[6] = 0;
    sub_4885A6(v2);
    v3 = this[10];
    this[7] = 0;
    if (v3)
    {
        do
        {
            v4 = (_DWORD*)v3[173];
            if (v3)
            {
                `eh vector destructor iterator'(v3 + 94, 0xCu, 26, (void (__thiscall *)(void *))sub_40E620);
                    sub_4885A6(v3);
            }
            v3 = v4;
        } while (v4);
        this[10] = 0;
        *this = &off_499040;
    }
    else
    {
        this[10] = 0;
        *this = &off_499040;
    }
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 4991F4: using guessed type _UNKNOWN *off_4991F4;

//----- (004133C0) --------------------------------------------------------
char __thiscall sub_4133C0(_DWORD* this)
{
    _DWORD* v2; // eax
    _DWORD* v3; // ecx
    int v4; // ebp
    void* v5; // edi
    void* v6; // edi
    char result; // al

    v2 = operator new(0x18000u);
    if (v2)
    {
        v3 = v2 + 19;
        v4 = 512;
        do
        {
            v3[1] = 0;
            *v3 = 0;
            *(v3 - 1) = 0;
            *(v3 - 2) = 0;
            *(v3 - 4) = 0;
            *(v3 - 5) = 0;
            *(v3 - 6) = 0;
            *(v3 - 7) = 0;
            *(v3 - 9) = 0;
            *(v3 - 10) = 0;
            *(v3 - 11) = 0;
            *(v3 - 12) = 0;
            v3[2] = 1065353216;
            *(v3 - 3) = 1065353216;
            *(v3 - 8) = 1065353216;
            *(v3 - 13) = 1065353216;
            v3[5] = 0;
            v3[6] = 0;
            v3[7] = 0;
            v3[24] = 0;
            v3[23] = 0;
            v3[22] = 0;
            v3[21] = 0;
            v3[19] = 0;
            v3[18] = 0;
            v3[17] = 0;
            v3[16] = 0;
            v3[14] = 0;
            v3[13] = 0;
            v3[12] = 0;
            v3[11] = 0;
            v3[25] = 1065353216;
            v3[20] = 1065353216;
            v3[15] = 1065353216;
            v3[10] = 1065353216;
            v3 += 48;
            --v4;
        } while (v4);
        v5 = v2;
    }
    else
    {
        v5 = 0;
    }
    this[6] = v5;
    memset(v5, 0, 0x18000u);
    v6 = operator new(0x7800u);
    result = 1;
    this[7] = v6;
    memset(v6, 0, 0x7800u);
    this[8] = 0;
    this[5] = 0;
    this[10] = 0;
    return result;
}

//----- (004134A0) --------------------------------------------------------
int __thiscall sub_4134A0(_DWORD* this)
{
    int v2; // edi
    int v3; // ebx
    void* v4; // edi
    int result; // eax

    sub_4139B0(this);
    v2 = 0;
    if ((int)this[8] > 0)
    {
        v3 = 0;
        do
        {
            sub_409A00(dword_520970, *(void**)(this[7] + v3));
            ++v2;
            v3 += 60;
        } while (v2 < this[8]);
    }
    v4 = (void*)this[7];
    result = 0;
    this[8] = 0;
    memset(v4, 0, 0x7800u);
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (004134F0) --------------------------------------------------------
void __thiscall sub_4134F0(_DWORD* this)
{
    int v2; // esi
    int* v3; // ecx
    int v4; // eax

    v2 = this[10];
    for (this[11] = v2; v2; v2 = this[11])
    {
        v3 = *(int**)(v2 + 360);
        if (v3)
        {
            sub_422230(v3);
            *(_DWORD*)(v2 + 360) = 0;
        }
        *(_DWORD*)(v2 + 360) = sub_422400(*(_DWORD**)(dword_520970 + 124), (char*)(v2 + 33), 0);
        v4 = this[11];
        if (v4)
            this[11] = *(_DWORD*)(v4 + 692);
    }
}
// 520970: using guessed type int dword_520970;

//----- (00413550) --------------------------------------------------------
void __thiscall sub_413550(int this)
{
    FILE* v2; // eax
    bool v3; // zf
    LPVOID* v4; // edi
    int v5; // ebx
    LPVOID* v6; // edi
    int v7; // eax
    FILE* v8; // [esp-4h] [ebp-24h]
    size_t ElementSize; // [esp+Ch] [ebp-14h] BYREF
    int v10; // [esp+10h] [ebp-10h] BYREF
    int v11; // [esp+14h] [ebp-Ch] BYREF
    unsigned int Buffer; // [esp+18h] [ebp-8h] BYREF
    int v13; // [esp+1Ch] [ebp-4h] BYREF

    if (*(_DWORD*)(this + 20))
    {
        fclose(*(FILE**)(this + 20));
        *(_DWORD*)(this + 20) = 0;
    }
    v2 = fopen(aParticleDat, Mode);
    *(_DWORD*)(this + 20) = v2;
    if (v2)
    {
        sub_4898CA(&Buffer, 4u, 1u, v2);
        if (Buffer >= 0xF3430023 && Buffer <= 0xF3430024)
        {
            v8 = *(FILE**)(this + 20);
            v10 = 0;
            sub_4898CA(&v10, 4u, 1u, v8);
            v3 = v10 == 0;
            v11 = 0;
            --v10;
            if (v3)
            {
            LABEL_17:
                fclose(*(FILE**)(this + 20));
                *(_DWORD*)(this + 20) = 0;
                sub_4134F0((_DWORD*)this);
            }
            else
            {
                while (1)
                {
                    sub_4898CA(&v11, 4u, 1u, *(FILE**)(this + 20));
                    if (v11 != -554860416)
                        break;
                    v4 = (LPVOID*)sub_413780((_DWORD*)this);
                    sub_4898CA(&ElementSize, 4u, 1u, *(FILE**)(this + 20));
                    sub_4898CA(v4, ElementSize, 1u, *(FILE**)(this + 20));
                    sub_4898CA(&ElementSize, 4u, 1u, *(FILE**)(this + 20));
                    sub_4898CA((char*)v4 + 33, ElementSize, 1u, *(FILE**)(this + 20));
                    sub_4898CA(&ElementSize, 4u, 1u, *(FILE**)(this + 20));
                    sub_4898CA((char*)v4 + 293, ElementSize, 1u, *(FILE**)(this + 20));
                    sub_4898CA(v4 + 91, 4u, 1u, *(FILE**)(this + 20));
                    sub_4898CA(v4 + 92, 4u, 1u, *(FILE**)(this + 20));
                    sub_4898CA(v4 + 93, 1u, 1u, *(FILE**)(this + 20));
                    if (Buffer < 0xF3430024)
                        v4[172] = (LPVOID)1;
                    else
                        sub_4898CA(v4 + 172, 4u, 1u, *(FILE**)(this + 20));
                    sub_4898CA(&v13, 4u, 1u, *(FILE**)(this + 20));
                    v5 = 0;
                    if (v13 > 0)
                    {
                        v6 = v4 + 94;
                        do
                        {
                            sub_40E780(v6, *(FILE**)(this + 20));
                            ++v5;
                            v6 += 3;
                        } while (v5 < v13);
                    }
                    v7 = *(_DWORD*)(this + 44);
                    if (v7)
                        *(_DWORD*)(this + 44) = *(_DWORD*)(v7 + 692);
                    v3 = v10-- == 0;
                    if (v3)
                        goto LABEL_17;
                }
            }
        }
    }
}

//----- (00413780) --------------------------------------------------------
_DWORD* __thiscall sub_413780(_DWORD* this)
{
    _DWORD* v2; // esi
    _DWORD* result; // eax
    int v4; // ecx

    v2 = operator new(0x2B8u);
    if (v2)
    {
        v2[90] = 0;
        v2[91] = 0;
        v2[92] = 0;
        *((_BYTE*)v2 + 372) = 0;
        `eh vector constructor iterator'(v2 + 94, 0xCu, 26, sub_40E5F0, sub_40E620);
            v2[173] = 0;
        *(_BYTE*)v2 = 0;
        *((_BYTE*)v2 + 33) = 0;
        *((_BYTE*)v2 + 293) = 0;
        result = v2;
    }
    else
    {
        result = 0;
    }
    result[173] = this[10];
    v4 = this[9] + 1;
    this[10] = result;
    this[9] = v4;
    return result;
}

//----- (00413830) --------------------------------------------------------
int __thiscall sub_413830(_DWORD* this, char* String1)
{
    int v2; // esi

    v2 = this[10];
    if (!v2)
        return 0;
    while (_strcmpi(String1, (const char*)v2))
    {
        v2 = *(_DWORD*)(v2 + 692);
        if (!v2)
            return 0;
    }
    return v2;
}

//----- (00413870) --------------------------------------------------------
_DWORD* __thiscall sub_413870(_DWORD* this, int a2)
{
    int v2; // edx
    int v3; // eax
    _BYTE* i; // ecx
    _DWORD* v6; // esi
    long double v7; // st7
    long double v8; // st7

    v2 = this[6];
    v3 = 0;
    for (i = (_BYTE*)(v2 + 4); *i; i += 192)
    {
        if (++v3 >= 512)
            return 0;
    }
    v6 = (_DWORD*)(v2 + 192 * v3);
    memset(v6, 0, 0xC0u);
    v6[4] = 0;
    *v6 = a2;
    if (*(float*)(a2 + 368) > 0.0)
        *((float*)v6 + 5) = 1.0 / *(float*)(a2 + 368);
    *((_BYTE*)v6 + 4) = 1;
    v6[3] = *(_DWORD*)(a2 + 364);
    v7 = fabs((double)rand() * 0.000030518509);
    *((float*)v6 + 22) = v7 + v7 - 1.0;
    v8 = fabs((double)rand() * 0.000030518509);
    *((float*)v6 + 23) = v8 + v8 - 1.0;
    v6[44] = 1065353216;
    v6[39] = 1065353216;
    v6[34] = 1065353216;
    v6[29] = 1065353216;
    v6[43] = 0;
    v6[42] = 0;
    v6[41] = 0;
    v6[40] = 0;
    v6[38] = 0;
    v6[37] = 0;
    v6[36] = 0;
    v6[35] = 0;
    v6[33] = 0;
    v6[32] = 0;
    v6[31] = 0;
    v6[30] = 0;
    return v6;
}

//----- (00413990) --------------------------------------------------------
char __stdcall sub_413990(_BYTE* a1)
{
    char result; // al

    result = 1;
    memset(a1, 0, 0xC0u);
    a1[4] = 1;
    a1[112] = 1;
    return result;
}

//----- (004139B0) --------------------------------------------------------
char __thiscall sub_4139B0(_DWORD* this)
{
    int i; // esi
    _BYTE* v2; // edx
    char result; // al

    for (i = 0; i < 98304; i += 192)
    {
        v2 = (_BYTE*)(i + this[6]);
        result = v2[4];
        if (result)
        {
            result = 0;
            memset(v2, 0, 0xC0u);
            v2[4] = 1;
            v2[112] = 1;
        }
    }
    return result;
}

//----- (004139F0) --------------------------------------------------------
char __thiscall sub_4139F0(_DWORD* this, int a2)
{
    _DWORD* v2; // ebx
    int v3; // esi
    int v4; // ebp
    double v5; // st7
    double v6; // st7
    double v7; // st7
    float* v8; // ecx
    double v9; // st7
    double v10; // st7
    float* v11; // eax
    float* v12; // eax
    float v13; // ecx
    double v14; // st7
    float v15; // edx
    long double v16; // st7
    double v17; // st7
    double v18; // st7
    double v19; // st7
    double v20; // st7
    int v21; // edi
    int v22; // esi
    int v23; // ecx
    float* v24; // edx
    int v25; // ecx
    int v26; // edi
    int v27; // edx
    double v28; // st7
    double v29; // st7
    void** v30; // edi
    int v31; // eax
    void* v32; // edx
    int v33; // eax
    int v34; // edx
    int v35; // esi
    _DWORD* v36; // eax
    double v37; // st7
    long double v38; // st7
    double v39; // st7
    long double v40; // st7
    long double v41; // st7
    long double v42; // st7
    long double v43; // st7
    long double v44; // st7
    bool v45; // al
    long double v46; // st7
    double v47; // st7
    long double v48; // st7
    long double v49; // st7
    long double v50; // st7
    double v51; // st7
    long double v52; // st7
    long double v53; // st7
    long double v54; // st6
    long double v55; // st7
    long double v56; // st7
    float v57; // ebp
    int v58; // edi
    double v59; // st7
    double v60; // st7
    double v61; // st7
    double v62; // st7
    double v63; // st7
    double v64; // st7
    float* v65; // eax
    float* v66; // eax
    double v67; // st7
    double v68; // st6
    long double v69; // st7
    double v70; // st7
    int v71; // eax
    void* v72; // edx
    double v73; // st7
    double v74; // st7
    float* v75; // esi
    double v76; // st7
    float v77; // eax
    float v78; // edx
    double v79; // st7
    int v80; // ebp
    double v81; // st7
    int v82; // ebx
    int v83; // ecx
    int v84; // ebp
    int v85; // ebx
    int v86; // edx
    int v87; // eax
    int v88; // ecx
    int v89; // ebx
    char v90; // al
    float v92; // [esp+10h] [ebp-BCh]
    float v93; // [esp+10h] [ebp-BCh]
    float v94; // [esp+10h] [ebp-BCh]
    float v95; // [esp+10h] [ebp-BCh]
    float v96; // [esp+10h] [ebp-BCh]
    float v97; // [esp+14h] [ebp-B8h]
    float v98; // [esp+14h] [ebp-B8h]
    float v99; // [esp+14h] [ebp-B8h]
    float v100; // [esp+14h] [ebp-B8h]
    float v101; // [esp+14h] [ebp-B8h]
    float v102; // [esp+18h] [ebp-B4h]
    float v103; // [esp+18h] [ebp-B4h]
    float v104; // [esp+18h] [ebp-B4h]
    float v105; // [esp+18h] [ebp-B4h]
    float v106; // [esp+18h] [ebp-B4h]
    float v107; // [esp+18h] [ebp-B4h]
    int v108; // [esp+18h] [ebp-B4h]
    float* v109; // [esp+1Ch] [ebp-B0h]
    float v110; // [esp+1Ch] [ebp-B0h]
    float v111; // [esp+1Ch] [ebp-B0h]
    float v112; // [esp+1Ch] [ebp-B0h]
    float v113; // [esp+20h] [ebp-ACh]
    float v114; // [esp+20h] [ebp-ACh]
    float v115; // [esp+20h] [ebp-ACh]
    float v116; // [esp+24h] [ebp-A8h]
    float v117; // [esp+24h] [ebp-A8h]
    float v118; // [esp+24h] [ebp-A8h]
    float v119; // [esp+2Ch] [ebp-A0h]
    char v120; // [esp+33h] [ebp-99h]
    float v121; // [esp+34h] [ebp-98h] BYREF
    float v122; // [esp+38h] [ebp-94h]
    float v123; // [esp+3Ch] [ebp-90h]
    float v124; // [esp+40h] [ebp-8Ch]
    float v125; // [esp+44h] [ebp-88h] BYREF
    float v126; // [esp+48h] [ebp-84h]
    float v127; // [esp+4Ch] [ebp-80h]
    int v128; // [esp+50h] [ebp-7Ch]
    float v129; // [esp+54h] [ebp-78h]
    float v130; // [esp+58h] [ebp-74h]
    float v131; // [esp+5Ch] [ebp-70h]
    float v132; // [esp+60h] [ebp-6Ch]
    float v133; // [esp+64h] [ebp-68h]
    float v134; // [esp+68h] [ebp-64h]
    float v135; // [esp+6Ch] [ebp-60h] BYREF
    float v136; // [esp+70h] [ebp-5Ch]
    float v137; // [esp+74h] [ebp-58h]
    float v138; // [esp+78h] [ebp-54h] BYREF
    float v139; // [esp+7Ch] [ebp-50h]
    float v140; // [esp+80h] [ebp-4Ch]
    float v141; // [esp+84h] [ebp-48h] BYREF
    float v142; // [esp+88h] [ebp-44h]
    float v143; // [esp+8Ch] [ebp-40h]
    __int64 v144; // [esp+90h] [ebp-3Ch]
    _DWORD* v145; // [esp+98h] [ebp-34h]
    float v146; // [esp+9Ch] [ebp-30h] BYREF
    float v147; // [esp+A0h] [ebp-2Ch]
    float v148; // [esp+A4h] [ebp-28h]
    int v149; // [esp+A8h] [ebp-24h] BYREF
    float v150; // [esp+ACh] [ebp-20h]
    float v151; // [esp+B0h] [ebp-1Ch]
    float v152; // [esp+B4h] [ebp-18h]
    float v153; // [esp+B8h] [ebp-14h]
    float v154; // [esp+BCh] [ebp-10h]
    float v155; // [esp+C0h] [ebp-Ch] BYREF
    float v156; // [esp+C4h] [ebp-8h]
    float v157; // [esp+C8h] [ebp-4h]

    v2 = this;
    v3 = 0;
    v145 = this;
    v128 = 0;
    do
    {
        v4 = v2[6] + 192 * v3;
        v5 = *(float*)(v4 + 12);
        if (v5 > 0.0)
        {
            v5 = *(float*)(v4 + 12) - *(float*)&a2;
            *(float*)(v4 + 12) = v5;
            if (v5 < 0.0)
                v5 = 0.0;
            *(float*)(v4 + 12) = v5;
        }
        if (*(_BYTE*)(v4 + 4))
        {
            v5 = *(float*)(v4 + 12);
            if (v5 == 0.0)
            {
                if (*(_BYTE*)(v4 + 112))
                {
                    *(_BYTE*)(v4 + 112) = 0;
                    *(_BYTE*)(v4 + 4) = 0;
                    goto LABEL_115;
                }
                v6 = *(float*)&a2 * *(float*)(v4 + 20);
                v124 = *(float*)(v4 + 16);
                v7 = v6 + *(float*)(v4 + 16);
                *(float*)(v4 + 16) = v7;
                if (v7 - 1.0 > 0.0000099999997)
                {
                    v5 = v124;
                    if (v124 >= 0.0000099999997 || (v5 = v124, v124 <= -0.0000099999997))
                    {
                        sub_413990((_BYTE*)v4);
                        goto LABEL_115;
                    }
                    *(_DWORD*)(v4 + 16) = 1065353216;
                }
                if (v124 >= 0.0000099999997 || v124 <= -0.0000099999997)
                {
                    v146 = 0.0;
                    v147 = 0.0;
                    v148 = 0.0;
                    v135 = 0.0;
                    v136 = 0.0;
                    v137 = 0.0;
                    v138 = 0.0;
                    v139 = 0.0;
                    v140 = 0.0;
                    sub_46C5C5(&v135, &v146, (float*)(v4 + 24));
                    sub_46C5C5(&v138, &v146, (float*)(v4 + 116));
                    v8 = (float*)(v4 + 96);
                    *(float*)(v4 + 96) = v138;
                    *(float*)(v4 + 100) = v139;
                    *(float*)(v4 + 104) = v140;
                    *(float*)(v4 + 96) = *(float*)(v4 + 96) - v135;
                    *(float*)(v4 + 100) = *(float*)(v4 + 100) - v136;
                    *(float*)(v4 + 104) = *(float*)(v4 + 104) - v137;
                    if (*(float*)&a2 <= 0.0000099999997)
                    {
                        *v8 = 0.0;
                        *(_DWORD*)(v4 + 100) = 0;
                        *(_DWORD*)(v4 + 104) = 0;
                    }
                    else
                    {
                        if (*(float*)&a2 == 0.0)
                            v9 = 0.0;
                        else
                            v9 = 1.0 / *(float*)&a2;
                        *v8 = v9 * *v8;
                        *(float*)(v4 + 100) = v9 * *(float*)(v4 + 100);
                        *(float*)(v4 + 104) = v9 * *(float*)(v4 + 104);
                    }
                }
                v149 = *(int*)(v4 + 180);
                v150 = *(float*)(v4 + 184);
                v10 = *(float*)(v4 + 188);
                v151 = *(float*)(v4 + 188);
                v109 = (float*)(v4 + 116);
                sub_46C5C5((float*)&v149, (float*)&v149, (float*)(v4 + 116));
                v11 = (float*)sub_408F30((_DWORD*)dword_520970);
                v120 = sub_402110(v11, (float*)&v149, 0.0);
                sub_413270((float*)v4, 7);
                v132 = v10;
                sub_413270((float*)v4, 8);
                *(float*)&v144 = v10;
                v12 = (float*)sub_408F30((_DWORD*)dword_520970);
                v13 = v12[9];
                v14 = v12[8] - *(float*)&v149;
                v15 = v12[10];
                v156 = v13;
                v157 = v15;
                if (v120)
                {
                    v16 = 1.0 - sqrt((v15 - v151) * (v15 - v151) + (v13 - v150) * (v13 - v150) + v14 * v14) * 0.000024999999;
                    v119 = v16;
                    if (v16 >= 1.0)
                    {
                        v119 = 1.0;
                    }
                    else if (v119 <= 0.5)
                    {
                        v119 = 0.5;
                    }
                }
                else
                {
                    v119 = 0.15000001;
                }
                v5 = v132;
                if (v132 > 0.0)
                {
                    v5 = *(float*)(v4 + 8) - *(float*)&a2;
                    for (*(float*)(v4 + 8) = v5; v5 < 0.0; v5 = *(float*)(v4 + 8))
                    {
                        v113 = fabs((double)rand() * 0.000030518509);
                        if (*(float*)&v144 <= 0.0)
                        {
                            v20 = v119 * v132;
                            if (v20 == 0.0)
                                v18 = 1.0;
                            else
                                v18 = 1.0 / v20;
                        }
                        else
                        {
                            v17 = v132 - *(float*)&v144;
                            if (v17 <= 0.001)
                                v17 = 0.001;
                            v97 = v17 * v119;
                            v116 = (*(float*)&v144 + v132) * v119;
                            if (v97 <= 0.0 || v116 <= 0.0)
                            {
                                v19 = *(float*)(v4 + 8) + 1.0;
                                goto LABEL_45;
                            }
                            if (v97 == v116)
                                v18 = 1.0 / v97;
                            else
                                v18 = 1.0 / (fabs((double)rand() * 0.000030518509) * (v116 - v97) + v97);
                        }
                        v19 = v18 + *(float*)(v4 + 8);
                    LABEL_45:
                        *(float*)(v4 + 8) = v19;
                        v21 = v2[8];
                        if (v21 >= *(int*)&dword_520A44)
                        {
                            v22 = -1;
                            v23 = 0;
                            if (v21 > 0)
                            {
                                v24 = (float*)v2[7];
                                while (*(_BYTE*)(*(_DWORD*)v24 + 8) || v24[2] <= 0.0)
                                {
                                    ++v23;
                                    v24 += 15;
                                    if (v23 >= v21)
                                        goto LABEL_53;
                                }
                                v22 = v23;
                            }
                        LABEL_53:
                            v25 = 0;
                            v134 = 0.0;
                            if (v22 < 0)
                            {
                                v26 = 0;
                                while (v25 < v2[8])
                                {
                                    v27 = v26 + v2[7];
                                    v28 = *(float*)(v27 + 12);
                                    if (v28 == 0.0)
                                        v29 = 1.0;
                                    else
                                        v29 = *(float*)(v27 + 8) / v28;
                                    if (v29 > v134)
                                    {
                                        v134 = v29;
                                        v22 = v25;
                                    }
                                    ++v25;
                                    v26 += 60;
                                    if (v22 >= 0)
                                        goto LABEL_64;
                                }
                                continue;
                            }
                        LABEL_64:
                            v30 = (void**)(v2[7] + 60 * v22);
                            sub_409A00(dword_520970, *v30);
                            *v30 = 0;
                            v31 = v2[8];
                            if (v22 < v31 - 1)
                            {
                                v32 = (void*)(v2[7] + 60 * v31 - 60);
                                qmemcpy(v30, v32, 0x3Cu);
                                memset(v32, 0, 0x3Cu);
                            }
                            --v2[8];
                        }
                        v33 = v2[8];
                        v34 = v2[7];
                        v2[8] = v33 + 1;
                        v35 = v34 + 60 * v33;
                        *(_DWORD*)(v35 + 4) = *(_DWORD*)v4;
                        v36 = sub_409960((_DWORD*)dword_520970, (int)v2);
                        *(_DWORD*)v35 = v36;
                        v36[3] = 5;
                        *(_DWORD*)(*(_DWORD*)v35 + 36) = *(_DWORD*)(*(_DWORD*)(v35 + 4) + 360);
                        v125 = *(float*)(v4 + 180);
                        v126 = *(float*)(v4 + 184);
                        v127 = *(float*)(v4 + 188);
                        v141 = *(float*)(v4 + 180);
                        v142 = *(float*)(v4 + 184);
                        v37 = *(float*)(v4 + 188);
                        v143 = *(float*)(v4 + 188);
                        sub_413270((float*)v4, 0);
                        v98 = v37;
                        if (v37 > 0.0)
                        {
                            v102 = -v98;
                            do
                            {
                                v133 = -v98;
                                if (v102 == v98)
                                    v129 = -v98;
                                else
                                    v129 = fabs((double)rand() * 0.000030518509) * (v98 - v133) + v133;
                                v131 = -v98;
                                if (v102 == v98)
                                    v38 = v131;
                                else
                                    v38 = fabs((double)rand() * 0.000030518509) * (v98 - v131) + v131;
                                v92 = v98 * v98;
                            } while (v38 * v38 + v129 * v129 > v92);
                            v2 = v145;
                            v125 = v125 + v129;
                            v126 = v126 + v38;
                            v141 = v141 + v129;
                            v142 = v142 + v38;
                        }
                        if (v124 >= 0.0000099999997 || v124 <= -0.0000099999997)
                        {
                            sub_46C5C5(&v125, &v125, (float*)(v4 + 24));
                            sub_46C5C5(&v141, &v141, v109);
                            v39 = (v141 - v125) * v113 + v125;
                            v153 = (v142 - v126) * v113 + v126;
                            v154 = (v143 - v127) * v113 + v127;
                        }
                        else
                        {
                            sub_46C5C5(&v125, &v125, v109);
                            v152 = v125;
                            v39 = v125;
                            v153 = v126;
                            v154 = v127;
                        }
                        *(float*)(v35 + 16) = v39;
                        *(float*)(v35 + 20) = v153;
                        *(float*)(v35 + 24) = v154;
                        v40 = fabs((double)rand() * 0.000030518509);
                        *(float*)(v35 + 48) = v40 + v40 - 1.0;
                        v41 = fabs((double)rand() * 0.000030518509);
                        v42 = v41 + v41 - 1.0;
                        *(float*)(v35 + 52) = v42;
                        sub_413270((float*)v4, 24);
                        v103 = v42;
                        sub_413270((float*)v4, 24);
                        v43 = -v42;
                        v99 = v43;
                        if (v43 == v103)
                            v44 = v99;
                        else
                            v44 = fabs((double)rand() * 0.000030518509) * (v103 - v99) + v99;
                        *(float*)(v35 + 44) = v44;
                        sub_413290(v35, 25);
                        v45 = v44 < 0.0000099999997 && v44 > -0.0000099999997;
                        *(_BYTE*)(v35 + 56) = !v45;
                        sub_413270((float*)v4, 3);
                        v104 = v44;
                        sub_413270((float*)v4, 4);
                        v117 = v44 + v104;
                        v100 = v104 - v44;
                        if (v100 == v117)
                            v46 = v100;
                        else
                            v46 = fabs((double)rand() * 0.000030518509) * (v117 - v100) + v100;
                        v105 = v46;
                        v123 = v46;
                        v121 = 0.0;
                        v122 = 0.0;
                        sub_413270((float*)v4, 1);
                        v101 = v46;
                        sub_413270((float*)v4, 2);
                        v118 = v46;
                        if (v101 > 0.0)
                        {
                            v47 = -v101;
                            v114 = v47;
                            if (v47 == v101)
                                v48 = v114;
                            else
                                v48 = fabs((double)rand() * 0.000030518509) * (v101 - v114) + v114;
                            v49 = v48 * 0.017453292;
                            v93 = cos(v49);
                            v123 = v93 * v105;
                            v122 = sin(v49) * v105;
                        }
                        v50 = v118;
                        if (v118 > 0.0)
                        {
                            v51 = -v118;
                            v115 = v51;
                            if (v51 == v118)
                                v52 = v115;
                            else
                                v52 = fabs((double)rand() * 0.000030518509) * (v118 - v115) + v115;
                            v53 = v52 * 0.017453292;
                            v94 = cos(v53);
                            v50 = sin(v53);
                            v121 = -(v123 * v50);
                            v123 = v123 * v94;
                        }
                        sub_413270((float*)v4, 23);
                        *(float*)(v35 + 28) = *(float*)(v4 + 96) * v50 + v121;
                        *(float*)(v35 + 32) = *(float*)(v4 + 100) * v50 + v122;
                        *(float*)(v35 + 36) = *(float*)(v4 + 104) * v50 + v123;
                        sub_413270((float*)v4, 5);
                        v106 = v50;
                        sub_413270((float*)v4, 6);
                        if (v50 <= 0.0)
                        {
                            v55 = v106;
                        }
                        else
                        {
                            v54 = v106 - v50;
                            if (v54 >= 0.0)
                                v130 = v54;
                            else
                                v130 = 0.0;
                            v107 = v50 + v106;
                            if (v130 == v107)
                                v55 = v130;
                            else
                                v55 = fabs((double)rand() * 0.000030518509) * (v107 - v130) + v130;
                        }
                        *(_DWORD*)(v35 + 8) = 0;
                        if (v55 == 0.0)
                            v56 = 1.0;
                        else
                            v56 = 1.0 / v55;
                        *(float*)(v35 + 12) = v56;
                    }
                }
                qmemcpy((void*)(v4 + 24), v109, 0x40u);
                v3 = v128;
            }
        }
    LABEL_115:
        v128 = ++v3;
    } while (v3 < 512);
    v57 = 0.0;
    if ((int)v2[8] > 0)
    {
        v108 = 0;
        do
        {
            v58 = v2[7] + v108;
            sub_413290(v58, 12);
            v59 = *(float*)(v58 + 36) - v5 * *(float*)&a2;
            *(float*)(v58 + 36) = v59;
            sub_413290(v58, 9);
            v110 = v59;
            if (v59 <= 0.0)
                goto LABEL_126;
            if (*(float*)(v58 + 28) <= 0.0)
            {
                v59 = *(float*)(v58 + 28);
                if (v59 >= 0.0)
                    goto LABEL_126;
                v59 = v110 * *(float*)&a2 + *(float*)(v58 + 28);
                *(float*)(v58 + 28) = v59;
                if (v59 > 0.0)
                    LABEL_124:
                v59 = 0.0;
            }
            else
            {
                v59 = *(float*)(v58 + 28) - v110 * *(float*)&a2;
                *(float*)(v58 + 28) = v59;
                if (v59 < 0.0)
                    goto LABEL_124;
            }
            *(float*)(v58 + 28) = v59;
        LABEL_126:
            sub_413290(v58, 10);
            v111 = v59;
            if (v59 == 0.0)
                goto LABEL_134;
            if (*(float*)(v58 + 32) <= 0.0)
            {
                v59 = *(float*)(v58 + 32);
                if (v59 >= 0.0)
                    goto LABEL_134;
                v59 = v111 * *(float*)&a2 + *(float*)(v58 + 32);
                *(float*)(v58 + 32) = v59;
                if (v59 > 0.0)
                    LABEL_132:
                v59 = 0.0;
            }
            else
            {
                v59 = *(float*)(v58 + 32) - v111 * *(float*)&a2;
                *(float*)(v58 + 32) = v59;
                if (v59 < 0.0)
                    goto LABEL_132;
            }
            *(float*)(v58 + 32) = v59;
        LABEL_134:
            sub_413290(v58, 11);
            v112 = v59;
            if (v59 == 0.0)
                goto LABEL_142;
            if (*(float*)(v58 + 36) <= 0.0)
            {
                if (*(float*)(v58 + 36) >= 0.0)
                    goto LABEL_142;
                v60 = v112 * *(float*)&a2 + *(float*)(v58 + 36);
                *(float*)(v58 + 36) = v60;
                if (v60 > 0.0)
                    LABEL_140:
                v60 = 0.0;
            }
            else
            {
                v60 = *(float*)(v58 + 36) - v112 * *(float*)&a2;
                *(float*)(v58 + 36) = v60;
                if (v60 < 0.0)
                    goto LABEL_140;
            }
            *(float*)(v58 + 36) = v60;
        LABEL_142:
            *(float*)(v58 + 16) = *(float*)&a2 * *(float*)(v58 + 28) + *(float*)(v58 + 16);
            *(float*)(v58 + 20) = *(float*)&a2 * *(float*)(v58 + 32) + *(float*)(v58 + 20);
            v61 = *(float*)&a2 * *(float*)(v58 + 36) + *(float*)(v58 + 24);
            *(float*)(v58 + 24) = v61;
            sub_413290(v58, 20);
            v95 = v61;
            sub_413290(v58, 21);
            v62 = v61 * *(float*)(v58 + 52);
            if (!*(_BYTE*)(v58 + 56))
            {
                v70 = (v62 + v95) * *(float*)&a2 + *(float*)(v58 + 44);
            LABEL_149:
                *(float*)(v58 + 44) = v70;
                goto LABEL_150;
            }
            if (sub_408F30((_DWORD*)dword_520970))
            {
                v155 = *(float*)(v58 + 16);
                v156 = *(float*)(v58 + 20);
                v157 = *(float*)(v58 + 24);
                v146 = *(float*)(v58 + 16) + *(float*)(v58 + 28);
                v63 = *(float*)(v58 + 32) + *(float*)(v58 + 20);
                v135 = 0.0;
                v136 = 0.0;
                v137 = 0.0;
                v147 = v63;
                v64 = *(float*)(v58 + 24) + *(float*)(v58 + 36);
                v121 = 0.0;
                v122 = 0.0;
                v123 = 0.0;
                v148 = v64;
                v65 = (float*)sub_408F30((_DWORD*)dword_520970);
                sub_402430(v65, &v155, &v135);
                v66 = (float*)sub_408F30((_DWORD*)dword_520970);
                sub_402430(v66, &v146, &v121);
                v67 = v121 - v135;
                v144 = (unsigned int)dword_5209D8;
                v122 = v122 - v136;
                v123 = v123 - v137;
                v68 = (double)(unsigned int)dword_5209D8;
                if (v68 == 0.0)
                    v69 = atan2(v67 * 0.0, v122);
                else
                    v69 = atan2(v67 * ((double)dword_5209F4 / v68), v122);
                v70 = v69 * 57.295776;
                goto LABEL_149;
            }
        LABEL_150:
            v5 = *(float*)&a2 * *(float*)(v58 + 12) + *(float*)(v58 + 8);
            *(float*)(v58 + 8) = v5;
            if (v5 <= 1.0)
            {
                LODWORD(v134) = LODWORD(v57) + 1;
                v108 += 60;
                sub_413290(v58, 14);
                v73 = v5 * *(float*)(v58 + 48);
                v96 = v73;
                sub_413290(v58, 13);
                v74 = v73 + v96;
                *(float*)(v58 + 40) = v74;
                if (v74 < 0.0)
                    v74 = 0.0;
                *(float*)(v58 + 40) = v74;
                v75 = *(float**)v58;
                v138 = *(float*)(v58 + 16);
                v139 = *(float*)(v58 + 20);
                v76 = *(float*)(v58 + 24);
                v77 = v139;
                v75[4] = v138;
                v140 = v76;
                v78 = v140;
                v75[5] = v77;
                v75[6] = v78;
                v75[12] = *(float*)(v58 + 40);
                v79 = *(float*)(v58 + 44) * 0.017453292;
                v75[13] = v79;
                sub_413290(v58, 17);
                v80 = (__int64)v79;
                sub_413290(v58, 18);
                sub_413290(v58, 19);
                sub_413290(v58, 15);
                v81 = v79 * 255.0;
                *((_DWORD*)v75 + 14) = (unsigned __int8)v80
                    | (((unsigned __int8)v80
                        | (((unsigned __int8)v80 | ((unsigned int)(__int64)v81 << 8)) << 8)) << 8);
                v82 = *(_DWORD*)(*(_DWORD*)(v58 + 4) + 688);
                sub_413290(v58, 22);
                v83 = v82 - 1;
                v84 = (__int64)v81;
                switch (v82)
                {
                case 1:
                    v85 = 1;
                    v128 = (__int64)v81;
                    break;
                case 4:
                    v85 = 2;
                    v128 = v84 / 2;
                    break;
                case 16:
                    v85 = 4;
                    v128 = v84 / 4;
                    break;
                case 64:
                    v85 = 8;
                    v128 = v84 / 8;
                    break;
                default:
                    v85 = 0;
                    v128 = 0;
                    break;
                }
                v86 = v84 % v85;
                switch (v83)
                {
                case 0:
                    v87 = 256;
                    break;
                case 3:
                    v87 = 128;
                    break;
                case 15:
                    v87 = 64;
                    break;
                case 63:
                    v87 = 32;
                    break;
                default:
                    v87 = 0;
                    break;
                }
                v57 = v134;
                v88 = v128;
                v89 = v128 * v87;
                v75[20] = (double)(v86 * v87 + 1) * 0.00390625;
                v75[21] = (double)(v89 + 1) * 0.00390625;
                v2 = v145;
                v75[22] = (double)(v87 * (v86 + 1) - 1) * 0.00390625;
                v75[23] = (double)(v87 * (v88 + 1) - 1) * 0.00390625;
                v5 = v75[12] * 1.4141999;
                v90 = *(_BYTE*)(*(_DWORD*)(v58 + 4) + 372);
                *((_DWORD*)v75 + 7) = 1;
                *((_BYTE*)v75 + 44) = v90;
                v75[8] = v5;
            }
            else
            {
                sub_409A00(dword_520970, *(void**)v58);
                *(_DWORD*)v58 = 0;
                v71 = v2[8];
                if (SLODWORD(v57) < v71 - 1)
                {
                    v72 = (void*)(v2[7] + 60 * v71 - 60);
                    qmemcpy((void*)v58, v72, 0x3Cu);
                    memset(v72, 0, 0x3Cu);
                }
                --v2[8];
            }
        } while (SLODWORD(v57) < v2[8]);
    }
    *(float*)dword_520A38 = (double)(int)v2[8] + *(float*)dword_520A38;
    return sub_428620(v2, a2);
}
// 413F43: conditional instruction was optimized away because esi.4<0
// 520970: using guessed type int dword_520970;
// 5209D8: using guessed type int dword_5209D8;
// 5209F4: using guessed type int dword_5209F4;
// 520A38: using guessed type int dword_520A38;

//----- (00414C80) --------------------------------------------------------
char __thiscall sub_414C80(_DWORD* this, int a2)
{
    int i; // edi
    int v4; // esi
    char* v5; // eax
    int v6; // eax

    for (i = 0; i < 98304; i += 192)
    {
        v4 = i + this[6];
        LOBYTE(v5) = *(_BYTE*)(v4 + 112);
        if (!(_BYTE)v5)
        {
            LOBYTE(v5) = *(_BYTE*)(v4 + 4);
            if ((_BYTE)v5)
            {
                v5 = (char*)(*(_DWORD*)v4 + 293);
                if (*v5)
                {
                    v6 = sub_405A30(*(_DWORD**)(a2 + 28), v5, -1, 1);
                    if (v6 < 0)
                        v6 = 0;
                    LOBYTE(v5) = sub_407690(a2, v6, (_DWORD*)(v4 + 116));
                }
            }
        }
    }
    return (char)v5;
}

//----- (00414CE0) --------------------------------------------------------
int __thiscall sub_414CE0(void* this)
{
    *(_DWORD*)this = &off_499224;
    return sub_4690A0(this);
}
// 499224: using guessed type _UNKNOWN *off_499224;

//----- (00414CF0) --------------------------------------------------------
int __fastcall sub_414CF0(int a1)
{
    int result; // eax

    result = a1;
    *(_DWORD*)(a1 + 4) = 0;
    *(_DWORD*)(a1 + 8) = 0;
    *(_DWORD*)(a1 + 12) = 0;
    *(_BYTE*)(a1 + 16) = 1;
    *(_BYTE*)(a1 + 32) = 1;
    *(_DWORD*)(a1 + 20) = 0;
    *(_DWORD*)(a1 + 24) = 0;
    *(_DWORD*)(a1 + 28) = 0;
    *(_BYTE*)(a1 + 36) = HIBYTE(a1);
    *(_DWORD*)(a1 + 40) = 0;
    *(_DWORD*)(a1 + 44) = 0;
    *(_DWORD*)(a1 + 48) = 0;
    *(_BYTE*)(a1 + 52) = HIBYTE(a1);
    *(_DWORD*)(a1 + 56) = 0;
    *(_DWORD*)(a1 + 60) = 0;
    *(_DWORD*)(a1 + 64) = 0;
    *(_BYTE*)(a1 + 68) = HIBYTE(a1);
    *(_DWORD*)(a1 + 72) = 0;
    *(_DWORD*)(a1 + 76) = 0;
    *(_DWORD*)(a1 + 80) = 0;
    *(_DWORD*)a1 = &off_499230;
    return result;
}
// 499230: using guessed type _UNKNOWN *off_499230;

//----- (00414D70) --------------------------------------------------------
void __thiscall sub_414D70(LPVOID* this)
{
    int i; // ebp
    _DWORD* v3; // eax
    void* v4; // edi
    void* v5; // eax

    *this = &off_499230;
    sub_4885A6(this[18]);
    this[18] = 0;
    this[19] = 0;
    this[20] = 0;
    sub_4885A6(this[14]);
    this[14] = 0;
    this[15] = 0;
    this[16] = 0;
    sub_4885A6(this[10]);
    this[10] = 0;
    this[11] = 0;
    this[12] = 0;
    if (*((_BYTE*)this + 32))
    {
        for (i = 0; i < (int)this[6]; ++i)
        {
            v3 = this[5];
            v4 = (void*)v3[i];
            if (v4)
            {
                ((void(__thiscall*)(_DWORD))nullsub_1)(v3[i]);
                sub_4885A6(v4);
            }
        }
    }
    memset(this[5], 0, 4 * (_DWORD)this[6]);
    v5 = this[5];
    this[6] = 0;
    sub_488CEE(v5);
    this[7] = 0;
    this[5] = 0;
    *this = &off_499040;
}
// 415760: using guessed type int nullsub_1();
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 499230: using guessed type _UNKNOWN *off_499230;

//----- (00414E60) --------------------------------------------------------
char __thiscall sub_414E60(int this)
{
    char* v2; // ebx
    int v3; // eax
    _DWORD* v4; // edx
    int v5; // eax
    int v6; // ecx
    int v7; // eax
    int* v8; // edx
    int v9; // eax
    _DWORD* v10; // ecx
    _DWORD* v11; // eax
    int v12; // ecx
    int v13; // edx
    int* v14; // ecx
    _DWORD* v15; // ecx
    int v16; // edx
    _DWORD* v17; // ecx
    int v18; // eax
    char* v19; // ebp
    int v20; // eax
    int v21; // edi
    unsigned int v22; // eax
    int v23; // eax
    int v25; // [esp+14h] [ebp-4Ch] BYREF
    int v26; // [esp+18h] [ebp-48h]
    int v27; // [esp+1Ch] [ebp-44h]
    char v28[12]; // [esp+24h] [ebp-3Ch] BYREF
    char v29[48]; // [esp+30h] [ebp-30h] BYREF

    sub_4013C0((int)v29, 12, 3, (int(__thiscall*)(int))Iostream_init::Iostream_init);
    if ((unsigned int)sub_419CC0((_DWORD*)(this + 52)) >= 2)
    {
        if ((unsigned int)sub_419CC0((_DWORD*)(this + 52)) > 2)
            sub_41A300((_DWORD*)(this + 52), (char*)(*(_DWORD*)(this + 56) + 120), *(char**)(this + 60));
    }
    else
    {
        v2 = *(char**)(this + 60);
        v3 = sub_419CC0((_DWORD*)(this + 52));
        sub_41A000((_DWORD*)(this + 52), v2, 2 - v3, v28);
    }
    v4 = *(_DWORD**)(this + 56);
    v25 = 1065353216;
    v26 = 0;
    *v4 = -973499978;
    v5 = *(_DWORD*)(this + 56);
    v26 = 1065353216;
    v27 = 0;
    *(_DWORD*)(v5 + 4) = -1008107422;
    v6 = *(_DWORD*)(this + 56);
    v7 = v25;
    v27 = 0;
    *(_DWORD*)(v6 + 8) = 0;
    v8 = (int*)(*(_DWORD*)(this + 56) + 12);
    v27 = 1065353216;
    *v8 = v7;
    v25 = 1065353216;
    v8[1] = 0;
    v8[2] = 0;
    v9 = v26;
    v10 = (_DWORD*)(*(_DWORD*)(this + 56) + 24);
    *v10 = 0;
    v26 = 1065353216;
    v10[1] = v9;
    v10[2] = 0;
    v11 = (_DWORD*)(*(_DWORD*)(this + 56) + 36);
    *v11 = 0;
    v12 = v27;
    v11[1] = 0;
    v27 = 1065353216;
    v11[2] = v12;
    *(_DWORD*)(*(_DWORD*)(this + 56) + 48) = 1149749993;
    *(_DWORD*)(*(_DWORD*)(this + 56) + 52) = 1157700555;
    *(_DWORD*)(*(_DWORD*)(this + 56) + 56) = 1120403456;
    *(_DWORD*)(*(_DWORD*)(this + 56) + 60) = 1182898167;
    *(_DWORD*)(*(_DWORD*)(this + 56) + 64) = 1164012827;
    *(_DWORD*)(*(_DWORD*)(this + 56) + 68) = 0;
    v13 = v25;
    v14 = (int*)(*(_DWORD*)(this + 56) + 72);
    v25 = 0;
    *v14 = v13;
    v14[1] = 0;
    v14[2] = 0;
    v15 = (_DWORD*)(*(_DWORD*)(this + 56) + 84);
    *v15 = 0;
    v16 = v26;
    v26 = 0;
    v15[1] = v16;
    v15[2] = 0;
    v17 = (_DWORD*)(*(_DWORD*)(this + 56) + 96);
    *v17 = 0;
    v17[1] = 0;
    v17[2] = v27;
    *(_DWORD*)(*(_DWORD*)(this + 56) + 108) = 1149427220;
    *(_DWORD*)(*(_DWORD*)(this + 56) + 112) = 1156436001;
    *(_DWORD*)(*(_DWORD*)(this + 56) + 116) = 1120403456;
    v18 = *(_DWORD*)(this + 40);
    if (v18 && (unsigned int)((*(_DWORD*)(this + 44) - v18) >> 4) >= 6)
    {
        if ((unsigned int)sub_448730((_DWORD*)(this + 36)) > 6)
            sub_448750((_DWORD*)(this + 36), (_DWORD*)(*(_DWORD*)(this + 40) + 96), *(_DWORD**)(this + 44));
    }
    else
    {
        v19 = *(char**)(this + 44);
        v20 = sub_448730((_DWORD*)(this + 36));
        sub_419CF0((char*)(this + 36), v19, 6 - v20, &v25);
    }
    **(_DWORD**)(this + 40) = -975202673;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 4) = -1036427723;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 8) = 0;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 12) = 1124929044;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 16) = -975716123;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 20) = 1127554679;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 24) = 0;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 28) = 1127947108;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 32) = 1175146158;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 36) = 1164496953;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 40) = 0;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 44) = 1149258899;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 48) = 1176633612;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 52) = 1170444159;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 56) = 0;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 60) = 1147626717;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 64) = 1175365576;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 68) = 1170928318;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 72) = 0;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 76) = 1130894328;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 80) = 1177209992;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 84) = 1173049395;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 88) = 0;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 92) = 1134108180;
    v21 = *(_DWORD*)(this + 72);
    if (!v21)
    {
        v23 = 0;
        goto LABEL_14;
    }
    v22 = (*(_DWORD*)(this + 76) - v21) >> 4;
    if (!v22)
    {
        v23 = (*(_DWORD*)(this + 76) - v21) >> 4;
    LABEL_14:
        sub_419CF0((char*)(this + 68), *(char**)(this + 76), 1 - v23, &v25);
        goto LABEL_17;
    }
    if (v22 > 1)
        *(_DWORD*)(this + 76) = v21 + 16;
LABEL_17:
    **(_DWORD**)(this + 72) = 1175910556;
    *(_DWORD*)(*(_DWORD*)(this + 72) + 4) = 1167101719;
    *(_DWORD*)(*(_DWORD*)(this + 72) + 8) = 1135941222;
    *(_DWORD*)(*(_DWORD*)(this + 72) + 12) = 1161404805;
    return 1;
}
// 415158: conditional instruction was optimized away because edi.4!=0

//----- (004151F0) --------------------------------------------------------
void __thiscall sub_4151F0(int this)
{
    int i; // ebp
    int v3; // eax
    void* v4; // edi
    void* v5; // eax

    if (*(_BYTE*)(this + 32))
    {
        for (i = 0; i < *(_DWORD*)(this + 24); ++i)
        {
            v3 = *(_DWORD*)(this + 20);
            v4 = *(void**)(v3 + 4 * i);
            if (v4)
            {
                nullsub_1(*(_DWORD*)(v3 + 4 * i));
                sub_4885A6(v4);
            }
        }
    }
    memset(*(void**)(this + 20), 0, 4 * *(_DWORD*)(this + 24));
    v5 = *(void**)(this + 20);
    *(_DWORD*)(this + 24) = 0;
    sub_488CEE(v5);
    *(_DWORD*)(this + 28) = 0;
    *(_DWORD*)(this + 20) = 0;
}
// 415760: using guessed type int __thiscall nullsub_1(_DWORD);

//----- (00415270) --------------------------------------------------------
_DWORD* __thiscall sub_415270(int this, int a2)
{
    _DWORD* v3; // eax
    _DWORD* v4; // ebx
    int v5; // eax
    int v6; // ecx
    int v7; // eax
    char* v8; // eax
    int v9; // edi
    int v10; // ecx

    v3 = operator new(0x10E0u);
    if (v3)
        v4 = sub_415660(v3, a2);
    else
        v4 = 0;
    v5 = *(_DWORD*)(this + 28);
    v6 = *(_DWORD*)(this + 24) + 1;
    *(_DWORD*)(this + 24) = v6;
    if (v6 > v5)
    {
        v7 = v5 + 8;
        *(_DWORD*)(this + 28) = v7;
        v8 = (char*)sub_488DD7(*(LPVOID*)(this + 20), 4 * v7);
        if (v8)
        {
            v9 = *(_DWORD*)(this + 24);
            v10 = *(_DWORD*)(this + 28) - v9;
            *(_DWORD*)(this + 20) = v8;
            memset(&v8[4 * v9], 0, 4 * v10);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 20) + 4 * *(_DWORD*)(this + 24) - 4) = v4;
    return v4;
}

//----- (00415330) --------------------------------------------------------
void __thiscall sub_415330(int this, void* a2)
{
    int v3; // eax
    int v4; // ecx
    void** v5; // edi
    void** i; // edx
    int v7; // ecx

    v3 = 0;
    v4 = *(_DWORD*)(this + 24);
    if (v4 > 0)
    {
        v5 = *(void***)(this + 20);
        for (i = v5; *i != a2; ++i)
        {
            if (++v3 >= v4)
                return;
        }
        v7 = v4 - 1;
        *(_DWORD*)(this + 24) = v7;
        if (v3 != v7)
        {
            memcpy(&v5[v3], &v5[v3 + 1], 4 * (v7 + 0x3FFFFFFF * v3));
            *(_DWORD*)(*(_DWORD*)(this + 20) + 4 * *(_DWORD*)(this + 24)) = 0;
        }
        if (*(_BYTE*)(this + 32))
        {
            if (a2)
            {
                nullsub_1(a2);
                sub_4885A6(a2);
            }
        }
    }
}
// 415760: using guessed type int __thiscall nullsub_1(_DWORD);

//----- (004153B0) --------------------------------------------------------
char __thiscall sub_4153B0(_DWORD* this, int a2)
{
    int v2; // ebx
    unsigned int v3; // edi
    int v4; // esi
    char v6; // c0

    v2 = this[18];
    v3 = 0;
    v4 = 0;
    while (v2 && v3 < (this[19] - v2) >> 4)
    {
        if (!v6)
            return 0;
        ++v3;
        v4 += 16;
    }
    return 1;
}
// 415409: variable 'v6' is possibly undefined

//----- (00415430) --------------------------------------------------------
char __thiscall sub_415430(_DWORD* this, int a2)
{
    int v3; // eax
    int i; // edi
    int v5; // ecx
    int v6; // edi
    int v7; // ecx
    unsigned int v8; // ebx
    int j; // edi
    int v10; // eax
    unsigned int v11; // ebx
    int k; // edi
    int v13; // eax
    float v15; // [esp+10h] [ebp-7Ch]
    int v16[3]; // [esp+14h] [ebp-78h] BYREF
    int v17[3]; // [esp+20h] [ebp-6Ch] BYREF
    int v18[3]; // [esp+2Ch] [ebp-60h] BYREF
    int v19[3]; // [esp+38h] [ebp-54h] BYREF
    int v20[9]; // [esp+44h] [ebp-48h] BYREF
    int v21[9]; // [esp+68h] [ebp-24h] BYREF

    v3 = *(_DWORD*)(a2 + 4132);
    if (v3 < 6)
        return 1;
    v15 = 0.0;
    if (v3 > 6)
        v15 = (1.0 - *(float*)(a2 + 16)) * *(float*)(a2 + 4288) + (double)(v3 - 7) * *(float*)(a2 + 4288);
    sub_4183A0(a2, a2, v15);
    for (i = 0; i < this[6]; ++i)
    {
        v5 = *(_DWORD*)(this[5] + 4 * i);
        if (v5 != a2 && *(_BYTE*)(v5 + 4148) && *(_DWORD*)(v5 + 4144) == *(_DWORD*)(a2 + 4144))
            sub_4183A0(v5, a2, v15);
    }
    if (!sub_418420(a2, a2, 0.1, (float*)v17, (float*)v20, v16))
        return 1;
    while (1)
    {
        v6 = 0;
        v15 = v15 + 0.1;
        if ((int)this[6] > 0)
            break;
    LABEL_18:
        v8 = 0;
        for (j = 0; ; j += 60)
        {
            v10 = this[14];
            if (!v10 || v8 >= (this[15] - v10) / 60)
                break;
            if (sub_40D330(
                (float*)(j + this[14]),
                (float*)(j + this[14] + 12),
                (float*)(j + this[14] + 48),
                (float*)v17,
                (float*)v20,
                (float*)v16))
            {
                return 0;
            }
            ++v8;
        }
        v11 = 0;
        for (k = 0; ; k += 16)
        {
            v13 = this[10];
            if (!v13 || v11 >= (this[11] - v13) >> 4)
                break;
            if (sub_40D900((float*)(k + v13), *(float*)(k + v13 + 12), (float*)v17, (float*)v20, (float*)v16))
                return 0;
            ++v11;
        }
        if (!sub_418420(a2, a2, 0.1, (float*)v17, (float*)v20, v16))
            return 1;
    }
    while (1)
    {
        v7 = *(_DWORD*)(this[5] + 4 * v6);
        if (v7 != a2
            && *(_BYTE*)(v7 + 4148)
            && *(_DWORD*)(v7 + 4144) == *(_DWORD*)(a2 + 4144)
            && sub_418420(v7, a2, 0.1, (float*)v19, (float*)v21, v18)
            && sub_40D330((float*)v17, (float*)v20, (float*)v16, (float*)v19, (float*)v21, (float*)v18))
        {
            return 0;
        }
        if (++v6 >= this[6])
            goto LABEL_18;
    }
}

//----- (00415660) --------------------------------------------------------
_DWORD* __thiscall sub_415660(_DWORD* this, int a2)
{
    _DWORD* result; // eax
    _DWORD* v3; // ecx
    int v4; // esi

    result = this;
    this[2] = 0;
    this[9] = 0;
    this[4] = 0;
    this[10] = 0;
    this[1033] = 0;
    this[1034] = 0;
    this[11] = 0;
    this[1035] = 0;
    *this = a2;
    this[5] = 1065353216;
    *((_BYTE*)this + 12) = 1;
    v3 = this + 35;
    v4 = 200;
    do
    {
        *(v3 - 1) = 1120403456;
        *v3 = 1120403456;
        v3[1] = 1120403456;
        v3 += 5;
        --v4;
    } while (v4);
    result[1071] = *(_DWORD*)(a2 + 292);
    result[1072] = *(_DWORD*)(a2 + 296);
    result[1073] = *(_DWORD*)(a2 + 300);
    result[1074] = *(_DWORD*)(a2 + 304);
    result[1075] = *(_DWORD*)(a2 + 308);
    result[1076] = *(_DWORD*)(a2 + 312);
    result[1077] = *(_DWORD*)(a2 + 316);
    result[1078] = *(_DWORD*)(a2 + 320);
    *((_BYTE*)result + 4316) = *(_BYTE*)(a2 + 324);
    result[1069] = 20;
    result[1070] = 10;
    return result;
}

//----- (00415770) --------------------------------------------------------
int __thiscall sub_415770(int this, float* a2, float* a3, int a4, int a5)
{
    double v5; // st7
    double v6; // st6
    int result; // eax
    float v8; // [esp+4h] [ebp-18h]
    float v9; // [esp+4h] [ebp-18h]
    float v10; // [esp+8h] [ebp-14h]
    float v11; // [esp+8h] [ebp-14h]
    float v12; // [esp+Ch] [ebp-10h]
    float v13; // [esp+Ch] [ebp-10h]
    float v14; // [esp+14h] [ebp-8h]
    float v15; // [esp+18h] [ebp-4h]
    float v16; // [esp+20h] [ebp+4h]
    float v17; // [esp+20h] [ebp+4h]
    float v18; // [esp+20h] [ebp+4h]

    *(_BYTE*)(this + 4148) = 0;
    if (a2)
    {
        *(_BYTE*)(this + 4148) = 1;
        v14 = a2[1] - a3[1];
        v15 = a2[2] - a3[2];
        v8 = (*a2 - *a3) * 0.5;
        *(float*)(this + 4152) = v8;
        v10 = v14 * 0.5;
        *(float*)(this + 4156) = v10;
        v12 = v15 * 0.5;
        *(float*)(this + 4160) = v12;
        v9 = *a2 - *(float*)(this + 4152);
        v11 = a2[1] - *(float*)(this + 4156);
        v13 = a2[2] - *(float*)(this + 4160);
        v5 = 0.0;
        v6 = *(float*)(this + 4152);
        *(float*)(this + 4164) = v9;
        *(float*)(this + 4168) = v11;
        *(float*)(this + 4172) = v13;
        if (v6 >= 0.0)
            v5 = *(float*)(this + 4152);
        if (v5 <= *(float*)(this + 4156))
            v5 = *(float*)(this + 4156);
        if (v5 <= *(float*)(this + 4160))
            v5 = *(float*)(this + 4160);
        v16 = v5 + *(float*)(this + 4164);
        if (v5 <= v16)
            v5 = v16;
        v17 = v5 + *(float*)(this + 4168);
        if (v5 <= v17)
            v5 = v17;
        v18 = v5 + *(float*)(this + 4172);
        if (v5 <= v18)
            v5 = v18;
        *(float*)(this + 4176) = v5 * 1.2;
    }
    *(_DWORD*)(this + 16) = 0;
    *(_DWORD*)(this + 4132) = 0;
    memset((void*)(this + 132), 0, 0xFA0u);
    result = a5;
    *(_DWORD*)(this + 4) = a4;
    *(_DWORD*)(this + 8) = a5;
    return result;
}

//----- (00415910) --------------------------------------------------------
void __thiscall sub_415910(void* this)
{
    sub_415330(*(_DWORD*)(dword_520970 + 244), this);
}
// 520970: using guessed type int dword_520970;

//----- (00415930) --------------------------------------------------------
void __thiscall sub_415930(int this, int a2, float a3)
{
    double v3; // st7

    *(_DWORD*)(this + 20) = 1065353216;
    v3 = (double)a2 + a3 - ((double)*(int*)(this + 4136) + *(float*)(this + 16));
    if (v3 >= 0.0000099999997 || v3 <= -0.0000099999997)
        *(float*)(this + 20) = v3 + 1.0;
    else
        *(_DWORD*)(this + 20) = 1065353216;
    if (*(float*)(this + 20) <= 1.5)
    {
        if (*(float*)(this + 20) < 0.5)
            *(_DWORD*)(this + 20) = 1056964608;
    }
    else
    {
        *(_DWORD*)(this + 20) = 1069547520;
    }
}

//----- (004159B0) --------------------------------------------------------
void __thiscall sub_4159B0(int this, float a2, _DWORD* a3, _DWORD* a4, float* a5, int a6, float* a7)
{
    double v8; // st7
    double v9; // st7
    int v10; // ecx
    double v11; // st7
    double v12; // st7
    double v13; // st6
    double v14; // st7
    double v15; // st7
    double v16; // st7
    float* v17; // eax
    float* v18; // eax
    float* v19; // eax
    int v20; // eax
    int v21; // ecx
    int v22; // edx
    float v23; // eax
    float v24; // ecx
    int v25; // eax
    _DWORD* v26; // eax
    float* v27; // ecx
    _DWORD* v28; // eax
    _DWORD* v29; // edx
    int v30; // ecx
    float v31; // ecx
    float* v32; // eax
    double v33; // st7
    _DWORD* v34; // esi
    int v35; // [esp+0h] [ebp-D4h]
    int v36; // [esp+0h] [ebp-D4h]
    int v37; // [esp+0h] [ebp-D4h]
    int v38; // [esp+0h] [ebp-D4h]
    int v39; // [esp+0h] [ebp-D4h]
    int v40; // [esp+0h] [ebp-D4h]
    int v41; // [esp+0h] [ebp-D4h]
    int v42; // [esp+0h] [ebp-D4h]
    int v43; // [esp+0h] [ebp-D4h]
    int v44; // [esp+0h] [ebp-D4h]
    int v45; // [esp+0h] [ebp-D4h]
    int v46; // [esp+0h] [ebp-D4h]
    int v47; // [esp+0h] [ebp-D4h]
    int v48; // [esp+0h] [ebp-D4h]
    int v49; // [esp+0h] [ebp-D4h]
    int v50; // [esp+0h] [ebp-D4h]
    int v51; // [esp+0h] [ebp-D4h]
    int v52; // [esp+0h] [ebp-D4h]
    int v53; // [esp+0h] [ebp-D4h]
    int v54; // [esp+0h] [ebp-D4h]
    int v55; // [esp+0h] [ebp-D4h]
    int v56; // [esp+0h] [ebp-D4h]
    int v57; // [esp+0h] [ebp-D4h]
    int v58; // [esp+0h] [ebp-D4h]
    int v59; // [esp+0h] [ebp-D4h]
    int v60; // [esp+0h] [ebp-D4h]
    int v61; // [esp+0h] [ebp-D4h]
    int v62; // [esp+0h] [ebp-D4h]
    int v63; // [esp+4h] [ebp-D0h]
    int v64; // [esp+4h] [ebp-D0h]
    int v65; // [esp+4h] [ebp-D0h]
    int v66; // [esp+4h] [ebp-D0h]
    int v67; // [esp+4h] [ebp-D0h]
    int v68; // [esp+4h] [ebp-D0h]
    int v69; // [esp+4h] [ebp-D0h]
    int v70; // [esp+4h] [ebp-D0h]
    int v71; // [esp+4h] [ebp-D0h]
    int v72; // [esp+4h] [ebp-D0h]
    int v73; // [esp+4h] [ebp-D0h]
    int v74; // [esp+4h] [ebp-D0h]
    int v75; // [esp+4h] [ebp-D0h]
    int v76; // [esp+4h] [ebp-D0h]
    int v77; // [esp+4h] [ebp-D0h]
    int v78; // [esp+4h] [ebp-D0h]
    int v79; // [esp+4h] [ebp-D0h]
    int v80; // [esp+4h] [ebp-D0h]
    int v81; // [esp+4h] [ebp-D0h]
    int v82; // [esp+4h] [ebp-D0h]
    int v83; // [esp+4h] [ebp-D0h]
    int v84; // [esp+4h] [ebp-D0h]
    int v85; // [esp+4h] [ebp-D0h]
    int v86; // [esp+4h] [ebp-D0h]
    int v87; // [esp+4h] [ebp-D0h]
    int v88; // [esp+4h] [ebp-D0h]
    int v89; // [esp+4h] [ebp-D0h]
    int v90; // [esp+4h] [ebp-D0h]
    int v91; // [esp+8h] [ebp-CCh]
    int v92; // [esp+8h] [ebp-CCh]
    int v93; // [esp+8h] [ebp-CCh]
    int v94; // [esp+8h] [ebp-CCh]
    int v95; // [esp+8h] [ebp-CCh]
    int v96; // [esp+8h] [ebp-CCh]
    int v97; // [esp+8h] [ebp-CCh]
    int v98; // [esp+8h] [ebp-CCh]
    int v99; // [esp+8h] [ebp-CCh]
    int v100; // [esp+8h] [ebp-CCh]
    int v101; // [esp+8h] [ebp-CCh]
    int v102; // [esp+8h] [ebp-CCh]
    int v103; // [esp+8h] [ebp-CCh]
    int v104; // [esp+8h] [ebp-CCh]
    int v105; // [esp+8h] [ebp-CCh]
    int v106; // [esp+8h] [ebp-CCh]
    int v107; // [esp+8h] [ebp-CCh]
    int v108; // [esp+8h] [ebp-CCh]
    int v109; // [esp+8h] [ebp-CCh]
    int v110; // [esp+8h] [ebp-CCh]
    int v111; // [esp+8h] [ebp-CCh]
    int v112; // [esp+8h] [ebp-CCh]
    int v113; // [esp+8h] [ebp-CCh]
    int v114; // [esp+8h] [ebp-CCh]
    int v115; // [esp+8h] [ebp-CCh]
    int v116; // [esp+8h] [ebp-CCh]
    int v117; // [esp+8h] [ebp-CCh]
    int v118; // [esp+8h] [ebp-CCh]
    float v119; // [esp+8h] [ebp-CCh]
    float v120; // [esp+18h] [ebp-BCh]
    float v121; // [esp+1Ch] [ebp-B8h]
    float v122; // [esp+1Ch] [ebp-B8h]
    float v123; // [esp+20h] [ebp-B4h]
    float v124; // [esp+24h] [ebp-B0h]
    float v125; // [esp+28h] [ebp-ACh]
    float v126; // [esp+28h] [ebp-ACh]
    float v127; // [esp+2Ch] [ebp-A8h] BYREF
    float v128; // [esp+30h] [ebp-A4h]
    float v129; // [esp+34h] [ebp-A0h]
    float v130; // [esp+38h] [ebp-9Ch] BYREF
    float v131; // [esp+3Ch] [ebp-98h]
    float v132; // [esp+40h] [ebp-94h]
    float v133; // [esp+44h] [ebp-90h] BYREF
    float v134; // [esp+48h] [ebp-8Ch]
    float v135; // [esp+4Ch] [ebp-88h]
    float v136; // [esp+50h] [ebp-84h] BYREF
    float v137; // [esp+54h] [ebp-80h]
    float v138; // [esp+58h] [ebp-7Ch]
    float v139; // [esp+5Ch] [ebp-78h] BYREF
    float v140; // [esp+60h] [ebp-74h]
    float v141; // [esp+64h] [ebp-70h]
    float v142; // [esp+68h] [ebp-6Ch] BYREF
    float v143; // [esp+6Ch] [ebp-68h]
    float v144; // [esp+70h] [ebp-64h]
    float v145; // [esp+74h] [ebp-60h] BYREF
    float v146; // [esp+78h] [ebp-5Ch]
    float v147; // [esp+7Ch] [ebp-58h]
    int v148; // [esp+80h] [ebp-54h] BYREF
    float v149; // [esp+84h] [ebp-50h]
    float v150; // [esp+88h] [ebp-4Ch]
    float v151; // [esp+8Ch] [ebp-48h] BYREF
    float v152; // [esp+90h] [ebp-44h]
    float v153; // [esp+94h] [ebp-40h]
    float v154; // [esp+98h] [ebp-3Ch] BYREF
    float v155; // [esp+9Ch] [ebp-38h]
    float v156; // [esp+A0h] [ebp-34h]
    int v157; // [esp+A4h] [ebp-30h] BYREF
    float v158; // [esp+A8h] [ebp-2Ch]
    float v159; // [esp+ACh] [ebp-28h]
    float v160; // [esp+B0h] [ebp-24h] BYREF
    float v161; // [esp+B4h] [ebp-20h]
    int v162; // [esp+B8h] [ebp-1Ch]
    _DWORD v163[3]; // [esp+BCh] [ebp-18h] BYREF
    float v164[2]; // [esp+C8h] [ebp-Ch] BYREF

    v8 = *(float*)(this + 4288);
    if (v8 == 0.0)
        v9 = 0.0;
    else
        v9 = a2 / v8;
    v10 = 0;
    v11 = v9 * *(float*)(this + 20) + *(float*)(this + 16);
    *(float*)(this + 16) = v11;
    if (v11 <= 1.0)
        goto LABEL_9;
    v12 = *(float*)(this + 16);
    do
    {
        ++v10;
        v13 = v12 - 1.0;
        v12 = v13;
    } while (v13 > 1.0);
    *(float*)(this + 16) = v13;
    if (v10 <= 0)
        LABEL_9:
    sub_416F80((_DWORD*)this, 1);
    else
        sub_416EE0(this, v10);
    v120 = *(float*)(this + 16);
    v14 = v120 * v120;
    v124 = v14;
    v15 = v14 * v120;
    v123 = v15;
    v16 = v15 * v120;
    v121 = v16;
    v125 = v16 * v120;
    *(float*)&v91 = v120 * *(float*)(this + 104);
    *(float*)&v63 = v120 * *(float*)(this + 100);
    *(float*)&v35 = v120 * *(float*)(this + 96);
    sub_40F4A0(&v136, v35, v63, v91);
    *(float*)&v92 = v124 * *(float*)(this + 92);
    *(float*)&v64 = v124 * *(float*)(this + 88);
    *(float*)&v36 = v124 * *(float*)(this + 84);
    sub_40F4A0(&v154, v36, v64, v92);
    *(float*)&v93 = v123 * *(float*)(this + 80);
    *(float*)&v65 = v123 * *(float*)(this + 76);
    *(float*)&v37 = v123 * *(float*)(this + 72);
    sub_40F4A0(&v157, v37, v65, v93);
    *(float*)&v94 = v121 * *(float*)(this + 68);
    *(float*)&v66 = v121 * *(float*)(this + 64);
    *(float*)&v38 = v121 * *(float*)(this + 60);
    sub_40F4A0(&v130, v38, v66, v94);
    *(float*)&v95 = v125 * *(float*)(this + 56);
    *(float*)&v67 = v125 * *(float*)(this + 52);
    *(float*)&v39 = v125 * *(float*)(this + 48);
    sub_40F4A0(&v127, v39, v67, v95);
    *(float*)&v96 = v132 + v129;
    *(float*)&v68 = v131 + v128;
    *(float*)&v40 = v130 + v127;
    sub_40F4A0(&v151, v40, v68, v96);
    *(float*)&v97 = v159 + v153;
    *(float*)&v69 = v158 + v152;
    *(float*)&v41 = *(float*)&v157 + v151;
    sub_40F4A0(&v145, v41, v69, v97);
    *(float*)&v98 = v156 + v147;
    *(float*)&v70 = v155 + v146;
    *(float*)&v42 = v154 + v145;
    sub_40F4A0(&v139, v42, v70, v98);
    *(float*)&v99 = v138 + v141;
    *(float*)&v71 = v137 + v140;
    *(float*)&v43 = v136 + v139;
    sub_40F4A0(&v142, v43, v71, v99);
    *(float*)&v100 = v144 + *(float*)(this + 116);
    *(float*)&v72 = v143 + *(float*)(this + 112);
    *(float*)&v44 = v142 + *(float*)(this + 108);
    sub_40F4A0(v163, v44, v72, v100);
    *(float*)&v101 = v120 * *(float*)(this + 92);
    *(float*)&v73 = v120 * *(float*)(this + 88);
    *(float*)&v45 = v120 * *(float*)(this + 84);
    sub_40F4A0(&v142, v45, v73, v101);
    *(float*)&v102 = v144 + v144;
    *(float*)&v74 = v143 + v143;
    *(float*)&v46 = v142 + v142;
    sub_40F4A0(&v127, v46, v74, v102);
    *(float*)&v103 = v124 * *(float*)(this + 80);
    *(float*)&v75 = v124 * *(float*)(this + 76);
    *(float*)&v47 = v124 * *(float*)(this + 72);
    sub_40F4A0(&v139, v47, v75, v103);
    *(float*)&v104 = v141 * 3.0;
    *(float*)&v76 = v140 * 3.0;
    *(float*)&v48 = v139 * 3.0;
    sub_40F4A0(&v157, v48, v76, v104);
    *(float*)&v105 = v123 * *(float*)(this + 68);
    *(float*)&v77 = v123 * *(float*)(this + 64);
    *(float*)&v49 = v123 * *(float*)(this + 60);
    sub_40F4A0(&v136, v49, v77, v105);
    *(float*)&v106 = v138 * 4.0;
    *(float*)&v78 = v137 * 4.0;
    *(float*)&v50 = v136 * 4.0;
    sub_40F4A0(&v154, v50, v78, v106);
    *(float*)&v107 = v121 * *(float*)(this + 56);
    *(float*)&v79 = v121 * *(float*)(this + 52);
    *(float*)&v51 = v121 * *(float*)(this + 48);
    sub_40F4A0(&v145, v51, v79, v107);
    *(float*)&v108 = v147 * 5.0;
    *(float*)&v80 = v146 * 5.0;
    *(float*)&v52 = v145 * 5.0;
    sub_40F4A0(&v151, v52, v80, v108);
    *(float*)&v109 = v156 + v153;
    *(float*)&v81 = v155 + v152;
    *(float*)&v53 = v154 + v151;
    sub_40F4A0(&v130, v53, v81, v109);
    *(float*)&v110 = v159 + v132;
    *(float*)&v82 = v158 + v131;
    *(float*)&v54 = *(float*)&v157 + v130;
    sub_40F4A0(&v148, v54, v82, v110);
    *(float*)&v111 = v129 + v150;
    *(float*)&v83 = v128 + v149;
    *(float*)&v55 = v127 + *(float*)&v148;
    sub_40F4A0(&v133, v55, v83, v111);
    *(float*)&v112 = v135 + *(float*)(this + 104);
    *(float*)&v84 = v134 + *(float*)(this + 100);
    *(float*)&v56 = v133 + *(float*)(this + 96);
    sub_40F4A0(&v160, v56, v84, v112);
    *(float*)&v113 = *(float*)(this + 92) + *(float*)(this + 92);
    *(float*)&v85 = *(float*)(this + 88) + *(float*)(this + 88);
    *(float*)&v57 = *(float*)(this + 84) + *(float*)(this + 84);
    sub_40F4A0(&v142, v57, v85, v113);
    *(float*)&v114 = v120 * *(float*)(this + 80);
    *(float*)&v86 = v120 * *(float*)(this + 76);
    *(float*)&v58 = v120 * *(float*)(this + 72);
    sub_40F4A0(&v133, v58, v86, v114);
    *(float*)&v115 = v135 * 6.0;
    *(float*)&v87 = v134 * 6.0;
    *(float*)&v59 = v133 * 6.0;
    sub_40F4A0(&v139, v59, v87, v115);
    *(float*)&v116 = v124 * *(float*)(this + 68);
    *(float*)&v88 = v124 * *(float*)(this + 64);
    *(float*)&v60 = v124 * *(float*)(this + 60);
    sub_40F4A0(&v148, v60, v88, v116);
    *(float*)&v117 = v150 * 12.0;
    *(float*)&v89 = v149 * 12.0;
    *(float*)&v61 = *(float*)&v148 * 12.0;
    sub_40F4A0(&v136, v61, v89, v117);
    *(float*)&v118 = v123 * *(float*)(this + 56);
    *(float*)&v90 = v123 * *(float*)(this + 52);
    *(float*)&v62 = v123 * *(float*)(this + 48);
    sub_40F4A0(&v145, v62, v90, v118);
    v17 = sub_4162F0(&v145, (float*)&v157, 20.0);
    v18 = sub_4162C0(v17, &v151, &v136);
    v19 = sub_4162C0(v18, &v154, &v139);
    sub_4162C0(v19, v164, &v142);
    v20 = v163[0];
    v21 = v163[1];
    v22 = v163[2];
    *a3 = v163[0];
    a3[1] = v21;
    a3[2] = v22;
    *(_DWORD*)(this + 24) = v20;
    v23 = v160;
    *(_DWORD*)(this + 28) = v21;
    v24 = v161;
    *(_DWORD*)(this + 32) = v22;
    *(float*)a6 = v23;
    v25 = v162;
    *(float*)(a6 + 4) = v24;
    *(_DWORD*)(a6 + 8) = v25;
    if (*(float*)(this + 4288) == 0.0)
    {
        v26 = sub_40F4A0(&v133, 0, 0, 0);
        *(_DWORD*)a6 = *v26;
        *(_DWORD*)(a6 + 4) = v26[1];
        *(_DWORD*)(a6 + 8) = v26[2];
    }
    else
    {
        sub_416290((float*)a6, *(float*)(this + 4288));
    }
    v122 = sub_419640((float*)a6);
    *a7 = v122;
    if (v122 <= 0.1)
    {
        v34 = (_DWORD*)(this + 36);
        *a4 = *v34;
        a4[1] = v34[1];
        a4[2] = v34[2];
        *a5 = 0.0;
    }
    else
    {
        if (v122 == 0.0)
        {
            v28 = a4;
            v29 = a4;
            *a4 = *(_DWORD*)a6;
            a4[1] = *(_DWORD*)(a6 + 4);
            v30 = *(_DWORD*)(a6 + 8);
        }
        else
        {
            v27 = sub_416320((float*)a6, (float*)&v148, v122);
            v28 = a4;
            v29 = a4;
            *a4 = *(_DWORD*)v27;
            a4[1] = *((_DWORD*)v27 + 1);
            v30 = *((_DWORD*)v27 + 2);
        }
        v29[2] = v30;
        *(_DWORD*)(this + 36) = *v28;
        *(_DWORD*)(this + 40) = v28[1];
        v31 = v160;
        *(_DWORD*)(this + 44) = v28[2];
        v127 = v31;
        v128 = v161;
        v129 = 0.0;
        sub_46B970(&v127, &v127);
        v130 = v164[0];
        v131 = v164[1];
        v132 = 0.0;
        v119 = sub_419670(&v127, &v130);
        v32 = sub_4162F0(&v127, (float*)&v148, v119);
        sub_416260(&v130, v32);
        v126 = *(float*)(this + 4288);
        if (v126 == 0.0)
            v33 = 0.0;
        else
            v33 = sub_419640(&v130) / v126;
        *a5 = v33;
        *a5 = v33 / (*a7 * 0.66666669);
        sub_419690(&v133, &v127, &v130);
        if (v135 >= 0.0)
            *a5 = *a5 * -1.0;
    }
}
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);

//----- (00416260) --------------------------------------------------------
float* __thiscall sub_416260(float* this, float* a2)
{
    float* result; // eax

    result = this;
    *this = *this - *a2;
    this[1] = this[1] - a2[1];
    this[2] = this[2] - a2[2];
    return result;
}

//----- (00416290) --------------------------------------------------------
float* __thiscall sub_416290(float* this, float a2)
{
    double v2; // st7
    float* result; // eax

    v2 = 1.0 / a2;
    result = this;
    *this = v2 * *this;
    this[1] = v2 * this[1];
    this[2] = v2 * this[2];
    return result;
}

//----- (004162C0) --------------------------------------------------------
float* __thiscall sub_4162C0(float* this, float* a2, float* a3)
{
    double v3; // st7
    double v4; // st6
    float* result; // eax

    v3 = a3[2] + this[2];
    v4 = a3[1] + this[1];
    result = a2;
    *a2 = *a3 + *this;
    a2[1] = v4;
    a2[2] = v3;
    return result;
}

//----- (004162F0) --------------------------------------------------------
float* __thiscall sub_4162F0(float* this, float* a2, float a3)
{
    double v3; // st7
    double v4; // st6
    float* result; // eax

    v3 = a3 * this[2];
    v4 = a3 * this[1];
    result = a2;
    *a2 = a3 * *this;
    a2[1] = v4;
    a2[2] = v3;
    return result;
}

//----- (00416320) --------------------------------------------------------
float* __thiscall sub_416320(float* this, float* a2, float a3)
{
    double v3; // st7
    float* result; // eax
    double v5; // st7
    double v6; // st6
    float v7; // [esp+8h] [ebp+8h]

    v3 = 1.0 / a3;
    result = a2;
    v7 = v3;
    v5 = v3 * this[2];
    v6 = v7 * this[1];
    *a2 = v7 * *this;
    a2[1] = v6;
    a2[2] = v5;
    return result;
}

//----- (00416350) --------------------------------------------------------
char __thiscall sub_416350(int this, _DWORD* a2, char a3)
{
    char result; // al
    _BYTE* v5; // eax
    _DWORD* v6; // eax
    int v7; // edx
    int v8; // eax
    _DWORD* v9; // ecx

    if (*(int*)(this + 4132) >= 200)
        return 0;
    if (!a3 || *(_BYTE*)(this + 4148) || (result = sub_4153B0(*(_DWORD**)(dword_520970 + 244), (int)a2)) != 0)
    {
        v5 = (_BYTE*)(this + 20 * *(_DWORD*)(this + 4132) + 132);
        ++*v5;
        v6 = (_DWORD*)(this + 20 * *(_DWORD*)(this + 4132) + 136);
        *v6 = *a2;
        v6[1] = a2[1];
        v6[2] = a2[2];
        *(_DWORD*)(this + 20 * *(_DWORD*)(this + 4132) + 148) = 0;
        v7 = *(_DWORD*)(this + 4132) + 1;
        *(_DWORD*)(this + 4132) = v7;
        if (a3 && *(_BYTE*)(this + 4148) && v7 >= 6 && !sub_415430(*(_DWORD**)(dword_520970 + 244), this))
        {
            v8 = *(_DWORD*)(this + 4132) - 1;
            *(_DWORD*)(this + 4132) = v8;
            *(_DWORD*)(this + 20 * v8 + 148) += *(_DWORD*)(this + 4280) / 2;
            v9 = (_DWORD*)(this + 20 * *(_DWORD*)(this + 4132) + 128);
            result = 0;
            *v9 += *(_DWORD*)(this + 4280) / 2;
        }
        else
        {
            *(_BYTE*)(this + 12) = 1;
            sub_4164D0((float*)this);
            if (*(_DWORD*)(this + 4132) == 6)
                sub_416570((float*)this);
            return 1;
        }
    }
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (004164A0) --------------------------------------------------------
void __thiscall sub_4164A0(int this, int a2)
{
    int v2; // edx
    int v3; // eax

    v2 = *(_DWORD*)(this + 4136);
    *(_DWORD*)(this + 4132) = a2;
    v3 = v2 + a2;
    if (*(_DWORD*)(this + 4140) < v2 + a2)
        v3 = *(_DWORD*)(this + 4140);
    *(_DWORD*)(this + 4140) = v3;
    sub_4164D0((float*)this);
}

//----- (004164D0) --------------------------------------------------------
void __thiscall sub_4164D0(float* this)
{
    int v2; // eax
    int v3; // eax
    double v4; // st7
    double v5; // st6
    double v6; // st7
    float v7; // ecx
    float v8; // edx
    float* v9; // esi
    float v10; // [esp+4h] [ebp-Ch] BYREF
    float v11; // [esp+8h] [ebp-8h]
    float v12; // [esp+Ch] [ebp-4h]

    v2 = *((_DWORD*)this + 1033);
    if (v2 > 1)
    {
        v3 = 5 * v2;
        v4 = this[v3 + 30] - this[v3 + 25];
        v5 = this[v3 + 29] - this[v3 + 24];
        v12 = 0.0;
        v10 = v5;
        v11 = v4;
        sub_46B970(&v10, &v10);
        v6 = v10 * v10 + v11 * v11 + v12 * v12;
        if (v6 >= 0.0000099999997 || v6 <= -0.0000099999997)
        {
            v7 = v11;
            v8 = v12;
            v9 = this + 30;
            *v9 = v10;
            v9[1] = v7;
            v9[2] = v8;
        }
    }
}
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);

//----- (00416570) --------------------------------------------------------
int __thiscall sub_416570(float* this)
{
    float* v1; // esi
    float v2; // edx
    float v3; // ecx
    float v4; // ecx
    float v5; // eax
    float* v6; // eax
    float* v7; // eax
    float* v8; // eax
    float* v9; // eax
    float* v10; // eax
    float* v11; // eax
    float* v12; // eax
    float* v13; // eax
    float* v14; // eax
    float* v15; // eax
    float* v16; // eax
    float* v17; // eax
    float* v18; // eax
    float* v19; // eax
    float* v20; // eax
    float* v21; // eax
    float* v22; // eax
    float* v23; // eax
    float* v24; // eax
    float* v25; // eax
    float* v26; // eax
    float* v27; // eax
    float* v28; // eax
    float* v29; // eax
    int result; // eax
    float* v31; // [esp-20h] [ebp-CCh]
    float* v32; // [esp-20h] [ebp-CCh]
    float* v33; // [esp-20h] [ebp-CCh]
    float* v34; // [esp-18h] [ebp-C4h]
    float* v35; // [esp-18h] [ebp-C4h]
    float* v36; // [esp-18h] [ebp-C4h]
    float* v37; // [esp-10h] [ebp-BCh]
    float* v38; // [esp-10h] [ebp-BCh]
    float* v39; // [esp-10h] [ebp-BCh]
    float* v40; // [esp-8h] [ebp-B4h]
    float* v41; // [esp-8h] [ebp-B4h]
    float* v42; // [esp-8h] [ebp-B4h]
    int v43; // [esp+0h] [ebp-ACh]
    int v44; // [esp+0h] [ebp-ACh]
    int v45; // [esp+0h] [ebp-ACh]
    int v46; // [esp+0h] [ebp-ACh]
    int v47; // [esp+0h] [ebp-ACh]
    int v48; // [esp+0h] [ebp-ACh]
    int v49; // [esp+0h] [ebp-ACh]
    int v50; // [esp+0h] [ebp-ACh]
    int v51; // [esp+0h] [ebp-ACh]
    int v52; // [esp+0h] [ebp-ACh]
    int v53; // [esp+0h] [ebp-ACh]
    int v54; // [esp+0h] [ebp-ACh]
    int v55; // [esp+0h] [ebp-ACh]
    int v56; // [esp+0h] [ebp-ACh]
    int v57; // [esp+0h] [ebp-ACh]
    int v58; // [esp+0h] [ebp-ACh]
    int v59; // [esp+0h] [ebp-ACh]
    int v60; // [esp+0h] [ebp-ACh]
    int v61; // [esp+0h] [ebp-ACh]
    int v62; // [esp+0h] [ebp-ACh]
    int v63; // [esp+0h] [ebp-ACh]
    int v64; // [esp+0h] [ebp-ACh]
    int v65; // [esp+0h] [ebp-ACh]
    int v66; // [esp+0h] [ebp-ACh]
    int v67; // [esp+0h] [ebp-ACh]
    int v68; // [esp+0h] [ebp-ACh]
    int v69; // [esp+0h] [ebp-ACh]
    int v70; // [esp+0h] [ebp-ACh]
    int v71; // [esp+0h] [ebp-ACh]
    int v72; // [esp+0h] [ebp-ACh]
    float* v73; // [esp+0h] [ebp-ACh]
    float* v74; // [esp+0h] [ebp-ACh]
    float* v75; // [esp+0h] [ebp-ACh]
    int v76; // [esp+4h] [ebp-A8h]
    int v77; // [esp+4h] [ebp-A8h]
    int v78; // [esp+4h] [ebp-A8h]
    int v79; // [esp+4h] [ebp-A8h]
    int v80; // [esp+4h] [ebp-A8h]
    int v81; // [esp+4h] [ebp-A8h]
    int v82; // [esp+4h] [ebp-A8h]
    int v83; // [esp+4h] [ebp-A8h]
    int v84; // [esp+4h] [ebp-A8h]
    int v85; // [esp+4h] [ebp-A8h]
    int v86; // [esp+4h] [ebp-A8h]
    int v87; // [esp+4h] [ebp-A8h]
    int v88; // [esp+4h] [ebp-A8h]
    int v89; // [esp+4h] [ebp-A8h]
    int v90; // [esp+4h] [ebp-A8h]
    int v91; // [esp+4h] [ebp-A8h]
    int v92; // [esp+4h] [ebp-A8h]
    int v93; // [esp+4h] [ebp-A8h]
    int v94; // [esp+4h] [ebp-A8h]
    int v95; // [esp+4h] [ebp-A8h]
    int v96; // [esp+4h] [ebp-A8h]
    int v97; // [esp+4h] [ebp-A8h]
    int v98; // [esp+4h] [ebp-A8h]
    int v99; // [esp+4h] [ebp-A8h]
    int v100; // [esp+4h] [ebp-A8h]
    int v101; // [esp+4h] [ebp-A8h]
    int v102; // [esp+4h] [ebp-A8h]
    int v103; // [esp+4h] [ebp-A8h]
    int v104; // [esp+4h] [ebp-A8h]
    int v105; // [esp+4h] [ebp-A8h]
    int v106; // [esp+8h] [ebp-A4h]
    int v107; // [esp+8h] [ebp-A4h]
    int v108; // [esp+8h] [ebp-A4h]
    int v109; // [esp+8h] [ebp-A4h]
    int v110; // [esp+8h] [ebp-A4h]
    int v111; // [esp+8h] [ebp-A4h]
    int v112; // [esp+8h] [ebp-A4h]
    int v113; // [esp+8h] [ebp-A4h]
    int v114; // [esp+8h] [ebp-A4h]
    int v115; // [esp+8h] [ebp-A4h]
    int v116; // [esp+8h] [ebp-A4h]
    int v117; // [esp+8h] [ebp-A4h]
    int v118; // [esp+8h] [ebp-A4h]
    int v119; // [esp+8h] [ebp-A4h]
    int v120; // [esp+8h] [ebp-A4h]
    int v121; // [esp+8h] [ebp-A4h]
    int v122; // [esp+8h] [ebp-A4h]
    int v123; // [esp+8h] [ebp-A4h]
    int v124; // [esp+8h] [ebp-A4h]
    int v125; // [esp+8h] [ebp-A4h]
    int v126; // [esp+8h] [ebp-A4h]
    int v127; // [esp+8h] [ebp-A4h]
    int v128; // [esp+8h] [ebp-A4h]
    int v129; // [esp+8h] [ebp-A4h]
    int v130; // [esp+8h] [ebp-A4h]
    int v131; // [esp+8h] [ebp-A4h]
    int v132; // [esp+8h] [ebp-A4h]
    int v133; // [esp+8h] [ebp-A4h]
    int v134; // [esp+8h] [ebp-A4h]
    int v135; // [esp+8h] [ebp-A4h]
    float v136; // [esp+1Ch] [ebp-90h] BYREF
    float v137; // [esp+20h] [ebp-8Ch]
    float v138; // [esp+24h] [ebp-88h]
    int v139; // [esp+28h] [ebp-84h] BYREF
    float v140; // [esp+2Ch] [ebp-80h]
    float v141; // [esp+30h] [ebp-7Ch]
    int v142; // [esp+34h] [ebp-78h] BYREF
    float v143; // [esp+38h] [ebp-74h]
    float v144; // [esp+3Ch] [ebp-70h]
    float v145; // [esp+40h] [ebp-6Ch] BYREF
    float v146; // [esp+44h] [ebp-68h]
    float v147; // [esp+48h] [ebp-64h]
    int v148; // [esp+4Ch] [ebp-60h] BYREF
    float v149; // [esp+50h] [ebp-5Ch]
    float v150; // [esp+54h] [ebp-58h]
    int v151; // [esp+58h] [ebp-54h] BYREF
    float v152; // [esp+5Ch] [ebp-50h]
    float v153; // [esp+60h] [ebp-4Ch]
    float v154; // [esp+64h] [ebp-48h] BYREF
    float v155; // [esp+68h] [ebp-44h]
    float v156; // [esp+6Ch] [ebp-40h]
    int v157; // [esp+70h] [ebp-3Ch] BYREF
    float v158; // [esp+74h] [ebp-38h]
    float v159; // [esp+78h] [ebp-34h]
    float v160; // [esp+7Ch] [ebp-30h] BYREF
    float v161; // [esp+80h] [ebp-2Ch]
    float v162; // [esp+84h] [ebp-28h]
    int v163; // [esp+88h] [ebp-24h] BYREF
    float v164; // [esp+8Ch] [ebp-20h]
    float v165; // [esp+90h] [ebp-1Ch]
    int v166; // [esp+94h] [ebp-18h] BYREF
    float v167; // [esp+98h] [ebp-14h]
    float v168; // [esp+9Ch] [ebp-10h]
    float v169; // [esp+A0h] [ebp-Ch] BYREF
    float v170; // [esp+A4h] [ebp-8h]
    float v171; // [esp+A8h] [ebp-4h]

    v1 = this;
    *(float*)&v106 = this[61] + this[61];
    *(float*)&v76 = this[60] + this[60];
    *(float*)&v43 = this[59] + this[59];
    sub_40F4A0(&v139, v43, v76, v106);
    *(float*)&v107 = v1[56] * -10.0;
    *(float*)&v77 = v1[55] * -10.0;
    *(float*)&v44 = v1[54] * -10.0;
    sub_40F4A0(&v142, v44, v77, v107);
    *(float*)&v108 = v1[51] * 20.0;
    *(float*)&v78 = v1[50] * 20.0;
    *(float*)&v45 = v1[49] * 20.0;
    sub_40F4A0(&v157, v45, v78, v108);
    *(float*)&v109 = v1[46] * -20.0;
    *(float*)&v79 = v1[45] * -20.0;
    *(float*)&v46 = v1[44] * -20.0;
    sub_40F4A0(&v163, v46, v79, v109);
    *(float*)&v110 = v1[41] * 10.0;
    *(float*)&v80 = v1[40] * 10.0;
    *(float*)&v47 = v1[39] * 10.0;
    sub_40F4A0(&v166, v47, v80, v110);
    *(float*)&v111 = v1[36] * -2.0;
    *(float*)&v81 = v1[35] * -2.0;
    *(float*)&v48 = v1[34] * -2.0;
    sub_40F4A0(&v169, v48, v81, v111);
    *(float*)&v112 = v168 + v171;
    *(float*)&v82 = v167 + v170;
    *(float*)&v49 = *(float*)&v166 + v169;
    sub_40F4A0(&v160, v49, v82, v112);
    *(float*)&v113 = v165 + v162;
    *(float*)&v83 = v164 + v161;
    *(float*)&v50 = *(float*)&v163 + v160;
    sub_40F4A0(&v154, v50, v83, v113);
    *(float*)&v114 = v159 + v156;
    *(float*)&v84 = v158 + v155;
    *(float*)&v51 = *(float*)&v157 + v154;
    sub_40F4A0(&v136, v51, v84, v114);
    *(float*)&v115 = v144 + v138;
    *(float*)&v85 = v143 + v137;
    *(float*)&v52 = *(float*)&v142 + v136;
    sub_40F4A0(&v145, v52, v85, v115);
    *(float*)&v116 = v141 + v147;
    *(float*)&v86 = v140 + v146;
    *(float*)&v53 = *(float*)&v139 + v145;
    sub_40F4A0(&v151, v53, v86, v116);
    *(float*)&v117 = v153 * 0.0041666669;
    *(float*)&v87 = v152 * 0.0041666669;
    *(float*)&v54 = *(float*)&v151 * 0.0041666669;
    sub_40F4A0(&v148, v54, v87, v117);
    v2 = v149;
    v1[12] = *(float*)&v148;
    v3 = v150;
    v1[13] = v2;
    v1[14] = v3;
    sub_40F4A0(&v160, 0, 0, 0);
    *(float*)&v118 = v1[56] * 10.0;
    *(float*)&v88 = v1[55] * 10.0;
    *(float*)&v55 = v1[54] * 10.0;
    sub_40F4A0(&v154, v55, v88, v118);
    *(float*)&v119 = v1[51] * -40.0;
    *(float*)&v89 = v1[50] * -40.0;
    *(float*)&v56 = v1[49] * -40.0;
    sub_40F4A0(&v136, v56, v89, v119);
    *(float*)&v120 = v1[46] * 60.0;
    *(float*)&v90 = v1[45] * 60.0;
    *(float*)&v57 = v1[44] * 60.0;
    sub_40F4A0(&v145, v57, v90, v120);
    *(float*)&v121 = v1[41] * -40.0;
    *(float*)&v91 = v1[40] * -40.0;
    *(float*)&v58 = v1[39] * -40.0;
    sub_40F4A0(&v148, v58, v91, v121);
    *(float*)&v122 = v1[36] * 10.0;
    *(float*)&v92 = v1[35] * 10.0;
    *(float*)&v59 = v1[34] * 10.0;
    sub_40F4A0(&v151, v59, v92, v122);
    *(float*)&v123 = v150 + v153;
    *(float*)&v93 = v149 + v152;
    *(float*)&v60 = *(float*)&v148 + *(float*)&v151;
    sub_40F4A0(&v139, v60, v93, v123);
    *(float*)&v124 = v147 + v141;
    *(float*)&v94 = v146 + v140;
    *(float*)&v61 = v145 + *(float*)&v139;
    sub_40F4A0(&v142, v61, v94, v124);
    *(float*)&v125 = v138 + v144;
    *(float*)&v95 = v137 + v143;
    *(float*)&v62 = v136 + *(float*)&v142;
    sub_40F4A0(&v157, v62, v95, v125);
    *(float*)&v126 = v156 + v159;
    *(float*)&v96 = v155 + v158;
    *(float*)&v63 = v154 + *(float*)&v157;
    sub_40F4A0(&v163, v63, v96, v126);
    *(float*)&v127 = v162 + v165;
    *(float*)&v97 = v161 + v164;
    *(float*)&v64 = v160 + *(float*)&v163;
    sub_40F4A0(&v169, v64, v97, v127);
    *(float*)&v128 = v171 * 0.0041666669;
    *(float*)&v98 = v170 * 0.0041666669;
    *(float*)&v65 = v169 * 0.0041666669;
    sub_40F4A0(&v166, v65, v98, v128);
    v4 = v167;
    v1[15] = *(float*)&v166;
    v5 = v168;
    v1[16] = v4;
    v1[17] = v5;
    sub_40F4A0(&v154, 0, 0, 0);
    *(float*)&v129 = v1[56] * 20.0;
    *(float*)&v99 = v1[55] * 20.0;
    *(float*)&v66 = v1[54] * 20.0;
    sub_40F4A0(&v157, v66, v99, v129);
    *(float*)&v130 = v1[51] * -40.0;
    *(float*)&v100 = v1[50] * -40.0;
    *(float*)&v67 = v1[49] * -40.0;
    sub_40F4A0(&v136, v67, v100, v130);
    sub_40F4A0(&v145, 0, 0, 0);
    *(float*)&v131 = v1[41] * 40.0;
    *(float*)&v101 = v1[40] * 40.0;
    *(float*)&v68 = v1[39] * 40.0;
    sub_40F4A0(&v148, v68, v101, v131);
    *(float*)&v132 = v1[36] * -20.0;
    *(float*)&v102 = v1[35] * -20.0;
    *(float*)&v69 = v1[34] * -20.0;
    sub_40F4A0(&v151, v69, v102, v132);
    *(float*)&v133 = v150 + v153;
    *(float*)&v103 = v149 + v152;
    *(float*)&v70 = *(float*)&v148 + *(float*)&v151;
    sub_40F4A0(&v139, v70, v103, v133);
    *(float*)&v134 = v147 + v141;
    *(float*)&v104 = v146 + v140;
    *(float*)&v71 = v145 + *(float*)&v139;
    sub_40F4A0(&v142, v71, v104, v134);
    *(float*)&v135 = v138 + v144;
    *(float*)&v105 = v137 + v143;
    *(float*)&v72 = v136 + *(float*)&v142;
    sub_40F4A0(&v160, v72, v105, v135);
    v6 = sub_4162C0(&v160, (float*)&v166, (float*)&v157);
    v7 = sub_4162C0(v6, &v169, &v154);
    v8 = sub_4162F0(v7, (float*)&v163, 0.0041666669);
    v1[18] = *v8;
    v1[19] = v8[1];
    v1[20] = v8[2];
    v73 = sub_4162F0(v1 + 59, (float*)&v151, 0.0);
    v40 = sub_4162F0(v1 + 54, (float*)&v139, 20.0);
    v37 = sub_4162F0(v1 + 49, (float*)&v142, 40.0);
    v34 = sub_4162F0(v1 + 44, (float*)&v157, -120.0);
    v31 = sub_4162F0(v1 + 39, (float*)&v163, 40.0);
    v9 = sub_4162F0(v1 + 34, (float*)&v166, 20.0);
    v10 = sub_4162C0(v9, &v169, v31);
    v11 = sub_4162C0(v10, &v160, v34);
    v12 = sub_4162C0(v11, &v154, v37);
    v13 = sub_4162C0(v12, &v136, v40);
    v14 = sub_4162C0(v13, &v145, v73);
    v15 = sub_4162F0(v14, (float*)&v148, 0.0041666669);
    v1[21] = *v15;
    v1[22] = v15[1];
    v1[23] = v15[2];
    v74 = sub_4162F0(v1 + 59, (float*)&v151, 0.0);
    v41 = sub_4162F0(v1 + 54, (float*)&v139, 10.0);
    v38 = sub_4162F0(v1 + 49, (float*)&v142, 100.0);
    v35 = sub_4162F0(v1 + 44, (float*)&v157, 0.0);
    v32 = sub_4162F0(v1 + 39, (float*)&v163, -100.0);
    v16 = sub_4162F0(v1 + 34, (float*)&v166, -10.0);
    v17 = sub_4162C0(v16, &v169, v32);
    v18 = sub_4162C0(v17, &v160, v35);
    v19 = sub_4162C0(v18, &v154, v38);
    v20 = sub_4162C0(v19, &v136, v41);
    v21 = sub_4162C0(v20, &v145, v74);
    v22 = sub_4162F0(v21, (float*)&v148, 0.0041666669);
    v1[24] = *v22;
    v1[25] = v22[1];
    v1[26] = v22[2];
    v75 = sub_4162F0(v1 + 59, (float*)&v151, 0.0);
    v42 = sub_4162F0(v1 + 54, (float*)&v139, 2.0);
    v39 = sub_4162F0(v1 + 49, (float*)&v142, 52.0);
    v36 = sub_4162F0(v1 + 44, (float*)&v157, 132.0);
    v33 = sub_4162F0(v1 + 39, (float*)&v163, 52.0);
    v23 = sub_4162F0(v1 + 34, (float*)&v166, 2.0);
    v24 = sub_4162C0(v23, &v169, v33);
    v25 = sub_4162C0(v24, &v160, v36);
    v26 = sub_4162C0(v25, &v154, v39);
    v27 = sub_4162C0(v26, &v136, v42);
    v28 = sub_4162C0(v27, &v145, v75);
    v29 = sub_4162F0(v28, (float*)&v148, 0.0041666669);
    v1 += 27;
    *v1 = *v29;
    v1[1] = v29[1];
    result = *((_DWORD*)v29 + 2);
    *((_DWORD*)v1 + 2) = result;
    return result;
}

//----- (00416EE0) --------------------------------------------------------
int __thiscall sub_416EE0(int this, int a2)
{
    int result; // eax
    int v4; // edi

    result = a2;
    if (a2 > 0)
    {
        v4 = *(_DWORD*)(this + 4136);
        *(_DWORD*)(this + 4132) -= a2;
        *(_BYTE*)(this + 12) = 1;
        *(_DWORD*)(this + 4136) = a2 + v4;
        memcpy((void*)(this + 132), (const void*)(20 * a2 + this + 132), 4000 - 20 * a2);
        memset((void*)(this - 20 * a2 + 4132), 0, 20 * a2);
        sub_416F80((_DWORD*)this, 1);
        result = *(_DWORD*)(this + 4132);
        if (result >= 6)
            return sub_416570((float*)this);
    }
    return result;
}

//----- (00416F80) --------------------------------------------------------
char __thiscall sub_416F80(_DWORD* this, char a2)
{
    int v4; // edi
    bool v5; // zf
    int v6; // edi
    int v7; // ecx
    unsigned __int8(__cdecl * v8)(_DWORD); // eax
    _DWORD* i; // eax
    int v10; // eax
    int v11; // edx
    int v12; // eax
    int v14; // edi
    _DWORD* v15; // ecx
    _DWORD* v16; // esi
    int v17; // [esp+14h] [ebp+4h]

    v4 = a2 != 0 ? 10 : 1000;
    v5 = a2 == 0;
    v17 = v4;
    if (!v5 && (int)this[1033] < 6)
    {
        sub_4164A0((int)this, 0);
        v6 = 6;
        do
        {
            sub_416350((int)this, this + 6, 0);
            --v6;
        } while (v6);
        v4 = v17;
        this[30] = this[9];
        this[31] = this[10];
        this[32] = this[11];
    }
    v7 = this[1033];
    if (v7 >= this[1069])
        return 1;
    while (--v4 > 0)
    {
        v8 = (unsigned __int8(__cdecl*)(_DWORD))this[2];
        if (v8)
        {
            if (!v8(this[1]))
            {
                for (i = &this[5 * this[1033] + 32]; ; i = &this[5 * this[1033] + 32])
                {
                    ++*i;
                    if ((int)this[1033] <= 8)
                    {
                        v10 = sub_417160(this);
                        v11 = 3 * this[1070];
                    }
                    else
                    {
                        v10 = sub_417160(this);
                        v11 = this[1070];
                    }
                    if (v10 <= v11)
                        break;
                    v12 = this[1033];
                    if (v12 <= 6)
                    {
                        if (a2)
                        {
                            sub_4164A0((int)this, 0);
                            v14 = 6;
                            do
                            {
                                sub_416350((int)this, this + 6, 0);
                                --v14;
                            } while (v14);
                            v15 = this + 9;
                            v16 = this + 30;
                            *v16 = *v15;
                            v16[1] = v15[1];
                            v16[2] = v15[2];
                        }
                        return 0;
                    }
                    sub_4164A0((int)this, v12 - 1);
                }
            }
        }
        else
        {
            this[1033] = v7 + 1;
            LOBYTE(this[5 * v7 + 33]) = 0;
            sub_417260((float*)this);
        }
        v7 = this[1033];
        if (v7 >= this[1069])
            return 1;
    }
    return 0;
}
// 41707E: conditional instruction was optimized away because eax.4<7
// 417082: conditional instruction was optimized away because bl.1==0

//----- (00417120) --------------------------------------------------------
int __thiscall sub_417120(void* this, int a2)
{
    return (int)this + 20 * a2 + 136;
}

//----- (00417140) --------------------------------------------------------
int __thiscall sub_417140(_DWORD* this, int a2)
{
    return sub_417120(this, this[1033] - a2 - 1);
}

//----- (00417160) --------------------------------------------------------
int __thiscall sub_417160(_DWORD* this)
{
    return this[5 * this[1033] + 32];
}

//----- (00417180) --------------------------------------------------------
char* __thiscall sub_417180(char* this)
{
    return this + 120;
}

//----- (00417190) --------------------------------------------------------
char __thiscall sub_417190(int this, int a2, _DWORD* a3, unsigned __int8 a4)
{
    signed int v5; // ecx
    int v6; // eax
    char v7; // bl
    int v8; // eax
    _BYTE* v9; // edi
    int v10; // edx

    v5 = a2 - *(_DWORD*)(this + 4136);
    if ((unsigned int)v5 >= 0xC8)
        return 0;
    v6 = this + 20 * v5;
    if (a4 < *(_BYTE*)(v6 + 132))
        return 0;
    *(_BYTE*)(v6 + 132) = a4;
    *(_DWORD*)(v6 + 136) = *a3;
    *(_DWORD*)(v6 + 140) = a3[1];
    v7 = 0;
    *(_DWORD*)(v6 + 144) = a3[2];
    *(_DWORD*)(v6 + 148) = 0;
    v8 = *(_DWORD*)(this + 4132);
    if (v8 <= v5)
    {
        if (v8 < v5)
        {
            v9 = (_BYTE*)(this + 20 * v8 + 132);
            v10 = v5 - v8;
            do
            {
                *v9 = 0;
                v9 += 20;
                --v10;
            } while (v10);
        }
        *(_DWORD*)(this + 4132) = v5 + 1;
    }
    if (v8 < 6 && *(int*)(this + 4132) >= 6 && !*(_DWORD*)(this + 4136))
        v7 = 1;
    sub_417260((float*)this);
    if (*(int*)(this + 4132) >= 6)
        sub_416570((float*)this);
    return v7;
}

//----- (00417260) --------------------------------------------------------
void __thiscall sub_417260(float* this)
{
    int v1; // edi
    int v2; // ebx
    float* i; // ebp
    _BYTE* v4; // eax
    int v5; // edx
    int v6; // esi
    float* v7; // ebx
    double v8; // st7
    double v9; // st7
    float* v10; // eax
    float* v11; // edx
    double v12; // st7
    float v13; // eax
    double v14; // st7
    int v15; // eax
    float* v16; // esi
    double v17; // st7
    double v18; // st6
    double v19; // st7
    double v20; // st7
    int v21; // eax
    float* v22; // edx
    double v23; // st7
    double v24; // st6
    double v25; // st7
    int v26; // [esp+8h] [ebp-A4h]
    int v27; // [esp+8h] [ebp-A4h]
    int v28; // [esp+Ch] [ebp-A0h]
    float v29; // [esp+10h] [ebp-9Ch]
    float v30; // [esp+14h] [ebp-98h]
    float v31; // [esp+1Ch] [ebp-90h]
    float v32; // [esp+20h] [ebp-8Ch]
    float v33; // [esp+28h] [ebp-84h]
    float v34; // [esp+2Ch] [ebp-80h]
    float v35; // [esp+30h] [ebp-7Ch]
    float v36; // [esp+34h] [ebp-78h]
    float v37; // [esp+38h] [ebp-74h]
    float v38; // [esp+3Ch] [ebp-70h]
    float v39; // [esp+40h] [ebp-6Ch]
    float v40; // [esp+44h] [ebp-68h]
    float v41; // [esp+48h] [ebp-64h]
    float v42; // [esp+58h] [ebp-54h]
    float v43; // [esp+5Ch] [ebp-50h]
    float v44; // [esp+60h] [ebp-4Ch]
    float v45; // [esp+70h] [ebp-3Ch]
    float v46; // [esp+74h] [ebp-38h]
    float v47; // [esp+78h] [ebp-34h]
    float v48; // [esp+7Ch] [ebp-30h]
    float v49; // [esp+80h] [ebp-2Ch]
    float v50; // [esp+84h] [ebp-28h]
    float v51; // [esp+88h] [ebp-24h]
    float v52; // [esp+8Ch] [ebp-20h]
    float v53; // [esp+94h] [ebp-18h]
    float v54; // [esp+98h] [ebp-14h]
    float v55; // [esp+A0h] [ebp-Ch]
    float v56; // [esp+A4h] [ebp-8h]

    v1 = *((_DWORD*)this + 1033);
    v2 = 0;
    v26 = 0;
    if (v1 > 0)
    {
        for (i = this + 34; ; i += 5)
        {
            v4 = i + 4;
            if (!*((_BYTE*)i - 4))
                break;
        LABEL_41:
            v1 = *((_DWORD*)this + 1033);
            v26 = ++v2;
            if (v2 >= v1)
                return;
        }
        v5 = v2 + 1;
        v6 = v2 - 1;
        v28 = v2 - 1;
        if (v2 - 1 >= 0)
        {
            v7 = i - 6;
            do
            {
                if (*(_BYTE*)v7)
                    break;
                --v6;
                v7 -= 5;
            } while (v6 >= 0);
            v2 = v26;
            v28 = v6;
        }
        v27 = v5;
        if (v5 < v1)
        {
            do
            {
                if (*v4)
                    break;
                ++v5;
                v4 += 20;
            } while (v5 < v1);
            v27 = v5;
        }
        if (v6 < 0)
        {
            if (v5 < v1)
            {
                v14 = 0.0;
                v15 = v5 + 1;
                v29 = 0.0;
                v30 = 0.0;
                if (v5 + 1 < v1)
                {
                    v16 = &this[5 * v15 + 33];
                    while (!*(_BYTE*)v16)
                    {
                        ++v15;
                        v16 += 5;
                        if (v15 >= v1)
                            goto LABEL_28;
                    }
                    if (v15 == v5)
                    {
                        v29 = 0.0;
                        v30 = 0.0;
                        v14 = 0.0;
                    }
                    else
                    {
                        v17 = 1.0 / ((double)v15 - (double)v27);
                        v33 = this[5 * v5 + 34] - this[5 * v15 + 34];
                        v29 = v17 * v33;
                        v34 = this[5 * v5 + 35] - this[5 * v15 + 35];
                        v30 = v34 * v17;
                        v35 = this[5 * v5 + 36] - this[5 * v15 + 36];
                        v14 = v17 * v35;
                    }
                }
            LABEL_28:
                v18 = (double)(v5 - v2);
                v53 = v18 * v29;
                v54 = v30 * v18;
                v48 = v53 + this[5 * v5 + 34];
                v49 = v54 + this[5 * v5 + 35];
                v19 = v14 * v18 + this[5 * v5 + 36];
                *i = v48;
                v50 = v19;
                i[1] = v49;
                i[2] = v50;
                goto LABEL_41;
            }
        }
        else if (v5 < v1)
        {
            v8 = (double)(v5 - v6);
            if (v8 == 0.0)
                v9 = 0.0;
            else
                v9 = (double)(v5 - v2) / v8;
            v10 = &this[5 * v5 + 34];
            v11 = i;
            v45 = (1.0 - v9) * *v10;
            v46 = (1.0 - v9) * v10[1];
            v47 = (1.0 - v9) * v10[2];
            v51 = v9 * this[5 * v6 + 34];
            v52 = v9 * this[5 * v6 + 35];
            v12 = v9 * this[5 * v6 + 36];
            v39 = v51 + v45;
            *i = v39;
            v40 = v52 + v46;
            i[1] = v40;
            v41 = v12 + v47;
            v13 = v41;
        LABEL_40:
            v11[2] = v13;
            goto LABEL_41;
        }
        if (v6 < 0)
        {
            v11 = i;
            *i = this[34];
            i[1] = this[35];
            v13 = this[36];
        }
        else
        {
            v20 = 0.0;
            v21 = v6 - 1;
            v31 = 0.0;
            v32 = 0.0;
            if (v6 - 1 >= 0)
            {
                v22 = &this[5 * v21 + 33];
                while (!*(_BYTE*)v22)
                {
                    --v21;
                    v22 -= 5;
                    if (v21 < 0)
                        goto LABEL_38;
                }
                if (v6 == v21)
                {
                    v31 = 0.0;
                    v20 = 0.0;
                    v32 = 0.0;
                }
                else
                {
                    v23 = 1.0 / ((double)v28 - (double)v21);
                    v36 = this[5 * v6 + 34] - this[5 * v21 + 34];
                    v31 = v23 * v36;
                    v37 = this[5 * v6 + 35] - this[5 * v21 + 35];
                    v32 = v37 * v23;
                    v38 = this[5 * v6 + 36] - this[5 * v21 + 36];
                    v20 = v23 * v38;
                }
            }
        LABEL_38:
            v24 = (double)(v2 - v6);
            v11 = i;
            v55 = v24 * v31;
            v56 = v32 * v24;
            v42 = v55 + this[5 * v6 + 34];
            v43 = v56 + this[5 * v6 + 35];
            v25 = v20 * v24 + this[5 * v6 + 36];
            *i = v42;
            v44 = v25;
            i[1] = v43;
            v13 = v44;
        }
        goto LABEL_40;
    }
}

//----- (004176E0) --------------------------------------------------------
char __thiscall sub_4176E0(_DWORD* this, _DWORD* a2, _DWORD* a3, _BYTE* a4, int a5)
{
    int v5; // edi
    int v6; // esi
    int v7; // eax
    _DWORD* v8; // eax

    if (!a2)
        return 0;
    if (!a3)
        return 0;
    v5 = a5;
    if (a5 >= this[1033])
        return 0;
    v6 = this[1034];
    v7 = this[1035] - v6;
    if (v7 < 0)
        v7 = 0;
    if (a5 < 0)
        v5 = this[1033];
    if (v7 >= v5)
        return 0;
    *a2 = v7 + v6;
    v8 = &this[5 * v7];
    *a3 = v8[34];
    a3[1] = v8[35];
    a3[2] = v8[36];
    *a4 = *((_BYTE*)v8 + 132);
    ++this[1035];
    return 1;
}

//----- (00417770) --------------------------------------------------------
int __thiscall sub_417770(float* this)
{
    float* v1; // esi
    double v2; // st7
    float* v3; // eax
    int v4; // eax
    double v5; // st7
    float* v6; // eax
    int v7; // eax
    double v8; // st7
    float* v9; // eax
    float v10; // edx
    float v11; // ecx
    int v12; // eax
    double v13; // st7
    float* v14; // eax
    int v15; // eax
    double v16; // st7
    float* v17; // eax
    float v18; // eax
    float v19; // edx
    int v20; // eax
    double v21; // st7
    float* v22; // eax
    float v23; // eax
    float v24; // edx
    int v25; // eax
    double v26; // st7
    float* v27; // eax
    float* v28; // eax
    float* v29; // eax
    float* v30; // eax
    float* v31; // eax
    float* v32; // eax
    float* v33; // eax
    float* v34; // eax
    float* v35; // eax
    float* v36; // eax
    float* v37; // eax
    float* v38; // eax
    float* v39; // eax
    float* v40; // eax
    float* v41; // eax
    float* v42; // eax
    float* v43; // eax
    float* v44; // eax
    float* v45; // eax
    float* v46; // eax
    float* v47; // eax
    int result; // eax
    float* v49; // [esp-20h] [ebp-C0h]
    float* v50; // [esp-20h] [ebp-C0h]
    float* v51; // [esp-18h] [ebp-B8h]
    float* v52; // [esp-18h] [ebp-B8h]
    float* v53; // [esp-10h] [ebp-B0h]
    float* v54; // [esp-10h] [ebp-B0h]
    float* v55; // [esp-8h] [ebp-A8h]
    float* v56; // [esp-8h] [ebp-A8h]
    int v57; // [esp+0h] [ebp-A0h]
    int v58; // [esp+0h] [ebp-A0h]
    int v59; // [esp+0h] [ebp-A0h]
    int v60; // [esp+0h] [ebp-A0h]
    int v61; // [esp+0h] [ebp-A0h]
    int v62; // [esp+0h] [ebp-A0h]
    int v63; // [esp+0h] [ebp-A0h]
    int v64; // [esp+0h] [ebp-A0h]
    int v65; // [esp+0h] [ebp-A0h]
    int v66; // [esp+0h] [ebp-A0h]
    int v67; // [esp+0h] [ebp-A0h]
    int v68; // [esp+0h] [ebp-A0h]
    int v69; // [esp+0h] [ebp-A0h]
    int v70; // [esp+0h] [ebp-A0h]
    int v71; // [esp+0h] [ebp-A0h]
    int v72; // [esp+0h] [ebp-A0h]
    int v73; // [esp+0h] [ebp-A0h]
    int v74; // [esp+0h] [ebp-A0h]
    int v75; // [esp+0h] [ebp-A0h]
    int v76; // [esp+0h] [ebp-A0h]
    int v77; // [esp+0h] [ebp-A0h]
    int v78; // [esp+0h] [ebp-A0h]
    int v79; // [esp+0h] [ebp-A0h]
    int v80; // [esp+0h] [ebp-A0h]
    int v81; // [esp+0h] [ebp-A0h]
    int v82; // [esp+0h] [ebp-A0h]
    int v83; // [esp+0h] [ebp-A0h]
    int v84; // [esp+0h] [ebp-A0h]
    int v85; // [esp+0h] [ebp-A0h]
    int v86; // [esp+0h] [ebp-A0h]
    int v87; // [esp+0h] [ebp-A0h]
    int v88; // [esp+0h] [ebp-A0h]
    int v89; // [esp+0h] [ebp-A0h]
    int v90; // [esp+0h] [ebp-A0h]
    int v91; // [esp+0h] [ebp-A0h]
    int v92; // [esp+0h] [ebp-A0h]
    int v93; // [esp+0h] [ebp-A0h]
    int v94; // [esp+0h] [ebp-A0h]
    float* v95; // [esp+0h] [ebp-A0h]
    float* v96; // [esp+0h] [ebp-A0h]
    int v97; // [esp+4h] [ebp-9Ch]
    int v98; // [esp+4h] [ebp-9Ch]
    int v99; // [esp+4h] [ebp-9Ch]
    int v100; // [esp+4h] [ebp-9Ch]
    int v101; // [esp+4h] [ebp-9Ch]
    int v102; // [esp+4h] [ebp-9Ch]
    int v103; // [esp+4h] [ebp-9Ch]
    int v104; // [esp+4h] [ebp-9Ch]
    int v105; // [esp+4h] [ebp-9Ch]
    int v106; // [esp+4h] [ebp-9Ch]
    int v107; // [esp+4h] [ebp-9Ch]
    int v108; // [esp+4h] [ebp-9Ch]
    int v109; // [esp+4h] [ebp-9Ch]
    int v110; // [esp+4h] [ebp-9Ch]
    int v111; // [esp+4h] [ebp-9Ch]
    int v112; // [esp+4h] [ebp-9Ch]
    int v113; // [esp+4h] [ebp-9Ch]
    int v114; // [esp+4h] [ebp-9Ch]
    int v115; // [esp+4h] [ebp-9Ch]
    int v116; // [esp+4h] [ebp-9Ch]
    int v117; // [esp+4h] [ebp-9Ch]
    int v118; // [esp+4h] [ebp-9Ch]
    int v119; // [esp+4h] [ebp-9Ch]
    int v120; // [esp+4h] [ebp-9Ch]
    int v121; // [esp+4h] [ebp-9Ch]
    int v122; // [esp+4h] [ebp-9Ch]
    int v123; // [esp+4h] [ebp-9Ch]
    int v124; // [esp+4h] [ebp-9Ch]
    int v125; // [esp+4h] [ebp-9Ch]
    int v126; // [esp+4h] [ebp-9Ch]
    int v127; // [esp+4h] [ebp-9Ch]
    int v128; // [esp+4h] [ebp-9Ch]
    int v129; // [esp+4h] [ebp-9Ch]
    int v130; // [esp+4h] [ebp-9Ch]
    int v131; // [esp+4h] [ebp-9Ch]
    int v132; // [esp+4h] [ebp-9Ch]
    int v133; // [esp+4h] [ebp-9Ch]
    int v134; // [esp+4h] [ebp-9Ch]
    int v135; // [esp+8h] [ebp-98h]
    int v136; // [esp+8h] [ebp-98h]
    int v137; // [esp+8h] [ebp-98h]
    int v138; // [esp+8h] [ebp-98h]
    int v139; // [esp+8h] [ebp-98h]
    int v140; // [esp+8h] [ebp-98h]
    int v141; // [esp+8h] [ebp-98h]
    int v142; // [esp+8h] [ebp-98h]
    int v143; // [esp+8h] [ebp-98h]
    int v144; // [esp+8h] [ebp-98h]
    int v145; // [esp+8h] [ebp-98h]
    int v146; // [esp+8h] [ebp-98h]
    int v147; // [esp+8h] [ebp-98h]
    int v148; // [esp+8h] [ebp-98h]
    int v149; // [esp+8h] [ebp-98h]
    int v150; // [esp+8h] [ebp-98h]
    int v151; // [esp+8h] [ebp-98h]
    int v152; // [esp+8h] [ebp-98h]
    int v153; // [esp+8h] [ebp-98h]
    int v154; // [esp+8h] [ebp-98h]
    int v155; // [esp+8h] [ebp-98h]
    int v156; // [esp+8h] [ebp-98h]
    int v157; // [esp+8h] [ebp-98h]
    int v158; // [esp+8h] [ebp-98h]
    int v159; // [esp+8h] [ebp-98h]
    int v160; // [esp+8h] [ebp-98h]
    int v161; // [esp+8h] [ebp-98h]
    int v162; // [esp+8h] [ebp-98h]
    int v163; // [esp+8h] [ebp-98h]
    int v164; // [esp+8h] [ebp-98h]
    int v165; // [esp+8h] [ebp-98h]
    int v166; // [esp+8h] [ebp-98h]
    int v167; // [esp+8h] [ebp-98h]
    int v168; // [esp+8h] [ebp-98h]
    int v169; // [esp+8h] [ebp-98h]
    int v170; // [esp+8h] [ebp-98h]
    int v171; // [esp+8h] [ebp-98h]
    int v172; // [esp+8h] [ebp-98h]
    float v173; // [esp+10h] [ebp-90h] BYREF
    float v174; // [esp+14h] [ebp-8Ch]
    float v175; // [esp+18h] [ebp-88h]
    int v176; // [esp+1Ch] [ebp-84h] BYREF
    float v177; // [esp+20h] [ebp-80h]
    float v178; // [esp+24h] [ebp-7Ch]
    int v179; // [esp+28h] [ebp-78h] BYREF
    float v180; // [esp+2Ch] [ebp-74h]
    float v181; // [esp+30h] [ebp-70h]
    float v182; // [esp+34h] [ebp-6Ch] BYREF
    float v183; // [esp+38h] [ebp-68h]
    float v184; // [esp+3Ch] [ebp-64h]
    int v185; // [esp+40h] [ebp-60h] BYREF
    float v186; // [esp+44h] [ebp-5Ch]
    float v187; // [esp+48h] [ebp-58h]
    int v188; // [esp+4Ch] [ebp-54h] BYREF
    float v189; // [esp+50h] [ebp-50h]
    float v190; // [esp+54h] [ebp-4Ch]
    int v191; // [esp+58h] [ebp-48h] BYREF
    float v192; // [esp+5Ch] [ebp-44h]
    float v193; // [esp+60h] [ebp-40h]
    int v194; // [esp+64h] [ebp-3Ch] BYREF
    float v195; // [esp+68h] [ebp-38h]
    float v196; // [esp+6Ch] [ebp-34h]
    int v197; // [esp+70h] [ebp-30h] BYREF
    float v198; // [esp+74h] [ebp-2Ch]
    float v199; // [esp+78h] [ebp-28h]
    int v200; // [esp+7Ch] [ebp-24h] BYREF
    float v201; // [esp+80h] [ebp-20h]
    float v202; // [esp+84h] [ebp-1Ch]
    float v203; // [esp+88h] [ebp-18h] BYREF
    float v204; // [esp+8Ch] [ebp-14h]
    float v205; // [esp+90h] [ebp-10h]
    float v206; // [esp+94h] [ebp-Ch] BYREF
    float v207; // [esp+98h] [ebp-8h]
    float v208; // [esp+9Ch] [ebp-4h]

    v1 = this;
    v2 = this[5 * *((_DWORD*)this + 1045) + 61];
    v3 = &this[5 * *((_DWORD*)this + 1045) + 59];
    *(float*)&v135 = v2 + v2;
    *(float*)&v97 = v3[1] + v3[1];
    *(float*)&v57 = *v3 + *v3;
    sub_40F4A0(&v176, v57, v97, v135);
    *(float*)&v136 = v1[5 * *((_DWORD*)v1 + 1045) + 56] * -10.0;
    *(float*)&v98 = v1[5 * *((_DWORD*)v1 + 1045) + 55] * -10.0;
    *(float*)&v58 = v1[5 * *((_DWORD*)v1 + 1045) + 54] * -10.0;
    sub_40F4A0(&v179, v58, v98, v136);
    v4 = *((_DWORD*)v1 + 1045);
    v5 = v1[5 * v4 + 51] * 20.0;
    v6 = &v1[5 * v4 + 49];
    *(float*)&v137 = v5;
    *(float*)&v99 = v6[1] * 20.0;
    *(float*)&v59 = *v6 * 20.0;
    sub_40F4A0(&v194, v59, v99, v137);
    *(float*)&v138 = v1[5 * *((_DWORD*)v1 + 1045) + 46] * -20.0;
    *(float*)&v100 = v1[5 * *((_DWORD*)v1 + 1045) + 45] * -20.0;
    *(float*)&v60 = v1[5 * *((_DWORD*)v1 + 1045) + 44] * -20.0;
    sub_40F4A0(&v197, v60, v100, v138);
    *(float*)&v139 = v1[5 * *((_DWORD*)v1 + 1045) + 41] * 10.0;
    *(float*)&v101 = v1[5 * *((_DWORD*)v1 + 1045) + 40] * 10.0;
    *(float*)&v61 = v1[5 * *((_DWORD*)v1 + 1045) + 39] * 10.0;
    sub_40F4A0(&v200, v61, v101, v139);
    v7 = *((_DWORD*)v1 + 1045);
    v8 = v1[5 * v7 + 36] * -2.0;
    v9 = &v1[5 * v7 + 34];
    *(float*)&v140 = v8;
    *(float*)&v102 = v9[1] * -2.0;
    *(float*)&v62 = *v9 * -2.0;
    sub_40F4A0(&v206, v62, v102, v140);
    *(float*)&v141 = v202 + v208;
    *(float*)&v103 = v201 + v207;
    *(float*)&v63 = *(float*)&v200 + v206;
    sub_40F4A0(&v203, v63, v103, v141);
    *(float*)&v142 = v199 + v205;
    *(float*)&v104 = v198 + v204;
    *(float*)&v64 = *(float*)&v197 + v203;
    sub_40F4A0(&v191, v64, v104, v142);
    *(float*)&v143 = v196 + v193;
    *(float*)&v105 = v195 + v192;
    *(float*)&v65 = *(float*)&v194 + *(float*)&v191;
    sub_40F4A0(&v173, v65, v105, v143);
    *(float*)&v144 = v181 + v175;
    *(float*)&v106 = v180 + v174;
    *(float*)&v66 = *(float*)&v179 + v173;
    sub_40F4A0(&v182, v66, v106, v144);
    *(float*)&v145 = v178 + v184;
    *(float*)&v107 = v177 + v183;
    *(float*)&v67 = *(float*)&v176 + v182;
    sub_40F4A0(&v188, v67, v107, v145);
    *(float*)&v146 = v190 * 0.0041666669;
    *(float*)&v108 = v189 * 0.0041666669;
    *(float*)&v68 = *(float*)&v188 * 0.0041666669;
    sub_40F4A0(&v185, v68, v108, v146);
    v10 = v186;
    v1[1051] = *(float*)&v185;
    v11 = v187;
    v1[1052] = v10;
    v1[1053] = v11;
    sub_40F4A0(&v203, 0, 0, 0);
    v12 = *((_DWORD*)v1 + 1045);
    v13 = v1[5 * v12 + 56] * 10.0;
    v14 = &v1[5 * v12 + 54];
    *(float*)&v147 = v13;
    *(float*)&v109 = v14[1] * 10.0;
    *(float*)&v69 = *v14 * 10.0;
    sub_40F4A0(&v191, v69, v109, v147);
    *(float*)&v148 = v1[5 * *((_DWORD*)v1 + 1045) + 51] * -40.0;
    *(float*)&v110 = v1[5 * *((_DWORD*)v1 + 1045) + 50] * -40.0;
    *(float*)&v70 = v1[5 * *((_DWORD*)v1 + 1045) + 49] * -40.0;
    sub_40F4A0(&v173, v70, v110, v148);
    *(float*)&v149 = v1[5 * *((_DWORD*)v1 + 1045) + 46] * 60.0;
    *(float*)&v111 = v1[5 * *((_DWORD*)v1 + 1045) + 45] * 60.0;
    *(float*)&v71 = v1[5 * *((_DWORD*)v1 + 1045) + 44] * 60.0;
    sub_40F4A0(&v182, v71, v111, v149);
    v15 = *((_DWORD*)v1 + 1045);
    v16 = v1[5 * v15 + 41] * -40.0;
    v17 = &v1[5 * v15 + 39];
    *(float*)&v150 = v16;
    *(float*)&v112 = v17[1] * -40.0;
    *(float*)&v72 = *v17 * -40.0;
    sub_40F4A0(&v185, v72, v112, v150);
    *(float*)&v151 = v1[5 * *((_DWORD*)v1 + 1045) + 36] * 10.0;
    *(float*)&v113 = v1[5 * *((_DWORD*)v1 + 1045) + 35] * 10.0;
    *(float*)&v73 = v1[5 * *((_DWORD*)v1 + 1045) + 34] * 10.0;
    sub_40F4A0(&v188, v73, v113, v151);
    *(float*)&v152 = v187 + v190;
    *(float*)&v114 = v186 + v189;
    *(float*)&v74 = *(float*)&v185 + *(float*)&v188;
    sub_40F4A0(&v176, v74, v114, v152);
    *(float*)&v153 = v184 + v178;
    *(float*)&v115 = v183 + v177;
    *(float*)&v75 = v182 + *(float*)&v176;
    sub_40F4A0(&v179, v75, v115, v153);
    *(float*)&v154 = v175 + v181;
    *(float*)&v116 = v174 + v180;
    *(float*)&v76 = v173 + *(float*)&v179;
    sub_40F4A0(&v194, v76, v116, v154);
    *(float*)&v155 = v193 + v196;
    *(float*)&v117 = v192 + v195;
    *(float*)&v77 = *(float*)&v191 + *(float*)&v194;
    sub_40F4A0(&v197, v77, v117, v155);
    *(float*)&v156 = v205 + v199;
    *(float*)&v118 = v204 + v198;
    *(float*)&v78 = v203 + *(float*)&v197;
    sub_40F4A0(&v206, v78, v118, v156);
    *(float*)&v157 = v208 * 0.0041666669;
    *(float*)&v119 = v207 * 0.0041666669;
    *(float*)&v79 = v206 * 0.0041666669;
    sub_40F4A0(&v200, v79, v119, v157);
    v18 = v201;
    v1[1054] = *(float*)&v200;
    v19 = v202;
    v1[1055] = v18;
    v1[1056] = v19;
    sub_40F4A0(&v203, 0, 0, 0);
    *(float*)&v158 = v1[5 * *((_DWORD*)v1 + 1045) + 56] * 20.0;
    *(float*)&v120 = v1[5 * *((_DWORD*)v1 + 1045) + 55] * 20.0;
    *(float*)&v80 = v1[5 * *((_DWORD*)v1 + 1045) + 54] * 20.0;
    sub_40F4A0(&v191, v80, v120, v158);
    *(float*)&v159 = v1[5 * *((_DWORD*)v1 + 1045) + 51] * -40.0;
    *(float*)&v121 = v1[5 * *((_DWORD*)v1 + 1045) + 50] * -40.0;
    *(float*)&v81 = v1[5 * *((_DWORD*)v1 + 1045) + 49] * -40.0;
    sub_40F4A0(&v173, v81, v121, v159);
    sub_40F4A0(&v182, 0, 0, 0);
    v20 = *((_DWORD*)v1 + 1045);
    v21 = v1[5 * v20 + 41] * 40.0;
    v22 = &v1[5 * v20 + 39];
    *(float*)&v160 = v21;
    *(float*)&v122 = v22[1] * 40.0;
    *(float*)&v82 = *v22 * 40.0;
    sub_40F4A0(&v185, v82, v122, v160);
    *(float*)&v161 = v1[5 * *((_DWORD*)v1 + 1045) + 36] * -20.0;
    *(float*)&v123 = v1[5 * *((_DWORD*)v1 + 1045) + 35] * -20.0;
    *(float*)&v83 = v1[5 * *((_DWORD*)v1 + 1045) + 34] * -20.0;
    sub_40F4A0(&v188, v83, v123, v161);
    *(float*)&v162 = v187 + v190;
    *(float*)&v124 = v186 + v189;
    *(float*)&v84 = *(float*)&v185 + *(float*)&v188;
    sub_40F4A0(&v176, v84, v124, v162);
    *(float*)&v163 = v184 + v178;
    *(float*)&v125 = v183 + v177;
    *(float*)&v85 = v182 + *(float*)&v176;
    sub_40F4A0(&v179, v85, v125, v163);
    *(float*)&v164 = v175 + v181;
    *(float*)&v126 = v174 + v180;
    *(float*)&v86 = v173 + *(float*)&v179;
    sub_40F4A0(&v194, v86, v126, v164);
    *(float*)&v165 = v193 + v196;
    *(float*)&v127 = v192 + v195;
    *(float*)&v87 = *(float*)&v191 + *(float*)&v194;
    sub_40F4A0(&v197, v87, v127, v165);
    *(float*)&v166 = v205 + v199;
    *(float*)&v128 = v204 + v198;
    *(float*)&v88 = v203 + *(float*)&v197;
    sub_40F4A0(&v206, v88, v128, v166);
    *(float*)&v167 = v208 * 0.0041666669;
    *(float*)&v129 = v207 * 0.0041666669;
    *(float*)&v89 = v206 * 0.0041666669;
    sub_40F4A0(&v200, v89, v129, v167);
    v23 = v201;
    v1[1057] = *(float*)&v200;
    v24 = v202;
    v1[1058] = v23;
    v1[1059] = v24;
    sub_40F4A0(&v185, 0, 0, 0);
    *(float*)&v168 = v1[5 * *((_DWORD*)v1 + 1045) + 56] * 20.0;
    *(float*)&v130 = v1[5 * *((_DWORD*)v1 + 1045) + 55] * 20.0;
    *(float*)&v90 = v1[5 * *((_DWORD*)v1 + 1045) + 54] * 20.0;
    sub_40F4A0(&v188, v90, v130, v168);
    *(float*)&v169 = v1[5 * *((_DWORD*)v1 + 1045) + 51] * 40.0;
    *(float*)&v131 = v1[5 * *((_DWORD*)v1 + 1045) + 50] * 40.0;
    *(float*)&v91 = v1[5 * *((_DWORD*)v1 + 1045) + 49] * 40.0;
    sub_40F4A0(&v182, v91, v131, v169);
    v25 = *((_DWORD*)v1 + 1045);
    v26 = v1[5 * v25 + 46] * -120.0;
    v27 = &v1[5 * v25 + 44];
    *(float*)&v170 = v26;
    *(float*)&v132 = v27[1] * -120.0;
    *(float*)&v92 = *v27 * -120.0;
    sub_40F4A0(&v176, v92, v132, v170);
    *(float*)&v171 = v1[5 * *((_DWORD*)v1 + 1045) + 41] * 40.0;
    *(float*)&v133 = v1[5 * *((_DWORD*)v1 + 1045) + 40] * 40.0;
    *(float*)&v93 = v1[5 * *((_DWORD*)v1 + 1045) + 39] * 40.0;
    sub_40F4A0(&v173, v93, v133, v171);
    *(float*)&v172 = v1[5 * *((_DWORD*)v1 + 1045) + 36] * 20.0;
    *(float*)&v134 = v1[5 * *((_DWORD*)v1 + 1045) + 35] * 20.0;
    *(float*)&v94 = v1[5 * *((_DWORD*)v1 + 1045) + 34] * 20.0;
    sub_40F4A0(&v179, v94, v134, v172);
    v28 = sub_4162C0((float*)&v179, (float*)&v200, &v173);
    v29 = sub_4162C0(v28, &v206, (float*)&v176);
    v30 = sub_4162C0(v29, (float*)&v197, &v182);
    v31 = sub_4162C0(v30, &v203, (float*)&v188);
    v32 = sub_4162C0(v31, (float*)&v194, (float*)&v185);
    v33 = sub_4162F0(v32, (float*)&v191, 0.0041666669);
    v1[1060] = *v33;
    v1[1061] = v33[1];
    v1[1062] = v33[2];
    v95 = sub_4162F0(&v1[5 * *((_DWORD*)v1 + 1045) + 59], (float*)&v188, 0.0);
    v55 = sub_4162F0(&v1[5 * *((_DWORD*)v1 + 1045) + 54], (float*)&v176, 10.0);
    v53 = sub_4162F0(&v1[5 * *((_DWORD*)v1 + 1045) + 49], (float*)&v179, 100.0);
    v51 = sub_4162F0(&v1[5 * *((_DWORD*)v1 + 1045) + 44], (float*)&v194, 0.0);
    v49 = sub_4162F0(&v1[5 * *((_DWORD*)v1 + 1045) + 39], (float*)&v197, -100.0);
    v34 = sub_4162F0(&v1[5 * *((_DWORD*)v1 + 1045) + 34], (float*)&v200, -10.0);
    v35 = sub_4162C0(v34, &v206, v49);
    v36 = sub_4162C0(v35, &v203, v51);
    v37 = sub_4162C0(v36, (float*)&v191, v53);
    v38 = sub_4162C0(v37, &v173, v55);
    v39 = sub_4162C0(v38, &v182, v95);
    v40 = sub_4162F0(v39, (float*)&v185, 0.0041666669);
    v1[1063] = *v40;
    v1[1064] = v40[1];
    v1[1065] = v40[2];
    v96 = sub_4162F0(&v1[5 * *((_DWORD*)v1 + 1045) + 59], (float*)&v188, 0.0);
    v56 = sub_4162F0(&v1[5 * *((_DWORD*)v1 + 1045) + 54], (float*)&v176, 2.0);
    v54 = sub_4162F0(&v1[5 * *((_DWORD*)v1 + 1045) + 49], (float*)&v179, 52.0);
    v52 = sub_4162F0(&v1[5 * *((_DWORD*)v1 + 1045) + 44], (float*)&v194, 132.0);
    v50 = sub_4162F0(&v1[5 * *((_DWORD*)v1 + 1045) + 39], (float*)&v197, 52.0);
    v41 = sub_4162F0(&v1[5 * *((_DWORD*)v1 + 1045) + 34], (float*)&v200, 2.0);
    v42 = sub_4162C0(v41, &v206, v50);
    v43 = sub_4162C0(v42, &v203, v52);
    v44 = sub_4162C0(v43, (float*)&v191, v54);
    v45 = sub_4162C0(v44, &v173, v56);
    v46 = sub_4162C0(v45, &v182, v96);
    v47 = sub_4162F0(v46, (float*)&v185, 0.0041666669);
    v1 += 1066;
    *v1 = *v47;
    v1[1] = v47[1];
    result = *((_DWORD*)v47 + 2);
    *((_DWORD*)v1 + 2) = result;
    return result;
}

//----- (004183A0) --------------------------------------------------------
char __thiscall sub_4183A0(int this, int a2, float a3)
{
    int v4; // eax
    int* v5; // ecx
    int v6; // eax
    int v7; // eax
    int v8; // eax

    v4 = *(_DWORD*)(this + 16);
    v5 = (int*)(this + 36);
    *(_DWORD*)(this + 4184) = v4;
    v6 = *v5;
    *(_DWORD*)(this + 4180) = 0;
    *(_DWORD*)(this + 4188) = v6;
    *(_BYTE*)(this + 4200) = 1;
    v7 = v5[1];
    *(_BYTE*)(this + 4201) = 0;
    *(_DWORD*)(this + 4192) = v7;
    v8 = *(_DWORD*)(this + 4132);
    *(_DWORD*)(this + 4196) = v5[2];
    *(_BYTE*)(this + 4202) = 0;
    if (v8 >= 6)
    {
        sub_417770((float*)this);
        LOBYTE(v8) = sub_418420(this, a2, a3, 0, 0, 0);
    }
    return v8;
}

//----- (00418420) --------------------------------------------------------
char __thiscall sub_418420(int this, int a2, float a3, float* a4, float* a5, _DWORD* a6)
{
    int v7; // ecx
    char v9; // al
    double v10; // st7
    double v11; // st7
    double v12; // st7
    double v13; // st7
    int v14; // ebp
    float* v15; // edi
    float* v16; // ecx
    int v17; // eax
    float* v18; // edi
    double v19; // st7
    double v20; // st5
    double v21; // st7
    double v22; // st7
    double v23; // st7
    double v24; // st7
    double v25; // st7
    double v26; // st7
    double v27; // st6
    int v28; // eax
    int v29; // ecx
    double v30; // st7
    double v31; // st6
    float v32; // edx
    long double v33; // st7
    double v34; // st7
    float v35; // ecx
    float v36; // eax
    unsigned __int8 v38; // c0
    unsigned __int8 v39; // c3
    float v40; // edx
    float v41; // eax
    int v42; // edi
    float* v43; // ebx
    float* v44; // ecx
    float* v45; // ebx
    float* v46; // eax
    float v47; // eax
    float v48; // edx
    float v49; // edx
    float v50; // ecx
    double v51; // st7
    double v52; // st6
    float v53; // ecx
    double v54; // st7
    float* v55; // eax
    float* v56; // eax
    float* v57; // eax
    _DWORD* v58; // esi
    int v59; // [esp+0h] [ebp-D4h]
    int v60; // [esp+0h] [ebp-D4h]
    int v61; // [esp+0h] [ebp-D4h]
    int v62; // [esp+0h] [ebp-D4h]
    int v63; // [esp+0h] [ebp-D4h]
    int v64; // [esp+0h] [ebp-D4h]
    int v65; // [esp+0h] [ebp-D4h]
    int v66; // [esp+0h] [ebp-D4h]
    int v67; // [esp+0h] [ebp-D4h]
    int v68; // [esp+0h] [ebp-D4h]
    int v69; // [esp+0h] [ebp-D4h]
    int v70; // [esp+0h] [ebp-D4h]
    int v71; // [esp+0h] [ebp-D4h]
    int v72; // [esp+0h] [ebp-D4h]
    int v73; // [esp+0h] [ebp-D4h]
    int v74; // [esp+0h] [ebp-D4h]
    int v75; // [esp+0h] [ebp-D4h]
    float* v76; // [esp+0h] [ebp-D4h]
    int v77; // [esp+4h] [ebp-D0h]
    int v78; // [esp+4h] [ebp-D0h]
    int v79; // [esp+4h] [ebp-D0h]
    int v80; // [esp+4h] [ebp-D0h]
    int v81; // [esp+4h] [ebp-D0h]
    int v82; // [esp+4h] [ebp-D0h]
    int v83; // [esp+4h] [ebp-D0h]
    int v84; // [esp+4h] [ebp-D0h]
    int v85; // [esp+4h] [ebp-D0h]
    int v86; // [esp+4h] [ebp-D0h]
    int v87; // [esp+4h] [ebp-D0h]
    int v88; // [esp+4h] [ebp-D0h]
    int v89; // [esp+4h] [ebp-D0h]
    int v90; // [esp+4h] [ebp-D0h]
    int v91; // [esp+4h] [ebp-D0h]
    int v92; // [esp+4h] [ebp-D0h]
    int v93; // [esp+4h] [ebp-D0h]
    int v94; // [esp+8h] [ebp-CCh]
    int v95; // [esp+8h] [ebp-CCh]
    int v96; // [esp+8h] [ebp-CCh]
    int v97; // [esp+8h] [ebp-CCh]
    int v98; // [esp+8h] [ebp-CCh]
    int v99; // [esp+8h] [ebp-CCh]
    int v100; // [esp+8h] [ebp-CCh]
    int v101; // [esp+8h] [ebp-CCh]
    int v102; // [esp+8h] [ebp-CCh]
    int v103; // [esp+8h] [ebp-CCh]
    int v104; // [esp+8h] [ebp-CCh]
    int v105; // [esp+8h] [ebp-CCh]
    int v106; // [esp+8h] [ebp-CCh]
    int v107; // [esp+8h] [ebp-CCh]
    int v108; // [esp+8h] [ebp-CCh]
    int v109; // [esp+8h] [ebp-CCh]
    int v110; // [esp+8h] [ebp-CCh]
    float v111; // [esp+1Ch] [ebp-B8h]
    float v112; // [esp+1Ch] [ebp-B8h]
    float v113; // [esp+20h] [ebp-B4h]
    float v114; // [esp+24h] [ebp-B0h] BYREF
    float v115; // [esp+28h] [ebp-ACh]
    float v116; // [esp+2Ch] [ebp-A8h]
    float v117; // [esp+30h] [ebp-A4h] BYREF
    float v118; // [esp+34h] [ebp-A0h]
    float v119; // [esp+38h] [ebp-9Ch]
    float v120; // [esp+3Ch] [ebp-98h]
    float v121; // [esp+40h] [ebp-94h]
    float v122; // [esp+44h] [ebp-90h] BYREF
    float v123; // [esp+48h] [ebp-8Ch]
    float v124; // [esp+4Ch] [ebp-88h]
    float v125; // [esp+50h] [ebp-84h] BYREF
    float v126; // [esp+54h] [ebp-80h]
    float v127; // [esp+58h] [ebp-7Ch]
    float v128; // [esp+5Ch] [ebp-78h] BYREF
    float v129; // [esp+60h] [ebp-74h]
    float v130; // [esp+64h] [ebp-70h]
    float v131; // [esp+68h] [ebp-6Ch] BYREF
    float v132; // [esp+6Ch] [ebp-68h]
    float v133; // [esp+70h] [ebp-64h]
    float v134; // [esp+74h] [ebp-60h] BYREF
    float v135; // [esp+78h] [ebp-5Ch]
    float v136; // [esp+7Ch] [ebp-58h]
    float v137; // [esp+80h] [ebp-54h] BYREF
    float v138; // [esp+84h] [ebp-50h]
    float v139; // [esp+88h] [ebp-4Ch]
    float v140; // [esp+8Ch] [ebp-48h] BYREF
    float v141; // [esp+90h] [ebp-44h]
    float v142; // [esp+94h] [ebp-40h]
    float v143[3]; // [esp+98h] [ebp-3Ch] BYREF
    float v144[3]; // [esp+A4h] [ebp-30h] BYREF
    int v145[3]; // [esp+B0h] [ebp-24h] BYREF
    int v146[3]; // [esp+BCh] [ebp-18h] BYREF
    _DWORD v147[3]; // [esp+C8h] [ebp-Ch] BYREF

    v7 = *(_DWORD*)(this + 4132);
    if (v7 - *(_DWORD*)(this + 4180) < 6)
        return 0;
    v9 = *(_BYTE*)(this + 4202);
    *(_BYTE*)(this + 4200) = 0;
    if (!v9)
    {
        v10 = *(float*)(this + 4288);
        v11 = v10 == 0.0 ? 0.0 : a3 / v10;
        v12 = v11 + *(float*)(this + 4184);
        *(float*)(this + 4184) = v12;
        if (v12 > 1.0)
        {
            while (1)
            {
                v13 = *(float*)(this + 4184) - 1.0;
                v14 = *(_DWORD*)(this + 4180) + 1;
                *(_BYTE*)(this + 4200) = 1;
                *(_DWORD*)(this + 4180) = v14;
                *(float*)(this + 4184) = v13;
                if (v7 - v14 < 6)
                    break;
                if (v13 <= 1.0)
                    goto LABEL_16;
            }
            if (this == a2)
                return 0;
            v15 = (float*)sub_417140((_DWORD*)this, 1);
            v16 = (float*)sub_417140((_DWORD*)this, 0);
            if (*v16 != *v15 || v16[1] != v15[1] || v16[2] != v15[2])
                return 0;
            v17 = *(_DWORD*)(this + 4180);
            *(_BYTE*)(this + 4202) = 1;
            *(_DWORD*)(this + 4184) = 1065353216;
            *(_DWORD*)(this + 4180) = v17 - 1;
        }
    }
LABEL_16:
    if (*(_BYTE*)(this + 4200))
        sub_417770((float*)this);
    if (this == a2)
    {
        v18 = a4;
        *(_BYTE*)(this + 4201) = 1;
    }
    else
    {
        v18 = a4;
        if (!a4 || *(_BYTE*)(this + 4200) || *(_BYTE*)(a2 + 4200))
        {
            v19 = sub_40DD90(
                (float*)(this + 20 * *(_DWORD*)(this + 4180) + 176),
                (float*)(this + 20 * *(_DWORD*)(this + 4180) + 196),
                (float*)(a2 + 20 * *(_DWORD*)(a2 + 4180) + 176),
                (float*)(a2 + 20 * *(_DWORD*)(a2 + 4180) + 196));
            v20 = *(float*)(a2 + 4176) + *(float*)(this + 4176);
            *(_BYTE*)(this + 4201) = v19 <= v20 * v20;
        }
    }
    if (!*(_BYTE*)(this + 4201))
        return 0;
    if (v18)
    {
        v113 = *(float*)(this + 4184);
        v21 = v113 * v113;
        v121 = v21;
        v22 = v21 * v113;
        v120 = v22;
        v23 = v22 * v113;
        v111 = v23;
        v24 = v23 * v113;
        v114 = v113 * *(float*)(this + 4252);
        v115 = v113 * *(float*)(this + 4256);
        v116 = v113 * *(float*)(this + 4260);
        v131 = v121 * *(float*)(this + 4240);
        v132 = v121 * *(float*)(this + 4244);
        v133 = v121 * *(float*)(this + 4248);
        v134 = v120 * *(float*)(this + 4228);
        v135 = v120 * *(float*)(this + 4232);
        v136 = v120 * *(float*)(this + 4236);
        v140 = v111 * *(float*)(this + 4216);
        v141 = v111 * *(float*)(this + 4220);
        v142 = v111 * *(float*)(this + 4224);
        v122 = v24 * *(float*)(this + 4204);
        v123 = v24 * *(float*)(this + 4208);
        v25 = v24 * *(float*)(this + 4212);
        v125 = v122 + v140;
        v126 = v123 + v141;
        v122 = v125 + v134;
        v123 = v126 + v135;
        *(float*)&v94 = v25 + v142 + v136 + v133;
        *(float*)&v77 = v123 + v132;
        *(float*)&v59 = v122 + v131;
        sub_40F4A0(&v125, v59, v77, v94);
        *(float*)&v95 = v127 + v116;
        *(float*)&v78 = v126 + v115;
        *(float*)&v60 = v125 + v114;
        sub_40F4A0(&v122, v60, v78, v95);
        *(float*)&v96 = v124 + *(float*)(this + 4272);
        *(float*)&v79 = v123 + *(float*)(this + 4268);
        *(float*)&v61 = v122 + *(float*)(this + 4264);
        sub_40F4A0(v147, v61, v79, v96);
        *(float*)&v97 = v113 * *(float*)(this + 4248);
        *(float*)&v80 = v113 * *(float*)(this + 4244);
        *(float*)&v62 = v113 * *(float*)(this + 4240);
        sub_40F4A0(&v125, v62, v80, v97);
        *(float*)&v98 = v127 + v127;
        *(float*)&v81 = v126 + v126;
        *(float*)&v63 = v125 + v125;
        sub_40F4A0(v146, v63, v81, v98);
        *(float*)&v99 = v121 * *(float*)(this + 4236);
        *(float*)&v82 = v121 * *(float*)(this + 4232);
        *(float*)&v64 = v121 * *(float*)(this + 4228);
        sub_40F4A0(&v122, v64, v82, v99);
        *(float*)&v100 = v124 * 3.0;
        *(float*)&v83 = v123 * 3.0;
        *(float*)&v65 = v122 * 3.0;
        sub_40F4A0(v145, v65, v83, v100);
        *(float*)&v101 = v120 * *(float*)(this + 4224);
        *(float*)&v84 = v120 * *(float*)(this + 4220);
        *(float*)&v66 = v120 * *(float*)(this + 4216);
        sub_40F4A0(&v114, v66, v84, v101);
        *(float*)&v102 = v116 * 4.0;
        *(float*)&v85 = v115 * 4.0;
        *(float*)&v67 = v114 * 4.0;
        sub_40F4A0(&v134, v67, v85, v102);
        *(float*)&v103 = v111 * *(float*)(this + 4212);
        *(float*)&v86 = v111 * *(float*)(this + 4208);
        *(float*)&v68 = v111 * *(float*)(this + 4204);
        sub_40F4A0(&v131, v68, v86, v103);
        *(float*)&v104 = v133 * 5.0;
        *(float*)&v87 = v132 * 5.0;
        *(float*)&v69 = v131 * 5.0;
        sub_40F4A0(&v140, v69, v87, v104);
        *(float*)&v105 = v136 + v142;
        *(float*)&v88 = v135 + v141;
        *(float*)&v70 = v134 + v140;
        sub_40F4A0(v143, v70, v88, v105);
        *(float*)&v106 = *(float*)&v145[2] + v143[2];
        *(float*)&v89 = *(float*)&v145[1] + v143[1];
        *(float*)&v71 = *(float*)v145 + v143[0];
        sub_40F4A0(v144, v71, v89, v106);
        *(float*)&v107 = *(float*)&v146[2] + v144[2];
        *(float*)&v90 = *(float*)&v146[1] + v144[1];
        *(float*)&v72 = *(float*)v146 + v144[0];
        sub_40F4A0(&v137, v72, v90, v107);
        *(float*)&v108 = v139 + *(float*)(this + 4260);
        *(float*)&v91 = v138 + *(float*)(this + 4256);
        *(float*)&v73 = v137 + *(float*)(this + 4252);
        sub_40F4A0(&v128, v73, v91, v108);
        v26 = v129 * v129;
        v27 = v130 * v130;
        v28 = v147[1];
        v29 = v147[2];
        *v18 = *(float*)v147;
        v30 = v26 + v27;
        v31 = v128 * v128;
        v32 = v128;
        *((_DWORD*)v18 + 1) = v28;
        v117 = v32;
        v118 = v129;
        *((_DWORD*)v18 + 2) = v29;
        v33 = sqrt(v30 + v31);
        v119 = v130;
        v112 = v33;
        if (v33 <= 0.1)
        {
            if (v38 | v39)
            {
                v42 = 1;
                if (*(int*)(this + 4132) > 1)
                {
                    while (1)
                    {
                        v43 = (float*)sub_417140((_DWORD*)this, v42 - 1);
                        v44 = (float*)sub_417140((_DWORD*)this, v42);
                        if (*v44 != *v43 || v44[1] != v43[1] || v44[2] != v43[2])
                            break;
                        if (++v42 >= *(_DWORD*)(this + 4132))
                            goto LABEL_41;
                    }
                    v45 = (float*)sub_417140((_DWORD*)this, v42);
                    v46 = (float*)sub_417140((_DWORD*)this, v42 - 1);
                    *(float*)&v109 = v46[2] - v45[2];
                    *(float*)&v92 = v46[1] - v45[1];
                    *(float*)&v74 = *v46 - *v45;
                    sub_40F4A0(&v137, v74, v92, v109);
                    v117 = v137;
                    v118 = v138;
                    v119 = v139;
                    sub_46B970(&v117, &v117);
                    goto LABEL_43;
                }
            LABEL_41:
                v114 = 0.0;
                v115 = 1.0;
                v116 = 0.0;
                v41 = 0.0;
                v117 = 0.0;
                v118 = 1.0;
            }
            else
            {
                v40 = *(float*)(this + 4192);
                v41 = *(float*)(this + 4196);
                v117 = *(float*)(this + 4188);
                v118 = v40;
            }
            v119 = v41;
        }
        else
        {
            if (v112 == 0.0)
            {
                v114 = 0.0;
                v115 = 0.0;
                v116 = 0.0;
                v117 = 0.0;
                v118 = 0.0;
                v119 = 0.0;
            }
            else
            {
                v34 = 1.0 / v112;
                v117 = v128 * v34;
                v118 = v118 * v34;
                v119 = v119 * v34;
            }
            v35 = v118;
            *(float*)(this + 4188) = v117;
            v36 = v119;
            *(float*)(this + 4192) = v35;
            *(float*)(this + 4196) = v36;
        }
    LABEL_43:
        v47 = v118;
        v114 = 0.0;
        v115 = 0.0;
        v116 = 1.0;
        a5[3] = v117;
        v48 = v119;
        a5[4] = v47;
        a5[5] = v48;
        v49 = v115;
        a5[6] = v114;
        v50 = v116;
        a5[7] = v49;
        a5[8] = v50;
        v114 = a5[4] * a5[8] - a5[7] * a5[5];
        v115 = a5[6] * a5[5] - a5[3] * a5[8];
        v51 = a5[7] * a5[3];
        v52 = a5[4] * a5[6];
        v53 = v115;
        *a5 = v114;
        a5[1] = v53;
        v116 = v51 - v52;
        a5[2] = v116;
        sub_46B970(a5, a5);
        sub_419690(a5 + 6, a5, a5 + 3);
        v54 = *(float*)(this + 4172);
        *(float*)&v110 = v54 * a5[8];
        *(float*)&v93 = v54 * a5[7];
        *(float*)&v75 = v54 * a5[6];
        sub_40F4A0(&v137, v75, v93, v110);
        v76 = sub_4162F0(a5 + 3, (float*)v146, *(float*)(this + 4168));
        v55 = sub_4162F0(a5, (float*)v145, *(float*)(this + 4164));
        v56 = sub_4162C0(v55, v143, v76);
        v57 = sub_4162C0(v56, v144, &v137);
        sub_418E20(a4, v57);
        v58 = (_DWORD*)(this + 4152);
        *a6 = *v58;
        a6[1] = v58[1];
        a6[2] = v58[2];
    }
    return 1;
}
// 418B9E: variable 'v38' is possibly undefined
// 418B9E: variable 'v39' is possibly undefined
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);

//----- (00418E20) --------------------------------------------------------
float* __thiscall sub_418E20(float* this, float* a2)
{
    float* result; // eax

    result = this;
    *this = *a2 + *this;
    this[1] = a2[1] + this[1];
    this[2] = a2[2] + this[2];
    return result;
}

//----- (00418E50) --------------------------------------------------------
bool __thiscall sub_418E50(int this, char a2, float a3)
{
    int v4; // eax
    float* v5; // edx
    int v6; // ecx
    char v7; // bl
    double v8; // st7
    double v9; // st7
    double v10; // st7
    long double v11; // st7
    float v12; // ecx
    double v13; // st7
    double v14; // st7
    double v15; // st7
    double v16; // st7
    double v17; // st7
    long double v18; // st7
    double v19; // st7
    double v20; // st7
    bool result; // al
    double v22; // st7
    double v23; // st6
    char v24; // [esp+9h] [ebp-3Bh]
    char v25; // [esp+Ah] [ebp-3Ah]
    char v26; // [esp+Bh] [ebp-39h]
    float v27; // [esp+Ch] [ebp-38h]
    float v28; // [esp+Ch] [ebp-38h]
    float v29; // [esp+Ch] [ebp-38h]
    float v30; // [esp+Ch] [ebp-38h]
    float v31; // [esp+Ch] [ebp-38h]
    float v32; // [esp+Ch] [ebp-38h]
    float v33; // [esp+Ch] [ebp-38h]
    float v34; // [esp+Ch] [ebp-38h]
    float v35; // [esp+Ch] [ebp-38h]
    int v36; // [esp+14h] [ebp-30h] BYREF
    float v37; // [esp+18h] [ebp-2Ch]
    float v38; // [esp+1Ch] [ebp-28h]
    float v39; // [esp+20h] [ebp-24h] BYREF
    float v40; // [esp+24h] [ebp-20h]
    float v41; // [esp+28h] [ebp-1Ch]
    float v42; // [esp+2Ch] [ebp-18h] BYREF
    float v43; // [esp+30h] [ebp-14h]
    float v44; // [esp+34h] [ebp-10h]
    float v45; // [esp+38h] [ebp-Ch] BYREF
    float v46; // [esp+3Ch] [ebp-8h]
    float v47; // [esp+40h] [ebp-4h]
    float v48; // [esp+4Ch] [ebp+8h]
    float v49; // [esp+4Ch] [ebp+8h]
    float v50; // [esp+4Ch] [ebp+8h]
    float v51; // [esp+4Ch] [ebp+8h]
    float v52; // [esp+4Ch] [ebp+8h]
    float v53; // [esp+4Ch] [ebp+8h]
    float v54; // [esp+4Ch] [ebp+8h]
    float v55; // [esp+4Ch] [ebp+8h]
    float v56; // [esp+4Ch] [ebp+8h]

    v24 = 0;
    v26 = 0;
    v4 = *(_DWORD*)(this + 4132);
    v5 = (float*)(this + 20 * v4 + 116);
    v39 = *v5;
    v40 = *(float*)(this + 20 * v4 + 120);
    v6 = this + 120;
    v41 = v5[2];
    v36 = *(int*)v6;
    v37 = *(float*)(v6 + 4);
    v38 = *(float*)(v6 + 8);
    if (a2 && v4 <= 8)
    {
        v7 = 1;
    }
    else
    {
        v7 = 0;
        v25 = 0;
        if (sub_417160((_DWORD*)this) <= *(_DWORD*)(this + 4280) / 2)
            goto LABEL_6;
    }
    v25 = 1;
LABEL_6:
    if (!LOBYTE(a3))
    {
        v16 = -*(float*)(this + 4292);
        v52 = v16;
        v33 = *(float*)(this + 4292);
        if (v16 != v33)
            v52 = fabs((double)rand() * 0.000030518509) * (v33 - v52) + v52;
        v12 = v52;
        goto LABEL_41;
    }
    if (!v25)
    {
        if (sub_419C40(this, &v39))
        {
            v10 = -*(float*)(this + 4292);
            v49 = v10;
            v29 = *(float*)(this + 4292);
            if (v10 != v29)
                v49 = fabs((double)rand() * 0.000030518509) * (v29 - v49) + v49;
            sub_401000((float*)&v36, v49);
            v26 = 1;
            goto LABEL_42;
        }
        v43 = v40;
        v42 = v39;
        v44 = v41;
        v11 = sqrt(v39 * v39 + v40 * v40);
        if (v11 == 0.0)
        {
            v45 = 0.0;
            v46 = 0.0;
            v47 = 0.0;
            v42 = 0.0;
            v43 = 0.0;
            v44 = 0.0;
        }
        else
        {
            v44 = 0.0;
            v42 = 1.0 / v11 * v39;
            v43 = v43 * (1.0 / v11);
        }
        if (v11 <= *(float*)(this + 4304) || v43 * v37 + v42 * *(float*)&v36 + v38 * v44 <= 0.0)
        {
            if (v11 < *(float*)(this + 4300) && v43 * v37 + v42 * *(float*)&v36 + v38 * v44 < 0.0)
            {
                v45 = -v42;
                v46 = -v43;
                v47 = -v44;
                if (sub_401170(&v45, (float*)&v36) <= 0.0)
                {
                    v14 = -*(float*)(this + 4292);
                    v31 = v14;
                    v51 = v14;
                    if (v14 != v31)
                        v51 = fabs((double)rand() * 0.000030518509) * (v31 - v51) + v51;
                    sub_401000((float*)&v36, v51);
                }
                else
                {
                    sub_401000((float*)&v36, *(float*)(this + 4292));
                }
                goto LABEL_42;
            }
            v15 = -*(float*)(this + 4292);
            v48 = v15;
            v32 = *(float*)(this + 4292);
            if (v15 != v32)
                v48 = fabs((double)rand() * 0.000030518509) * (v32 - v48) + v48;
            goto LABEL_37;
        }
        if (sub_401170(&v42, (float*)&v36) <= 0.0)
        {
            v13 = -*(float*)(this + 4292);
            v30 = v13;
            v50 = v13;
            if (v13 != v30)
                v50 = fabs((double)rand() * 0.000030518509) * (v30 - v50) + v50;
            v12 = v50;
        }
        else
        {
            v12 = *(float*)(this + 4292);
        }
    LABEL_41:
        sub_401000((float*)&v36, v12);
        goto LABEL_42;
    }
    if (v7)
    {
        v27 = *(float*)(this + 4292) + *(float*)(this + 4292);
        v8 = *(float*)(this + 4292) * -2.0;
        v48 = v8;
        if (v8 != v27)
            v48 = fabs((double)rand() * 0.000030518509) * (v27 - v48) + v48;
    }
    else
    {
        v9 = -*(float*)(this + 4292);
        v48 = v9;
        v28 = *(float*)(this + 4292);
        if (v9 != v28)
            v48 = fabs((double)rand() * 0.000030518509) * (v28 - v48) + v48;
    }
LABEL_37:
    sub_401000((float*)&v36, v48);
    v24 = 1;
LABEL_42:
    v17 = -*(float*)(this + 4296);
    v53 = v17;
    v34 = *(float*)(this + 4296);
    if (v17 == v34)
        v18 = v53;
    else
        v18 = fabs((double)rand() * 0.000030518509) * (v34 - v53) + v53;
    v38 = tan(v18);
    sub_46B970(&v36, &v36);
    v19 = *(float*)(this + 4288) * *(float*)(this + 4284);
    *(float*)&v36 = v19 * *(float*)&v36;
    v37 = v19 * v37;
    *(float*)&v36 = *(float*)&v36 + v39;
    v37 = v37 + v40;
    v38 = v41 + v19 * v38;
    if (*(float*)(this + 4308) <= (double)v41)
        v20 = *(float*)(this + 4308);
    else
        v20 = v41;
    if (*(float*)(this + 4312) >= (double)v41)
        v54 = *(float*)(this + 4312);
    else
        v54 = v41;
    if (v38 < v20 || v38 >(double)v54)
        return 0;
    if (!v24)
        goto LABEL_71;
    v55 = v40 * v40 + v39 * v39;
    v22 = *(float*)(this + 4300) * *(float*)(this + 4300);
    if (v55 < v22)
        v22 = v55;
    v23 = *(float*)(this + 4304) * *(float*)(this + 4304);
    if (v55 <= v23)
        v35 = v23;
    else
        v35 = v40 * v40 + v39 * v39;
    v56 = v37 * v37 + *(float*)&v36 * *(float*)&v36;
    if (v56 < v22)
        return 0;
    if (!v25 && *(_BYTE*)(this + 4316) && v56 > (double)v35)
        return 0;
LABEL_71:
    if (!v26)
        return sub_416350(this, &v36, a2) != 0;
    result = sub_419C40(this, (float*)&v36);
    if (result)
        return sub_416350(this, &v36, a2) != 0;
    return result;
}
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);

//----- (00419640) --------------------------------------------------------
double __cdecl sub_419640(float* a1)
{
    return sqrt(*a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2]);
}

//----- (00419670) --------------------------------------------------------
double __cdecl sub_419670(float* a1, float* a2)
{
    return a1[2] * a2[2] + a1[1] * a2[1] + *a1 * *a2;
}

//----- (00419690) --------------------------------------------------------
float* __cdecl sub_419690(float* a1, float* a2, float* a3)
{
    float* result; // eax
    double v4; // st7
    float v5; // [esp+0h] [ebp-Ch]
    float v6; // [esp+4h] [ebp-8h]
    float v7; // [esp+8h] [ebp-4h]

    v5 = a3[2] * a2[1] - a2[2] * a3[1];
    v6 = a2[2] * *a3 - a3[2] * *a2;
    result = a1;
    v4 = *a2 * a3[1] - *a3 * a2[1];
    *a1 = v5;
    v7 = v4;
    a1[1] = v6;
    a1[2] = v7;
    return result;
}

//----- (004196F0) --------------------------------------------------------
bool __thiscall sub_4196F0(int this, float* a2, float a3, float a4, char a5, char a6)
{
    double v8; // st7
    long double v9; // st7
    double v10; // st7
    float* v11; // eax
    bool result; // al
    int v13; // [esp+8h] [ebp-18h] BYREF
    float v14; // [esp+Ch] [ebp-14h]
    float v15; // [esp+10h] [ebp-10h]
    float v16[3]; // [esp+14h] [ebp-Ch] BYREF
    float v17; // [esp+24h] [ebp+4h]
    float v18; // [esp+2Ch] [ebp+Ch]

    v16[0] = *a2;
    v16[1] = a2[1];
    v16[2] = 0.0;
    sub_46B970(v16, v16);
    v13 = *(int*)(this + 120);
    v14 = *(float*)(this + 124);
    v15 = *(float*)(this + 128);
    v17 = sub_401170((float*)&v13, v16);
    if (*(float*)(this + 4292) <= (double)v17)
        v17 = *(float*)(this + 4292);
    v8 = -*(float*)(this + 4292);
    if (v17 <= v8)
        v17 = v8;
    sub_401000((float*)&v13, v17);
    if (a3 >= fabs(v17))
    {
        v9 = sub_4011F0((int)a2);
        if (LOBYTE(a4))
        {
            if (v9 >= *(float*)(this + 4296))
                v9 = *(float*)(this + 4296);
            v18 = -*(float*)(this + 4296);
            if (v9 <= v18)
                v9 = v18;
        }
        v15 = tan(v9);
        sub_46B970(&v13, &v13);
    }
    v10 = *(float*)(this + 4288) * *(float*)(this + 4284);
    v11 = (float*)(this + 20 * *(_DWORD*)(this + 4132) + 116);
    *(float*)&v13 = *(float*)&v13 * v10;
    v14 = v14 * v10;
    v15 = v10 * v15;
    *(float*)&v13 = *(float*)&v13 + *v11;
    v14 = v14 + v11[1];
    v15 = v15 + v11[2];
    if (!a6)
        return sub_416350(this, &v13, a5) != 0;
    result = sub_419C40(this, (float*)&v13);
    if (result)
        return sub_416350(this, &v13, a5) != 0;
    return result;
}
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);

//----- (004198A0) --------------------------------------------------------
bool __thiscall sub_4198A0(_DWORD* this, float* a2, float a3, float a4, char a5, char a6)
{
    double v7; // st7
    double v8; // st6
    float v10[3]; // [esp+4h] [ebp-Ch] BYREF

    v7 = a2[2] - *(float*)&this[5 * this[1033] + 31];
    v8 = a2[1] - *(float*)&this[5 * this[1033] + 30];
    v10[0] = *a2 - *(float*)&this[5 * this[1033] + 29];
    v10[1] = v8;
    v10[2] = v7;
    sub_46B970(v10, v10);
    return sub_4196F0((int)this, v10, a3, a4, a5, a6);
}
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);

//----- (00419910) --------------------------------------------------------
bool __thiscall sub_419910(int this, float a2, float a3, float a4, char a5, char a6)
{
    char v7; // bl
    int v8; // ecx
    float v9; // ecx
    long double v10; // st7
    double v11; // st7
    bool result; // al
    int v13; // [esp+8h] [ebp-18h] BYREF
    float v14; // [esp+Ch] [ebp-14h]
    float v15; // [esp+10h] [ebp-10h]
    float v16; // [esp+14h] [ebp-Ch]
    float v17; // [esp+18h] [ebp-8h]
    float v18; // [esp+1Ch] [ebp-4h]
    float v19; // [esp+2Ch] [ebp+Ch]

    v7 = LOBYTE(a4);
    v8 = this + 20 * *(_DWORD*)(this + 4132) + 116;
    v16 = *(float*)v8;
    v17 = *(float*)(v8 + 4);
    v9 = *(float*)(v8 + 8);
    v13 = *(int*)(this + 120);
    v18 = v9;
    v14 = *(float*)(this + 124);
    v15 = *(float*)(this + 128);
    if (LOBYTE(a4))
        v19 = a2 * *(float*)(this + 4292);
    else
        v19 = a2;
    sub_401000((float*)&v13, v19);
    v10 = a3;
    if (v7)
        v10 = v10 * *(float*)(this + 4296);
    v15 = tan(v10);
    sub_46B970(&v13, &v13);
    v11 = *(float*)(this + 4288) * *(float*)(this + 4284);
    *(float*)&v13 = *(float*)&v13 * v11;
    v14 = v14 * v11;
    *(float*)&v13 = v16 + *(float*)&v13;
    v14 = v14 + v17;
    v15 = v18 + v11 * v15;
    if (!a6)
        return sub_416350(this, &v13, a5) != 0;
    result = sub_419C40(this, (float*)&v13);
    if (result)
        return sub_416350(this, &v13, a5) != 0;
    return result;
}
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);

//----- (00419A30) --------------------------------------------------------
char __thiscall sub_419A30(_DWORD* this, float a2, float a3, float a4)
{
    int v5; // ebx
    int v6; // edi
    float* i; // esi
    long double v8; // st7
    float v10; // [esp+10h] [ebp-FC4h]
    float v11; // [esp+14h] [ebp-FC0h]
    float v12; // [esp+18h] [ebp-FBCh]
    float v13; // [esp+1Ch] [ebp-FB8h]
    float v14; // [esp+20h] [ebp-FB4h]
    float v15[3]; // [esp+28h] [ebp-FACh] BYREF
    _BYTE v16[12]; // [esp+34h] [ebp-FA0h] BYREF
    char v17; // [esp+40h] [ebp-F94h] BYREF

    v5 = this[1033];
    qmemcpy(v16, this + 33, 4 * ((unsigned int)(20 * v5) >> 2));
    sub_4164A0((int)this, 0);
    v6 = 0;
    if (v5 <= 0)
        return 1;
    v13 = -a4;
    v12 = -a3;
    v14 = -a2;
    for (i = (float*)&v17; ; i += 5)
    {
        v11 = v13 == a4 ? -a4 : fabs((double)rand() * 0.000030518509) * (a4 - v13) + v13;
        v10 = v12 == a3 ? -a3 : fabs((double)rand() * 0.000030518509) * (a3 - v12) + v12;
        v8 = v14 == a2 ? v14 : fabs((double)rand() * 0.000030518509) * (a2 - v14) + v14;
        v15[0] = v8 + *(i - 2);
        v15[1] = v10 + *(i - 1);
        v15[2] = v11 + *i;
        if (!sub_416350((int)this, v15, 1))
            break;
        if (++v6 >= v5)
            return 1;
    }
    return 0;
}

//----- (00419BC0) --------------------------------------------------------
char __thiscall sub_419BC0(_DWORD* this, int a2)
{
    int v3; // ebp
    int v4; // esi
    _DWORD* i; // edi
    _BYTE v7[4000]; // [esp+10h] [ebp-FA0h] BYREF

    v3 = this[1033];
    qmemcpy(v7, this + 33, 4 * ((unsigned int)(20 * v3) >> 2));
    sub_4164A0((int)this, 0);
    v4 = v3 - 1;
    if (v3 - 1 < 0)
        return 1;
    for (i = &v7[20 * v4 + 4]; sub_416350((int)this, i, 1); i -= 5)
    {
        if (--v4 < 0)
            return 1;
    }
    return 0;
}

//----- (00419C40) --------------------------------------------------------
bool __thiscall sub_419C40(int this, float* a2)
{
    double v2; // st7

    v2 = *a2 * *a2 + a2[1] * a2[1];
    return v2 >= *(float*)(this + 4300) * *(float*)(this + 4300)
        && (!*(_BYTE*)(this + 4316) || v2 <= *(float*)(this + 4304) * *(float*)(this + 4304))
        && a2[2] >= (double)*(float*)(this + 4308)
        && a2[2] <= (double)*(float*)(this + 4312);
}

//----- (00419CC0) --------------------------------------------------------
int __thiscall sub_419CC0(_DWORD* this)
{
    int result; // eax

    result = this[1];
    if (result)
        return (this[2] - result) / 60;
    return result;
}

//----- (00419CF0) --------------------------------------------------------
char* __thiscall sub_419CF0(char* this, char* a2, unsigned int a3, _DWORD* a4)
{
    char* v4; // ebx
    char* result; // eax
    unsigned int v6; // edi
    int v7; // edx
    unsigned int v8; // ecx
    int v9; // eax
    int v10; // eax
    _DWORD* v12; // edx
    char* v13; // eax
    _DWORD* v14; // eax
    char* v15; // ebx
    _DWORD* v16; // esi
    char* v17; // eax
    int v18; // ecx
    int v19; // eax
    int v20; // ebp
    char* v21; // esi
    char* v22; // ecx
    char* v23; // eax
    _DWORD* v24; // esi
    unsigned int v25; // edi
    char* v26; // ecx
    char* j; // eax
    char* v28; // edi
    int v29; // edi
    _DWORD* v30; // esi
    char* v31; // ecx
    _DWORD* v32; // ecx
    char* v33; // eax
    char* i; // eax
    char* v35; // ebx
    _DWORD* v37; // [esp+14h] [ebp-4h]
    unsigned int v38; // [esp+1Ch] [ebp+4h]
    int v39; // [esp+20h] [ebp+8h]

    v4 = this;
    result = (char*)*((_DWORD*)this + 2);
    v6 = a3;
    if ((*((_DWORD*)this + 3) - (int)result) >> 4 >= a3)
    {
        if ((result - a2) >> 4 >= a3)
        {
            if (a3)
            {
                v29 = 16 * a3;
                v30 = (_DWORD*)*((_DWORD*)this + 2);
                v31 = &result[-16 * a3];
                if (v31 != result)
                {
                    do
                    {
                        if (v30)
                        {
                            *v30 = *(_DWORD*)v31;
                            v30[1] = *((_DWORD*)v31 + 1);
                            v30[2] = *((_DWORD*)v31 + 2);
                            v30[3] = *((_DWORD*)v31 + 3);
                            v29 = 16 * a3;
                        }
                        v31 += 16;
                        v30 += 4;
                    } while (v31 != result);
                    v4 = this;
                }
                v32 = (_DWORD*)*((_DWORD*)v4 + 2);
                v33 = (char*)&v32[v29 / 0xFFFFFFFC];
                if (a2 != (char*)&v32[v29 / 0xFFFFFFFC])
                {
                    do
                    {
                        v33 -= 16;
                        v32 -= 4;
                        *v32 = *(_DWORD*)v33;
                        v32[1] = *((_DWORD*)v33 + 1);
                        v32[2] = *((_DWORD*)v33 + 2);
                        v32[3] = *((_DWORD*)v33 + 3);
                    } while (v33 != a2);
                }
                for (i = a2; i != &a2[v29]; *((_DWORD*)v35 + 3) = a4[3])
                {
                    v35 = i;
                    i += 16;
                    *(_DWORD*)v35 = *a4;
                    *((_DWORD*)v35 + 1) = a4[1];
                    *((_DWORD*)v35 + 2) = a4[2];
                }
                result = this;
                *((_DWORD*)this + 2) += v29;
            }
        }
        else
        {
            v20 = 16 * a3;
            v21 = &a2[16 * a3];
            if (a2 != result)
            {
                v22 = &v21[-v20];
                do
                {
                    if (v21)
                    {
                        *(_DWORD*)v21 = *(_DWORD*)v22;
                        *((_DWORD*)v21 + 1) = *((_DWORD*)v22 + 1);
                        *((_DWORD*)v21 + 2) = *((_DWORD*)v22 + 2);
                        v20 = 16 * a3;
                        *((_DWORD*)v21 + 3) = *((_DWORD*)v22 + 3);
                        v6 = a3;
                    }
                    v22 += 16;
                    v21 += 16;
                } while (v22 != result);
                v4 = this;
            }
            v23 = (char*)*((_DWORD*)v4 + 2);
            v24 = a4;
            v25 = v6 - ((v23 - a2) >> 4);
            if (v25)
            {
                do
                {
                    if (v23)
                    {
                        *(_DWORD*)v23 = *v24;
                        *((_DWORD*)v23 + 1) = v24[1];
                        *((_DWORD*)v23 + 2) = v24[2];
                        *((_DWORD*)v23 + 3) = v24[3];
                        v24 = a4;
                    }
                    v23 += 16;
                    --v25;
                } while (v25);
                v4 = this;
            }
            v26 = (char*)*((_DWORD*)v4 + 2);
            for (j = a2; j != v26; *((_DWORD*)v28 + 3) = v24[3])
            {
                v28 = j;
                j += 16;
                *(_DWORD*)v28 = *v24;
                *((_DWORD*)v28 + 1) = v24[1];
                *((_DWORD*)v28 + 2) = v24[2];
            }
            result = this;
            *((_DWORD*)this + 2) += v20;
        }
    }
    else
    {
        v7 = *((_DWORD*)this + 1);
        if (!v7 || (v8 = (int)&result[-v7] >> 4, a3 >= v8))
            v8 = a3;
        if (v7)
            v9 = (int)&result[-v7] >> 4;
        else
            v9 = 0;
        v10 = v8 + v9;
        v39 = v10;
        if (v10 < 0)
            v10 = 0;
        v37 = operator new(16 * v10);
        v12 = v37;
        v13 = (char*)*((_DWORD*)v4 + 1);
        if (v13 != a2)
        {
            do
            {
                if (v12)
                {
                    *v12 = *(_DWORD*)v13;
                    v12[1] = *((_DWORD*)v13 + 1);
                    v12[2] = *((_DWORD*)v13 + 2);
                    v12[3] = *((_DWORD*)v13 + 3);
                }
                v13 += 16;
                v12 += 4;
            } while (v13 != a2);
            v4 = this;
        }
        v14 = v12;
        if (v6)
        {
            v38 = v6;
            do
            {
                if (v14)
                {
                    *v14 = *a4;
                    v14[1] = a4[1];
                    v14[2] = a4[2];
                    v14[3] = a4[3];
                }
                v14 += 4;
                --v38;
            } while (v38);
            v4 = this;
        }
        v15 = (char*)*((_DWORD*)v4 + 2);
        v16 = &v12[4 * v6];
        if (a2 != v15)
        {
            v17 = a2;
            do
            {
                if (v16)
                {
                    *v16 = *(_DWORD*)v17;
                    v16[1] = *((_DWORD*)v17 + 1);
                    v16[2] = *((_DWORD*)v17 + 2);
                    v16[3] = *((_DWORD*)v17 + 3);
                }
                v17 += 16;
                v16 += 4;
            } while (v17 != v15);
        }
        sub_4885A6(*((LPVOID*)this + 1));
        v18 = *((_DWORD*)this + 1);
        *((_DWORD*)this + 3) = &v37[4 * v39];
        if (v18)
        {
            v19 = *((_DWORD*)this + 2);
            *((_DWORD*)this + 1) = v37;
            result = (char*)&v37[4 * v6 + 4 * ((v19 - v18) >> 4)];
        }
        else
        {
            *((_DWORD*)this + 1) = v37;
            result = (char*)&v37[4 * v6];
        }
        *((_DWORD*)this + 2) = result;
    }
    return result;
}

//----- (0041A000) --------------------------------------------------------
int __thiscall sub_41A000(_DWORD* this, char* a2, unsigned int a3, const void* a4)
{
    _DWORD* v4; // esi
    char* v6; // ebx
    int v7; // edi
    unsigned int v8; // ecx
    int v9; // edx
    unsigned int v10; // eax
    char* v11; // edx
    char* k; // eax
    char* v13; // eax
    unsigned int v14; // ebx
    char* v15; // edi
    char* v16; // ebx
    char* v17; // eax
    int v18; // eax
    int v19; // edx
    int result; // eax
    char* v21; // edi
    int v22; // ecx
    char* v23; // eax
    char* v24; // edx
    char* v25; // ebx
    unsigned int j; // eax
    char* v27; // edx
    char* v28; // eax
    char* v29; // edi
    char* v30; // edx
    int v31; // ebp
    char* i; // eax
    char* v33; // edx
    char* v34; // eax
    char* v35; // edx
    void* v36; // edi
    char* v38; // [esp+14h] [ebp-4h]
    unsigned int v39; // [esp+20h] [ebp+8h]
    int v40; // [esp+20h] [ebp+8h]
    char* v41; // [esp+24h] [ebp+Ch]

    v4 = this;
    v6 = (char*)this[2];
    if ((this[3] - (int)v6) / 60 >= a3)
    {
        v21 = a2;
        result = -2004318071 * (v6 - a2);
        if ((v6 - a2) / 60 >= a3)
        {
            if (a3)
            {
                v30 = (char*)this[2];
                v31 = 60 * a3;
                for (i = &v6[-60 * a3]; i != v6; v30 += 60)
                {
                    if (v30)
                    {
                        qmemcpy(v30, i, 0x3Cu);
                        v21 = a2;
                        v4 = this;
                    }
                    i += 60;
                }
                v33 = (char*)v4[2];
                v34 = &v33[-v31];
                if (v21 != &v33[-v31])
                {
                    do
                    {
                        v34 -= 60;
                        v33 -= 60;
                        qmemcpy(v33, v34, 0x3Cu);
                    } while (v34 != a2);
                    v4 = this;
                    v21 = a2;
                }
                v35 = &v21[v31];
                result = (int)v21;
                if (v21 != &v21[v31])
                {
                    do
                    {
                        v36 = (void*)result;
                        result += 60;
                        qmemcpy(v36, a4, 0x3Cu);
                    } while ((char*)result != v35);
                    v4 = this;
                }
                v4[2] += v31;
            }
        }
        else
        {
            v22 = 60 * a3;
            v40 = 60 * a3;
            v23 = &a2[60 * a3];
            if (a2 != v6)
            {
                v24 = &v23[-v22];
                do
                {
                    if (v23)
                    {
                        qmemcpy(v23, v24, 0x3Cu);
                        v21 = a2;
                        v4 = this;
                    }
                    v24 += 60;
                    v23 += 60;
                } while (v24 != v6);
            }
            v25 = (char*)v4[2];
            for (j = a3 - (v25 - v21) / 60; j; --j)
            {
                if (v25)
                {
                    qmemcpy(v25, a4, 0x3Cu);
                    v21 = a2;
                    v4 = this;
                }
                v25 += 60;
            }
            v27 = (char*)v4[2];
            v28 = v21;
            if (v21 != v27)
            {
                do
                {
                    v29 = v28;
                    v28 += 60;
                    qmemcpy(v29, a4, 0x3Cu);
                } while (v28 != v27);
                v4 = this;
            }
            result = v40 + v4[2];
            v4[2] = result;
        }
    }
    else
    {
        v7 = this[1];
        if (!v7 || (v8 = (int)&v6[-v7] / 60, a3 >= v8))
            v8 = a3;
        if (v7)
            v9 = (int)&v6[-v7] / 60;
        else
            v9 = 0;
        v10 = v9 + v8;
        v39 = v9 + v8;
        if ((int)(v9 + v8) < 0)
            v10 = 0;
        v38 = (char*)operator new(60 * v10);
        v11 = v38;
        for (k = (char*)v4[1]; k != a2; v11 += 60)
        {
            if (v11)
            {
                qmemcpy(v11, k, 0x3Cu);
                v4 = this;
            }
            k += 60;
        }
        v13 = v11;
        if (a3)
        {
            v14 = a3;
            do
            {
                if (v13)
                {
                    qmemcpy(v13, a4, 0x3Cu);
                    v4 = this;
                }
                v13 += 60;
                --v14;
            } while (v14);
        }
        v15 = (char*)v4[2];
        v41 = v15;
        v16 = &v11[60 * a3];
        if (a2 != v15)
        {
            v17 = a2;
            do
            {
                if (v16)
                {
                    qmemcpy(v16, v17, 0x3Cu);
                    v4 = this;
                    v15 = v41;
                }
                v17 += 60;
                v16 += 60;
            } while (v17 != v15);
        }
        sub_4885A6((LPVOID)v4[1]);
        v4[3] = &v38[60 * v39];
        v18 = v4[1];
        if (v18)
            v19 = (v4[2] - v18) / 60;
        else
            v19 = 0;
        v4[1] = v38;
        result = (int)&v38[60 * v19 + 60 * a3];
        v4[2] = result;
    }
    return result;
}

//----- (0041A300) --------------------------------------------------------
char* __thiscall sub_41A300(_DWORD* this, char* a2, char* a3)
{
    char* v3; // edx
    char* v4; // ebx
    char* v5; // ebp
    const void* v6; // esi
    void* v7; // edi

    v3 = a3;
    v4 = a2;
    v5 = (char*)this[2];
    if (a3 != v5)
    {
        do
        {
            v6 = v3;
            v7 = v4;
            v3 += 60;
            v4 += 60;
            qmemcpy(v7, v6, 0x3Cu);
        } while (v3 != v5);
    }
    this[2] = v4;
    return a2;
}

//----- (0041A360) --------------------------------------------------------
bool __cdecl sub_41A360(char a1)
{
    byte_5200B8 = a1;
    return DialogBoxParamA(hInstance, (LPCSTR)0x66, 0, DialogFunc, 0) > 0;
}
// 5200B8: using guessed type char byte_5200B8;

//----- (0041A390) --------------------------------------------------------
LRESULT sub_41A390()
{
    LRESULT(__stdcall * v0)(HWND, UINT, WPARAM, LPARAM); // ebp
    LRESULT v1; // eax
    int* v2; // ebx
    int* v3; // ebx
    int v4; // eax
    int v5; // ebp
    int v6; // edi
    int v7; // esi
    LRESULT v8; // eax
    WPARAM v9; // eax
    int* v11; // edi
    int v12; // ebx
    int v13; // esi
    LRESULT v14; // eax
    WPARAM v15; // eax
    bool v16; // [esp+13h] [ebp-111h]
    signed int wParam; // [esp+14h] [ebp-110h]
    WPARAM wParama; // [esp+14h] [ebp-110h]
    WPARAM v19; // [esp+18h] [ebp-10Ch]
    signed int v20; // [esp+18h] [ebp-10Ch]
    unsigned int v21; // [esp+1Ch] [ebp-108h]
    int* v22; // [esp+20h] [ebp-104h]
    char lParam[256]; // [esp+24h] [ebp-100h] BYREF

    v0 = SendMessageA;
    SendMessageA(dword_5200C4, 0x14Bu, 0, 0);
    if ((_BYTE)dword_5200AC)
    {
        v1 = SendMessageA(dword_5200C0, 0x147u, 0, 0);
        v16 = 0;
        v21 = 0;
        v2 = &dword_4F6160[4323 * SendMessageA(dword_5200C0, 0x150u, v1, 0)];
        wParam = -1;
        v19 = -1;
        v22 = v2;
        if (!v2[56])
            goto LABEL_17;
        v3 = v2 + 59;
        do
        {
            v4 = *v3;
            v5 = 16;
            if (*v3 == 22 || v4 == 21 || v4 == 20)
                v5 = 32;
            v6 = *(v3 - 1);
            v7 = *(v3 - 2);
            sprintf(lParam, "%d x %d - %d bit", v7, v6, v5);
            v8 = SendMessageA(dword_5200C4, 0x143u, 0, (LPARAM)lParam);
            if (v7 == *(_DWORD*)dword_4F5CD4 && v6 == *(_DWORD*)&dword_5200BC && !v16)
            {
                wParam = v8;
                v16 = v5 == *(_DWORD*)&dword_520098;
            }
            if (v7 == 640 && v6 == 480)
                v19 = v8;
            v3 += 5;
            ++v21;
        } while (v21 < v22[56]);
        v9 = wParam;
        v0 = SendMessageA;
        if (wParam <= -1)
            LABEL_17:
        v9 = v19;
        return v0(dword_5200C4, 0x14Eu, v9, 0);
    }
    else
    {
        v11 = dword_4A2994;
        v20 = -1;
        wParama = -1;
        do
        {
            v12 = *v11;
            v13 = *(v11 - 1);
            sprintf(lParam, "%d x %d", v13, *v11);
            v14 = SendMessageA(dword_5200C4, 0x143u, 0, (LPARAM)lParam);
            if (v13 == *(_DWORD*)dword_4F5CD4 && v12 == *(_DWORD*)&dword_5200BC)
                v20 = v14;
            if (v13 == 640 && v12 == 480)
                wParama = v14;
            v11 += 2;
        } while ((int)v11 < (int)&aDXD[4]);
        v15 = v20;
        if (v20 <= -1)
            v15 = wParama;
        return SendMessageA(dword_5200C4, 0x14Eu, v15, 0);
    }
}
// 4A2994: using guessed type int dword_4A2994[11];
// 4F5CD4: using guessed type BYTE dword_4F5CD4[56];
// 4F6160: using guessed type int dword_4F6160[];
// 5200AC: using guessed type int dword_5200AC;

//----- (0041A5A0) --------------------------------------------------------
INT_PTR __stdcall DialogFunc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)
{
    INT_PTR result; // eax
    LRESULT v5; // esi
    LRESULT v6; // eax
    int v7; // edx
    int v8; // eax
    int v9; // edx
    int* v10; // eax
    char* v11; // eax
    LRESULT v12; // esi
    LRESULT v13; // eax
    int v14; // edx
    int v15; // ecx
    _DWORD* v16; // eax
    LRESULT v17; // eax
    bool v18; // al
    int v20; // eax
    WPARAM v21; // ebp
    LRESULT v22; // edi
    int v23; // edi
    int v24; // esi
    int v25; // ebx
    int SystemMetrics; // eax
    tagRECT Rect; // [esp+10h] [ebp-10h] BYREF
    HWND hDlga; // [esp+24h] [ebp+4h]

    if (a2 == 24)
    {
        if (a3 && dword_5200CC)
        {
            dword_5200CC = 0;
            GetWindowRect(hDlg, &Rect);
            v23 = Rect.bottom - Rect.top;
            v24 = Rect.right - Rect.left;
            v25 = (GetSystemMetrics(0) - v24) / 2;
            SystemMetrics = GetSystemMetrics(1);
            MoveWindow(hDlg, v25, (SystemMetrics - v23) / 2, v24, v23, 0);
        }
        if (byte_5200B8 && a3)
            ShowWindow(hDlg, 0);
        return 1;
    }
    if (a2 == 272)
    {
        *(_DWORD*)dword_4F5CD4 = sub_422BA0(AppName, aScreenwidth, 640);
        *(_DWORD*)&dword_5200BC = sub_422BA0(AppName, aScreenheight, 480);
        *(_DWORD*)&dword_520098 = sub_422BA0(AppName, aScreendepth, 16);
        dword_5200CC = 1;
        dword_5200C0 = GetDlgItem(hDlg, 1001);
        dword_5200C4 = GetDlgItem(hDlg, 1002);
        dword_5200B4 = GetDlgItem(hDlg, 1005);
        dword_5200A0 = GetDlgItem(hDlg, 1006);
        dword_4F5CD0 = GetDlgItem(hDlg, 1080);
        dword_4F5D10 = GetDlgItem(hDlg, 1007);
        v20 = sub_422BA0(AppName, aFullscreen_0, 1);
        LOBYTE(dword_5200AC) = v20 != 0;
        if (v20)
            ShowWindow(dword_5200B4, 0);
        byte_4F5D0C = sub_422BA0(AppName, aLoadeverything, 0) != 0;
        LOBYTE(dword_52009C) = sub_422BA0(AppName, aWaitforvsync, 1) != 0;
        byte_5209BC = sub_422BA0(AppName, aZbuffertoggle, 1) != 0;
        SendMessageA(dword_5200B4, 0xF1u, (_BYTE)dword_5200AC != 0, 0);
        SendMessageA(
            dword_5200A0,
            0xF1u,
            ((unsigned __int8)dword_52009C & (unsigned __int8)-((_BYTE)dword_5200AC != 0)) != 0,
            0);
        EnableWindow(dword_5200A0, (unsigned __int8)dword_5200AC);
        SendMessageA(dword_4F5CD0, 0xF1u, byte_4F5D0C != 0, 0);
        SendMessageA(dword_4F5D10, 0xF1u, byte_5209BC != 0, 0);
        dword_4F5CC8 = GetDlgItem(hDlg, 1003);
        SendMessageA(dword_4F5CC8, 0x143u, 0, (LPARAM)aHigh);
        SendMessageA(dword_4F5CC8, 0x143u, 0, (LPARAM)aMedium);
        SendMessageA(dword_4F5CC8, 0x143u, 0, (LPARAM)aLow);
        SendMessageA(dword_4F5CC8, 0x14Eu, wParam, 0);
        dword_4F5CCC = GetDlgItem(hDlg, 1004);
        SendMessageA(dword_4F5CCC, 0x143u, 0, (LPARAM)aHigh);
        SendMessageA(dword_4F5CCC, 0x143u, 0, (LPARAM)aMedium);
        SendMessageA(dword_4F5CCC, 0x143u, 0, (LPARAM)aLow);
        switch (*(_DWORD*)&dword_520A44)
        {
        case 0x100:
            SendMessageA(dword_4F5CCC, 0x14Eu, 0, 0);
            break;
        case 0x80:
            SendMessageA(dword_4F5CCC, 0x14Eu, 1u, 0);
            break;
        case 0x40:
            SendMessageA(dword_4F5CCC, 0x14Eu, 2u, 0);
            break;
        }
        dword_5200A4 = GetDlgItem(hDlg, 1009);
        SendMessageA(dword_5200A4, 0xF1u, byte_520974 != 0, 0);
        sub_41B030();
        v21 = -1;
        for (hDlga = 0; (unsigned int)hDlga < dword_5200B0; hDlga = (HWND)((char*)hDlga + 1))
        {
            v22 = SendMessageA(dword_5200C0, 0x143u, 0, (LPARAM)&unk_4F5F20);
            SendMessageA(dword_5200C0, 0x151u, v22, v22);
            if (v21 == -1)
                v21 = v22;
        }
        SendMessageA(dword_5200C0, 0x14Eu, v21, 0);
        sub_41A390();
        if (byte_5200B8)
        {
            ShowWindow(hDlg, 0);
            SendMessageA(hDlg, 0x111u, 1u, 0);
            return 1;
        }
        return 1;
    }
    if (a2 != 273)
        return 0;
    if ((unsigned __int16)a3 > 0x3ECu)
    {
        switch ((__int16)a3)
        {
        case 1005:
            if (HIWORD(a3))
                return 0;
            LOBYTE(dword_5200AC) = SendMessageA(dword_5200B4, 0xF0u, 0, 0) == 1;
            sub_422DC0((HKEY)AppName, aFullscreen_0, dword_5200AC);
            sub_41A390();
            if ((_BYTE)dword_5200AC)
            {
                SendMessageA(dword_5200A0, 0xF1u, (_BYTE)dword_52009C != 0, 0);
                EnableWindow(dword_5200A0, (unsigned __int8)dword_5200AC);
            }
            else
            {
                SendMessageA(dword_5200A0, 0xF1u, 0, 0);
                EnableWindow(dword_5200A0, 0);
            }
            result = 0;
            break;
        case 1006:
            if (HIWORD(a3))
                return 0;
            v18 = SendMessageA(dword_5200A0, 0xF0u, 0, 0) == 1;
            LOBYTE(dword_52009C) = v18;
            if (!(_BYTE)dword_5200AC)
                return 0;
            sub_422DC0((HKEY)AppName, aWaitforvsync, v18);
            result = 0;
            break;
        case 1007:
            if (!HIWORD(a3))
            {
                byte_5209BC = SendMessageA(dword_4F5D10, 0xF0u, 0, 0) == 1;
                sub_422DC0((HKEY)AppName, aZbuffertoggle, byte_5209BC);
            }
            return 0;
        case 1009:
            if (HIWORD(a3))
                return 0;
            byte_520974 = SendMessageA(dword_5200A4, 0xF0u, 0, 0) == 1;
            sub_422DC0((HKEY)AppName, aAnimatedocean, byte_520974);
            result = 0;
            break;
        case 1080:
            if (HIWORD(a3))
                return 0;
            byte_4F5D0C = SendMessageA(dword_4F5CD0, 0xF0u, 0, 0) == 1;
            sub_422DC0((HKEY)AppName, aLoadeverything, byte_4F5D0C);
            result = 0;
            break;
        default:
            return 0;
        }
        return result;
    }
    if ((unsigned __int16)a3 == 1004)
    {
        if (HIWORD(a3) == 768 || HIWORD(a3) == 1)
        {
            v17 = SendMessageA(dword_4F5CCC, 0x147u, 0, 0);
            if (v17)
            {
                if (v17 == 1)
                {
                    *(_DWORD*)&dword_520A44 = 128;
                    sub_422DC0((HKEY)AppName, aMaxparticles, 0x80u);
                    return 0;
                }
                else
                {
                    if (v17 == 2)
                        *(_DWORD*)&dword_520A44 = 64;
                    sub_422DC0((HKEY)AppName, aMaxparticles, dword_520A44);
                    return 0;
                }
            }
            else
            {
                *(_DWORD*)&dword_520A44 = 256;
                sub_422DC0((HKEY)AppName, aMaxparticles, 0);
                return 0;
            }
        }
        return 0;
    }
    if ((unsigned __int16)a3 > 0x3E9u)
    {
        if ((unsigned __int16)a3 == 1002)
        {
            if (HIWORD(a3) == 9)
            {
                v12 = SendMessageA(dword_5200C0, 0x147u, 0, 0);
                v13 = SendMessageA(dword_5200C4, 0x147u, 0, 0);
                if (!(_BYTE)dword_5200AC)
                {
                    v14 = dword_4A2994[2 * v13];
                    *(_DWORD*)dword_4F5CD4 = dword_4A2990[2 * v13];
                    *(_DWORD*)&dword_5200BC = v14;
                    return 0;
                }
                v15 = dword_4F624C[4323 * v12 + 810 * dword_52096C + 5 * v13];
                v16 = (_DWORD*)((char*)&unk_4F6244 + 17292 * v12 + 3240 * dword_52096C + 20 * v13);
                *(_DWORD*)dword_4F5CD4 = *v16;
                *(_DWORD*)&dword_5200BC = v16[1];
                *(_DWORD*)&dword_520098 = 16;
                if (v15 == 22 || v15 == 21 || v15 == 20)
                {
                    *(_DWORD*)&dword_520098 = 32;
                    return 0;
                }
            }
        }
        else if ((unsigned __int16)a3 == 1003 && (HIWORD(a3) == 768 || HIWORD(a3) == 1))
        {
            wParam = SendMessageA(dword_4F5CC8, 0x147u, 0, 0);
            sub_422DC0((HKEY)AppName, aTexturescaledo, wParam);
            return 0;
        }
        return 0;
    }
    if ((unsigned __int16)a3 == 1001)
    {
        if (HIWORD(a3) == 9)
        {
            sub_41A390();
            return 0;
        }
        return 0;
    }
    if ((unsigned __int16)a3 != 1)
    {
        if ((unsigned __int16)a3 == 2)
        {
            EndDialog(hDlg, 0);
            return 0;
        }
        return 0;
    }
    v5 = SendMessageA(dword_5200C0, 0x147u, 0, 0);
    v6 = SendMessageA(dword_5200C4, 0x147u, 0, 0);
    dword_52096C = 1;
    dword_520A48 = v5;
    byte_520A18 = (_BYTE)dword_5200AC != 0 ? dword_52009C : 0;
    LOBYTE(dword_520A30) = (_BYTE)dword_5200AC == 0;
    byte_520A10 = byte_4F5D0C;
    if ((_BYTE)dword_5200AC)
    {
        v9 = 5 * v6;
        v10 = (int*)((char*)&unk_4F6EEC + 17292 * v5 + 20 * v6);
        dword_5209EC = dword_4F6EFC[4323 * v5 + v9];
        dword_5209E0 = v10[2];
        dword_5209F4 = *v10;
        dword_5209D8 = v10[1];
    }
    else
    {
        v7 = dword_4A2990[2 * v6];
        v8 = dword_4A2994[2 * v6];
        dword_5209EC = 80;
        dword_5209F4 = v7;
        dword_5209D8 = v8;
    }
    sub_422DC0((HKEY)AppName, aScreenwidth, dword_4F5CD4[0]);
    sub_422DC0((HKEY)AppName, aScreenheight, dword_5200BC);
    sub_422DC0((HKEY)AppName, aScreendepth, dword_520098);
    v11 = aWindowed;
    if (!(_BYTE)dword_520A30)
        v11 = aFullscreen;
    sub_4229D0(aPickvideomodeS, (char)v11);
    EndDialog(hDlg, 1);
    return 0;
}
// 41A390: using guessed type int sub_41A390(void);
// 41B030: using guessed type int sub_41B030(void);
// 4A2990: using guessed type int dword_4A2990[];
// 4A2994: using guessed type int dword_4A2994[11];
// 4F5CD4: using guessed type BYTE dword_4F5CD4[56];
// 4F5D0C: using guessed type char byte_4F5D0C;
// 4F624C: using guessed type int dword_4F624C[];
// 4F6EFC: using guessed type int dword_4F6EFC[];
// 52009C: using guessed type int dword_52009C;
// 5200AC: using guessed type int dword_5200AC;
// 5200B0: using guessed type int dword_5200B0;
// 5200B8: using guessed type char byte_5200B8;
// 5200CC: using guessed type int dword_5200CC;
// 52096C: using guessed type int dword_52096C;
// 520974: using guessed type char byte_520974;
// 5209BC: using guessed type char byte_5209BC;
// 5209D8: using guessed type int dword_5209D8;
// 5209E0: using guessed type int dword_5209E0;
// 5209EC: using guessed type int dword_5209EC;
// 5209F4: using guessed type int dword_5209F4;
// 520A10: using guessed type char byte_520A10;
// 520A18: using guessed type char byte_520A18;
// 520A30: using guessed type int dword_520A30;
// 520A48: using guessed type int dword_520A48;

//----- (0041B030) --------------------------------------------------------
int sub_41B030()
{
    int v0; // ecx
    unsigned int v1; // edi
    size_t v2; // ebx
    _DWORD* v3; // esi
    unsigned int v4; // ebp
    unsigned int* v5; // esi
    unsigned int v6; // edi
    size_t v7; // ecx
    _DWORD* v8; // eax
    unsigned int v9; // eax
    int v10; // edx
    unsigned int v11; // eax
    int* v12; // ecx
    int v13; // eax
    int* v14; // esi
    int v15; // ebp
    int v16; // edi
    int v17; // ebx
    int* v18; // eax
    int v19; // edx
    int v20; // eax
    int* v21; // ecx
    unsigned int j; // edx
    bool v23; // zf
    unsigned int v24; // edi
    unsigned int v25; // edx
    int* v26; // ecx
    int v27; // eax
    int v29; // edx
    unsigned int* k; // edi
    unsigned int v31; // eax
    _DWORD* v32; // ecx
    int v33; // [esp+40h] [ebp-7F8h]
    unsigned int v34; // [esp+60h] [ebp-7D8h]
    int v35; // [esp+64h] [ebp-7D4h]
    unsigned int i; // [esp+64h] [ebp-7D4h]
    size_t v37; // [esp+68h] [ebp-7D0h]
    unsigned int* v38; // [esp+68h] [ebp-7D0h]
    unsigned int v39; // [esp+6Ch] [ebp-7CCh]
    unsigned int v40; // [esp+70h] [ebp-7C8h]
    size_t v41; // [esp+70h] [ebp-7C8h]
    _DWORD* v42; // [esp+74h] [ebp-7C4h]
    int v43; // [esp+78h] [ebp-7C0h]
    int v44; // [esp+7Ch] [ebp-7BCh]
    int v45; // [esp+80h] [ebp-7B8h]
    int v46; // [esp+84h] [ebp-7B4h]
    _DWORD v47[2]; // [esp+88h] [ebp-7B0h]
    _DWORD v48[2]; // [esp+90h] [ebp-7A8h]
    __int64 v49; // [esp+98h] [ebp-7A0h]
    int v50; // [esp+A0h] [ebp-798h]
    int v51; // [esp+A4h] [ebp-794h]
    int v52; // [esp+A8h] [ebp-790h] BYREF
    unsigned int v53; // [esp+ACh] [ebp-78Ch]
    unsigned int v54; // [esp+B4h] [ebp-784h]
    _DWORD v55[40]; // [esp+B8h] [ebp-780h]
    int v56; // [esp+158h] [ebp-6E0h] BYREF
    _BYTE v57[156]; // [esp+15Ch] [ebp-6DCh] BYREF
    int Base; // [esp+1F8h] [ebp-640h] BYREF
    _DWORD v59[2]; // [esp+1FCh] [ebp-63Ch] BYREF
    char v60; // [esp+204h] [ebp-634h] BYREF

    v46 = 0;
    v44 = 0;
    v43 = 0;
    v45 = 0;
    v34 = 0;
    v0 = *(_DWORD*)dword_520A14;
    v47[0] = &off_4A2AEC;
    v47[1] = aRef;
    v48[0] = 1;
    v48[1] = 2;
    if (!(*(int(__stdcall**)(int))(v0 + 16))(dword_520A14))
        goto LABEL_74;
    do
    {
        v1 = v34;
        v2 = 0;
        v3 = (_DWORD*)((char*)&unk_4F5D20 + 17292 * dword_5200B0);
        v42 = v3;
        (*(void(__stdcall**)(int, unsigned int, _DWORD, _DWORD*))(*(_DWORD*)dword_520A14 + 20))(
            dword_520A14,
            v34,
            0,
            v3);
        (*(void(__stdcall**)(int, unsigned int, _DWORD*))(*(_DWORD*)dword_520A14 + 32))(dword_520A14, v34, v3 + 267);
        v3[271] = 0;
        v3[4322] = 0;
        v37 = 0;
        v4 = 1;
        v40 = (*(int(__stdcall**)(int, unsigned int))(*(_DWORD*)dword_520A14 + 24))(dword_520A14, v34);
        v56 = v3[270];
        v39 = 1;
        v35 = 0;
        if (v40)
        {
            v5 = v59;
            v38 = (unsigned int*)v57;
            while (1)
            {
                (*(void(__stdcall**)(int, unsigned int, int, int*))(*(_DWORD*)dword_520A14 + 28))(
                    dword_520A14,
                    v1,
                    v35,
                    &v52);
                if ((unsigned int)v52 >= 0x200)
                {
                    v6 = v53;
                    if (v53 >= 0x180)
                    {
                        v49 = v53;
                        v50 = v52;
                        v51 = 0;
                        if ((double)v53 / (double)v52 == 0.75)
                        {
                            v7 = 0;
                            if (v2)
                            {
                                v8 = v59;
                                do
                                {
                                    if (*(v8 - 1) == v52 && *v8 == v53)
                                    {
                                        v4 = v39;
                                        if (v8[2] == v54)
                                            break;
                                    }
                                    ++v7;
                                    v8 += 4;
                                } while (v7 < v2);
                            }
                            if (v7 == v2)
                            {
                                v9 = v54;
                                *(v5 - 1) = v52;
                                *v5 = v6;
                                v5[2] = v9;
                                v5[1] = 0;
                                v10 = v5[6];
                                v5 += 4;
                                ++v2;
                                sub_4229D0("Mode %d: %d x %d, %d bits", v7, v59[4 * v7 - 1], v59[4 * v7], v10);
                                v11 = 0;
                                if (v4)
                                {
                                    v12 = &v56;
                                    do
                                    {
                                        if (v54 == *v12)
                                            break;
                                        ++v11;
                                        ++v12;
                                    } while (v11 < v4);
                                }
                                if (v11 == v4)
                                {
                                    v39 = ++v4;
                                    *v38++ = v54;
                                }
                            }
                        }
                    }
                }
                if (++v35 >= v40)
                    break;
                v1 = v34;
            }
            v37 = v2;
        }
        qsort(&Base, v2, 0x10u, (_CoreCrtNonSecureSearchSortCompareFunction)CompareFunction);
        for (i = 0; i < 2; ++i)
        {
            v13 = v48[i];
            v14 = &v42[810 * v42[271] + 272];
            v15 = (int)&v42[810 * v42[271] + 273];
            *v14 = v13;
            (*(void(__stdcall**)(int, unsigned int, int, int))(*(_DWORD*)dword_520A14 + 52))(dword_520A14, v34, v13, v15);
            v16 = 0;
            v14[54] = v47[i];
            v14[56] = 0;
            v14[807] = 0;
            v14[55] = 0;
            v14[808] = 0;
            v14[809] = 0;
            if (v39)
            {
                while (1)
                {
                    v17 = *(_DWORD*)&v57[4 * v16 - 4];
                    v18 = (int*)dword_520A14;
                    *(_DWORD*)&v57[4 * v16 + 76] = 0;
                    v19 = *v18;
                    v33 = *v14;
                    v55[v16] = 0;
                    if ((*(int(__stdcall**)(int*, unsigned int, int, int, int, _DWORD))(v19 + 36))(v18, v34, v33, v17, v17, 0) >= 0)
                        break;
                LABEL_47:
                    if (++v16 >= v39)
                        goto LABEL_48;
                }
                if (*v14 == 1)
                {
                    v46 = 1;
                    if ((v14[4] & 0x80000) != 0)
                    {
                        v44 = 1;
                        if (!v16)
                            v43 = 1;
                    }
                }
                v20 = v14[8];
                if ((v20 & 0x10000) != 0)
                {
                    if ((v20 & 0x100000) != 0)
                    {
                        v55[v16 + 20] = 80;
                        if (sub_427EA0() >= 0)
                            v55[v16] = 1;
                    }
                    if (v55[v16])
                        goto LABEL_44;
                    v55[v16 + 20] = 64;
                    if (sub_427EA0() >= 0)
                        v55[v16] = 1;
                    if (v55[v16])
                    {
                    LABEL_44:
                        if (dword_4A2988 && !sub_41B970(v34, *v14, v17, &v57[4 * v16 + 76]))
                            v55[v16] = 0;
                        goto LABEL_47;
                    }
                    v55[v16 + 20] = 128;
                    if (sub_427EA0() >= 0)
                        v55[v16] = 1;
                }
                if (!v55[v16])
                {
                    v55[v16 + 20] = 32;
                    if (sub_427EA0() >= 0)
                        v55[v16] = 1;
                    if (!v55[v16])
                        goto LABEL_47;
                }
                goto LABEL_44;
            }
        LABEL_48:
            if (v37)
            {
                v21 = (int*)&v60;
                v41 = v37;
                do
                {
                    for (j = 0; j < v39; ++j)
                    {
                        if (*v21 == *(_DWORD*)&v57[4 * j - 4] && v55[j] == 1)
                        {
                            v14[5 * v14[56] + 57] = *(v21 - 3);
                            v14[5 * v14[56] + 58] = *(v21 - 2);
                            v14[5 * v14[56] + 59] = *v21;
                            v14[5 * v14[56] + 60] = v55[j + 20];
                            v14[5 * v14[56] + 61] = *(_DWORD*)&v57[4 * j + 76];
                            v23 = *v14 == 1;
                            ++v14[56];
                            if (v23)
                                v45 = 1;
                        }
                    }
                    v21 += 4;
                    --v41;
                } while (v41);
            }
            v24 = v14[56];
            v25 = 0;
            if (v24)
            {
                v26 = v14 + 59;
                do
                {
                    if (*(v26 - 2) == 640 && *(v26 - 1) == 480)
                    {
                        v14[807] = v25;
                        v27 = *v26;
                        if (*v26 == 23 || v27 == 24 || v27 == 25)
                            break;
                    }
                    ++v25;
                    v26 += 5;
                } while (v25 < v24);
            }
            if (v55[0] && (v14[4] & 0x80000) != 0)
            {
                v14[55] = 1;
                v14[808] = 1;
            }
            if (v24)
                ++v42[271];
        }
        if (v42[271])
            ++dword_5200B0;
        ++v34;
    } while (v34 < (*(int(__stdcall**)(int))(*(_DWORD*)dword_520A14 + 16))(dword_520A14));
LABEL_74:
    if (!dword_5200B0)
        return -2113929213;
    v29 = 0;
    for (k = (unsigned int*)&unk_4F615C; ; k += 4323)
    {
        v31 = 0;
        if (*k)
            break;
    LABEL_81:
        if (++v29 >= (unsigned int)dword_5200B0)
            return -2113929212;
    }
    v32 = k + 809;
    while (!*v32)
    {
        ++v31;
        v32 += 810;
        if (v31 >= *k)
            goto LABEL_81;
    }
    dword_5200C8 = v29;
    dword_4F5D18 = 1;
    dword_4FA0A8[4323 * v29] = v31;
    if (dword_4F6160[4323 * v29 + 810 * v31] == 2)
    {
        if (!v46)
        {
            sub_41B760(-2113929211, 1);
            return 0;
        }
        if (!v45)
        {
            sub_41B760(-2113929210, 1);
            return 0;
        }
        if (!v44)
        {
            sub_41B760(-2113929209, 1);
            return 0;
        }
        if (!v43)
        {
            sub_41B760(-2113929208, 1);
            return 0;
        }
        sub_41B760(-2113929207, 1);
    }
    return 0;
}
// 4A2988: using guessed type int dword_4A2988;
// 4A2AEC: using guessed type _UNKNOWN *off_4A2AEC;
// 4F5D18: using guessed type int dword_4F5D18;
// 4F6160: using guessed type int dword_4F6160[];
// 4FA0A8: using guessed type int dword_4FA0A8[38908];
// 5200B0: using guessed type int dword_5200B0;
// 5200C8: using guessed type int dword_5200C8;
// 520A14: using guessed type int dword_520A14;

//----- (0041B710) --------------------------------------------------------
int __cdecl CompareFunction(_DWORD* a1, _DWORD* a2)
{
    int v2; // eax
    int v3; // ecx
    unsigned int v5; // eax
    unsigned int v6; // ecx

    v2 = a1[3];
    v3 = a2[3];
    if (v2 > v3)
        return -1;
    if (v2 < v3)
        return 1;
    if (*a1 < *a2)
        return -1;
    if (*a1 > *a2)
        return 1;
    v5 = a1[1];
    v6 = a2[1];
    if (v6 <= v5)
        return v6 < v5;
    else
        return -1;
}

//----- (0041B760) --------------------------------------------------------
int __cdecl sub_41B760(int a1, int a2)
{
    const char* v2; // edi
    CHAR Text[512]; // [esp+10h] [ebp-200h] BYREF

    if (a1 > -2113929209)
    {
        if (a1 > -2005532292)
        {
        LABEL_25:
            v2 = aGenericApplica;
            goto LABEL_26;
        }
        if (a1 == -2005532292)
        {
            v2 = aNotEnoughVideo;
        }
        else
        {
            switch (a1)
            {
            case -2113929208:
                v2 = aYourDirect3dHa_0;
                break;
            case -2113929207:
                v2 = aThisSampleRequ_0;
                break;
            case -2113929206:
                v2 = aAD3dObjectHasA;
                break;
            case -2113929205:
                v2 = aCouldNotLoadRe;
                break;
            case -2113929204:
                v2 = aCouldNotResetT;
                break;
            default:
                goto LABEL_25;
            }
        }
    }
    else
    {
        if (a1 == -2113929209)
        {
            v2 = aYourDirect3dHa;
            goto LABEL_26;
        }
        if (a1 <= -2113929212)
        {
            switch (a1)
            {
            case -2113929212:
                v2 = aThisSampleCann;
                goto LABEL_26;
            case -2147024882:
                v2 = aNotEnoughMemor;
                goto LABEL_26;
            case -2113929215:
                v2 = aCouldNotInitia;
                goto LABEL_26;
            case -2113929213:
                v2 = aCouldNotFindAn;
                goto LABEL_26;
            }
            goto LABEL_25;
        }
        if (a1 == -2113929211)
            v2 = aNoHardwareAcce;
        else
            v2 = aThisSampleRequ;
    }
LABEL_26:
    strcpy(Text, v2);
    if (a2 == 1)
    {
        strcat(Text, aThisProgramWil);
        MessageBoxA(0, Text, Caption, 0x10u);
        if (dword_5209E4)
        {
            SendMessageA(dword_5209E4, 0x10u, 0, 0);
            return a1;
        }
    }
    else
    {
        if (a2 == 2)
            strcat(Text, aSwitchingToThe);
        MessageBoxA(0, Text, aError, 0x30u);
    }
    return a1;
}
// 41B7EF: conditional instruction was optimized away because %arg_0.4==82000006

//----- (0041B970) --------------------------------------------------------
int __cdecl sub_41B970(int a1, int a2, int a3, _DWORD* a4)
{
    if ((unsigned int)dword_4F5D14 <= 0x10
        && !dword_5200A8
        && (*(int(__stdcall**)(int, int, int, int, int, int, int))(*(_DWORD*)dword_520A14 + 40))(
            dword_520A14,
            a1,
            a2,
            a3,
            2,
            1,
            80) >= 0
        && (*(int(__stdcall**)(int, int, int, int, int, int))(*(_DWORD*)dword_520A14 + 48))(
            dword_520A14,
            a1,
            a2,
            a3,
            a3,
            80) >= 0)
    {
        *a4 = 80;
        return 1;
    }
    if ((unsigned int)dword_4F5D14 <= 0xF
        && (unsigned int)dword_5200A8 <= 1
        && (*(int(__stdcall**)(int, int, int, int, int, int, int))(*(_DWORD*)dword_520A14 + 40))(
            dword_520A14,
            a1,
            a2,
            a3,
            2,
            1,
            73) >= 0
        && (*(int(__stdcall**)(int, int, int, int, int, int))(*(_DWORD*)dword_520A14 + 48))(
            dword_520A14,
            a1,
            a2,
            a3,
            a3,
            73) >= 0)
    {
        *a4 = 73;
        return 1;
    }
    if ((unsigned int)dword_4F5D14 > 0x18)
        goto LABEL_29;
    if (!dword_5200A8
        && (*(int(__stdcall**)(int, int, int, int, int, int, int))(*(_DWORD*)dword_520A14 + 40))(
            dword_520A14,
            a1,
            a2,
            a3,
            2,
            1,
            77) >= 0
        && (*(int(__stdcall**)(int, int, int, int, int, int))(*(_DWORD*)dword_520A14 + 48))(
            dword_520A14,
            a1,
            a2,
            a3,
            a3,
            77) >= 0)
    {
        *a4 = 77;
        return 1;
    }
    if ((unsigned int)dword_4F5D14 > 0x18)
        goto LABEL_29;
    if ((unsigned int)dword_5200A8 <= 8
        && (*(int(__stdcall**)(int, int, int, int, int, int, int))(*(_DWORD*)dword_520A14 + 40))(
            dword_520A14,
            a1,
            a2,
            a3,
            2,
            1,
            75) >= 0
        && (*(int(__stdcall**)(int, int, int, int, int, int))(*(_DWORD*)dword_520A14 + 48))(
            dword_520A14,
            a1,
            a2,
            a3,
            a3,
            75) >= 0)
    {
        *a4 = 75;
        return 1;
    }
    if ((unsigned int)dword_4F5D14 > 0x18
        || (unsigned int)dword_5200A8 > 4
        || (*(int(__stdcall**)(int, int, int, int, int, int, int))(*(_DWORD*)dword_520A14 + 40))(
            dword_520A14,
            a1,
            a2,
            a3,
            2,
            1,
            79) < 0
        || (*(int(__stdcall**)(int, int, int, int, int, int))(*(_DWORD*)dword_520A14 + 48))(
            dword_520A14,
            a1,
            a2,
            a3,
            a3,
            79) < 0)
    {
    LABEL_29:
        if ((unsigned int)dword_4F5D14 > 0x20
            || dword_5200A8
            || (*(int(__stdcall**)(int, int, int, int, int, int, int))(*(_DWORD*)dword_520A14 + 40))(
                dword_520A14,
                a1,
                a2,
                a3,
                2,
                1,
                71) < 0
            || (*(int(__stdcall**)(int, int, int, int, int, int))(*(_DWORD*)dword_520A14 + 48))(
                dword_520A14,
                a1,
                a2,
                a3,
                a3,
                71) < 0)
        {
            return 0;
        }
        else
        {
            *a4 = 71;
            return 1;
        }
    }
    else
    {
        *a4 = 79;
        return 1;
    }
}
// 4F5D14: using guessed type int dword_4F5D14;
// 5200A8: using guessed type int dword_5200A8;
// 520A14: using guessed type int dword_520A14;

//----- (0041BB80) --------------------------------------------------------
_DWORD* __thiscall sub_41BB80(_DWORD* this)
{
    sub_41BB90(this);
    return this;
}

//----- (0041BB90) --------------------------------------------------------
int __thiscall sub_41BB90(_DWORD* this)
{
    int v1; // esi
    _DWORD* v2; // edi
    int result; // eax

    *this = -1;
    this[1] = -1;
    this[2] = -1;
    this[4] = -1;
    this[5] = -1;
    this[6] = -1;
    v1 = 0;
    v2 = this + 15;
    do
    {
        *(v2 - 8) = 0;
        (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**)ArgList + 244))(*(_DWORD*)ArgList, v1, 0);
        (*(void(__stdcall**)(_DWORD, int, int, int))(**(_DWORD**)ArgList + 252))(*(_DWORD*)ArgList, v1, 1, 1);
        result = (*(int(__stdcall**)(_DWORD, int, int, int))(**(_DWORD**)ArgList + 252))(*(_DWORD*)ArgList, v1, 4, 1);
        *v2 = -1;
        v2[8] = -1;
        ++v1;
        ++v2;
    } while (v1 < 8);
    return result;
}

//----- (0041BC00) --------------------------------------------------------
int __thiscall sub_41BC00(_DWORD* this, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
    int result; // eax
    int v10; // [esp+64h] [ebp-4h]

    if (a2 != -1 && a2 != *this)
    {
        *this = a2;
        if (a2)
            (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 137, 0);
        else
            (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 137, 1);
    }
    if (a3 != -1 && a3 != this[1])
    {
        this[1] = a3;
        if (a3)
        {
            if (a3 == 1)
            {
                (*(void(__stdcall**)(_DWORD, int, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 19, 5, v10);
                (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 20, 6);
            }
            else
            {
                if (a3 != 2)
                    goto LABEL_15;
                (*(void(__stdcall**)(_DWORD, int, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 19, 5, v10);
                (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 20, 2);
            }
            (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 27, 1);
            (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 24, 1);
            (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 15, 1);
            (*(void(__stdcall**)(_DWORD, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 25);
            goto LABEL_15;
        }
        (*(void(__stdcall**)(_DWORD, int, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 19, 2, v10);
        (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 20, 1);
        (*(void(__stdcall**)(_DWORD, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 27);
    }
LABEL_15:
    if (a4 != -1 && a4 != this[2])
    {
        this[2] = a4;
        if (a4)
        {
            if (a4 == 1)
                (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 23, 4);
        }
        else
        {
            (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 23, 3);
        }
    }
    if (a5 != -1 && a5 != this[3])
    {
        this[3] = a5;
        if (byte_5209BC && a5)
        {
            if (a5 == 1)
                (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 14, 0);
        }
        else
        {
            (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 14, 1);
        }
    }
    if (a6 != -1 && a6 != this[4])
    {
        this[4] = a6;
        if (a6)
        {
            if (a6 == 1)
            {
                (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 22, 3);
            }
            else if (a6 == 2)
            {
                (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 22, 1);
            }
        }
        else
        {
            (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 22, 2);
        }
    }
    if (a7 != -1 && a7 != this[5])
    {
        this[5] = a7;
        if (a7)
        {
            if (a7 == 1)
                (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 8, 2);
        }
        else
        {
            (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 8, 3);
        }
    }
    result = a8;
    if (a8 != -1 && a8 != this[6])
    {
        this[6] = a8;
        if (a8)
        {
            if (a8 == 1)
            {
                (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 141, 0);
                (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 145, 0);
                return (*(int(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 147, 0);
            }
        }
        else
        {
            (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 141, 1);
            (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 145, 1);
            return (*(int(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 147, 1);
        }
    }
    return result;
}
// 41BC66: variable 'v10' is possibly undefined
// 5209BC: using guessed type char byte_5209BC;

//----- (0041BEF0) --------------------------------------------------------
int __thiscall sub_41BEF0(_DWORD* this, int a2, int a3, int a4, int a5)
{
    int v6; // eax
    int v7; // ecx
    int result; // eax
    int v9; // [esp+34h] [ebp-8h]

    if (a3 != this[a2 + 7])
    {
        this[a2 + 7] = a3;
        if (a3)
        {
            sub_422270(a3, a2);
            (*(void(__stdcall**)(_DWORD, int, int, int))(**(_DWORD**)ArgList + 252))(*(_DWORD*)ArgList, a2, 1, 4);
            (*(void(__stdcall**)(_DWORD, int, int, int))(**(_DWORD**)ArgList + 252))(*(_DWORD*)ArgList, a2, 4, 4);
        }
        else
        {
            (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**)ArgList + 244))(*(_DWORD*)ArgList, a2, 0);
            (*(void(__stdcall**)(_DWORD, int, int, int))(**(_DWORD**)ArgList + 252))(*(_DWORD*)ArgList, a2, 1, 1);
            (*(void(__stdcall**)(_DWORD, int, int, int))(**(_DWORD**)ArgList + 252))(*(_DWORD*)ArgList, a2, 4, 1);
        }
    }
    if (a4 != -1 && this[a2 + 15] != a4)
    {
        this[a2 + 15] = a4;
        if (!a4)
        {
            (*(void(__stdcall**)(_DWORD, _DWORD, int, _DWORD, int))(**(_DWORD**)ArgList + 252))(
                *(_DWORD*)ArgList,
                0,
                17,
                0,
                v9);
            v6 = *(_DWORD*)ArgList;
            v7 = **(_DWORD**)ArgList;
        LABEL_11:
            (*(void(__stdcall**)(int, _DWORD, int))(v7 + 252))(v6, 0, 16);
            goto LABEL_12;
        }
        if (a4 == 1)
        {
            (*(void(__stdcall**)(_DWORD, _DWORD, int, int, int))(**(_DWORD**)ArgList + 252))(
                *(_DWORD*)ArgList,
                0,
                17,
                2,
                v9);
            v6 = *(_DWORD*)ArgList;
            v7 = **(_DWORD**)ArgList;
            goto LABEL_11;
        }
    }
LABEL_12:
    result = a5;
    if (a5 != -1 && this[a2 + 23] != a5)
    {
        this[a2 + 23] = a5;
        if (a5)
        {
            if (a5 == 1)
            {
                (*(void(__stdcall**)(_DWORD, int, int, int))(**(_DWORD**)ArgList + 252))(*(_DWORD*)ArgList, a2, 13, 3);
                return (*(int(__stdcall**)(_DWORD, int, int, int))(**(_DWORD**)ArgList + 252))(*(_DWORD*)ArgList, a2, 14, 3);
            }
        }
        else
        {
            (*(void(__stdcall**)(_DWORD, int, int, int))(**(_DWORD**)ArgList + 252))(*(_DWORD*)ArgList, a2, 13, 1);
            return (*(int(__stdcall**)(_DWORD, int, int, int))(**(_DWORD**)ArgList + 252))(*(_DWORD*)ArgList, a2, 14, 1);
        }
    }
    return result;
}
// 41BF94: variable 'v9' is possibly undefined

//----- (0041C050) --------------------------------------------------------
int __thiscall sub_41C050(_DWORD* this)
{
    int result; // eax

    result = 0;
    this[3] = 0;
    this[8] = 0;
    return result;
}

//----- (0041C060) --------------------------------------------------------
int __thiscall sub_41C060(_DWORD* this, int a2, int a3, int a4)
{
    sub_41C050(this);
    *this = a2;
    return sub_41C090(this, a3, a4);
}

//----- (0041C090) --------------------------------------------------------
int __thiscall sub_41C090(_DWORD* this, int a2, int a3)
{
    int result; // eax

    result = a2;
    this[1] = a2;
    this[2] = a3;
    return result;
}

//----- (0041C0B0) --------------------------------------------------------
void __thiscall sub_41C0B0(int this, float a2)
{
    int v2; // eax

    *(float*)(this + 4 * *(_DWORD*)(this + 32) + 36) = a2;
    v2 = *(_DWORD*)(this + 32) + 1;
    *(_DWORD*)(this + 32) = v2;
    if (v2 == 4)
        sub_41C0E0((float*)this);
}

//----- (0041C0E0) --------------------------------------------------------
void __thiscall sub_41C0E0(float* this)
{
    double v1; // st7

    this[4] = this[10] * 3.0 + this[12] + this[11] * -3.0 - this[9];
    v1 = this[11] * 3.0;
    this[5] = this[9] * 3.0 + this[10] * -6.0 + v1;
    this[6] = this[9] * -3.0 + v1;
    this[7] = this[10] * 4.0 + this[9] + this[11];
}

//----- (0041C150) --------------------------------------------------------
void __thiscall sub_41C150(int this)
{
    int v2; // ecx
    int v3; // eax
    bool v4; // zf
    _DWORD* v5; // eax

    v2 = 0;
    v3 = *(_DWORD*)(this + 32) - 1;
    v4 = *(_DWORD*)(this + 32) == 1;
    *(_DWORD*)(this + 32) = v3;
    if (v3 >= 0 && !v4)
    {
        v5 = (_DWORD*)(this + 36);
        do
        {
            ++v2;
            *v5 = v5[1];
            ++v5;
        } while (v2 < *(_DWORD*)(this + 32));
    }
    sub_41C190(this);
    if (*(int*)(this + 32) >= 4)
        sub_41C0E0((float*)this);
}

//----- (0041C190) --------------------------------------------------------
void __thiscall sub_41C190(int this)
{
    float v2; // [esp+4h] [ebp-Ch]
    float v3; // [esp+8h] [ebp-8h]
    float v4; // [esp+Ch] [ebp-4h]

    while (*(int*)(this + 32) < 4)
    {
        v2 = *(float*)(this + 4);
        v3 = *(float*)(this + 8);
        if (v2 == v3)
        {
            sub_41C0B0(this, *(float*)(this + 4));
        }
        else
        {
            v4 = fabs((double)rand() * 0.000030518509) * (v3 - v2) + v2;
            sub_41C0B0(this, v4);
        }
    }
}

//----- (0041C200) --------------------------------------------------------
double __thiscall sub_41C200(float* this, float a2)
{
    double v3; // st7
    double v4; // st7
    double v5; // st7

    v3 = *this;
    if (v3 == 0.0)
        v4 = 0.0;
    else
        v4 = a2 / v3;
    this[3] = v4 + this[3];
    sub_41C190((int)this);
    while (this[3] > 1.0)
    {
        this[3] = this[3] - 1.0;
        sub_41C150((int)this);
    }
    v5 = this[3];
    return (v5 * v5 * v5 * this[4] + v5 * v5 * this[5] + v5 * this[6] + this[7]) * 0.16666667;
}

//----- (0041C2A0) --------------------------------------------------------
double __stdcall sub_41C2A0(float a1)
{
    double result; // st7

    for (result = a1; result < 0.0; result = result + 6.2831855)
        ;
    for (; result > 6.2831855; result = result - 6.2831855)
        ;
    return result;
}

//----- (0041C2F0) --------------------------------------------------------
double __thiscall sub_41C2F0(float* this, float a2)
{
    double result; // st7

    result = sub_41C2A0(a2);
    if (result < *this)
        return result + 6.2831855;
    return result;
}

//----- (0041C310) --------------------------------------------------------
BOOL __thiscall sub_41C310(int this, float a2, float a3)
{
    double v4; // st7
    double v5; // st7
    BOOL result; // eax

    *(float*)this = sub_41C2A0(a2);
    v4 = sub_41C2F0((float*)this, a3);
    *(float*)(this + 4) = v4;
    v5 = *(float*)this + 6.2831855 - v4;
    result = v5 < 0.0000099999997 && v5 > -0.0000099999997;
    *(_BYTE*)(this + 8) = result;
    if (result)
    {
        *(_DWORD*)this = 0;
        *(_DWORD*)(this + 4) = 1086918619;
    }
    return result;
}

//----- (0041C380) --------------------------------------------------------
BOOL __thiscall sub_41C380(float* this, float a2)
{
    double v3; // st7

    v3 = sub_41C2F0(this, a2);
    return v3 >= *this && v3 <= this[1];
}

//----- (0041C3C0) --------------------------------------------------------
void __thiscall sub_41C3C0(int this, float a2, float a3, int a4)
{
    double v5; // st7
    long double v6; // st7
    bool v7; // c0
    double v8; // st6
    float v9; // [esp+0h] [ebp-10h]
    float v10; // [esp+0h] [ebp-10h]
    float v11; // [esp+0h] [ebp-10h]
    float v12; // [esp+8h] [ebp-8h]
    float v13; // [esp+14h] [ebp+4h]
    float v14; // [esp+14h] [ebp+4h]
    float v15; // [esp+18h] [ebp+8h]

    v13 = sub_41C2F0((float*)this, a2);
    v15 = sub_41C2F0((float*)this, a3);
    if (*(_BYTE*)(this + 8))
    {
        v9 = v13 - v15;
        v12 = sub_41C2F0((float*)this, v9);
        v10 = v15 - v13;
        v14 = sub_41C2F0((float*)this, v10);
        if (v12 >= (double)v14)
            v5 = v14;
        else
            v5 = v12;
        if (*(float*)&a4 < v5)
        {
            v6 = *(float*)&a4;
            v7 = v12 < (double)v14;
        }
        else
        {
            if (v12 >= (double)v14)
                v6 = v14;
            else
                v6 = v12;
            v7 = v12 < (double)v14;
        }
    }
    else
    {
        v6 = fabs(v15 - v13);
        if (*(float*)&a4 < v6)
            v6 = *(float*)&a4;
        v7 = v15 < (double)v13;
    }
    if (v7)
        v8 = 1.0;
    else
        v8 = -1.0;
    v11 = v6 * v8 + v15;
    sub_41C2A0(v11);
}

//----- (0041C4E0) --------------------------------------------------------
void __thiscall sub_41C4E0(float* this)
{
    float v2; // ecx
    float v3; // [esp+8h] [ebp-8h]
    float v4; // [esp+8h] [ebp-8h]

    v2 = *this;
    v3 = this[1];
    if (v2 == v3)
    {
        sub_41C2A0(v2);
    }
    else
    {
        v4 = fabs((double)rand() * 0.000030518509) * (v3 - v2) + v2;
        sub_41C2A0(v4);
    }
}

//----- (0041C550) --------------------------------------------------------
char __cdecl sub_41C550(HWND a1, int a2, LPCGUID pcGuidDevice)
{
    char ArgList[36]; // [esp+Ch] [ebp-84h] BYREF
    int v5[24]; // [esp+30h] [ebp-60h] BYREF

    if (ppDS)
    {
        sub_4229D0(aInitsoundDirec);
        return 1;
    }
    if (DirectSoundCreate(pcGuidDevice, &ppDS, 0) < 0)
    {
        sub_4229D0(aSoundCanTCreat);
        return 0;
    }
    if (ppDS->lpVtbl->SetCooperativeLevel(ppDS, a1, 2) < 0)
    {
        sub_4229D0(aSoundCanTSetDs);
        return 0;
    }
    memset(ArgList, 0, sizeof(ArgList));
    *(_DWORD*)ArgList = 36;
    *(_DWORD*)&ArgList[4] = 1;
    if (ppDS->lpVtbl->CreateSoundBuffer(ppDS, (LPCDSBUFFERDESC)ArgList, (LPDIRECTSOUNDBUFFER*)&dword_5200D0, 0) < 0)
        goto LABEL_10;
    if ((*(int(__stdcall**)(int, _DWORD, _DWORD, int))(*(_DWORD*)dword_5200D0 + 48))(dword_5200D0, 0, 0, 1) >= 0)
    {
        sub_4229D0(aSoundCreatedPr);
    LABEL_10:
        v5[0] = 96;
        ppDS->lpVtbl->GetCaps(ppDS, (LPDSCAPS)v5);
        return 1;
    }
    (*(void(__stdcall**)(int))(*(_DWORD*)dword_5200D0 + 8))(dword_5200D0);
    dword_5200D0 = 0;
    sub_4229D0(aSoundFailedCre);
    return 0;
}
// 5200D0: using guessed type int dword_5200D0;

//----- (0041C680) --------------------------------------------------------
LPDIRECTSOUND sub_41C680()
{
    LPDIRECTSOUND result; // eax

    result = ppDS;
    if (ppDS)
    {
        result = (LPDIRECTSOUND)ppDS->lpVtbl->Release(ppDS);
        ppDS = 0;
    }
    return result;
}

//----- (0041C6A0) --------------------------------------------------------
_DWORD* __thiscall sub_41C6A0(_DWORD* this)
{
    memset(this + 76, 0, 0x1Cu);
    this[75] = 0;
    this[8] = 0;
    *((_BYTE*)this + 2) = 0;
    *(_BYTE*)this = 0;
    *((_BYTE*)this + 3) = 0;
    this[9] = operator new(0x12u);
    this[1] = 0;
    this[3] = 1065353216;
    this[4] = 1065353216;
    this[2] = 1065353216;
    *((_BYTE*)this + 1) = 0;
    this[5] = 0;
    this[6] = 0;
    this[7] = 0;
    this[86] = 0;
    *((_BYTE*)this + 40) = 0;
    return this;
}

//----- (0041C700) --------------------------------------------------------
FILE* __thiscall sub_41C700(int this)
{
    const char* v2; // edi

    v2 = (const char*)(this + 40);
    sub_4229D0("SOUND: Destroying '%s'", (const char*)(this + 40));
    sub_41C940(this);
    sub_4885A6(*(LPVOID*)(this + 36));
    *(_DWORD*)(this + 36) = 0;
    return sub_4229D0("SOUND: Done destroying '%s'", v2);
}

//----- (0041C740) --------------------------------------------------------
char __thiscall sub_41C740(int this)
{
    sub_41CFD0(this, *(float*)(this + 12));
    return sub_41D010((_DWORD*)this, *(float*)(this + 24));
}

//----- (0041C760) --------------------------------------------------------
unsigned int __thiscall sub_41C760(int this, const char* a2)
{
    unsigned int result; // eax

    sub_41C940(this);
    result = strlen(a2) + 1;
    qmemcpy((void*)(this + 40), a2, result);
    return result;
}

//----- (0041C7A0) --------------------------------------------------------
char __thiscall sub_41C7A0(int this, char a2)
{
    char result; // al
    bool v4; // bl

    result = a2;
    if (a2 != *(_BYTE*)(this + 2))
    {
        v4 = *(_DWORD*)(this + 32) != 0;
        result = sub_41C940(this);
        *(_BYTE*)(this + 2) = a2;
        if (v4)
        {
            result = *(_BYTE*)(this + 3);
            if (!result)
                return sub_41CA40(this);
        }
    }
    return result;
}

//----- (0041C7E0) --------------------------------------------------------
char __thiscall sub_41C7E0(_BYTE* this, char a2)
{
    this[3] = a2;
    if (!a2)
        return sub_41CA40((int)this);
    sub_41C940((int)this);
    return sub_41C810((int)this);
}

//----- (0041C810) --------------------------------------------------------
char __thiscall sub_41C810(int this)
{
    int v2; // ecx
    _DWORD* v3; // edi
    int v4; // eax
    double v6; // st7
    double v7; // st7
    int v8; // eax

    v2 = *(_DWORD*)(this + 36);
    v3 = (_DWORD*)(this + 304);
    *(_DWORD*)v2 = 0;
    *(_DWORD*)(v2 + 4) = 0;
    *(_DWORD*)(v2 + 8) = 0;
    *(_DWORD*)(v2 + 12) = 0;
    *(_WORD*)(v2 + 16) = 0;
    v4 = ((int(__cdecl*)(int, int))sf_open_read)(this + 40, this + 304);
    *(_DWORD*)(this + 300) = v4;
    if (!v4)
        return 0;
    ++dword_5200D8;
    *(_WORD*)(*(_DWORD*)(this + 36) + 16) = 18;
    *(_DWORD*)(*(_DWORD*)(this + 36) + 8) = (unsigned int)(*(_DWORD*)(this + 316) * *(_DWORD*)(this + 312) * *v3) >> 3;
    *(_WORD*)(*(_DWORD*)(this + 36) + 2) = *(_WORD*)(this + 312);
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4) = *v3;
    *(_WORD*)(*(_DWORD*)(this + 36) + 14) = *(_WORD*)(this + 316);
    **(_WORD**)(this + 36) = 1;
    *(_WORD*)(*(_DWORD*)(this + 36) + 12) = (unsigned int)(*(_DWORD*)(this + 316) * *(_DWORD*)(this + 312)) >> 3;
    v6 = (double)(unsigned int)*v3;
    if (v6 == 0.0)
        v7 = 0.0;
    else
        v7 = (double)*(int*)(this + 308) / v6;
    v8 = *(_DWORD*)(this + 300);
    *(float*)(this + 4) = v7;
    if (v8)
    {
        sf_close();
        *(_DWORD*)(this + 300) = 0;
        ++dword_5200DC;
    }
    return 1;
}
// 5200D8: using guessed type int dword_5200D8;
// 5200DC: using guessed type int dword_5200DC;

//----- (0041C940) --------------------------------------------------------
char __thiscall sub_41C940(int this)
{
    int v2; // eax
    int v3; // eax

    v2 = *(_DWORD*)(this + 32);
    if (v2)
    {
        (*(void(__stdcall**)(int))(*(_DWORD*)v2 + 72))(v2);
        (*(void(__stdcall**)(_DWORD))(**(_DWORD**)(this + 32) + 8))(*(_DWORD*)(this + 32));
        *(_DWORD*)(this + 32) = 0;
    }
    LOBYTE(v3) = *(_BYTE*)(this + 2);
    *(_BYTE*)(this + 1) = 0;
    if ((_BYTE)v3)
    {
        v3 = *(_DWORD*)(this + 300);
        if (v3)
        {
            sf_close();
            *(_DWORD*)(this + 300) = 0;
            LOBYTE(v3) = ++dword_5200DC;
        }
    }
    return v3;
}
// 5200DC: using guessed type int dword_5200DC;

//----- (0041C9A0) --------------------------------------------------------
char __thiscall sub_41C9A0(char* this, char* a2)
{
    if (ppDS->lpVtbl->DuplicateSoundBuffer(
        ppDS,
        (LPDIRECTSOUNDBUFFER) * ((_DWORD*)a2 + 8),
        (LPDIRECTSOUNDBUFFER*)(this + 32)) >= 0)
    {
        strcpy(this + 40, a2 + 40);
        *this = *a2;
        *((_DWORD*)this + 1) = *((_DWORD*)a2 + 1);
        *((_DWORD*)this + 3) = *((_DWORD*)a2 + 3);
        *((_DWORD*)this + 4) = *((_DWORD*)a2 + 4);
        *((_DWORD*)this + 5) = *((_DWORD*)a2 + 5);
        *((_DWORD*)this + 6) = *((_DWORD*)a2 + 6);
        sub_4229D0(aSoundDuplicate, a2 + 40);
        return 1;
    }
    else
    {
        sub_4229D0("SOUND: couldn't duplicate sound '%s'", a2 + 40);
        return 0;
    }
}

//----- (0041CA40) --------------------------------------------------------
char __thiscall sub_41CA40(int this)
{
    __int64 v2; // rcx
    char v4; // al
    _DWORD* v5; // edi
    int v6; // eax
    _DWORD* v7; // ebp
    int v8; // eax
    int v9; // ecx
    int v10; // edx
    double v11; // st7
    double v12; // st7
    int v13; // ebp
    unsigned int v14; // edx
    int v15; // eax
    const char* ArgList; // [esp+4Ch] [ebp-38h]
    unsigned int v17; // [esp+50h] [ebp-34h] BYREF
    int v18; // [esp+54h] [ebp-30h] BYREF
    __int64 v19; // [esp+58h] [ebp-2Ch]
    _DWORD v20[9]; // [esp+60h] [ebp-24h] BYREF

    sub_41C940(this);
    HIDWORD(v2) = 0;
    if (*(_BYTE*)(this + 2))
        return sub_41D1A0((char*)this);
    if (!ppDS)
    {
        sub_4229D0("SOUND: can't load '%s', because dsound isn't created yet", (const char*)(this + 40));
        return 0;
    }
    v4 = *(_BYTE*)(this + 40);
    *(_BYTE*)(this + 1) = 0;
    ArgList = (const char*)(this + 40);
    if (!v4)
    {
        sub_4229D0(aSoundCanTLoadS_0);
        return 0;
    }
    if (!sub_422B20((char*)(this + 40)))
    {
        sub_4229D0("SOUND: can't load sound '%s', file not readable", (const char*)(this + 40));
        return 0;
    }
    v5 = (_DWORD*)(this + 304);
    v6 = sf_open_read(this + 40, this + 304);
    *(_DWORD*)(this + 300) = v6;
    if (!v6)
    {
        sub_4229D0("SOUND: can't load sound '%s', sf_open_read failed", (const char*)(this + 40));
        return 0;
    }
    v7 = (_DWORD*)(this + 32);
    ++dword_5200D8;
    v8 = *(_DWORD*)(this + 36);
    *(_DWORD*)(this + 28) = 0;
    *(_WORD*)(v8 + 16) = 18;
    *(_DWORD*)(*(_DWORD*)(this + 36) + 8) = (unsigned int)(*v5 * *(_DWORD*)(this + 316) * *(_DWORD*)(this + 312)) >> 3;
    *(_WORD*)(*(_DWORD*)(this + 36) + 2) = *(_WORD*)(this + 312);
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4) = *v5;
    *(_WORD*)(*(_DWORD*)(this + 36) + 14) = *(_WORD*)(this + 316);
    **(_WORD**)(this + 36) = 1;
    *(_WORD*)(*(_DWORD*)(this + 36) + 12) = (unsigned int)(*(_DWORD*)(this + 316) * *(_DWORD*)(this + 312)) >> 3;
    if (!*(_DWORD*)(this + 32))
    {
        memset(v20, 0, sizeof(v20));
        v9 = *(_DWORD*)(this + 36);
        v20[2] = (unsigned int)(*(_DWORD*)(this + 316) * *(_DWORD*)(this + 312) * *(_DWORD*)(this + 308)) >> 3;
        v20[4] = v9;
        v20[0] = 36;
        v20[1] = 65762;
        if (ppDS->lpVtbl->CreateSoundBuffer(ppDS, (LPCDSBUFFERDESC)v20, (LPDIRECTSOUNDBUFFER*)(this + 32), 0) < 0)
        {
            if (*(_DWORD*)(this + 300))
            {
                sf_close();
                *(_DWORD*)(this + 300) = 0;
                ++dword_5200DC;
            }
            sub_4229D0("SOUND: can't load sound '%s', couldn't create sound buffer", ArgList);
            return 0;
        }
        (*(void(__stdcall**)(_DWORD, int))(*(_DWORD*)*v7 + 32))(*v7, this + 344);
        sub_41C740(this);
    }
    if ((*(int(__stdcall**)(_DWORD, _DWORD, _DWORD, int*, unsigned int*, _DWORD, _DWORD, int))(*(_DWORD*)*v7 + 44))(
        *v7,
        0,
        0,
        &v18,
        &v17,
        0,
        0,
        2) >= 0)
    {
        LODWORD(v2) = 2 * sf_read_short(*(_DWORD*)(this + 300), v18, v17 >> 1);
        if ((_DWORD)v2)
        {
            v10 = *(_DWORD*)(this + 36);
            HIDWORD(v19) = 0;
            v19 = *(unsigned int*)(v10 + 8);
            v11 = (double)v19;
            if (v11 == 0.0)
            {
                v12 = 0.0;
            }
            else
            {
                v19 = v2;
                v12 = (double)(int)v2 / v11;
            }
            v13 = *v7;
            v14 = v17;
            v15 = v18;
            *(float*)(this + 4) = v12;
            (*(void(__stdcall**)(int, int, unsigned int, _DWORD, _DWORD))(*(_DWORD*)v13 + 76))(v13, v15, v14, 0, 0);
            if (*(_DWORD*)(this + 300))
            {
                sf_close();
                *(_DWORD*)(this + 300) = 0;
                ++dword_5200DC;
            }
            sub_4229D0("SOUND: loaded '%s'", ArgList);
            return 1;
        }
        else
        {
            if (*(_DWORD*)(this + 300))
            {
                sf_close();
                *(_DWORD*)(this + 300) = 0;
                ++dword_5200DC;
            }
            sub_4229D0("SOUND: can't read wave file for '%s'", ArgList);
            return 0;
        }
    }
    else
    {
        if (*(_DWORD*)(this + 300))
        {
            sf_close();
            *(_DWORD*)(this + 300) = 0;
            ++dword_5200DC;
        }
        sub_4229D0("SOUND: can't lock sound buffer for '%s'", ArgList);
        return 0;
    }
}
// 46A8B6: using guessed type int __cdecl sf_open_read(_DWORD, _DWORD);
// 46A8BC: using guessed type int __cdecl sf_read_short(_DWORD, _DWORD, _DWORD);
// 5200D8: using guessed type int dword_5200D8;
// 5200DC: using guessed type int dword_5200DC;

//----- (0041CD90) --------------------------------------------------------
char __thiscall sub_41CD90(int this)
{
    int v2; // eax
    int* v3; // edi
    int v4; // ebx
    BOOL v5; // ecx

    LOBYTE(v2) = *(_BYTE*)(this + 3);
    if ((_BYTE)v2)
        LOBYTE(v2) = sub_41CA40(this);
    v3 = *(int**)(this + 32);
    *(_BYTE*)(this + 1) = 1;
    if (v3)
    {
        v4 = *v3;
        (*(void(__stdcall**)(int*, _DWORD))(*v3 + 60))(v3, (__int64)(*(float*)(this + 12) * 10000.0 - 10000.0));
        v5 = *(_BYTE*)(this + 2) || *(_BYTE*)this;
        v2 = (*(int(__stdcall**)(_DWORD, _DWORD, _DWORD, BOOL))(**(_DWORD**)(this + 32) + 48))(
            *(_DWORD*)(this + 32),
            0,
            0,
            v5);
        if (v2 == -2005401450)
        {
            v2 = (*(int(__stdcall**)(_DWORD))(**(_DWORD**)(this + 32) + 80))(*(_DWORD*)(this + 32));
            if (v2 >= 0)
            {
                if (*(_BYTE*)(this + 2))
                {
                    sub_41CE60(v4, *(_DWORD*)(this + 32));
                    (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD, int))(**(_DWORD**)(this + 32) + 48))(
                        *(_DWORD*)(this + 32),
                        0,
                        0,
                        1);
                    LOBYTE(v2) = sub_41C740(this);
                }
                else
                {
                    if (sub_41CA40(this))
                        (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD, bool))(**(_DWORD**)(this + 32) + 48))(
                            *(_DWORD*)(this + 32),
                            0,
                            0,
                            *(_BYTE*)this != 0);
                    LOBYTE(v2) = sub_41C740(this);
                }
            }
        }
    }
    else
    {
        *(_BYTE*)(this + 1) = 0;
    }
    return v2;
}

//----- (0041CE60) --------------------------------------------------------
char __usercall sub_41CE60@<al>(int a1@<ebx>, unsigned int a2)
{
    unsigned int v2; // esi
    char v3; // dl
    char* v4; // edi
    int v5; // eax
    unsigned int v6; // ecx
    char* v8; // [esp+30h] [ebp-1Ch] BYREF
    char v9[4]; // [esp+34h] [ebp-18h] BYREF
    char v10[14]; // [esp+38h] [ebp-14h] BYREF
    __int16 v11; // [esp+46h] [ebp-6h]

    v2 = a2;
    if ((*(int(__stdcall**)(unsigned int, char*, int, char*))(*(_DWORD*)a2 + 20))(a2, v10, 18, v9) < 0
        || (*(int(__stdcall**)(unsigned int, _DWORD, _DWORD, char**, unsigned int*, _DWORD, _DWORD, int))(*(_DWORD*)v2 + 44))(
            v2,
            0,
            0,
            &v8,
            &a2,
            0,
            0,
            2) < 0)
    {
        return 0;
    }
    v3 = a2;
    v4 = v8;
    LOBYTE(a1) = v11 != 8 ? 0 : 0x80;
    BYTE1(a1) = a1;
    v5 = a1 << 16;
    LOWORD(v5) = a1;
    v6 = a2 >> 2;
    memset32(v8, v5, a2 >> 2);
    memset(&v4[4 * v6], a1, v3 & 3);
    (*(void(__stdcall**)(unsigned int, char*, unsigned int, _DWORD, _DWORD))(*(_DWORD*)v2 + 76))(v2, v8, a2, 0, 0);
    return 1;
}
// 41CE60: could not find valid save-restore pair for ebx

//----- (0041CF00) --------------------------------------------------------
char __thiscall sub_41CF00(int this)
{
    int v2; // eax

    if (*(_BYTE*)(this + 3))
    {
        LOBYTE(v2) = sub_41C940(this);
        *(_BYTE*)(this + 1) = 0;
    }
    else if (*(_BYTE*)(this + 2))
    {
        LOBYTE(v2) = sub_41D1A0((char*)this);
        *(_BYTE*)(this + 1) = 0;
    }
    else
    {
        v2 = *(_DWORD*)(this + 32);
        if (v2)
        {
            (*(void(__stdcall**)(_DWORD))(*(_DWORD*)v2 + 72))(*(_DWORD*)(this + 32));
            LOBYTE(v2) = (*(int(__stdcall**)(_DWORD, _DWORD))(**(_DWORD**)(this + 32) + 52))(*(_DWORD*)(this + 32), 0);
        }
        *(_BYTE*)(this + 1) = 0;
    }
    return v2;
}

//----- (0041CF50) --------------------------------------------------------
int __thiscall sub_41CF50(int this)
{
    int result; // eax

    result = *(_DWORD*)(this + 32);
    if (result)
        result = (*(int(__stdcall**)(int))(*(_DWORD*)result + 72))(result);
    *(_BYTE*)(this + 1) = 0;
    *(_DWORD*)(this + 28) = 0;
    *(_DWORD*)(this + 340) = 0;
    return result;
}

//----- (0041CF80) --------------------------------------------------------
int __thiscall sub_41CF80(int this, float a2)
{
    unsigned int v3; // ecx
    __int64 v4; // rax

    v3 = *(_DWORD*)(this + 344);
    *(float*)(this + 8) = a2;
    v4 = (__int64)((double)v3 * a2);
    if ((_DWORD)v4)
        LODWORD(v4) = (*(int(__stdcall**)(_DWORD, _DWORD))(**(_DWORD**)(this + 32) + 68))(*(_DWORD*)(this + 32), v4);
    return v4;
}

//----- (0041CFD0) --------------------------------------------------------
int __thiscall sub_41CFD0(int this, float a2)
{
    int result; // eax
    int v3; // esi

    result = LODWORD(a2);
    v3 = *(_DWORD*)(this + 32);
    *(float*)(this + 12) = a2;
    *(float*)(this + 16) = a2;
    *(_DWORD*)(this + 20) = 0;
    if (v3)
        return (*(int(__stdcall**)(int, _DWORD))(*(_DWORD*)v3 + 60))(v3, (__int64)(a2 * 10000.0 - 10000.0));
    return result;
}

//----- (0041D010) --------------------------------------------------------
char __thiscall sub_41D010(_DWORD* this, float a2)
{
    int v2; // esi
    double v4; // st7

    v2 = this[8];
    if (!v2)
        return 0;
    v4 = a2;
    if (a2 >= -1.0)
    {
        if (v4 > 1.0)
            v4 = 1.0;
    }
    else
    {
        v4 = -1.0;
    }
    if (!(*(int(__stdcall**)(int, _DWORD))(*(_DWORD*)v2 + 64))(v2, (__int64)(v4 * 10000.0)))
        return 1;
    sub_4229D0(aSoundCouldnTPa);
    return 0;
}

//----- (0041D090) --------------------------------------------------------
char __fastcall sub_41D090(int a1)
{
    int v1; // eax
    int v3; // [esp+8h] [ebp-4h] BYREF

    v3 = a1;
    v1 = *(_DWORD*)(a1 + 32);
    if (!v1)
        return 0;
    v3 = 0;
    (*(void(__stdcall**)(int, int*))(*(_DWORD*)v1 + 36))(v1, &v3);
    return v3 & 1;
}

//----- (0041D0C0) --------------------------------------------------------
char __userpurge sub_41D0C0@<al>(int a1@<ecx>, int a2@<ebp>, float a3)
{
    char v4; // bl
    double v5; // st7
    int v6; // eax
    int v7; // ecx
    int v8; // edi

    v4 = 0;
    v5 = a3 * *(float*)(a1 + 20) + *(float*)(a1 + 12);
    *(float*)(a1 + 12) = v5;
    if (*(float*)(a1 + 20) <= 0.0 || v5 <= *(float*)(a1 + 16))
    {
        if (*(float*)(a1 + 20) < 0.0 && v5 < *(float*)(a1 + 16))
        {
            v7 = *(_DWORD*)(a1 + 16);
            *(_DWORD*)(a1 + 20) = 0;
            *(_DWORD*)(a1 + 12) = v7;
        }
    }
    else
    {
        v6 = *(_DWORD*)(a1 + 16);
        *(_DWORD*)(a1 + 20) = 0;
        *(_DWORD*)(a1 + 12) = v6;
    }
    v8 = *(_DWORD*)(a1 + 32);
    if (v8)
        (*(void(__stdcall**)(int, _DWORD))(*(_DWORD*)v8 + 60))(v8, (__int64)(*(float*)(a1 + 12) * 10000.0 - 10000.0));
    if (*(_BYTE*)(a1 + 2))
    {
        v4 = sub_41D4F0(a1, a2);
        if (!v4)
            return v4;
    }
    else
    {
        if (!*(_BYTE*)(a1 + 1) || sub_41D090(a1))
            return v4;
        *(_BYTE*)(a1 + 1) = 0;
        v4 = 1;
    }
    if (*(_BYTE*)(a1 + 3))
        sub_41C940(a1);
    return v4;
}

//----- (0041D1A0) --------------------------------------------------------
char __thiscall sub_41D1A0(char* this)
{
    char result; // al
    int v3; // eax
    int v4; // eax
    unsigned int* v5; // ebx
    _DWORD* v6; // ebp
    int v7; // eax
    int v8; // edx
    double v9; // st7
    int v10; // eax
    double v11; // st7
    int v12; // edi
    unsigned int v13; // ecx
    int v14; // eax
    int v15; // edi
    int v16; // eax
    int v17; // ecx
    int v18; // edx
    bool v19; // zf
    unsigned int v20; // ebp
    char* v21; // edi
    int v22; // eax
    int v23; // [esp+34h] [ebp-30h] BYREF
    __int64 v24; // [esp+38h] [ebp-2Ch] BYREF
    _DWORD v25[9]; // [esp+40h] [ebp-24h] BYREF

    if (ppDS)
    {
        v3 = *((_DWORD*)this + 75);
        *((_DWORD*)this + 1) = 0;
        *((_DWORD*)this + 84) = -1;
        if (v3)
        {
            sf_close();
            *((_DWORD*)this + 75) = 0;
            ++dword_5200DC;
        }
        v4 = *((_DWORD*)this + 8);
        v5 = (unsigned int*)(this + 32);
        if (v4)
        {
            (*(void(__stdcall**)(_DWORD))(*(_DWORD*)v4 + 8))(*((_DWORD*)this + 8));
            *v5 = 0;
        }
        result = sub_422B20(this + 40);
        if (result)
        {
            v6 = this + 304;
            v7 = sf_open_read(this + 40, this + 304);
            *((_DWORD*)this + 75) = v7;
            if (v7)
            {
                HIDWORD(v24) = 0;
                ++dword_5200D8;
                v8 = *((_DWORD*)this + 9);
                *((_DWORD*)this + 7) = 0;
                *(_WORD*)(v8 + 16) = 18;
                *(_DWORD*)(*((_DWORD*)this + 9) + 8) = (unsigned int)(*((_DWORD*)this + 78) * *v6 * *((_DWORD*)this + 79)) >> 3;
                *(_WORD*)(*((_DWORD*)this + 9) + 2) = *((_WORD*)this + 156);
                *(_DWORD*)(*((_DWORD*)this + 9) + 4) = *v6;
                *(_WORD*)(*((_DWORD*)this + 9) + 14) = *((_WORD*)this + 158);
                **((_WORD**)this + 9) = 1;
                *(_WORD*)(*((_DWORD*)this + 9) + 12) = (unsigned int)(*((_DWORD*)this + 78) * *((_DWORD*)this + 79)) >> 3;
                LODWORD(v24) = *v6;
                v9 = (double)v24;
                if (v9 == 0.0)
                {
                    v11 = 0.0;
                }
                else
                {
                    v10 = *((_DWORD*)this + 77);
                    v24 = (unsigned int)v10;
                    v11 = (double)v10 / v9;
                }
                *((float*)this + 1) = v11;
                HIDWORD(v24) = 0;
                memset(v25, 0, sizeof(v25));
                v12 = *((_DWORD*)this + 9);
                v25[0] = 36;
                v25[1] = 65760;
                LODWORD(v24) = *(_DWORD*)(v12 + 8);
                v25[2] = (__int64)((double)(unsigned int)v24 * 2.0);
                v25[4] = v12;
                if (ppDS->lpVtbl->CreateSoundBuffer(ppDS, (LPCDSBUFFERDESC)v25, (LPDIRECTSOUNDBUFFER*)(this + 32), 0) >= 0)
                {
                    sub_41CE60((int)v5, *v5);
                    v13 = *v5;
                    v14 = v25[2] >> 1;
                    *((_DWORD*)this + 83) = v25[2] >> 1;
                    (*(void(__stdcall**)(unsigned int, _DWORD, int, __int64*, int*, _DWORD, _DWORD, _DWORD))(*(_DWORD*)v13 + 44))(
                        v13,
                        0,
                        2 * v14,
                        &v24,
                        &v23,
                        0,
                        0,
                        0);
                    v15 = 2
                        * ((int(__cdecl*)(_DWORD, _DWORD, unsigned int))sf_read_short)(
                            *((_DWORD*)this + 75),
                            v24,
                            (unsigned int)v23 >> 1);
                    if (v15 < v23)
                    {
                        sf_close();
                        *((_DWORD*)this + 75) = 0;
                        ++dword_5200DC;
                        if (*this)
                        {
                            v16 = sf_open_read(this + 40, this + 304);
                            *((_DWORD*)this + 75) = v16;
                            *((_DWORD*)this + 7) = 0;
                            if (v16)
                            {
                                ++dword_5200D8;
                                ((void(__cdecl*)(_DWORD, _DWORD, unsigned int))sf_read_short)(
                                    *((_DWORD*)this + 75),
                                    v24 + v15,
                                    (unsigned int)(v23 - v15) >> 1);
                            }
                            else
                            {
                                sub_4229D0("Can't reset streaming sound '%s'", this + 40);
                            }
                        }
                        else
                        {
                            v17 = v23;
                            v18 = *((_DWORD*)this + 9);
                            *((_DWORD*)this + 84) = v15;
                            v19 = *(_WORD*)(v18 + 14) == 8;
                            HIWORD(v18) = WORD1(v24);
                            v20 = v17 - v15;
                            v21 = (char*)(v24 + v15);
                            LOBYTE(v18) = !v19 ? 0 : 0x80;
                            BYTE1(v18) = v18;
                            v22 = v18 << 16;
                            LOWORD(v22) = v18;
                            memset32(v21, v22, v20 >> 2);
                            memset(&v21[4 * (v20 >> 2)], v18, v20 & 3);
                        }
                    }
                    (*(void(__stdcall**)(unsigned int, _DWORD, int, _DWORD, _DWORD))(*(_DWORD*)*v5 + 76))(*v5, v24, v23, 0, 0);
                    *((_DWORD*)this + 85) = 0;
                    return 1;
                }
                else
                {
                    sub_4229D0(aSoundStreamsta_0);
                    if (*((_DWORD*)this + 75))
                    {
                        sf_close();
                        *((_DWORD*)this + 75) = 0;
                        ++dword_5200DC;
                    }
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
    }
    else
    {
        sub_4229D0(aSoundStreamsta);
        return 0;
    }
    return result;
}
// 46A8B6: using guessed type int __cdecl sf_open_read(_DWORD, _DWORD);
// 5200D8: using guessed type int dword_5200D8;
// 5200DC: using guessed type int dword_5200DC;

//----- (0041D4F0) --------------------------------------------------------
char __usercall sub_41D4F0@<al>(int a1@<ecx>, int a2@<ebp>)
{
    char v3; // bl
    int v4; // eax
    unsigned int v6; // edi
    unsigned int v7; // ecx
    unsigned int v8; // edx
    unsigned int v9; // eax
    int v10; // ebp
    unsigned int v11; // edi
    int v12; // eax
    int v13; // edx
    unsigned int v14; // ecx
    bool v15; // zf
    char v16; // bp
    char* v17; // edi
    int v18; // eax
    _BYTE v20[4]; // [esp+38h] [ebp-Ch] BYREF
    unsigned int v21; // [esp+3Ch] [ebp-8h] BYREF
    unsigned int v22; // [esp+40h] [ebp-4h] BYREF

    v3 = 0;
    v4 = *(_DWORD*)(a1 + 32);
    if (!v4)
        return 0;
    if ((*(int(__stdcall**)(int, unsigned int*, _DWORD))(*(_DWORD*)v4 + 16))(v4, &v22, 0) < 0)
        return 1;
    v6 = *(_DWORD*)(a1 + 340);
    v7 = v22;
    if (v22 < v6)
        *(float*)(a1 + 28) = *(float*)(a1 + 28) + 2.0;
    v8 = *(_DWORD*)(a1 + 336);
    if (v8 == -1)
        goto LABEL_19;
    if (v6 < v8 && v7 >= v8)
        v3 = 1;
    if (v7 < v6)
    {
        if (v7 >= v8)
            goto LABEL_16;
        if (v6 < v8)
            v3 = 1;
        if (v7 >= v8)
        {
        LABEL_16:
            sub_41CF50(a1);
            sub_41D1A0((char*)a1);
            return 1;
        }
    }
    if (!v3)
    {
    LABEL_19:
        v9 = *(_DWORD*)(a1 + 332);
        if ((v7 >= v9 && v6 < v9 || v7 < v6) && v8 == -1)
        {
            v10 = v7 < v9 ? v9 : 0;
            (*(void(__stdcall**)(_DWORD, int, unsigned int, unsigned int*, _BYTE*, _DWORD, _DWORD, _DWORD, int))(**(_DWORD**)(a1 + 32) + 44))(
                *(_DWORD*)(a1 + 32),
                v10,
                v9,
                &v21,
                v20,
                0,
                0,
                0,
                a2);
            v11 = 2 * sf_read_short(*(_DWORD*)(a1 + 300), v22, v21 >> 1);
            if (v11 < v21)
            {
                sf_close();
                *(_DWORD*)(a1 + 300) = 0;
                ++dword_5200DC;
                if (*(_BYTE*)a1)
                {
                    v12 = sf_open_read(a1 + 40, a1 + 304);
                    *(_DWORD*)(a1 + 300) = v12;
                    *(_DWORD*)(a1 + 28) = 0;
                    if (v12)
                    {
                        ++dword_5200D8;
                        sf_read_short(*(_DWORD*)(a1 + 300), v22 + v11, (v21 - v11) >> 1);
                    }
                    else
                    {
                        sub_4229D0(aSoundCanTReset);
                    }
                }
                else
                {
                    v13 = *(_DWORD*)(a1 + 36);
                    v14 = v21 - v11;
                    *(_DWORD*)(a1 + 336) = v11 + v10;
                    v15 = *(_WORD*)(v13 + 14) == 8;
                    HIWORD(v13) = HIWORD(v22);
                    v16 = v14;
                    v17 = (char*)(v22 + v11);
                    LOBYTE(v13) = !v15 ? 0 : 0x80;
                    BYTE1(v13) = v13;
                    v18 = v13 << 16;
                    LOWORD(v18) = v13;
                    v14 >>= 2;
                    memset32(v17, v18, v14);
                    memset(&v17[4 * v14], v13, v16 & 3);
                }
            }
            (*(void(__stdcall**)(_DWORD, unsigned int, unsigned int, _DWORD))(**(_DWORD**)(a1 + 32) + 76))(
                *(_DWORD*)(a1 + 32),
                v22,
                v21,
                0);
            v7 = v22;
        }
        *(_DWORD*)(a1 + 340) = v7;
        return v3;
    }
    else
    {
        sub_41CF50(a1);
        sub_41D1A0((char*)a1);
        return v3;
    }
}
// 41D4F0: could not find valid save-restore pair for ebp
// 46A8B6: using guessed type int __cdecl sf_open_read(_DWORD, _DWORD);
// 46A8BC: using guessed type int __cdecl sf_read_short(_DWORD, _DWORD, _DWORD);
// 5200D8: using guessed type int dword_5200D8;
// 5200DC: using guessed type int dword_5200DC;

//----- (0041D700) --------------------------------------------------------
void __thiscall sub_41D700(_DWORD* this)
{
    int v2; // eax
    int v3; // ecx
    _DWORD* v4; // esi
    int v5; // eax
    _DWORD* v6; // edi
    _DWORD* v7; // edx
    int v8; // ecx

    v2 = this[68] - 1;
    this[68] = v2;
    if (!v2 && !this[69])
    {
        if (dword_5200E8)
        {
            v3 = *(_DWORD*)(dword_5200E8 + 24);
            v4 = (_DWORD*)(dword_5200E8 + 20);
            v5 = 0;
            if (v3 > 0)
            {
                v6 = (_DWORD*)*v4;
                v7 = (_DWORD*)*v4;
                while ((_DWORD*)*v7 != this)
                {
                    ++v5;
                    ++v7;
                    if (v5 >= v3)
                        goto LABEL_11;
                }
                v8 = v3 - 1;
                *(_DWORD*)(dword_5200E8 + 24) = v8;
                if (v5 != v8)
                {
                    memcpy(&v6[v5], &v6[v5 + 1], 4 * (v8 + 0x3FFFFFFF * v5));
                    *(_DWORD*)(*v4 + 4 * v4[1]) = 0;
                }
            }
        }
    LABEL_11:
        if (this)
        {
            sub_403880((int)this);
            sub_4885A6(this);
        }
    }
}
// 5200E8: using guessed type int dword_5200E8;

//----- (0041D790) --------------------------------------------------------
void __thiscall sub_41D790(_DWORD* this)
{
    ++this[69];
}

//----- (0041D7A0) --------------------------------------------------------
void __thiscall sub_41D7A0(_DWORD* this)
{
    int v2; // edx
    int v3; // ecx
    int v4; // edx
    int v5; // ecx
    _DWORD* v6; // esi
    int v7; // eax
    _DWORD* v8; // ebx
    _DWORD* v9; // edx
    int v10; // ecx

    v2 = this[69];
    v3 = this[68];
    v4 = v2 - 1;
    this[69] = v4;
    if (!v3 && !v4)
    {
        if (dword_5200E8)
        {
            v5 = *(_DWORD*)(dword_5200E8 + 24);
            v6 = (_DWORD*)(dword_5200E8 + 20);
            v7 = 0;
            if (v5 > 0)
            {
                v8 = (_DWORD*)*v6;
                v9 = (_DWORD*)*v6;
                while ((_DWORD*)*v9 != this)
                {
                    ++v7;
                    ++v9;
                    if (v7 >= v5)
                        goto LABEL_11;
                }
                v10 = v5 - 1;
                *(_DWORD*)(dword_5200E8 + 24) = v10;
                if (v7 != v10)
                {
                    memcpy(&v8[v7], &v8[v7 + 1], 4 * (v10 + 0x3FFFFFFF * v7));
                    *(_DWORD*)(*v6 + 4 * v6[1]) = 0;
                }
            }
        }
    LABEL_11:
        if (this)
        {
            sub_403880((int)this);
            sub_4885A6(this);
        }
    }
}
// 5200E8: using guessed type int dword_5200E8;

//----- (0041D840) --------------------------------------------------------
char __thiscall sub_41D840(int this)
{
    char result; // al

    result = *(_BYTE*)(this + 16);
    if (!result)
    {
        *(_BYTE*)(this + 16) = 1;
        *(_DWORD*)(this + 20) = 0;
    }
    return result;
}

//----- (0041D860) --------------------------------------------------------
char __thiscall sub_41D860(int this)
{
    char result; // al
    int v3; // ecx

    result = *(_BYTE*)(this + 16);
    if (result)
    {
        v3 = *(_DWORD*)(this + 12);
        *(_BYTE*)(this + 16) = 0;
        if (v3)
        {
            sub_41CF50(v3);
            *(_DWORD*)(this + 12) = 0;
        }
        result = *(_BYTE*)(this + 52);
        if (result)
            return sub_41D9A0(this);
    }
    return result;
}

//----- (0041D8A0) --------------------------------------------------------
char __thiscall sub_41D8A0(_BYTE* this, char a2)
{
    char result; // al

    result = a2;
    this[68] = a2;
    return result;
}

//----- (0041D8B0) --------------------------------------------------------
int __thiscall sub_41D8B0(_DWORD* this, int a2, int a3, int a4, int a5, int a6, int a7)
{
    int result; // eax

    this[18] = a2;
    this[19] = a3;
    this[20] = a4;
    result = a6;
    this[21] = a5;
    this[22] = a6;
    this[23] = a7;
    return result;
}

//----- (0041D8E0) --------------------------------------------------------
int __thiscall sub_41D8E0(int this, char a2, int a3)
{
    int result; // eax

    LOBYTE(result) = a2;
    *(_BYTE*)(this + 96) = a2;
    *(_DWORD*)(this + 100) = a3;
    return result;
}

//----- (0041D900) --------------------------------------------------------
int __thiscall sub_41D900(_DWORD* this, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
    int result; // eax

    this[26] = a2;
    this[27] = a3;
    this[28] = a4;
    this[29] = a5;
    this[30] = a6;
    result = a8;
    this[31] = a7;
    this[32] = a8;
    return result;
}

//----- (0041D940) --------------------------------------------------------
int __thiscall sub_41D940(_DWORD* this, int a2, int a3)
{
    int result; // eax

    result = a2;
    this[33] = a2;
    this[34] = a3;
    return result;
}

//----- (0041D960) --------------------------------------------------------
int __thiscall sub_41D960(_DWORD* this, _DWORD* a2, _DWORD* a3)
{
    _DWORD* v3; // eax
    _DWORD* v4; // ecx
    int result; // eax

    v3 = this + 7;
    v4 = this + 10;
    *v3 = *a2;
    v3[1] = a2[1];
    v3[2] = a2[2];
    *v4 = *a3;
    v4[1] = a3[1];
    result = a3[2];
    v4[2] = result;
    return result;
}

//----- (0041D9A0) --------------------------------------------------------
int __thiscall sub_41D9A0(int this)
{
    int v2; // ecx
    int result; // eax

    v2 = *(_DWORD*)(this + 12);
    if (v2)
    {
        result = sub_41CF50(v2);
        *(_DWORD*)(this + 12) = 0;
    }
    *(_BYTE*)(this + 53) = 1;
    return result;
}

//----- (0041D9C0) --------------------------------------------------------
_DWORD* __thiscall sub_41D9C0(_DWORD* this)
{
    _DWORD* v2; // eax
    _DWORD* v3; // ecx
    int v4; // edx
    void* v5; // edi
    int v6; // eax

    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
    *((_BYTE*)this + 16) = 1;
    this[5] = 0;
    this[6] = 0;
    this[7] = 0;
    *((_BYTE*)this + 32) = 1;
    this[10] = 0;
    this[11] = 0;
    this[12] = 0;
    *((_BYTE*)this + 52) = 0;
    this[14] = 0;
    this[15] = 0;
    this[16] = 0;
    this[17] = 0;
    this[18] = 0;
    this[19] = 0;
    this[20] = 0;
    this[21] = 0;
    this[22] = 0;
    this[23] = 0;
    this[24] = 0;
    this[25] = 0;
    *this = &off_4992B4;
    dword_5200E8 = (int)this;
    byte_4A34BC = sub_422BA0(AppName, aDoppler, 1) != 0;
    *(_DWORD*)&dword_4A34C0 = sub_422BA0(AppName, aVolume, 100);
    v2 = operator new(0x4600u);
    if (v2)
    {
        v3 = v2 + 9;
        v4 = 128;
        do
        {
            *(v3 - 2) = 0;
            *(v3 - 1) = 0;
            *v3 = 0;
            v3[1] = 0;
            v3[2] = 0;
            v3[3] = 0;
            v3 += 35;
            --v4;
        } while (v4);
        v5 = v2;
    }
    else
    {
        v5 = 0;
    }
    v6 = 0;
    this[9] = v5;
    memset(v5, 0, 0x4600u);
    do
    {
        v6 += 140;
        *(_DWORD*)(this[9] + v6 - 140) = 0;
    } while (v6 < 17920);
    this[26] = 0;
    return this;
}
// 4992B4: using guessed type _UNKNOWN *off_4992B4;
// 4A34BC: using guessed type char byte_4A34BC;
// 5200E8: using guessed type int dword_5200E8;

//----- (0041DB10) --------------------------------------------------------
void __thiscall sub_41DB10(_DWORD* this)
{
    _DWORD* v1; // ebx
    int i; // esi
    int v3; // eax
    void* v4; // edi
    int v5; // esi
    int v6; // edx
    int v7; // eax
    int v8; // ecx
    int v9; // esi
    int v10; // edi
    void** v11; // edx
    int v12; // ecx
    int v13; // eax
    int v14; // ebp
    int v15; // ecx
    void** v16; // ebp
    int j; // ebx
    void* v18; // edi
    int v19; // ecx
    int v20; // eax
    _DWORD* v21; // edi
    _DWORD* v22; // edx
    int v23; // ecx
    void** v24; // esi
    int k; // edi
    void* v26; // ecx
    void* v27; // eax
    void* v28; // [esp-4h] [ebp-30h]
    char ArgList[4]; // [esp+14h] [ebp-18h]
    int v31; // [esp+18h] [ebp-14h]
    void* v32; // [esp+1Ch] [ebp-10h]

    v1 = this;
    *this = &off_4992B4;
    for (i = 0; i < 17920; i += 140)
    {
        v3 = v1[9];
        v4 = *(void**)(v3 + i);
        if (v4)
        {
            sub_4213B0(*(_DWORD*)(v3 + i));
            sub_4885A6(v4);
        }
    }
    sub_4885A6((LPVOID)v1[9]);
    v1[9] = 0;
    v5 = v1[6] - 1;
    v31 = v5;
    if (v5 >= 0)
    {
        while (1)
        {
            v6 = v1[6];
            v7 = 0;
            if (v6 > 0)
            {
                v8 = v1[5];
                do
                {
                    ++v7;
                    v8 += 4;
                } while (v7 < v6);
            }
            v9 = *(_DWORD*)(v1[5] + 4 * v5);
            sub_4229D0("SoundManager: Deleting soundresource '%s'", (const char*)(v9 + 4));
            v10 = *(_DWORD*)(v9 + 268) - 1;
            if (v10 >= 0)
            {
                *(_DWORD*)ArgList = *(_DWORD*)(v9 + 268);
                do
                {
                    sub_4229D0("SoundManager: Deleting copy %d", *(_DWORD*)ArgList);
                    v11 = *(void***)(v9 + 280);
                    v12 = *(_DWORD*)(v9 + 284);
                    v32 = v11[v10];
                    v13 = 0;
                    if (v12 > 0)
                    {
                        v14 = *(_DWORD*)(v9 + 280);
                        while (*v11 != v32)
                        {
                            ++v13;
                            ++v11;
                            if (v13 >= v12)
                                goto LABEL_20;
                        }
                        v15 = v12 - 1;
                        *(_DWORD*)(v9 + 284) = v15;
                        if (v13 != v15)
                        {
                            memcpy((void*)(v14 + 4 * v13), (const void*)(v14 + 4 * v13 + 4), 4 * (v15 + 0x3FFFFFFF * v13));
                            *(_DWORD*)(*(_DWORD*)(v9 + 280) + 4 * *(_DWORD*)(v9 + 284)) = 0;
                        }
                    LABEL_20:
                        v1 = this;
                    }
                    if (v32)
                    {
                        sub_41C700((int)v32);
                        sub_4885A6(v32);
                    }
                    --v10;
                    --*(_DWORD*)ArgList;
                } while (v10 >= 0);
            }
            v16 = (void**)(v9 + 280);
            if (*(_BYTE*)(v9 + 292))
            {
                for (j = 0; j < *(_DWORD*)(v9 + 284); ++j)
                {
                    v18 = (void*)*((_DWORD*)*v16 + j);
                    if (v18)
                    {
                        sub_41C700(*((_DWORD*)*v16 + j));
                        sub_4885A6(v18);
                    }
                }
                v1 = this;
            }
            memset(*v16, 0, 4 * *(_DWORD*)(v9 + 284));
            v28 = *v16;
            *(_DWORD*)(v9 + 284) = 0;
            sub_488CEE(v28);
            *(_DWORD*)(v9 + 288) = 0;
            *v16 = 0;
            v19 = v1[6];
            v20 = 0;
            if (v19 > 0)
            {
                v21 = (_DWORD*)v1[5];
                v22 = v21;
                while (*v22 != v9)
                {
                    ++v20;
                    ++v22;
                    if (v20 >= v19)
                        goto LABEL_37;
                }
                v23 = v19 - 1;
                v1[6] = v23;
                if (v20 != v23)
                {
                    memcpy(&v21[v20], &v21[v20 + 1], 4 * (v23 + 0x3FFFFFFF * v20));
                    *(_DWORD*)(v1[5] + 4 * v1[6]) = 0;
                }
            }
        LABEL_37:
            if (v9)
            {
                sub_41F1A0(v9 + 280, 1);
                sub_4885A6((LPVOID)v9);
            }
            sub_4229D0(aSoundmanagerDo);
            if (--v31 < 0)
                break;
            v5 = v31;
        }
    }
    v24 = (void**)(v1 + 5);
    if (*((_BYTE*)v1 + 32))
    {
        for (k = 0; k < v1[6]; ++k)
        {
            v26 = (void*)*((_DWORD*)*v24 + k);
            if (v26)
                sub_403860(v26, 1);
        }
    }
    memset(*v24, 0, 4 * v1[6]);
    v27 = *v24;
    v1[6] = 0;
    sub_488CEE(v27);
    v1[7] = 0;
    *v24 = 0;
    dword_5200E8 = 0;
    sub_45CF30((int)(v1 + 10), 1);
    sub_41F220((int)(v1 + 5), 1);
    *v1 = &off_499040;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 4992B4: using guessed type _UNKNOWN *off_4992B4;
// 5200E8: using guessed type int dword_5200E8;

//----- (0041DE10) --------------------------------------------------------
char* __thiscall sub_41DE10(_DWORD* this, char* String2, int a3, char a4, char a5, char a6, char a7)
{
    int v8; // esi
    char* v9; // ebp
    int v10; // edi
    _BYTE* v11; // eax
    int v12; // edi
    char* v13; // esi
    _DWORD* v14; // eax
    int v16; // eax
    int v17; // ecx
    int v18; // eax
    void* v19; // ecx
    int v20; // eax
    char* v21; // eax
    int v22; // edi
    int v23; // ecx
    int v24; // eax
    int v25; // ecx
    void* v26; // edx
    int v27; // eax
    char* v28; // eax
    int v29; // esi
    int v30; // ecx
    int v31; // edx
    int v32; // edi
    _DWORD* v33; // eax
    char* v34; // ebx
    int v35; // eax
    int v36; // ecx
    void* v37; // ecx
    int v38; // eax
    char* v39; // eax
    int v40; // esi
    int v41; // ecx
    char v42; // [esp+13h] [ebp-11h]
    int v43; // [esp+14h] [ebp-10h]
    char v44; // [esp+2Ch] [ebp+8h]
    int v45; // [esp+34h] [ebp+10h]
    char* v46; // [esp+3Ch] [ebp+18h]

    v8 = 0;
    v9 = 0;
    v43 = this[6];
    if (v43 > 0)
    {
        while (1)
        {
            v10 = *(_DWORD*)(this[5] + 4 * v8);
            if (!_strcmpi((const char*)(v10 + 4), String2))
                break;
            if (++v8 >= v43)
                goto LABEL_6;
        }
        v9 = (char*)v10;
        ++*(_DWORD*)(v10 + 272);
    }
LABEL_6:
    v42 = 0;
    if (!v9)
    {
        v11 = operator new(0x128u);
        if (v11)
        {
            v11[264] = 0;
            v11[265] = 1;
            v11[266] = 0;
            v11[267] = 0;
            *((_DWORD*)v11 + 67) = 0;
            *((_DWORD*)v11 + 68) = 1;
            *((_DWORD*)v11 + 69) = 0;
            *((_DWORD*)v11 + 70) = 0;
            *((_DWORD*)v11 + 71) = 0;
            *((_DWORD*)v11 + 72) = 0;
            v11[292] = 1;
            v11[4] = 0;
            v9 = v11;
        }
        else
        {
            v9 = 0;
        }
        *(_DWORD*)v9 = -221101263;
        strcpy(v9 + 4, String2);
        v42 = 1;
        *((_DWORD*)v9 + 67) = 0;
        v9[267] = a7;
        v9[264] = a4;
        v9[265] = a5;
        v9[266] = a6;
    }
    v12 = a3;
    v13 = 0;
    if (!a3)
        return v9;
    if (*((_DWORD*)v9 + 67))
    {
        v46 = (char*)**((_DWORD**)v9 + 70);
    LABEL_26:
        if (v42)
        {
            v24 = this[7];
            v25 = this[6] + 1;
            this[6] = v25;
            if (v25 > v24)
            {
                v26 = (void*)this[5];
                v27 = v24 + 8;
                this[7] = v27;
                v28 = (char*)sub_488DD7(v26, 4 * v27);
                if (v28)
                {
                    v29 = this[6];
                    v30 = this[7] - v29;
                    this[5] = v28;
                    memset(&v28[4 * v29], 0, 4 * v30);
                    v12 = a3;
                }
            }
            *(_DWORD*)(this[5] + 4 * this[6] - 4) = v9;
        }
        v31 = v12;
        v32 = v12 - 1;
        if (v31)
        {
            v44 = a5 == 0;
            v45 = v32 + 1;
            do
            {
                v33 = operator new(0x15Cu);
                if (v33)
                    v34 = (char*)sub_41C6A0(v33);
                else
                    v34 = 0;
                sub_41C7E0(v46, v44);
                sub_41C7A0((int)v46, a6);
                if (v9[267] || v9[266] || !v9[265])
                {
                    sub_41C760((int)v34, String2);
                    sub_41CA40((int)v34);
                }
                else
                {
                    sub_41C9A0(v34, v46);
                }
                v35 = *((_DWORD*)v9 + 72);
                v36 = *((_DWORD*)v9 + 71) + 1;
                *((_DWORD*)v9 + 71) = v36;
                if (v36 > v35)
                {
                    v37 = (void*)*((_DWORD*)v9 + 70);
                    v38 = v35 + 8;
                    *((_DWORD*)v9 + 72) = v38;
                    v39 = (char*)sub_488DD7(v37, 4 * v38);
                    if (v39)
                    {
                        v40 = *((_DWORD*)v9 + 71);
                        v41 = *((_DWORD*)v9 + 72) - v40;
                        *((_DWORD*)v9 + 70) = v39;
                        memset(&v39[4 * v40], 0, 4 * v41);
                    }
                }
                *(_DWORD*)(*((_DWORD*)v9 + 70) + 4 * *((_DWORD*)v9 + 71) - 4) = v34;
                *v34 = a4;
                ++*((_DWORD*)v9 + 67);
                --v45;
            } while (v45);
        }
        return v9;
    }
    v14 = operator new(0x15Cu);
    if (v14)
        v13 = (char*)sub_41C6A0(v14);
    v46 = v13;
    sub_41C7A0((int)v13, a6);
    sub_41C760((int)v13, String2);
    *v13 = a4;
    sub_41C7E0(v13, a5 == 0);
    if (sub_41CA40((int)v13))
    {
        v16 = *((_DWORD*)v9 + 71) + 1;
        *((_DWORD*)v9 + 71) = v16;
        v17 = v16;
        v18 = *((_DWORD*)v9 + 72);
        if (v17 > v18)
        {
            v19 = (void*)*((_DWORD*)v9 + 70);
            v20 = v18 + 8;
            *((_DWORD*)v9 + 72) = v20;
            v21 = (char*)sub_488DD7(v19, 4 * v20);
            if (v21)
            {
                v22 = *((_DWORD*)v9 + 71);
                v23 = *((_DWORD*)v9 + 72) - v22;
                *((_DWORD*)v9 + 70) = v21;
                memset(&v21[4 * v22], 0, 4 * v23);
                v12 = a3;
            }
        }
        *(_DWORD*)(*((_DWORD*)v9 + 70) + 4 * *((_DWORD*)v9 + 71) - 4) = v13;
        --v12;
        ++*((_DWORD*)v9 + 67);
        a3 = v12;
        goto LABEL_26;
    }
    if (v13)
    {
        sub_41C700((int)v13);
        sub_4885A6(v13);
    }
    if (v9)
        sub_41D700(v9);
    return 0;
}

//----- (0041E250) --------------------------------------------------------
int __thiscall sub_41E250(_DWORD* this, char* String2)
{
    int v4; // esi
    int v5; // edi
    char* String2a; // [esp+14h] [ebp+4h]

    sub_4229D0("FindSoundResource(%s)", String2);
    v4 = 0;
    String2a = (char*)this[6];
    if ((int)String2a <= 0)
    {
    LABEL_4:
        sub_4229D0("FindSoundResource(%s) failed to find the sound", String2);
        return 0;
    }
    else
    {
        while (1)
        {
            v5 = *(_DWORD*)(this[5] + 4 * v4);
            if (!_strcmpi((const char*)(v5 + 4), String2))
                break;
            if (++v4 >= (int)String2a)
                goto LABEL_4;
        }
        sub_4229D0("FindSoundResource(%s) worked: %d", String2, v4);
        return v5;
    }
}

//----- (0041E2D0) --------------------------------------------------------
int __thiscall sub_41E2D0(_DWORD* this, _DWORD* a2, char a3, char a4)
{
    int v5; // eax
    int i; // esi
    _DWORD* v8; // ecx
    _DWORD* v9; // eax

    v5 = 0;
    for (i = this[9]; *(_DWORD*)(i + 8); i += 140)
    {
        if (++v5 >= 128)
            return 0;
    }
    v8 = *(_DWORD**)(i + 8);
    if (v8)
    {
        sub_41D7A0(v8);
        *(_DWORD*)(i + 8) = 0;
    }
    *(_DWORD*)(i + 12) = 0;
    *(_BYTE*)(i + 16) = 0;
    *(_DWORD*)(i + 28) = 0;
    *(_DWORD*)(i + 32) = 0;
    *(_DWORD*)(i + 36) = 0;
    *(_DWORD*)(i + 40) = 0;
    *(_DWORD*)(i + 44) = 0;
    *(_DWORD*)(i + 48) = 0;
    *(_BYTE*)(i + 52) = 0;
    *(_BYTE*)(i + 53) = 0;
    *(_DWORD*)(i + 56) = 0;
    *(_DWORD*)(i + 8) = a2;
    sub_41D790(a2);
    *(_BYTE*)(i + 52) = a3;
    *(_BYTE*)(i + 24) = a4;
    v9 = sub_409960((_DWORD*)dword_520970, (int)this);
    *(_DWORD*)(i + 4) = v9;
    v9[10] = i;
    *(_DWORD*)(i + 64) = 1065353216;
    sub_41D8A0((_BYTE*)i, 0);
    sub_41D8B0((_DWORD*)i, 1133903872, 1065353216, 1065353216, 1189765120, 0, 1065353216);
    sub_41D8E0(i, 0, 0);
    sub_41D900((_DWORD*)i, 1120403456, 0, 0, 1065353216, 1065353216, 1065353216, 1065353216);
    *(_DWORD*)(i + 132) = 0;
    *(_DWORD*)(i + 136) = 0;
    return i;
}
// 520970: using guessed type int dword_520970;

//----- (0041E3D0) --------------------------------------------------------
char __stdcall sub_41E3D0(int a1)
{
    int v1; // eax
    int v2; // edx
    int i; // ecx

    v1 = 0;
    v2 = *(_DWORD*)(a1 + 284);
    if (v2 <= 0)
        return 0;
    for (i = *(_DWORD*)(a1 + 280); *(_BYTE*)(*(_DWORD*)i + 1); i += 4)
    {
        if (++v1 >= v2)
            return 0;
    }
    return 1;
}

//----- (0041E410) --------------------------------------------------------
char __thiscall sub_41E410(_DWORD* this, int a2)
{
    int v2; // ebp
    _DWORD* v3; // eax
    _DWORD* v4; // esi
    int v5; // ebx
    float* v6; // ecx
    long double v7; // st4
    int v8; // eax
    int i; // esi
    int v10; // edi
    int v11; // esi
    _DWORD* v12; // ecx
    int v13; // ecx
    char v14; // al
    double v15; // st7
    double v16; // st6
    double v17; // st5
    int v18; // ecx
    int v19; // eax
    float* v20; // eax
    char v21; // al
    int v22; // ecx
    int* v23; // eax
    double v24; // st7
    int v25; // eax
    int v26; // eax
    _DWORD* v27; // eax
    int v28; // esi
    int v29; // eax
    int v30; // eax
    int v31; // edx
    int v32; // ecx
    int v33; // eax
    _DWORD* v34; // edx
    int v35; // edi
    int v36; // esi
    int v37; // ecx
    char v38; // cl
    int v39; // esi
    int v40; // ebp
    int v41; // edi
    int v42; // ecx
    int v43; // edx
    int* v44; // eax
    int k; // ecx
    int m; // esi
    int v47; // eax
    int v49; // [esp+18h] [ebp-14h]
    _DWORD* j; // [esp+18h] [ebp-14h]
    float ArgLista; // [esp+1Ch] [ebp-10h]
    float ArgListb; // [esp+1Ch] [ebp-10h]
    char ArgList[4]; // [esp+1Ch] [ebp-10h]
    int v55; // [esp+24h] [ebp-8h] BYREF
    int v56; // [esp+28h] [ebp-4h] BYREF

    v2 = (int)this;
    v3 = (_DWORD*)sub_408F30((_DWORD*)dword_520970);
    v4 = v3;
    v5 = 0;
    if (v3)
    {
        *(_DWORD*)(v2 + 56) = v3[8];
        *(_DWORD*)(v2 + 60) = v3[9];
        *(_DWORD*)(v2 + 64) = v3[10];
        v6 = (float*)(v2 + 80);
        *(_DWORD*)(v2 + 80) = v3[11];
        *(_DWORD*)(v2 + 84) = v3[12];
        *(_DWORD*)(v2 + 88) = v3[13];
        *(float*)(v2 + 80) = *(float*)(v2 + 80) - *(float*)(v2 + 56);
        *(float*)(v2 + 84) = *(float*)(v2 + 84) - *(float*)(v2 + 60);
        *(float*)(v2 + 88) = *(float*)(v2 + 88) - *(float*)(v2 + 64);
        v7 = sqrt(
            *(float*)(v2 + 80) * *(float*)(v2 + 80)
            + *(float*)(v2 + 84) * *(float*)(v2 + 84)
            + *(float*)(v2 + 88) * *(float*)(v2 + 88));
        if (v7 >= 0.0000099999997 || v7 <= -0.0000099999997)
        {
            if (v7 == 0.0)
            {
                sub_40E550(v6, 0.0);
            }
            else
            {
                ArgListb = 1.0 / v7;
                sub_40E550(v6, ArgListb);
            }
        }
        else
        {
            ArgLista = 1.0 / 1.0;
            sub_40E550(v6, ArgLista);
        }
        *(_DWORD*)(v2 + 92) = v4[14];
        *(_DWORD*)(v2 + 96) = v4[15];
        *(_DWORD*)(v2 + 100) = v4[16];
        v8 = dword_520970 + 104;
        *(_DWORD*)(v2 + 68) = *(_DWORD*)(dword_520970 + 104);
        *(_DWORD*)(v2 + 72) = *(_DWORD*)(v8 + 4);
        *(_DWORD*)(v2 + 76) = *(_DWORD*)(v8 + 8);
    }
    if (*(_BYTE*)(v2 + 52))
    {
        for (i = 0; i < *(_DWORD*)(v2 + 44); ++i)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(v2 + 40) + 4 * i));
    }
    memset(*(void**)(v2 + 40), 0, 4 * *(_DWORD*)(v2 + 44));
    *(_DWORD*)ArgList = 0;
    v10 = 0;
    *(_DWORD*)(v2 + 44) = 0;
    v49 = 0;
    do
    {
        v11 = v10 + *(_DWORD*)(v2 + 36);
        if (*(_BYTE*)(v11 + 53))
        {
            sub_409A00(dword_520970, *(void**)(v11 + 4));
            v12 = *(_DWORD**)(v11 + 8);
            *(_DWORD*)(v11 + 4) = 0;
            if (v12)
            {
                sub_41D7A0(v12);
                *(_DWORD*)(v11 + 8) = 0;
            }
            *(_DWORD*)(v11 + 12) = 0;
            *(_BYTE*)(v11 + 16) = 0;
            *(_DWORD*)(v11 + 28) = 0;
            *(_DWORD*)(v11 + 32) = 0;
            *(_DWORD*)(v11 + 36) = 0;
            *(_DWORD*)(v11 + 40) = 0;
            *(_DWORD*)(v11 + 44) = 0;
            *(_DWORD*)(v11 + 48) = 0;
            *(_BYTE*)(v11 + 52) = 0;
            *(_BYTE*)(v11 + 53) = 0;
            *(_DWORD*)(v11 + 56) = 0;
            goto LABEL_37;
        }
        if (*(_DWORD*)(v11 + 8))
        {
            v13 = *(_DWORD*)(v11 + 12);
            if (v13)
            {
                sub_41D0C0(v13, v2, *(float*)&a2);
                if (!*(_BYTE*)(*(_DWORD*)(v11 + 12) + 1))
                {
                    v14 = *(_BYTE*)(v11 + 52);
                    *(_DWORD*)(v11 + 12) = 0;
                    *(_BYTE*)(v11 + 16) = 0;
                    if (v14)
                        sub_41D9A0(v11);
                    goto LABEL_35;
                }
            }
        }
        if (*(_BYTE*)(v11 + 16))
        {
            v15 = *(float*)(v2 + 56) - *(float*)(v11 + 28);
            v16 = *(float*)(v2 + 60) - *(float*)(v11 + 32);
            v17 = *(float*)(v2 + 64) - *(float*)(v11 + 36);
            *(float*)(v11 + 56) = sqrt(v17 * v17 + v16 * v16 + v15 * v15);
            v18 = *(_DWORD*)(v2 + 48);
            v19 = *(_DWORD*)(v2 + 44) + 1;
            *(_DWORD*)(v2 + 44) = v19;
            if (v19 > v18)
                sub_41F2A0((void**)(v2 + 40));
            v10 = v49;
            *(_DWORD*)(*(_DWORD*)(v2 + 40) + 4 * *(_DWORD*)(v2 + 44) - 4) = v11;
        }
        if (*(float*)(v2 + 104) != 0.0 && *(_DWORD*)v11)
        {
            v20 = (float*)sub_408F30((_DWORD*)dword_520970);
            v21 = sub_402300(v20, (float*)(v11 + 28), &v56, &v55);
            v22 = *(_DWORD*)v11;
            if (v21)
            {
                *(_BYTE*)(v22 + 33) = 1;
                sub_421540((void**)v22);
                v23 = dword_4A35D0;
                if (!*(_BYTE*)(v11 + 16))
                    v23 = dword_4A35CC;
                sub_421190(*(_DWORD*)v11, aDSD, *(_DWORD*)ArgList, v23, *(_DWORD*)(v11 + 60), *(float*)(v11 + 56));
                v24 = (double)v55;
                v25 = *(_DWORD*)v11;
                *(float*)(v25 + 12) = (float)v56;
                *(_BYTE*)(v25 + 32) = 1;
                *(float*)(v25 + 16) = v24;
                goto LABEL_34;
            }
        LABEL_33:
            *(_BYTE*)(v22 + 33) = 0;
            sub_421540((void**)v22);
            goto LABEL_34;
        }
        v22 = *(_DWORD*)v11;
        if (*(_DWORD*)v11)
            goto LABEL_33;
    LABEL_34:
        *(_DWORD*)(v11 + 60) = -1;
    LABEL_35:
        v26 = *(_DWORD*)(v11 + 4);
        if (v26)
        {
            v27 = (_DWORD*)(v26 + 16);
            *v27 = *(_DWORD*)(v11 + 28);
            v27[1] = *(_DWORD*)(v11 + 32);
            v27[2] = *(_DWORD*)(v11 + 36);
            *(_DWORD*)(*(_DWORD*)(v11 + 4) + 28) = 0;
            *(_DWORD*)(*(_DWORD*)(v11 + 4) + 12) = 2;
        }
    LABEL_37:
        v10 += 140;
        ++*(_DWORD*)ArgList;
        v49 = v10;
    } while (v10 < 17920);
    qsort(*(void**)(v2 + 40), *(_DWORD*)(v2 + 44), 4u, (_CoreCrtNonSecureSearchSortCompareFunction)sub_41E920);
    v29 = 0;
    v55 = *(_DWORD*)(v2 + 44);
    v28 = v55;
    if (v55 > 0)
    {
        do
        {
            *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v2 + 40) + 4 * v29) + 60) = v29;
            ++v29;
        } while (v29 < v28);
    }
    if (v28 > 0)
    {
        while (1)
        {
            v30 = *(_DWORD*)(v2 + 40);
            v31 = *(_DWORD*)(v30 + 4 * v5);
            v32 = v30 + 4 * v5;
            v33 = v5;
            v34 = *(_DWORD**)(v31 + 8);
            for (j = v34; v33 < v28; v32 += 4)
            {
                if (*(_DWORD**)(*(_DWORD*)v32 + 8) != v34)
                    break;
                *(_DWORD*)ArgList = v33++;
            }
            v35 = *(_DWORD*)ArgList;
            if (*(int*)ArgList > v34[67] + v5 - 1)
            {
                do
                {
                    v36 = *(_DWORD*)(*(_DWORD*)(v2 + 40) + 4 * v35);
                    v37 = *(_DWORD*)(v36 + 12);
                    if (v37)
                    {
                        sub_41CF00(v37);
                        v38 = *(_BYTE*)(v36 + 52);
                        *(_DWORD*)(v36 + 12) = 0;
                        if (v38)
                        {
                            sub_41D9A0(v36);
                        }
                        else if (!*(_BYTE*)(*(_DWORD*)(v36 + 8) + 264))
                        {
                            *(_BYTE*)(v36 + 16) = 0;
                            *(_DWORD*)(v36 + 20) = 0;
                        }
                        v34 = j;
                    }
                    --v35;
                } while (v35 > v34[67] + v5 - 1);
                v35 = *(_DWORD*)ArgList;
            }
            v39 = 0;
            v40 = v5;
            if (v5 <= v35)
            {
                while (v40 < v5 + v34[67])
                {
                    v41 = *(_DWORD*)(this[10] + 4 * v40);
                    if (!*(_DWORD*)(v41 + 12))
                    {
                        v42 = v34[70];
                        v43 = v34[71];
                        v44 = (int*)(v42 + 4 * v39);
                        for (k = *v44; v39 < v43; ++v44)
                        {
                            if (!*(_BYTE*)(k + 1))
                                break;
                            k = v44[1];
                            ++v39;
                        }
                        if (!k || *(_BYTE*)(k + 1))
                            break;
                        *(_DWORD*)(v41 + 12) = k;
                        sub_41CFD0(k, 0.0);
                        sub_41D010(*(_DWORD**)(v41 + 12), 0.0);
                        sub_41CF00(*(_DWORD*)(v41 + 12));
                        sub_41CD90(*(_DWORD*)(v41 + 12));
                        sub_41CF80(*(_DWORD*)(v41 + 12), 1.0);
                        v34 = j;
                    }
                    if (++v40 > *(int*)ArgList)
                        break;
                }
            }
            v2 = (int)this;
            v5 = *(_DWORD*)ArgList + 1;
            if (*(_DWORD*)ArgList + 1 >= v55)
                break;
            v28 = v55;
        }
    }
    for (m = 0; m < 17920; m += 140)
    {
        v47 = m + *(_DWORD*)(v2 + 36);
        if (*(_DWORD*)(v47 + 8))
        {
            *(float*)(v47 + 20) = *(float*)&a2 + *(float*)(v47 + 20);
            sub_41EA30((float*)v2, v47, a2);
        }
    }
    return sub_428620((_DWORD*)v2, a2);
}
// 4A35CC: using guessed type int dword_4A35CC[];
// 4A35D0: using guessed type int dword_4A35D0[];
// 520970: using guessed type int dword_520970;

//----- (0041E920) --------------------------------------------------------
unsigned int __cdecl sub_41E920(int* a1, int* a2)
{
    int v2; // ecx
    int v3; // edx
    int v4; // esi
    int v5; // eax
    unsigned int v6; // eax

    v2 = *a1;
    v3 = *a2;
    v4 = *(_DWORD*)(*a1 + 8);
    v5 = *(_DWORD*)(*a2 + 8);
    if (v4 != v5)
    {
        v6 = (int)((unsigned __int64)(3714566311LL * (v5 - v4)) >> 32) >> 8;
        return (v6 >> 31) + v6;
    }
    if (*(_BYTE*)(v4 + 264))
    {
        if (*(float*)(v2 + 56) < (double)*(float*)(v3 + 56))
            return -1;
        if (*(float*)(v2 + 56) > (double)*(float*)(v3 + 56))
            return 1;
        return (v2 - v3) / 140;
    }
    if (!*(_DWORD*)(v2 + 12))
    {
        if (*(_DWORD*)(v3 + 12))
            return -1;
        if (*(float*)(v2 + 20) < (double)*(float*)(v3 + 20))
            return 1;
        if (*(float*)(v2 + 20) > (double)*(float*)(v3 + 20))
            return -1;
        return (v2 - v3) / 140;
    }
    if (!*(_DWORD*)(v3 + 12))
        return 1;
    if (*(float*)(v2 + 20) < (double)*(float*)(v3 + 20))
        return -1;
    if (*(float*)(v2 + 20) <= (double)*(float*)(v3 + 20))
        return (v2 - v3) / 140;
    return 1;
}
// 41E99D: conditional instruction was optimized away because eax.4!=0
// 41E9AD: conditional instruction was optimized away because eax.4==0

//----- (0041EA30) --------------------------------------------------------
void __thiscall sub_41EA30(float* this, int a2, int a3)
{
    _DWORD* v5; // ebx
    double v6; // st7
    double v7; // st7
    double v8; // st7
    double v9; // st7
    double v10; // st6
    double v11; // st6
    double v12; // st6
    double v13; // st6
    double v14; // st6
    double v15; // st7
    double v16; // st6
    long double v17; // st5
    double v18; // st5
    double v19; // st7
    double v20; // st7
    double v21; // st7
    double v22; // st6
    long double v23; // st5
    double v24; // st5
    double v25; // st7
    double v26; // st7
    float v27; // [esp+0h] [ebp-2Ch]
    float v28; // [esp+0h] [ebp-2Ch]
    float v29; // [esp+0h] [ebp-2Ch]
    float v30; // [esp+0h] [ebp-2Ch]
    float v31; // [esp+10h] [ebp-1Ch]
    float v32; // [esp+14h] [ebp-18h]
    float v33; // [esp+18h] [ebp-14h]
    float v34; // [esp+18h] [ebp-14h]
    float v35; // [esp+1Ch] [ebp-10h]
    float v36; // [esp+20h] [ebp-Ch]
    float v37; // [esp+20h] [ebp-Ch]
    float v38; // [esp+24h] [ebp-8h]
    float v39; // [esp+24h] [ebp-8h]
    float v40; // [esp+24h] [ebp-8h]
    float v41; // [esp+30h] [ebp+4h]
    float v42; // [esp+30h] [ebp+4h]
    float v43; // [esp+30h] [ebp+4h]

    v5 = *(_DWORD**)(a2 + 12);
    if (!v5)
        return;
    if (*(float*)(a2 + 132) != 0.0)
    {
        v6 = *(float*)(a2 + 136);
        if (v6 == 0.0)
            v7 = 0.0;
        else
            v7 = (*(float*)(a2 + 132) - *(float*)(a2 + 20)) / v6;
        *(float*)(a2 + 64) = v7;
        if (v7 >= 1.0)
            v7 = 1.0;
        *(float*)(a2 + 64) = v7;
        if (v7 <= 0.0)
        {
            sub_41D9A0(a2);
            return;
        }
    }
    v8 = *(float*)(a2 + 84) - *(float*)(a2 + 72);
    if (v8 == 0.0)
    {
        v41 = 0.0;
    }
    else
    {
        v41 = (*(float*)(a2 + 56) - *(float*)(a2 + 72)) / v8;
        if (v41 > 0.0)
        {
            if (v41 >= 1.0)
                v41 = 1.0;
        }
        else
        {
            v41 = 0.0;
        }
    }
    v9 = 1.0;
    if (*(_BYTE*)(a2 + 24))
        v9 = (*(float*)(a2 + 88) - *(float*)(a2 + 76)) * v41 + *(float*)(a2 + 76);
    if (*(_BYTE*)(a2 + 96))
    {
        v10 = *(float*)(a2 + 100);
        if (v10 == 0.0)
            v11 = 0.0;
        else
            v11 = *(float*)(a2 + 36) / v10;
    }
    else
    {
        v11 = v41;
    }
    v31 = (*(float*)(a2 + 92) - *(float*)(a2 + 80)) * v11 + *(float*)(a2 + 80);
    if (*(_BYTE*)(*(_DWORD*)(a2 + 8) + 264))
    {
        v12 = *(float*)(a2 + 104);
        if (v12 == 0.0)
        {
            v42 = 0.0;
        }
        else
        {
            v42 = sqrt(
                *(float*)(a2 + 40) * *(float*)(a2 + 40)
                + *(float*)(a2 + 44) * *(float*)(a2 + 44)
                + *(float*)(a2 + 48) * *(float*)(a2 + 48))
                / v12;
            if (v42 >= 1.0)
                v42 = 1.0;
        }
        v31 = ((*(float*)(a2 + 128) - *(float*)(a2 + 124)) * v42 + *(float*)(a2 + 124)) * v31;
        if (v42 < (double)*(float*)(a2 + 112) || v42 >(double) * (float*)(a2 + 116))
        {
            if (v42 < (double)*(float*)(a2 + 108) || v42 >(double) * (float*)(a2 + 120))
            {
                v9 = 0.0;
            }
            else
            {
                if (v42 >= (double)*(float*)(a2 + 112))
                {
                    v14 = *(float*)(a2 + 120) - *(float*)(a2 + 116);
                    if (v14 != 0.0)
                    {
                        v9 = v9 * ((*(float*)(a2 + 120) - v42) / v14);
                        goto LABEL_39;
                    }
                }
                else
                {
                    v13 = *(float*)(a2 + 112) - *(float*)(a2 + 108);
                    if (v13 != 0.0)
                    {
                        v9 = v9 * ((v42 - *(float*)(a2 + 108)) / v13);
                        goto LABEL_39;
                    }
                }
                v9 = v9 * 1.0;
            }
        }
    }
LABEL_39:
    v43 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * *(float*)(a2 + 64) * v9 * 0.40000001 + 0.60000002;
    if (v43 - 0.60000002 >= 0.0000099999997)
        sub_41CFD0((int)v5, v43);
    else
        sub_41CFD0((int)v5, 0.0);
    if (v43 > 0.60000002)
    {
        v15 = *(float*)(a2 + 28) - this[14];
        v33 = *(float*)(a2 + 32) - this[15];
        v16 = *(float*)(a2 + 36) - this[16];
        v17 = sqrt(v16 * v16 + v33 * v33 + v15 * v15);
        if (v17 >= 0.0000099999997 || v17 <= -0.0000099999997)
        {
            if (v17 == 0.0)
                v18 = 0.0;
            else
                v18 = 1.0 / v17;
        }
        else
        {
            v18 = 1.0 / 1.0;
        }
        v32 = v18 * v15;
        v34 = v33 * v18;
        v35 = v16 * v18;
        if (*(_BYTE*)(a2 + 24) && *(_BYTE*)(a2 + 68) && byte_4A34BC)
        {
            v19 = 1.0
                - (-v35 * *(float*)(a2 + 48) + -v34 * *(float*)(a2 + 44) + -v32 * *(float*)(a2 + 40)) * 0.000074074072;
            if (v19 == 0.0)
            {
                v28 = 1.0 * v31;
                sub_41CF80((int)v5, v28);
            }
            else
            {
                v20 = ((v35 * this[19] + v34 * this[18] + v32 * this[17]) * 0.000074074072 + 1.0) / v19;
                if (v20 < 1.1)
                {
                    if (v20 <= 0.89999998)
                        v20 = 0.89999998;
                    v29 = v20 * v31;
                    sub_41CF80((int)v5, v29);
                }
                else
                {
                    v27 = 1.1 * v31;
                    sub_41CF80((int)v5, v27);
                }
            }
        }
        else
        {
            sub_41CF80((int)v5, v31);
        }
        if (*(_BYTE*)(a2 + 24))
        {
            v21 = this[22] * this[24] - this[21] * this[25];
            v38 = this[20] * this[25] - this[22] * this[23];
            v22 = this[23] * this[21] - this[20] * this[24];
            v23 = sqrt(v22 * v22 + v38 * v38 + v21 * v21);
            if (v23 >= 0.0000099999997 || v23 <= -0.0000099999997)
            {
                if (v23 == 0.0)
                    v24 = 0.0;
                else
                    v24 = 1.0 / v23;
            }
            else
            {
                v24 = 1.0 / 1.0;
            }
            v36 = v24 * v21;
            v39 = v38 * v24;
            v37 = -v36;
            v40 = -v39;
            v25 = -(v22 * v24) * v35 + v40 * v34 + v37 * v32;
            if (v25 >= -0.2)
            {
                if (v25 > 0.2)
                    v26 = v25 - 0.2;
                else
                    v26 = 0.0;
            }
            else
            {
                v26 = v25 + 0.2;
            }
            v30 = v26 * 0.1375;
            sub_41D010(v5, v30);
        }
    }
}
// 4A34BC: using guessed type char byte_4A34BC;

//----- (0041EFE0) --------------------------------------------------------
int __thiscall sub_41EFE0(float* this, int a2)
{
    int v2; // eax
    _DWORD v4[16]; // [esp+0h] [ebp-40h] BYREF

    if (this[26] == 0.0)
        return 0;
    memset(&v4[11], 0, 16);
    memset(&v4[6], 0, 16);
    memset(&v4[1], 0, 16);
    v4[15] = 1065353216;
    v4[10] = 1065353216;
    v4[5] = 1065353216;
    v4[0] = 1065353216;
    (*(void(__stdcall**)(_DWORD, int, _DWORD*))(**(_DWORD**)ArgList + 148))(*(_DWORD*)ArgList, 256, v4);
    v2 = *(_DWORD*)(a2 + 40);
    if (!*(_DWORD*)(v2 + 8))
        return 0;
    if (*(_DWORD*)(v2 + 12))
        return sub_41F3D0(
            *(float*)(v2 + 28),
            *(float*)(v2 + 32),
            *(float*)(v2 + 36),
            300.0,
            COERCE_FLOAT(128),
            0.0,
            0.0,
            255);
    return sub_41F3D0(
        *(float*)(v2 + 28),
        *(float*)(v2 + 32),
        *(float*)(v2 + 36),
        300.0,
        0.0,
        COERCE_FLOAT(64),
        0.0,
        255);
}

//----- (0041F0F0) --------------------------------------------------------
int __thiscall sub_41F0F0(_DWORD* this)
{
    int i; // esi
    int v3; // ecx
    int result; // eax

    for (i = 0; i < 17920; i += 140)
    {
        v3 = i + this[9];
        result = *(_DWORD*)(v3 + 8);
        if (result)
            result = sub_41D9A0(v3);
    }
    return result;
}

//----- (0041F120) --------------------------------------------------------
void __thiscall sub_41F120(int this)
{
    int i; // ebp
    void* v3; // edi
    void* v4; // eax

    if (*(_BYTE*)(this + 12))
    {
        for (i = 0; i < *(_DWORD*)(this + 4); ++i)
        {
            v3 = *(void**)(*(_DWORD*)this + 4 * i);
            if (v3)
            {
                sub_403880(*(_DWORD*)(*(_DWORD*)this + 4 * i));
                sub_4885A6(v3);
            }
        }
    }
    memset(*(void**)this, 0, 4 * *(_DWORD*)(this + 4));
    v4 = *(void**)this;
    *(_DWORD*)(this + 4) = 0;
    sub_488CEE(v4);
    *(_DWORD*)(this + 8) = 0;
    *(_DWORD*)this = 0;
}

//----- (0041F1A0) --------------------------------------------------------
void __thiscall sub_41F1A0(int this, char a2)
{
    int i; // ebp
    void* v4; // edi

    if (*(_BYTE*)(this + 12))
    {
        for (i = 0; i < *(_DWORD*)(this + 4); ++i)
        {
            v4 = *(void**)(*(_DWORD*)this + 4 * i);
            if (v4)
            {
                sub_41C700(*(_DWORD*)(*(_DWORD*)this + 4 * i));
                sub_4885A6(v4);
            }
        }
    }
    memset(*(void**)this, 0, 4 * *(_DWORD*)(this + 4));
    *(_DWORD*)(this + 4) = 0;
    if (a2)
    {
        sub_488CEE(*(LPVOID*)this);
        *(_DWORD*)(this + 8) = 0;
        *(_DWORD*)this = 0;
    }
}

//----- (0041F220) --------------------------------------------------------
void __thiscall sub_41F220(int this, char a2)
{
    int i; // ebp
    void* v4; // edi

    if (*(_BYTE*)(this + 12))
    {
        for (i = 0; i < *(_DWORD*)(this + 4); ++i)
        {
            v4 = *(void**)(*(_DWORD*)this + 4 * i);
            if (v4)
            {
                sub_403880(*(_DWORD*)(*(_DWORD*)this + 4 * i));
                sub_4885A6(v4);
            }
        }
    }
    memset(*(void**)this, 0, 4 * *(_DWORD*)(this + 4));
    *(_DWORD*)(this + 4) = 0;
    if (a2)
    {
        sub_488CEE(*(LPVOID*)this);
        *(_DWORD*)(this + 8) = 0;
        *(_DWORD*)this = 0;
    }
}

//----- (0041F2A0) --------------------------------------------------------
int __thiscall sub_41F2A0(void** this)
{
    void* v2; // eax
    void* v3; // ecx
    char* v4; // eax
    _BYTE* v5; // ecx
    void* v6; // edi

    v2 = this[2];
    v3 = *this;
    v2 = (char*)v2 + 8;
    this[2] = v2;
    v4 = (char*)sub_488DD7(v3, 4 * (_DWORD)v2);
    if (!v4)
        return 0;
    v5 = this[2];
    v6 = this[1];
    *this = v4;
    memset(&v4[4 * (_DWORD)v6], 0, 4 * (v5 - (_BYTE*)v6));
    return 1;
}

//----- (0041F2F0) --------------------------------------------------------
char __usercall sub_41F2F0@<al>(int a1@<ecx>, void* a2@<esi>)
{
    _UNKNOWN* retaddr; // [esp+48h] [ebp+0h] BYREF

    if ((*(int(__stdcall**)(_DWORD, int, int, int, int, int*))(**(_DWORD**)ArgList + 92))(
        *(_DWORD*)ArgList,
        1488,
        8,
        18,
        1,
        &dword_5200EC))
    {
        return 0;
    }
    if ((*(int(__stdcall**)(_DWORD, int, int, int, int, int*, int))(**(_DWORD**)ArgList + 96))(
        *(_DWORD*)ArgList,
        720,
        8,
        101,
        1,
        &dword_5200F0,
        a1))
    {
        (*(void(__cdecl**)(int))(*(_DWORD*)dword_5200EC + 8))(dword_5200EC);
        dword_5200EC = 0;
        return 0;
    }
    else
    {
        (*(void(__stdcall**)(int, _DWORD, _DWORD, _UNKNOWN**))(*(_DWORD*)dword_5200F0 + 44))(
            dword_5200F0,
            0,
            0,
            &retaddr);
        qmemcpy(a2, &unk_4A3BA8, 0x2D0u);
        (*(void(__stdcall**)(int))(*(_DWORD*)dword_5200F0 + 48))(dword_5200F0);
        return 1;
    }
}
// 41F2F0: could not find valid save-restore pair for edi
// 41F2F0: could not find valid save-restore pair for esi
// 5200EC: using guessed type int dword_5200EC;
// 5200F0: using guessed type int dword_5200F0;

//----- (0041F390) --------------------------------------------------------
int sub_41F390()
{
    int result; // eax

    if (dword_5200EC)
    {
        (*(void(__stdcall**)(int))(*(_DWORD*)dword_5200EC + 8))(dword_5200EC);
        dword_5200EC = 0;
    }
    result = dword_5200F0;
    if (dword_5200F0)
    {
        result = (*(int(__stdcall**)(int))(*(_DWORD*)dword_5200F0 + 8))(dword_5200F0);
        dword_5200F0 = 0;
    }
    return result;
}
// 5200EC: using guessed type int dword_5200EC;
// 5200F0: using guessed type int dword_5200F0;

//----- (0041F3D0) --------------------------------------------------------
int __cdecl sub_41F3D0(float a1, float a2, float a3, float a4, float a5, float a6, float a7, int a8)
{
    int i; // eax
    double v9; // st7
    float v11[17]; // [esp+0h] [ebp-44h] BYREF

    memset(v11, 0, sizeof(v11));
    v11[4] = (double)SLODWORD(a5) * 0.0039215689;
    a5 = (double)SLODWORD(a6) * 0.0039215689;
    v11[5] = a5;
    v11[1] = a5;
    a6 = (double)SLODWORD(a7) * 0.0039215689;
    v11[6] = a6;
    v11[2] = a6;
    a7 = (double)a8 * 0.0039215689;
    v11[7] = a7;
    v11[3] = a7;
    v11[0] = v11[4];
    (*(void(__stdcall**)(_DWORD, float*))(**(_DWORD**)ArgList + 168))(*(_DWORD*)ArgList, v11);
    sub_41BEF0((_DWORD*)dword_520A50, 0, 0, -1, -1);
    sub_41BEF0((_DWORD*)dword_520A50, 1, 0, -1, -1);
    sub_41BC00((_DWORD*)dword_520A50, 0, a8 != 255, 1, 0, 2, 0, 1);
    (*(void(__stdcall**)(int, _DWORD, _DWORD, float*, _DWORD))(*(_DWORD*)dword_5200EC + 44))(
        dword_5200EC,
        0,
        0,
        &a5,
        0);
    for (i = 0; i < 372; *(_DWORD*)(i * 4 + LODWORD(a5) - 4) = dword_4A35D4[i])
    {
        v9 = a4 * flt_4A35D8[i];
        i += 6;
        *(float*)(i * 4 + LODWORD(a5) - 24) = v9 + a1;
        *(float*)(i * 4 + LODWORD(a5) - 20) = a4 * flt_4A35C4[i] + a2;
        *(float*)(i * 4 + LODWORD(a5) - 16) = a4 * flt_4A35C8[i] + a3;
        *(_DWORD*)(i * 4 + LODWORD(a5) - 12) = dword_4A35CC[i];
        *(_DWORD*)(i * 4 + LODWORD(a5) - 8) = dword_4A35D0[i];
    }
    (*(void(__stdcall**)(int))(*(_DWORD*)dword_5200EC + 48))(dword_5200EC);
    (*(void(__stdcall**)(_DWORD, int))(**(_DWORD**)ArgList + 304))(*(_DWORD*)ArgList, 18);
    (*(void(__stdcall**)(_DWORD, _DWORD, int, int))(**(_DWORD**)ArgList + 332))(
        *(_DWORD*)ArgList,
        0,
        dword_5200EC,
        24);
    (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**)ArgList + 340))(*(_DWORD*)ArgList, dword_5200F0, 0);
    (*(void(__stdcall**)(_DWORD, int, _DWORD, int, _DWORD, int))(**(_DWORD**)ArgList + 284))(
        *(_DWORD*)ArgList,
        4,
        0,
        62,
        0,
        120);
    *(float*)dword_520A20 = *(float*)dword_520A20 + 1.0;
    return 120;
}
// 4A35C4: using guessed type float flt_4A35C4[];
// 4A35C8: using guessed type float flt_4A35C8[];
// 4A35CC: using guessed type int dword_4A35CC[];
// 4A35D0: using guessed type int dword_4A35D0[];
// 4A35D4: using guessed type int dword_4A35D4[];
// 4A35D8: using guessed type float flt_4A35D8[];
// 5200EC: using guessed type int dword_5200EC;
// 5200F0: using guessed type int dword_5200F0;
// 520A20: using guessed type int dword_520A20;
// 520A50: using guessed type int dword_520A50;

//----- (0041F5B0) --------------------------------------------------------
int __thiscall sub_41F5B0(int this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
    _DWORD* v10; // eax
    int v11; // edx
    float* v12; // eax
    double v13; // st7
    float v14; // edx
    float v16; // [esp+14h] [ebp-10h]

    *(_DWORD*)(this + 4) = 0;
    *(_DWORD*)(this + 8) = 0;
    *(_DWORD*)(this + 12) = 0;
    *(_BYTE*)(this + 16) = 1;
    *(_DWORD*)(this + 20) = a6;
    *(_DWORD*)(this + 24) = a7;
    *(_DWORD*)(this + 28) = a8;
    *(_DWORD*)(this + 32) = a9;
    *(_DWORD*)(this + 36) = a2;
    *(_DWORD*)(this + 40) = a3;
    *(_DWORD*)(this + 44) = a4;
    *(_DWORD*)(this + 48) = a5;
    *(_DWORD*)this = &off_4992F4;
    *(_DWORD*)(this + 56) = 0;
    v10 = sub_409960((_DWORD*)dword_520970, this);
    v11 = *(_DWORD*)(this + 32);
    *(_DWORD*)(this + 52) = v10;
    v10[3] = v11 != 255 ? 4 : 2;
    v12 = (float*)(*(_DWORD*)(this + 52) + 16);
    v13 = *(float*)(this + 44);
    v14 = *(float*)(this + 40);
    *v12 = *(float*)(this + 36);
    v16 = v13;
    v12[1] = v14;
    v12[2] = v16;
    *(_DWORD*)(*(_DWORD*)(this + 52) + 28) = 0;
    *(_DWORD*)(*(_DWORD*)(this + 52) + 32) = *(_DWORD*)(this + 48);
    return this;
}
// 4992F4: using guessed type _UNKNOWN *off_4992F4;
// 520970: using guessed type int dword_520970;

//----- (0041F6C0) --------------------------------------------------------
int __thiscall sub_41F6C0(int this, float a2)
{
    double v3; // st7
    double v4; // st6
    double v5; // st6
    float* v6; // edx
    double v7; // st7
    float v8; // ecx
    int result; // eax
    float v10; // [esp+8h] [ebp-Ch]
    float v11; // [esp+10h] [ebp-4h]

    if (*(float*)(this + 56) > 0.0)
    {
        v3 = *(float*)(this + 56) - a2;
        *(float*)(this + 56) = v3;
        v4 = *(float*)(this + 60);
        if (v4 == 0.0)
            v5 = 1.0;
        else
            v5 = v3 / v4;
        *(_DWORD*)(this + 32) = (__int64)(v5 * 255.0);
        if (v3 <= 0.0)
        {
            *(_DWORD*)(this + 36) = 0;
            *(_DWORD*)(this + 40) = 0;
            *(_DWORD*)(this + 44) = 0;
            *(_DWORD*)(this + 48) = 0;
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 52) + 12) = *(_DWORD*)(this + 32) != 255 ? 4 : 2;
    v10 = *(float*)(this + 36);
    v6 = (float*)(*(_DWORD*)(this + 52) + 16);
    v7 = *(float*)(this + 44);
    v8 = *(float*)(this + 40);
    *v6 = v10;
    v11 = v7;
    v6[1] = v8;
    v6[2] = v11;
    *(_DWORD*)(*(_DWORD*)(this + 52) + 28) = 0;
    result = *(_DWORD*)(this + 48);
    *(_DWORD*)(*(_DWORD*)(this + 52) + 32) = result;
    return result;
}

//----- (0041F790) --------------------------------------------------------
int __thiscall sub_41F790(int this, int a2)
{
    _DWORD v4[16]; // [esp+4h] [ebp-40h] BYREF

    memset(&v4[11], 0, 16);
    memset(&v4[6], 0, 16);
    memset(&v4[1], 0, 16);
    v4[15] = 1065353216;
    v4[10] = 1065353216;
    v4[5] = 1065353216;
    v4[0] = 1065353216;
    (*(void(__stdcall**)(_DWORD, int, _DWORD*))(**(_DWORD**)ArgList + 148))(*(_DWORD*)ArgList, 256, v4);
    return sub_41F3D0(
        *(float*)(this + 36),
        *(float*)(this + 40),
        *(float*)(this + 44),
        *(float*)(this + 48),
        *(float*)(this + 20),
        *(float*)(this + 24),
        *(float*)(this + 28),
        *(_DWORD*)(this + 32));
}

//----- (0041F860) --------------------------------------------------------
int __thiscall sub_41F860(void** this)
{
    int result; // eax

    *this = &off_4992F4;
    result = sub_409A00(dword_520970, this[13]);
    *this = &off_499040;
    return result;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 4992F4: using guessed type _UNKNOWN *off_4992F4;
// 520970: using guessed type int dword_520970;

//----- (0041F8F0) --------------------------------------------------------
char __usercall sub_41F8F0@<al>(int a1@<ecx>, int a2@<edi>)
{
    int v2; // edi
    int i; // eax
    __int16 v4; // dx
    __int16 v5; // si
    __int16 v6; // cx
    char result; // al
    int v8; // [esp+44h] [ebp-4h] BYREF
    char* retaddr; // [esp+48h] [ebp+0h]

    v8 = a1;
    if ((*(int(__stdcall**)(_DWORD, int, int, int, int, int*))(**(_DWORD**)ArgList + 96))(
        *(_DWORD*)ArgList,
        3072,
        8,
        101,
        1,
        &dword_520124)
        || (*(int(__stdcall**)(_DWORD, int, int, int, int, int*))(**(_DWORD**)ArgList + 92))(
            *(_DWORD*)ArgList,
            24576,
            8,
            322,
            1,
            &dword_5200F8))
    {
        result = 0;
        dword_520100 = -1;
    }
    else
    {
        (*(void(__stdcall**)(int, _DWORD, int, int*, _DWORD, int))(*(_DWORD*)dword_520124 + 44))(
            dword_520124,
            0,
            3072,
            &v8,
            0,
            a2);
        v2 = 0;
        for (i = 0; i < 3072; i += 12)
        {
            *(_WORD*)&retaddr[i] = 4 * v2;
            v4 = 4 * v2 + 1;
            *(_WORD*)&retaddr[i + 2] = v4;
            v5 = 4 * v2 + 2;
            v6 = 4 * v2 + 3;
            *(_WORD*)&retaddr[i + 4] = v5;
            ++v2;
            *(_WORD*)&retaddr[i + 6] = v6;
            *(_WORD*)&retaddr[i + 8] = v5;
            *(_WORD*)&retaddr[i + 10] = v4;
        }
        (*(void(__cdecl**)(int))(*(_DWORD*)dword_520124 + 48))(dword_520124);
        result = 1;
        dword_520100 = -1;
    }
    return result;
}
// 5200F8: using guessed type int dword_5200F8;
// 520100: using guessed type int dword_520100;
// 520124: using guessed type int dword_520124;

//----- (0041F9E0) --------------------------------------------------------
int sub_41F9E0()
{
    int result; // eax

    if (dword_5200F8)
    {
        (*(void(__stdcall**)(int))(*(_DWORD*)dword_5200F8 + 8))(dword_5200F8);
        dword_5200F8 = 0;
    }
    result = dword_520124;
    if (dword_520124)
    {
        result = (*(int(__stdcall**)(int))(*(_DWORD*)dword_520124 + 8))(dword_520124);
        dword_520124 = 0;
    }
    dword_520100 = -1;
    return result;
}
// 5200F8: using guessed type int dword_5200F8;
// 520100: using guessed type int dword_520100;
// 520124: using guessed type int dword_520124;

//----- (0041FA20) --------------------------------------------------------
int __cdecl sub_41FA20(int a1, char a2)
{
    int v2; // eax
    float* v3; // edx
    float v4; // ecx
    double v5; // st7
    double v6; // st6
    double v7; // st5
    int result; // eax
    int v9; // [esp+14h] [ebp-Ch]
    int v10; // [esp+18h] [ebp-8h]
    int v11; // [esp+1Ch] [ebp-4h]

    v2 = sub_408F30((_DWORD*)dword_520970);
    dword_520108 = *(_DWORD*)(v2 + 56);
    dword_52010C = *(_DWORD*)(v2 + 60);
    v3 = (float*)(v2 + 44);
    v4 = *(float*)(v2 + 64);
    v2 += 32;
    dword_520110 = LODWORD(v4);
    v5 = *v3 - *(float*)v2;
    v6 = v3[1] - *(float*)(v2 + 4);
    v7 = v3[2] - *(float*)(v2 + 8);
    *(float*)&v9 = *(float*)&dword_52010C * v7 - v4 * v6;
    dword_520118 = v9;
    *(float*)&v10 = v4 * v5 - *(float*)&dword_520108 * v7;
    dword_52011C = v10;
    *(float*)&v11 = *(float*)&dword_520108 * v6 - *(float*)&dword_52010C * v5;
    dword_520120 = v11;
    sub_46B970(&dword_520118, &dword_520118);
    (*(void(__stdcall**)(_DWORD, int))(**(_DWORD**)ArgList + 304))(*(_DWORD*)ArgList, 322);
    (*(void(__stdcall**)(_DWORD, _DWORD, int, int))(**(_DWORD**)ArgList + 332))(
        *(_DWORD*)ArgList,
        0,
        dword_5200F8,
        24);
    (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**)ArgList + 340))(*(_DWORD*)ArgList, dword_520124, 0);
    result = a1;
    if (a1)
    {
        sub_41BEF0((_DWORD*)dword_520A50, 0, a1, 1, 1);
        sub_41BEF0((_DWORD*)dword_520A50, 1, 0, -1, -1);
        result = sub_41BC00((_DWORD*)dword_520A50, 1, (a2 != 0) + 1, 1, 1, 1, -1, 0);
    }
    dword_520100 = 0;
    byte_5200FC = 0;
    return result;
}
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);
// 5200F8: using guessed type int dword_5200F8;
// 5200FC: using guessed type char byte_5200FC;
// 520100: using guessed type int dword_520100;
// 520108: using guessed type int dword_520108;
// 52010C: using guessed type int dword_52010C;
// 520110: using guessed type int dword_520110;
// 520118: using guessed type int dword_520118;
// 52011C: using guessed type int dword_52011C;
// 520120: using guessed type int dword_520120;
// 520124: using guessed type int dword_520124;
// 520970: using guessed type int dword_520970;
// 520A50: using guessed type int dword_520A50;

//----- (0041FBB0) --------------------------------------------------------
int __cdecl sub_41FBB0(
    int a1,
    int a2,
    int a3,
    float a4,
    float a5,
    int a6,
    float a7,
    float a8,
    float a9,
    float a10,
    float a11,
    float a12,
    float a13,
    float a14)
{
    float* v14; // eax
    double v15; // st7
    double v16; // st7
    double v17; // st7
    float* v18; // eax
    float* v19; // eax
    int result; // eax
    int v21; // [esp+8h] [ebp-E0h]
    int v22; // [esp+8h] [ebp-E0h]
    int v23; // [esp+8h] [ebp-E0h]
    int v24; // [esp+8h] [ebp-E0h]
    int v25; // [esp+8h] [ebp-E0h]
    int v26; // [esp+8h] [ebp-E0h]
    int v27; // [esp+8h] [ebp-E0h]
    int v28; // [esp+8h] [ebp-E0h]
    int v29; // [esp+8h] [ebp-E0h]
    int v30; // [esp+8h] [ebp-E0h]
    int v31; // [esp+8h] [ebp-E0h]
    int v32; // [esp+8h] [ebp-E0h]
    int v33; // [esp+8h] [ebp-E0h]
    int v34; // [esp+8h] [ebp-E0h]
    int v35; // [esp+8h] [ebp-E0h]
    int v36; // [esp+8h] [ebp-E0h]
    int v37; // [esp+8h] [ebp-E0h]
    int v38; // [esp+8h] [ebp-E0h]
    int v39; // [esp+8h] [ebp-E0h]
    int v40; // [esp+8h] [ebp-E0h]
    int v41; // [esp+8h] [ebp-E0h]
    int v42; // [esp+8h] [ebp-E0h]
    int v43; // [esp+8h] [ebp-E0h]
    int v44; // [esp+8h] [ebp-E0h]
    int v45; // [esp+8h] [ebp-E0h]
    int v46; // [esp+Ch] [ebp-DCh]
    int v47; // [esp+Ch] [ebp-DCh]
    int v48; // [esp+Ch] [ebp-DCh]
    int v49; // [esp+Ch] [ebp-DCh]
    int v50; // [esp+Ch] [ebp-DCh]
    int v51; // [esp+Ch] [ebp-DCh]
    int v52; // [esp+Ch] [ebp-DCh]
    int v53; // [esp+Ch] [ebp-DCh]
    int v54; // [esp+Ch] [ebp-DCh]
    int v55; // [esp+Ch] [ebp-DCh]
    int v56; // [esp+Ch] [ebp-DCh]
    int v57; // [esp+Ch] [ebp-DCh]
    int v58; // [esp+Ch] [ebp-DCh]
    int v59; // [esp+Ch] [ebp-DCh]
    int v60; // [esp+Ch] [ebp-DCh]
    int v61; // [esp+Ch] [ebp-DCh]
    int v62; // [esp+Ch] [ebp-DCh]
    int v63; // [esp+Ch] [ebp-DCh]
    int v64; // [esp+Ch] [ebp-DCh]
    int v65; // [esp+Ch] [ebp-DCh]
    int v66; // [esp+Ch] [ebp-DCh]
    int v67; // [esp+Ch] [ebp-DCh]
    int v68; // [esp+Ch] [ebp-DCh]
    int v69; // [esp+Ch] [ebp-DCh]
    int v70; // [esp+Ch] [ebp-DCh]
    int v71; // [esp+10h] [ebp-D8h]
    int v72; // [esp+10h] [ebp-D8h]
    int v73; // [esp+10h] [ebp-D8h]
    int v74; // [esp+10h] [ebp-D8h]
    int v75; // [esp+10h] [ebp-D8h]
    int v76; // [esp+10h] [ebp-D8h]
    int v77; // [esp+10h] [ebp-D8h]
    int v78; // [esp+10h] [ebp-D8h]
    int v79; // [esp+10h] [ebp-D8h]
    int v80; // [esp+10h] [ebp-D8h]
    int v81; // [esp+10h] [ebp-D8h]
    int v82; // [esp+10h] [ebp-D8h]
    int v83; // [esp+10h] [ebp-D8h]
    int v84; // [esp+10h] [ebp-D8h]
    int v85; // [esp+10h] [ebp-D8h]
    int v86; // [esp+10h] [ebp-D8h]
    int v87; // [esp+10h] [ebp-D8h]
    int v88; // [esp+10h] [ebp-D8h]
    int v89; // [esp+10h] [ebp-D8h]
    int v90; // [esp+10h] [ebp-D8h]
    int v91; // [esp+10h] [ebp-D8h]
    int v92; // [esp+10h] [ebp-D8h]
    int v93; // [esp+10h] [ebp-D8h]
    int v94; // [esp+10h] [ebp-D8h]
    int v95; // [esp+10h] [ebp-D8h]
    int v96; // [esp+14h] [ebp-D4h] BYREF
    float v97; // [esp+18h] [ebp-D0h] BYREF
    float v98; // [esp+1Ch] [ebp-CCh]
    float v99; // [esp+20h] [ebp-C8h]
    int v100; // [esp+24h] [ebp-C4h] BYREF
    float v101; // [esp+28h] [ebp-C0h]
    float v102; // [esp+2Ch] [ebp-BCh]
    float v103; // [esp+30h] [ebp-B8h] BYREF
    float v104; // [esp+34h] [ebp-B4h]
    float v105; // [esp+38h] [ebp-B0h]
    float v106; // [esp+3Ch] [ebp-ACh] BYREF
    float v107; // [esp+40h] [ebp-A8h]
    float v108; // [esp+44h] [ebp-A4h]
    float v109; // [esp+48h] [ebp-A0h] BYREF
    float v110; // [esp+4Ch] [ebp-9Ch]
    float v111; // [esp+50h] [ebp-98h]
    float v112; // [esp+54h] [ebp-94h] BYREF
    float v113; // [esp+58h] [ebp-90h]
    float v114; // [esp+5Ch] [ebp-8Ch]
    float v115[3]; // [esp+60h] [ebp-88h] BYREF
    float v116[3]; // [esp+6Ch] [ebp-7Ch] BYREF
    float v117[3]; // [esp+78h] [ebp-70h] BYREF
    float v118[3]; // [esp+84h] [ebp-64h] BYREF
    float v119[3]; // [esp+90h] [ebp-58h] BYREF
    int v120[3]; // [esp+9Ch] [ebp-4Ch] BYREF
    int v121[16]; // [esp+A8h] [ebp-40h] BYREF
    float v122; // [esp+F8h] [ebp+10h]

    v122 = a4 * 0.5;
    sub_406BE0(v121);
    v14 = (float*)sub_408F30((_DWORD*)dword_520970);
    *(float*)&v71 = v14[13] - v14[10];
    *(float*)&v46 = v14[12] - v14[9];
    *(float*)&v21 = v14[11] - v14[8];
    sub_40F4A0(v120, v21, v46, v71);
    sub_46BFED((int)v121, (int)v120, a5);
    sub_40E880(v121, a1, a2, a3);
    v15 = -a13;
    *(float*)&v72 = v15 * *(float*)&dword_520120;
    *(float*)&v47 = v15 * *(float*)&dword_52011C;
    *(float*)&v22 = v15 * *(float*)&dword_520118;
    sub_40F4A0(&v100, v22, v47, v72);
    v16 = -a14;
    *(float*)&v73 = v16 * *(float*)&dword_520110;
    *(float*)&v48 = v16 * *(float*)&dword_52010C;
    *(float*)&v23 = v16 * *(float*)&dword_520108;
    sub_40F4A0(&v103, v23, v48, v73);
    *(float*)&v74 = v102 + v105;
    *(float*)&v49 = v101 + v104;
    *(float*)&v24 = *(float*)&v100 + v103;
    sub_40F4A0(&v97, v24, v49, v74);
    v17 = v122 + v122;
    *(float*)&v75 = v99 * v17;
    *(float*)&v50 = v98 * v17;
    *(float*)&v25 = v97 * v17;
    sub_40F4A0(&v112, v25, v50, v75);
    *(float*)&v76 = *(float*)&dword_520120 * a11;
    *(float*)&v51 = *(float*)&dword_52011C * a11;
    *(float*)&v26 = *(float*)&dword_520118 * a11;
    sub_40F4A0(&v97, v26, v51, v76);
    *(float*)&v77 = *(float*)&dword_520110 * a12;
    *(float*)&v52 = *(float*)&dword_52010C * a12;
    *(float*)&v27 = *(float*)&dword_520108 * a12;
    sub_40F4A0(&v103, v27, v52, v77);
    *(float*)&v78 = v99 + v105;
    *(float*)&v53 = v98 + v104;
    *(float*)&v28 = v97 + v103;
    sub_40F4A0(&v100, v28, v53, v78);
    *(float*)&v79 = v102 * v122;
    *(float*)&v54 = v101 * v122;
    *(float*)&v29 = *(float*)&v100 * v122;
    sub_40F4A0(&v106, v29, v54, v79);
    *(float*)&v80 = v114 + v108;
    *(float*)&v55 = v113 + v107;
    *(float*)&v30 = v112 + v106;
    sub_40F4A0(&v109, v30, v55, v80);
    sub_408A30(v115, &v109);
    *(float*)&v81 = *(float*)&dword_520120 * a11;
    *(float*)&v56 = *(float*)&dword_52011C * a11;
    *(float*)&v31 = *(float*)&dword_520118 * a11;
    sub_40F4A0(&v97, v31, v56, v81);
    *(float*)&v82 = *(float*)&dword_520110 * a12;
    *(float*)&v57 = *(float*)&dword_52010C * a12;
    *(float*)&v32 = *(float*)&dword_520108 * a12;
    sub_40F4A0(&v106, v32, v57, v82);
    *(float*)&v83 = v108 - v99;
    *(float*)&v58 = v107 - v98;
    *(float*)&v33 = v106 - v97;
    sub_40F4A0(&v103, v33, v58, v83);
    *(float*)&v84 = v105 * v122;
    *(float*)&v59 = v104 * v122;
    *(float*)&v34 = v103 * v122;
    sub_40F4A0(&v100, v34, v59, v84);
    *(float*)&v85 = v102 + v114;
    *(float*)&v60 = v101 + v113;
    *(float*)&v35 = *(float*)&v100 + v112;
    sub_40F4A0(&v109, v35, v60, v85);
    sub_408A30(v117, &v109);
    *(float*)&v86 = *(float*)&dword_520120 * a11;
    *(float*)&v61 = *(float*)&dword_52011C * a11;
    *(float*)&v36 = *(float*)&dword_520118 * a11;
    sub_40F4A0(&v97, v36, v61, v86);
    *(float*)&v87 = -*(float*)&dword_520110;
    *(float*)&v62 = -*(float*)&dword_52010C;
    *(float*)&v37 = -*(float*)&dword_520108;
    sub_40F4A0(&v106, v37, v62, v87);
    *(float*)&v88 = v108 * a12;
    *(float*)&v63 = v107 * a12;
    *(float*)&v38 = v106 * a12;
    sub_40F4A0(&v103, v38, v63, v88);
    *(float*)&v89 = v99 + v105;
    *(float*)&v64 = v98 + v104;
    *(float*)&v39 = v97 + v103;
    sub_40F4A0(&v100, v39, v64, v89);
    *(float*)&v90 = v102 * v122;
    *(float*)&v65 = v101 * v122;
    *(float*)&v40 = *(float*)&v100 * v122;
    sub_40F4A0(&v109, v40, v65, v90);
    *(float*)&v91 = v111 + v114;
    *(float*)&v66 = v110 + v113;
    *(float*)&v41 = v109 + v112;
    sub_40F4A0(v119, v41, v66, v91);
    sub_408A30(v118, v119);
    *(float*)&v92 = *(float*)&dword_520120 * a11;
    *(float*)&v67 = *(float*)&dword_52011C * a11;
    *(float*)&v42 = *(float*)&dword_520118 * a11;
    sub_40F4A0(&v97, v42, v67, v92);
    *(float*)&v93 = -*(float*)&dword_520110;
    *(float*)&v68 = -*(float*)&dword_52010C;
    *(float*)&v43 = -*(float*)&dword_520108;
    sub_40F4A0(&v109, v43, v68, v93);
    *(float*)&v94 = v111 * a12;
    *(float*)&v69 = v110 * a12;
    *(float*)&v44 = v109 * a12;
    sub_40F4A0(&v106, v44, v69, v94);
    *(float*)&v95 = v108 - v99;
    *(float*)&v70 = v107 - v98;
    *(float*)&v45 = v106 - v97;
    sub_40F4A0(v119, v45, v70, v95);
    v18 = sub_4162F0(v119, (float*)&v100, v122);
    v19 = sub_4162C0(v18, &v103, &v112);
    sub_408A30(v116, v19);
    sub_421100(v115, (float*)v121);
    sub_421100(v117, (float*)v121);
    sub_421100(v118, (float*)v121);
    sub_421100(v116, (float*)v121);
    (*(void(__stdcall**)(int, _DWORD, int, int*, _DWORD))(*(_DWORD*)dword_5200F8 + 44))(
        dword_5200F8,
        0,
        24576,
        &v96,
        0);
    v96 += 96 * dword_520100;
    *(float*)v96 = v115[0];
    *(float*)(v96 + 4) = v115[1];
    *(float*)(v96 + 8) = v115[2];
    *(_DWORD*)(v96 + 12) = a6;
    *(float*)(v96 + 16) = a7;
    *(float*)(v96 + 20) = a8;
    *(float*)(v96 + 24) = v117[0];
    *(float*)(v96 + 28) = v117[1];
    *(float*)(v96 + 32) = v117[2];
    *(_DWORD*)(v96 + 36) = a6;
    *(float*)(v96 + 40) = a9;
    *(float*)(v96 + 44) = a8;
    *(float*)(v96 + 48) = v118[0];
    *(float*)(v96 + 52) = v118[1];
    *(float*)(v96 + 56) = v118[2];
    *(_DWORD*)(v96 + 60) = a6;
    *(float*)(v96 + 64) = a7;
    *(float*)(v96 + 68) = a10;
    *(float*)(v96 + 72) = v116[0];
    *(float*)(v96 + 76) = v116[1];
    *(float*)(v96 + 80) = v116[2];
    *(_DWORD*)(v96 + 84) = a6;
    *(float*)(v96 + 88) = a9;
    *(float*)(v96 + 92) = a10;
    (*(void(__stdcall**)(int))(*(_DWORD*)dword_5200F8 + 48))(dword_5200F8);
    result = 0;
    if (++dword_520100 == 256)
    {
        result = sub_4204C0();
        dword_520100 = 0;
    }
    return result;
}
// 5200F8: using guessed type int dword_5200F8;
// 520100: using guessed type int dword_520100;
// 520108: using guessed type int dword_520108;
// 52010C: using guessed type int dword_52010C;
// 520110: using guessed type int dword_520110;
// 520118: using guessed type int dword_520118;
// 52011C: using guessed type int dword_52011C;
// 520120: using guessed type int dword_520120;
// 520970: using guessed type int dword_520970;

//----- (00420350) --------------------------------------------------------
int __cdecl sub_420350(_DWORD* a1, _DWORD* a2, _DWORD* a3, _DWORD* a4, int a5)
{
    int result; // eax
    _DWORD* v6; // [esp+14h] [ebp-4h] BYREF

    byte_5200FC = 1;
    (*(void(__stdcall**)(int, _DWORD, int, _DWORD**, _DWORD))(*(_DWORD*)dword_5200F8 + 44))(
        dword_5200F8,
        0,
        24576,
        &v6,
        0);
    v6 += 24 * dword_520100;
    *v6 = *a1;
    v6[1] = a1[1];
    v6[2] = a1[2];
    v6[3] = a5;
    v6[4] = 0;
    v6[5] = 0;
    v6[6] = *a2;
    v6[7] = a2[1];
    v6[8] = a2[2];
    v6[9] = a5;
    v6[10] = 1065353216;
    v6[11] = 0;
    v6[12] = *a4;
    v6[13] = a4[1];
    v6[14] = a4[2];
    v6[15] = a5;
    v6[16] = 0;
    v6[17] = 1065353216;
    v6[18] = *a3;
    v6[19] = a3[1];
    v6[20] = a3[2];
    v6[21] = a5;
    v6[22] = 1065353216;
    v6[23] = 1065353216;
    (*(void(__stdcall**)(int))(*(_DWORD*)dword_5200F8 + 48))(dword_5200F8);
    result = 0;
    if (++dword_520100 == 256)
    {
        result = sub_4204C0();
        dword_520100 = 0;
    }
    return result;
}
// 5200F8: using guessed type int dword_5200F8;
// 5200FC: using guessed type char byte_5200FC;
// 520100: using guessed type int dword_520100;

//----- (004204A0) --------------------------------------------------------
int sub_4204A0()
{
    int result; // eax

    result = 0;
    if (dword_520100 > 0)
        result = sub_4204C0();
    dword_520100 = -1;
    return result;
}
// 520100: using guessed type int dword_520100;

//----- (004204C0) --------------------------------------------------------
int sub_4204C0()
{
    _DWORD v1[16]; // [esp+0h] [ebp-40h] BYREF

    memset(&v1[11], 0, 16);
    memset(&v1[6], 0, 16);
    memset(&v1[1], 0, 16);
    v1[15] = 1065353216;
    v1[10] = 1065353216;
    v1[5] = 1065353216;
    v1[0] = 1065353216;
    (*(void(__stdcall**)(_DWORD, int, _DWORD*))(**(_DWORD**)ArgList + 148))(*(_DWORD*)ArgList, 256, v1);
    (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 47, 2);
    if (byte_5200FC)
        (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 22, 1);
    (*(void(__stdcall**)(_DWORD, int, _DWORD, int, _DWORD, int))(**(_DWORD**)ArgList + 284))(
        *(_DWORD*)ArgList,
        4,
        0,
        4 * dword_520100,
        0,
        2 * dword_520100);
    (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 47, 0);
    if (byte_5200FC)
    {
        (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 22, 3);
        byte_5200FC = 0;
    }
    *(float*)dword_520A20 = *(float*)dword_520A20 + 1.0;
    return 2 * dword_520100;
}
// 5200FC: using guessed type char byte_5200FC;
// 520100: using guessed type int dword_520100;
// 520A20: using guessed type int dword_520A20;

//----- (00420600) --------------------------------------------------------
bool __cdecl sub_420600(
    float* a1,
    float* a2,
    int a3,
    int a4,
    int a5,
    float a6,
    float a7,
    float* a8,
    float a9,
    float a10,
    float a11,
    float a12)
{
    float* v12; // eax
    double v13; // st7
    double v14; // st7
    double v15; // st7
    float* v16; // eax
    float* v17; // eax
    float* v18; // eax
    float* v19; // eax
    float* v20; // eax
    float* v21; // eax
    float* v22; // eax
    float* v23; // eax
    float* v24; // eax
    float* v25; // eax
    float* v27; // [esp-8h] [ebp-F0h]
    int v28; // [esp+0h] [ebp-E8h]
    int v29; // [esp+0h] [ebp-E8h]
    int v30; // [esp+0h] [ebp-E8h]
    int v31; // [esp+0h] [ebp-E8h]
    int v32; // [esp+0h] [ebp-E8h]
    int v33; // [esp+0h] [ebp-E8h]
    int v34; // [esp+0h] [ebp-E8h]
    int v35; // [esp+0h] [ebp-E8h]
    int v36; // [esp+0h] [ebp-E8h]
    int v37; // [esp+0h] [ebp-E8h]
    int v38; // [esp+0h] [ebp-E8h]
    int v39; // [esp+0h] [ebp-E8h]
    int v40; // [esp+0h] [ebp-E8h]
    int v41; // [esp+0h] [ebp-E8h]
    int v42; // [esp+0h] [ebp-E8h]
    int v43; // [esp+0h] [ebp-E8h]
    int v44; // [esp+4h] [ebp-E4h]
    int v45; // [esp+4h] [ebp-E4h]
    int v46; // [esp+4h] [ebp-E4h]
    int v47; // [esp+4h] [ebp-E4h]
    int v48; // [esp+4h] [ebp-E4h]
    int v49; // [esp+4h] [ebp-E4h]
    int v50; // [esp+4h] [ebp-E4h]
    int v51; // [esp+4h] [ebp-E4h]
    int v52; // [esp+4h] [ebp-E4h]
    int v53; // [esp+4h] [ebp-E4h]
    int v54; // [esp+4h] [ebp-E4h]
    int v55; // [esp+4h] [ebp-E4h]
    int v56; // [esp+4h] [ebp-E4h]
    int v57; // [esp+4h] [ebp-E4h]
    int v58; // [esp+4h] [ebp-E4h]
    int v59; // [esp+4h] [ebp-E4h]
    int v60; // [esp+8h] [ebp-E0h]
    int v61; // [esp+8h] [ebp-E0h]
    int v62; // [esp+8h] [ebp-E0h]
    int v63; // [esp+8h] [ebp-E0h]
    int v64; // [esp+8h] [ebp-E0h]
    int v65; // [esp+8h] [ebp-E0h]
    int v66; // [esp+8h] [ebp-E0h]
    int v67; // [esp+8h] [ebp-E0h]
    int v68; // [esp+8h] [ebp-E0h]
    int v69; // [esp+8h] [ebp-E0h]
    int v70; // [esp+8h] [ebp-E0h]
    int v71; // [esp+8h] [ebp-E0h]
    int v72; // [esp+8h] [ebp-E0h]
    int v73; // [esp+8h] [ebp-E0h]
    int v74; // [esp+8h] [ebp-E0h]
    int v75; // [esp+8h] [ebp-E0h]
    int v76; // [esp+18h] [ebp-D0h] BYREF
    float v77; // [esp+1Ch] [ebp-CCh]
    float v78; // [esp+20h] [ebp-C8h]
    int v79; // [esp+24h] [ebp-C4h] BYREF
    float v80; // [esp+28h] [ebp-C0h]
    float v81; // [esp+2Ch] [ebp-BCh]
    int v82; // [esp+30h] [ebp-B8h] BYREF
    float v83; // [esp+34h] [ebp-B4h]
    float v84; // [esp+38h] [ebp-B0h]
    int v85; // [esp+3Ch] [ebp-ACh] BYREF
    float v86; // [esp+40h] [ebp-A8h]
    float v87; // [esp+44h] [ebp-A4h]
    float v88; // [esp+48h] [ebp-A0h] BYREF
    float v89; // [esp+4Ch] [ebp-9Ch]
    float v90; // [esp+50h] [ebp-98h]
    int v91[3]; // [esp+54h] [ebp-94h] BYREF
    float v92[3]; // [esp+60h] [ebp-88h] BYREF
    float v93[3]; // [esp+6Ch] [ebp-7Ch] BYREF
    float v94[3]; // [esp+78h] [ebp-70h] BYREF
    float v95[3]; // [esp+84h] [ebp-64h] BYREF
    int v96[3]; // [esp+90h] [ebp-58h] BYREF
    float v97[3]; // [esp+9Ch] [ebp-4Ch] BYREF
    int v98[16]; // [esp+A8h] [ebp-40h] BYREF
    float v99; // [esp+100h] [ebp+18h]

    v99 = a6 * 0.5;
    sub_406BE0(v98);
    v12 = (float*)sub_408F30((_DWORD*)dword_520970);
    *(float*)&v60 = v12[13] - v12[10];
    *(float*)&v44 = v12[12] - v12[9];
    *(float*)&v28 = v12[11] - v12[8];
    sub_40F4A0(v96, v28, v44, v60);
    sub_46BFED((int)v98, (int)v96, a7);
    sub_40E880(v98, a3, a4, a5);
    v13 = -a11;
    *(float*)&v61 = v13 * *(float*)&dword_520120;
    *(float*)&v45 = v13 * *(float*)&dword_52011C;
    *(float*)&v29 = v13 * *(float*)&dword_520118;
    sub_40F4A0(&v82, v29, v45, v61);
    v14 = -a12;
    *(float*)&v62 = v14 * *(float*)&dword_520110;
    *(float*)&v46 = v14 * *(float*)&dword_52010C;
    *(float*)&v30 = v14 * *(float*)&dword_520108;
    sub_40F4A0(&v76, v30, v46, v62);
    *(float*)&v63 = v84 + v78;
    *(float*)&v47 = v83 + v77;
    *(float*)&v31 = *(float*)&v82 + *(float*)&v76;
    sub_40F4A0(&v79, v31, v47, v63);
    v15 = v99 + v99;
    *(float*)&v64 = v81 * v15;
    *(float*)&v48 = v80 * v15;
    *(float*)&v32 = *(float*)&v79 * v15;
    sub_40F4A0(&v88, v32, v48, v64);
    *(float*)&v65 = *(float*)&dword_520120 * a9;
    *(float*)&v49 = *(float*)&dword_52011C * a9;
    *(float*)&v33 = *(float*)&dword_520118 * a9;
    sub_40F4A0(&v79, v33, v49, v65);
    *(float*)&v66 = *(float*)&dword_520110 * a10;
    *(float*)&v50 = *(float*)&dword_52010C * a10;
    *(float*)&v34 = *(float*)&dword_520108 * a10;
    sub_40F4A0(&v76, v34, v50, v66);
    *(float*)&v67 = v81 + v78;
    *(float*)&v51 = v80 + v77;
    *(float*)&v35 = *(float*)&v79 + *(float*)&v76;
    sub_40F4A0(&v82, v35, v51, v67);
    *(float*)&v68 = v84 * v99;
    *(float*)&v52 = v83 * v99;
    *(float*)&v36 = *(float*)&v82 * v99;
    sub_40F4A0(&v85, v36, v52, v68);
    *(float*)&v69 = v90 + v87;
    *(float*)&v53 = v89 + v86;
    *(float*)&v37 = v88 + *(float*)&v85;
    sub_40F4A0(v91, v37, v53, v69);
    sub_408A30(v95, v91);
    *(float*)&v70 = *(float*)&dword_520120 * a9;
    *(float*)&v54 = *(float*)&dword_52011C * a9;
    *(float*)&v38 = *(float*)&dword_520118 * a9;
    sub_40F4A0(&v79, v38, v54, v70);
    *(float*)&v71 = *(float*)&dword_520110 * a10;
    *(float*)&v55 = *(float*)&dword_52010C * a10;
    *(float*)&v39 = *(float*)&dword_520108 * a10;
    sub_40F4A0(&v85, v39, v55, v71);
    *(float*)&v72 = v87 - v81;
    *(float*)&v56 = v86 - v80;
    *(float*)&v40 = *(float*)&v85 - *(float*)&v79;
    sub_40F4A0(&v76, v40, v56, v72);
    *(float*)&v73 = v78 * v99;
    *(float*)&v57 = v77 * v99;
    *(float*)&v41 = *(float*)&v76 * v99;
    sub_40F4A0(&v82, v41, v57, v73);
    *(float*)&v74 = v84 + v90;
    *(float*)&v58 = v83 + v89;
    *(float*)&v42 = *(float*)&v82 + v88;
    sub_40F4A0(v91, v42, v58, v74);
    sub_408A30(v93, v91);
    *(float*)&v75 = *(float*)&dword_520120 * a9;
    *(float*)&v59 = *(float*)&dword_52011C * a9;
    *(float*)&v43 = *(float*)&dword_520118 * a9;
    sub_40F4A0(v91, v43, v59, v75);
    v16 = sub_4210B0((float*)&dword_520108, v97);
    v17 = sub_4162F0(v16, (float*)&v82, a10);
    v18 = sub_4162C0(v17, (float*)&v76, (float*)v91);
    v19 = sub_4162F0(v18, (float*)&v79, v99);
    v20 = sub_4162C0(v19, (float*)&v85, &v88);
    sub_408A30(v92, v20);
    v27 = sub_4162F0((float*)&dword_520118, (float*)&v85, a9);
    v21 = sub_4210B0((float*)&dword_520108, (float*)&v82);
    v22 = sub_4162F0(v21, (float*)&v76, a10);
    v23 = sub_4210D0(v22, (float*)&v79, v27);
    v24 = sub_4162F0(v23, (float*)v91, v99);
    v25 = sub_4162C0(v24, v97, &v88);
    sub_408A30(v94, v25);
    sub_421100(v95, (float*)v98);
    sub_421100(v93, (float*)v98);
    sub_421100(v92, (float*)v98);
    sub_421100(v94, (float*)v98);
    return sub_40C910(a1, a2, v95, v93, v92, a8) || sub_40C910(a1, a2, v94, v92, v93, a8) != 0;
}
// 520108: using guessed type int dword_520108;
// 52010C: using guessed type int dword_52010C;
// 520110: using guessed type int dword_520110;
// 520118: using guessed type int dword_520118;
// 52011C: using guessed type int dword_52011C;
// 520120: using guessed type int dword_520120;
// 520970: using guessed type int dword_520970;

//----- (00420B50) --------------------------------------------------------
bool __cdecl sub_420B50(
    float* a1,
    float a2,
    int a3,
    int a4,
    int a5,
    float a6,
    float a7,
    float* a8,
    float* a9,
    float a10,
    float a11,
    float a12,
    float a13)
{
    float* v13; // eax
    double v14; // st7
    double v15; // st7
    double v16; // st7
    float* v17; // eax
    float* v18; // eax
    float* v19; // eax
    float* v20; // eax
    float* v21; // eax
    float* v22; // eax
    float* v23; // eax
    float* v24; // eax
    float* v25; // eax
    float* v26; // eax
    float* v28; // [esp-8h] [ebp-F4h]
    int v29; // [esp+0h] [ebp-ECh]
    int v30; // [esp+0h] [ebp-ECh]
    int v31; // [esp+0h] [ebp-ECh]
    int v32; // [esp+0h] [ebp-ECh]
    int v33; // [esp+0h] [ebp-ECh]
    int v34; // [esp+0h] [ebp-ECh]
    int v35; // [esp+0h] [ebp-ECh]
    int v36; // [esp+0h] [ebp-ECh]
    int v37; // [esp+0h] [ebp-ECh]
    int v38; // [esp+0h] [ebp-ECh]
    int v39; // [esp+0h] [ebp-ECh]
    int v40; // [esp+0h] [ebp-ECh]
    int v41; // [esp+0h] [ebp-ECh]
    int v42; // [esp+0h] [ebp-ECh]
    int v43; // [esp+0h] [ebp-ECh]
    int v44; // [esp+0h] [ebp-ECh]
    int v45; // [esp+4h] [ebp-E8h]
    int v46; // [esp+4h] [ebp-E8h]
    int v47; // [esp+4h] [ebp-E8h]
    int v48; // [esp+4h] [ebp-E8h]
    int v49; // [esp+4h] [ebp-E8h]
    int v50; // [esp+4h] [ebp-E8h]
    int v51; // [esp+4h] [ebp-E8h]
    int v52; // [esp+4h] [ebp-E8h]
    int v53; // [esp+4h] [ebp-E8h]
    int v54; // [esp+4h] [ebp-E8h]
    int v55; // [esp+4h] [ebp-E8h]
    int v56; // [esp+4h] [ebp-E8h]
    int v57; // [esp+4h] [ebp-E8h]
    int v58; // [esp+4h] [ebp-E8h]
    int v59; // [esp+4h] [ebp-E8h]
    int v60; // [esp+4h] [ebp-E8h]
    int v61; // [esp+8h] [ebp-E4h]
    int v62; // [esp+8h] [ebp-E4h]
    int v63; // [esp+8h] [ebp-E4h]
    int v64; // [esp+8h] [ebp-E4h]
    int v65; // [esp+8h] [ebp-E4h]
    int v66; // [esp+8h] [ebp-E4h]
    int v67; // [esp+8h] [ebp-E4h]
    int v68; // [esp+8h] [ebp-E4h]
    int v69; // [esp+8h] [ebp-E4h]
    int v70; // [esp+8h] [ebp-E4h]
    int v71; // [esp+8h] [ebp-E4h]
    int v72; // [esp+8h] [ebp-E4h]
    int v73; // [esp+8h] [ebp-E4h]
    int v74; // [esp+8h] [ebp-E4h]
    int v75; // [esp+8h] [ebp-E4h]
    int v76; // [esp+8h] [ebp-E4h]
    int v77; // [esp+1Ch] [ebp-D0h] BYREF
    float v78; // [esp+20h] [ebp-CCh]
    float v79; // [esp+24h] [ebp-C8h]
    int v80; // [esp+28h] [ebp-C4h] BYREF
    float v81; // [esp+2Ch] [ebp-C0h]
    float v82; // [esp+30h] [ebp-BCh]
    int v83; // [esp+34h] [ebp-B8h] BYREF
    float v84; // [esp+38h] [ebp-B4h]
    float v85; // [esp+3Ch] [ebp-B0h]
    int v86; // [esp+40h] [ebp-ACh] BYREF
    float v87; // [esp+44h] [ebp-A8h]
    float v88; // [esp+48h] [ebp-A4h]
    float v89; // [esp+4Ch] [ebp-A0h] BYREF
    float v90; // [esp+50h] [ebp-9Ch]
    float v91; // [esp+54h] [ebp-98h]
    int v92[3]; // [esp+58h] [ebp-94h] BYREF
    int v93[3]; // [esp+64h] [ebp-88h] BYREF
    int v94[3]; // [esp+70h] [ebp-7Ch] BYREF
    int v95[3]; // [esp+7Ch] [ebp-70h] BYREF
    int v96[3]; // [esp+88h] [ebp-64h] BYREF
    int v97[3]; // [esp+94h] [ebp-58h] BYREF
    float v98[3]; // [esp+A0h] [ebp-4Ch] BYREF
    int v99[16]; // [esp+ACh] [ebp-40h] BYREF
    float v100; // [esp+104h] [ebp+18h]

    v100 = a6 * 0.5;
    sub_406BE0(v99);
    v13 = (float*)sub_408F30((_DWORD*)dword_520970);
    *(float*)&v61 = v13[13] - v13[10];
    *(float*)&v45 = v13[12] - v13[9];
    *(float*)&v29 = v13[11] - v13[8];
    sub_40F4A0(v97, v29, v45, v61);
    sub_46BFED((int)v99, (int)v97, a7);
    sub_40E880(v99, a3, a4, a5);
    v14 = -a12;
    *(float*)&v62 = v14 * *(float*)&dword_520120;
    *(float*)&v46 = v14 * *(float*)&dword_52011C;
    *(float*)&v30 = v14 * *(float*)&dword_520118;
    sub_40F4A0(&v83, v30, v46, v62);
    v15 = -a13;
    *(float*)&v63 = v15 * *(float*)&dword_520110;
    *(float*)&v47 = v15 * *(float*)&dword_52010C;
    *(float*)&v31 = v15 * *(float*)&dword_520108;
    sub_40F4A0(&v77, v31, v47, v63);
    *(float*)&v64 = v85 + v79;
    *(float*)&v48 = v84 + v78;
    *(float*)&v32 = *(float*)&v83 + *(float*)&v77;
    sub_40F4A0(&v80, v32, v48, v64);
    v16 = v100 + v100;
    *(float*)&v65 = v82 * v16;
    *(float*)&v49 = v81 * v16;
    *(float*)&v33 = *(float*)&v80 * v16;
    sub_40F4A0(&v89, v33, v49, v65);
    *(float*)&v66 = *(float*)&dword_520120 * a10;
    *(float*)&v50 = *(float*)&dword_52011C * a10;
    *(float*)&v34 = *(float*)&dword_520118 * a10;
    sub_40F4A0(&v80, v34, v50, v66);
    *(float*)&v67 = *(float*)&dword_520110 * a11;
    *(float*)&v51 = *(float*)&dword_52010C * a11;
    *(float*)&v35 = *(float*)&dword_520108 * a11;
    sub_40F4A0(&v77, v35, v51, v67);
    *(float*)&v68 = v82 + v79;
    *(float*)&v52 = v81 + v78;
    *(float*)&v36 = *(float*)&v80 + *(float*)&v77;
    sub_40F4A0(&v83, v36, v52, v68);
    *(float*)&v69 = v85 * v100;
    *(float*)&v53 = v84 * v100;
    *(float*)&v37 = *(float*)&v83 * v100;
    sub_40F4A0(&v86, v37, v53, v69);
    *(float*)&v70 = v91 + v88;
    *(float*)&v54 = v90 + v87;
    *(float*)&v38 = v89 + *(float*)&v86;
    sub_40F4A0(v92, v38, v54, v70);
    sub_408A30(v96, v92);
    *(float*)&v71 = *(float*)&dword_520120 * a10;
    *(float*)&v55 = *(float*)&dword_52011C * a10;
    *(float*)&v39 = *(float*)&dword_520118 * a10;
    sub_40F4A0(&v80, v39, v55, v71);
    *(float*)&v72 = *(float*)&dword_520110 * a11;
    *(float*)&v56 = *(float*)&dword_52010C * a11;
    *(float*)&v40 = *(float*)&dword_520108 * a11;
    sub_40F4A0(&v86, v40, v56, v72);
    *(float*)&v73 = v88 - v82;
    *(float*)&v57 = v87 - v81;
    *(float*)&v41 = *(float*)&v86 - *(float*)&v80;
    sub_40F4A0(&v77, v41, v57, v73);
    *(float*)&v74 = v79 * v100;
    *(float*)&v58 = v78 * v100;
    *(float*)&v42 = *(float*)&v77 * v100;
    sub_40F4A0(&v83, v42, v58, v74);
    *(float*)&v75 = v85 + v91;
    *(float*)&v59 = v84 + v90;
    *(float*)&v43 = *(float*)&v83 + v89;
    sub_40F4A0(v92, v43, v59, v75);
    sub_408A30(v94, v92);
    *(float*)&v76 = *(float*)&dword_520120 * a10;
    *(float*)&v60 = *(float*)&dword_52011C * a10;
    *(float*)&v44 = *(float*)&dword_520118 * a10;
    sub_40F4A0(v92, v44, v60, v76);
    v17 = sub_4210B0((float*)&dword_520108, v98);
    v18 = sub_4162F0(v17, (float*)&v83, a11);
    v19 = sub_4162C0(v18, (float*)&v77, (float*)v92);
    v20 = sub_4162F0(v19, (float*)&v80, v100);
    v21 = sub_4162C0(v20, (float*)&v86, &v89);
    sub_408A30(v93, v21);
    v28 = sub_4162F0((float*)&dword_520118, (float*)&v86, a10);
    v22 = sub_4210B0((float*)&dword_520108, (float*)&v83);
    v23 = sub_4162F0(v22, (float*)&v77, a11);
    v24 = sub_4210D0(v23, (float*)&v80, v28);
    v25 = sub_4162F0(v24, (float*)v92, v100);
    v26 = sub_4162C0(v25, v98, &v89);
    sub_408A30(v95, v26);
    sub_421100((float*)v96, (float*)v99);
    sub_421100((float*)v94, (float*)v99);
    sub_421100((float*)v93, (float*)v99);
    sub_421100((float*)v95, (float*)v99);
    return sub_40CCD0(a1, a2, (float*)v96, (float*)v94, (float*)v93, a8, a9)
        || sub_40CCD0(a1, a2, (float*)v95, (float*)v93, (float*)v94, a8, a9) != 0;
}
// 520108: using guessed type int dword_520108;
// 52010C: using guessed type int dword_52010C;
// 520110: using guessed type int dword_520110;
// 520118: using guessed type int dword_520118;
// 52011C: using guessed type int dword_52011C;
// 520120: using guessed type int dword_520120;
// 520970: using guessed type int dword_520970;

//----- (004210B0) --------------------------------------------------------
float* __thiscall sub_4210B0(float* this, float* a2)
{
    double v2; // st7
    float* result; // eax
    double v4; // st6

    v2 = -this[2];
    result = a2;
    v4 = -this[1];
    *a2 = -*this;
    a2[1] = v4;
    a2[2] = v2;
    return result;
}

//----- (004210D0) --------------------------------------------------------
float* __thiscall sub_4210D0(float* this, float* a2, float* a3)
{
    double v3; // st7
    double v4; // st6
    float* result; // eax

    v3 = this[2] - a3[2];
    v4 = this[1] - a3[1];
    result = a2;
    *a2 = *this - *a3;
    a2[1] = v4;
    a2[2] = v3;
    return result;
}

//----- (00421100) --------------------------------------------------------
float* __thiscall sub_421100(float* this, float* a2)
{
    return sub_46C5C5(this, this, a2);
}

//----- (00421110) --------------------------------------------------------
char __thiscall sub_421110(int this, const char* a2)
{
    signed int v3; // kr04_4

    v3 = strlen(a2) + 1;
    if (v3 > *(_DWORD*)(this + 4))
    {
        sub_4885A6(*(LPVOID*)(this + 8));
        *(_DWORD*)(this + 8) = operator new(v3);
        *(_DWORD*)(this + 4) = v3;
    }
    strcpy(*(char**)(this + 8), a2);
    return sub_421AB0(*(_DWORD*)this, *(char**)(this + 8), (float*)(this + 24), (_DWORD*)(this + 28));
}

//----- (00421190) --------------------------------------------------------
char sub_421190(int a1, char* Format, ...)
{
    va_list va; // [esp+10h] [ebp+Ch] BYREF

    va_start(va, Format);
    if (_vsnprintf(*(char* const*)(a1 + 8), *(_DWORD*)(a1 + 4) - 1, Format, va) == -1)
        *(_BYTE*)(*(_DWORD*)(a1 + 8) + *(_DWORD*)(a1 + 4) - 1) = 0;
    return sub_421AB0(*(_DWORD*)a1, *(char**)(a1 + 8), (float*)(a1 + 24), (_DWORD*)(a1 + 28));
}

//----- (004211E0) --------------------------------------------------------
char __thiscall sub_4211E0(int this, char a2)
{
    unsigned int v3; // kr04_4
    char* v5; // [esp+Ch] [ebp-4h]

    v3 = strlen(*(const char**)(this + 8)) + 1;
    if ((signed int)(v3 + 1) > *(_DWORD*)(this + 4))
    {
        v5 = strcpy((char*)operator new(v3 + 1), *(const char**)(this + 8));
        sub_4885A6(*(LPVOID*)(this + 8));
        *(_DWORD*)(this + 8) = v5;
        *(_DWORD*)(this + 4) = v3 + 1;
    }
    *(_BYTE*)(*(_DWORD*)(this + 8) + v3 - 1) = a2;
    *(_BYTE*)(*(_DWORD*)(this + 8) + v3) = 0;
    return sub_421AB0(*(_DWORD*)this, *(char**)(this + 8), (float*)(this + 24), (_DWORD*)(this + 28));
}

//----- (00421280) --------------------------------------------------------
char __thiscall sub_421280(int this)
{
    const char* v2; // esi
    unsigned int v3; // kr04_4

    v2 = *(const char**)(this + 8);
    v3 = strlen(v2) + 1;
    if ((int)(v3 - 1) > 0)
        v2[v3 - 2] = 0;
    return sub_421AB0(*(_DWORD*)this, *(char**)(this + 8), (float*)(this + 24), (_DWORD*)(this + 28));
}

//----- (004212C0) --------------------------------------------------------
_DWORD* __thiscall sub_4212C0(int this, int a2)
{
    *(_DWORD*)(this + 52) = (a2 << 24) | *(_DWORD*)(this + 52) & 0xFFFFFF;
    *(_DWORD*)(this + 56) = (a2 << 24) | *(_DWORD*)(this + 56) & 0xFFFFFF;
    *(_BYTE*)(this + 34) = a2 == 0;
    return sub_421540((void**)this);
}

//----- (00421300) --------------------------------------------------------
_DWORD* __thiscall sub_421300(int this, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
    *(_DWORD*)(this + 52) = a4 | ((a3 | (((a5 << 8) | a2) << 8)) << 8);
    *(_BYTE*)(this + 34) = a5 == 0;
    return sub_421540((void**)this);
}

//----- (00421350) --------------------------------------------------------
_DWORD* __thiscall sub_421350(int this, int a2)
{
    *(_DWORD*)(this + 52) = a2;
    *(_BYTE*)(this + 34) = (a2 & 0xFF000000) == 0;
    return sub_421540((void**)this);
}

//----- (00421370) --------------------------------------------------------
int __thiscall sub_421370(_DWORD* this, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
    int result; // eax

    result = a4 | ((a3 | (((a5 << 8) | a2) << 8)) << 8);
    this[14] = result;
    return result;
}

//----- (004213B0) --------------------------------------------------------
void __thiscall sub_4213B0(int this)
{
    int v2; // eax
    _DWORD* v3; // esi
    int v4; // ecx
    _DWORD* v5; // ebx
    _DWORD* v6; // edx
    int v7; // ecx
    void* v8; // edi

    v2 = 0;
    v3 = (_DWORD*)(*(_DWORD*)(this + 48) + 36);
    v4 = *(_DWORD*)(*(_DWORD*)(this + 48) + 40);
    if (v4 > 0)
    {
        v5 = (_DWORD*)*v3;
        v6 = (_DWORD*)*v3;
        while (*v6 != this)
        {
            ++v2;
            ++v6;
            if (v2 >= v4)
                goto LABEL_8;
        }
        v7 = v4 - 1;
        v3[1] = v7;
        if (v2 != v7)
        {
            memcpy(&v5[v2], &v5[v2 + 1], 4 * (v7 + 0x3FFFFFFF * v2));
            *(_DWORD*)(*v3 + 4 * v3[1]) = 0;
        }
    }
LABEL_8:
    sub_4885A6(*(LPVOID*)(this + 8));
    v8 = *(void**)(this + 44);
    if (v8)
        sub_409A00(dword_520970, v8);
}
// 520970: using guessed type int dword_520970;

//----- (00421430) --------------------------------------------------------
int __thiscall sub_421430(_DWORD* this, int a2, int a3, int a4, int a5)
{
    int result; // eax

    this[16] = a2;
    result = a4;
    this[17] = a3;
    this[15] = 0;
    this[18] = a4;
    this[19] = a5;
    return result;
}

//----- (00421460) --------------------------------------------------------
void __thiscall sub_421460(int this, int a2)
{
    double v2; // st7
    double v3; // st7
    double v4; // st7
    float v5; // [esp+4h] [ebp-4h]

    v5 = *(float*)(dword_520970 + 68) + *(float*)(this + 60);
    v2 = *(float*)(this + 64);
    *(float*)(this + 60) = v5;
    if (v2 >= 0.0)
    {
        if (v5 > (double)*(float*)(this + 64))
        {
            if (v5 >= (double)*(float*)(this + 68))
            {
                sub_4212C0(this, *(_DWORD*)(this + 76));
            }
            else
            {
                v3 = *(float*)(this + 68) - *(float*)(this + 64);
                if (v3 == 0.0)
                    v4 = 0.0;
                else
                    v4 = (v5 - *(float*)(this + 64)) / v3;
                sub_4212C0(
                    this,
                    (__int64)(((double)*(int*)(this + 76) - (double)*(int*)(this + 72)) * v4 + (double)*(int*)(this + 72)));
            }
        }
        else
        {
            sub_4212C0(this, *(_DWORD*)(this + 72));
        }
    }
}
// 520970: using guessed type int dword_520970;

//----- (00421540) --------------------------------------------------------
_DWORD* __thiscall sub_421540(void** this)
{
    _DWORD* v2; // eax
    _DWORD* result; // eax

    if (!*((_BYTE*)this + 33) || *((_BYTE*)this + 34))
    {
        if (this[11])
        {
            sub_409A00(dword_520970, this[11]);
            this[11] = 0;
        }
    }
    else if (!this[11])
    {
        v2 = sub_409960((_DWORD*)dword_520970, *(_DWORD*)(dword_520970 + 132));
        this[11] = v2;
        v2[3] = 6;
        *((_DWORD*)this[11] + 9) = *((_DWORD*)*this + 65);
    }
    result = this[11];
    if (result)
    {
        result[10] = this;
        result = this[11];
        result[6] = this[5];
    }
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (004215C0) --------------------------------------------------------
_DWORD* __thiscall sub_4215C0(_DWORD* this)
{
    _DWORD* v2; // ebp
    int v3; // ecx
    char* v5; // [esp+30h] [ebp-28h]
    int v6; // [esp+30h] [ebp-28h]
    _DWORD v7[2]; // [esp+44h] [ebp-14h] BYREF
    int v8; // [esp+54h] [ebp-4h]

    v7[1] = this;
    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
    *((_BYTE*)this + 16) = 1;
    v8 = 0;
    this[5] = 0;
    this[6] = 0;
    this[7] = 0;
    *((_BYTE*)this + 32) = 1;
    this[9] = 0;
    this[10] = 0;
    this[11] = 0;
    *((_BYTE*)this + 48) = 1;
    v2 = this + 14;
    *this = &off_499314;
    v5 = (char*)(this + 14);
    v3 = **(_DWORD**)ArgList;
    LOBYTE(v8) = 2;
    if (!(*(int(__stdcall**)(_DWORD, int, int, int, int, char*))(v3 + 96))(*(_DWORD*)ArgList, 12, 8, 101, 1, v5)
        && !(*(int(__stdcall**)(_DWORD, int, int, int, int, _DWORD*))(**(_DWORD**)ArgList + 92))(
            *(_DWORD*)ArgList,
            112,
            8,
            324,
            1,
            this + 13))
    {
        (*(void(__stdcall**)(_DWORD, _DWORD, int, _DWORD*, _DWORD))(*(_DWORD*)*v2 + 44))(*v2, 0, 12, v7, 0);
        *(_WORD*)v7[0] = 0;
        *(_WORD*)(v7[0] + 2) = 1;
        *(_WORD*)(v7[0] + 4) = 2;
        *(_WORD*)(v7[0] + 6) = 3;
        *(_WORD*)(v7[0] + 8) = 2;
        *(_WORD*)(v7[0] + 10) = 1;
        (*(void(__stdcall**)(int))(*(_DWORD*)*v2 + 48))(v6);
    }
    return this;
}
// 4216A2: variable 'v6' is possibly undefined
// 499314: using guessed type _UNKNOWN *off_499314;

//----- (004216E0) --------------------------------------------------------
void __thiscall sub_4216E0(void* this)
{
    int v2; // eax
    int v3; // eax
    int i; // ebp
    int v5; // eax
    void* v6; // edi
    void* v7; // eax
    int j; // edi
    void* v9; // eax

    *(_DWORD*)this = &off_499314;
    v2 = *((_DWORD*)this + 14);
    if (v2)
    {
        (*(void(__stdcall**)(int))(*(_DWORD*)v2 + 8))(v2);
        *((_DWORD*)this + 14) = 0;
    }
    v3 = *((_DWORD*)this + 13);
    if (v3)
    {
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)v3 + 8))(*((_DWORD*)this + 13));
        *((_DWORD*)this + 13) = 0;
    }
    if (*((_BYTE*)this + 48))
    {
        for (i = 0; i < *((_DWORD*)this + 10); ++i)
        {
            v5 = *((_DWORD*)this + 9);
            v6 = *(void**)(v5 + 4 * i);
            if (v6)
            {
                sub_4213B0(*(_DWORD*)(v5 + 4 * i));
                sub_4885A6(v6);
            }
        }
    }
    memset(*((void**)this + 9), 0, 4 * *((_DWORD*)this + 10));
    v7 = (void*)*((_DWORD*)this + 9);
    *((_DWORD*)this + 10) = 0;
    sub_488CEE(v7);
    *((_DWORD*)this + 11) = 0;
    *((_DWORD*)this + 9) = 0;
    if (*((_BYTE*)this + 32))
    {
        for (j = 0; j < *((_DWORD*)this + 6); ++j)
            sub_4885A6(*(LPVOID*)(*((_DWORD*)this + 5) + 4 * j));
    }
    memset(*((void**)this + 5), 0, 4 * *((_DWORD*)this + 6));
    v9 = (void*)*((_DWORD*)this + 5);
    *((_DWORD*)this + 6) = 0;
    sub_488CEE(v9);
    *((_DWORD*)this + 7) = 0;
    *((_DWORD*)this + 5) = 0;
    *(_DWORD*)this = &off_499040;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 499314: using guessed type _UNKNOWN *off_499314;

//----- (00421810) --------------------------------------------------------
int __thiscall sub_421810(int this, const char* a2, int a3, int a4)
{
    char* v5; // ebx
    _DWORD* v6; // eax
    int v8; // eax
    int v9; // ecx
    int v10; // eax
    char* v11; // eax
    int v12; // esi
    int v13; // ecx
    int v14; // edx
    int v15; // esi
    double v16; // st7
    double v17; // st7
    double v18; // st7
    double v19; // st6
    double v20; // st6
    __int64 v21; // rax

    v5 = (char*)operator new(0x114u);
    *((_DWORD*)v5 + 66) = a3;
    strcpy(v5, a2);
    v6 = sub_422400(*(_DWORD**)(dword_520970 + 124), v5, 1);
    *((_DWORD*)v5 + 65) = v6;
    if (!v6)
        return -1;
    *((_DWORD*)v5 + 67) = a4;
    v8 = *(_DWORD*)(this + 28);
    v9 = *(_DWORD*)(this + 24) + 1;
    *(_DWORD*)(this + 24) = v9;
    if (v9 > v8)
    {
        v10 = v8 + 8;
        *(_DWORD*)(this + 28) = v10;
        v11 = (char*)sub_488DD7(*(LPVOID*)(this + 20), 4 * v10);
        if (v11)
        {
            v12 = *(_DWORD*)(this + 24);
            v13 = *(_DWORD*)(this + 28) - v12;
            *(_DWORD*)(this + 20) = v11;
            memset(&v11[4 * v12], 0, 4 * v13);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 20) + 4 * *(_DWORD*)(this + 24) - 4) = v5;
    v14 = *((_DWORD*)v5 + 65);
    *((_DWORD*)v5 + 68) = 0;
    v15 = *((_DWORD*)v5 + 66);
    v16 = (double)*(int*)(v14 + 28);
    if (v16 == 0.0)
        v17 = 1.0;
    else
        v17 = 1.0 / v16;
    if (*(_BYTE*)v15)
    {
        v18 = v17 + v17;
        do
        {
            v19 = v18 + *(float*)(v15 + 12);
            *(float*)(v15 + 12) = v19;
            *(float*)(v15 + 20) = (v19 - *(float*)(v15 + 4)) * (double)*(int*)(*((_DWORD*)v5 + 65) + 28);
            v20 = (*(float*)(v15 + 16) - *(float*)(v15 + 8)) * (double)*(int*)(*((_DWORD*)v5 + 65) + 32);
            *(float*)(v15 + 24) = v20;
            if (*((_DWORD*)v5 + 68) <= (int)(__int64)v20)
                v21 = (__int64)*(float*)(v15 + 24);
            else
                LODWORD(v21) = *((_DWORD*)v5 + 68);
            v15 += 28;
            *((_DWORD*)v5 + 68) = v21;
        } while (*(_BYTE*)v15);
    }
    return *(_DWORD*)(this + 24) - 1;
}
// 520970: using guessed type int dword_520970;

//----- (00421980) --------------------------------------------------------
_BYTE* __thiscall sub_421980(int this, int a2, unsigned int a3)
{
    int v4; // edi
    _BYTE* v5; // esi
    _BYTE* v6; // eax
    int v7; // eax
    int v8; // ecx
    int v9; // eax
    char* v10; // eax
    int v11; // edi
    int v12; // ecx

    v4 = *(_DWORD*)(*(_DWORD*)(this + 20) + 4 * a2);
    v5 = operator new(0x50u);
    if (v5)
    {
        *(_DWORD*)v5 = v4;
        v5[33] = 1;
        *((_DWORD*)v5 + 9) = 1;
        *((_DWORD*)v5 + 10) = 1;
        *((_DWORD*)v5 + 1) = a3;
        *((_DWORD*)v5 + 3) = 0;
        *((_DWORD*)v5 + 4) = 0;
        *((_DWORD*)v5 + 5) = 0;
        *((_DWORD*)v5 + 6) = 0;
        *((_DWORD*)v5 + 7) = 0;
        v5[32] = 0;
        v5[34] = 0;
        v5[35] = 0;
        *((_DWORD*)v5 + 11) = 0;
        *((_DWORD*)v5 + 12) = this;
        *((_DWORD*)v5 + 15) = 0;
        *((_DWORD*)v5 + 16) = -1082130432;
        *((_DWORD*)v5 + 17) = -1082130432;
        *((_DWORD*)v5 + 18) = 255;
        *((_DWORD*)v5 + 19) = 255;
        v6 = operator new(a3);
        *((_DWORD*)v5 + 2) = v6;
        *v6 = 0;
        sub_421300((int)v5, 0xFFu, 0xFFu, 0xFFu, 255);
        sub_421370(v5, 0, 0, 0, 255);
        sub_421540((void**)v5);
    }
    else
    {
        v5 = 0;
    }
    v7 = *(_DWORD*)(this + 44);
    v8 = *(_DWORD*)(this + 40) + 1;
    *(_DWORD*)(this + 40) = v8;
    if (v8 > v7)
    {
        v9 = v7 + 8;
        *(_DWORD*)(this + 44) = v9;
        v10 = (char*)sub_488DD7(*(LPVOID*)(this + 36), 4 * v9);
        if (v10)
        {
            v11 = *(_DWORD*)(this + 40);
            v12 = *(_DWORD*)(this + 44) - v11;
            *(_DWORD*)(this + 36) = v10;
            memset(&v10[4 * v11], 0, 4 * v12);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v5;
    return v5;
}

//----- (00421AB0) --------------------------------------------------------
char __stdcall sub_421AB0(int a1, char* a2, float* a3, _DWORD* a4)
{
    char* v4; // esi
    char result; // al
    char* v6; // eax

    v4 = a2;
    *a4 = 0;
    *a3 = 0.0;
    for (result = *a2; *v4; *a3 = *a3 - 2.0)
    {
        v6 = sub_421DB0(a1, *v4);
        if (v6)
        {
            *a4 = *((_DWORD*)v6 + 6);
            *a3 = *((float*)v6 + 5) + *a3;
        }
        result = *++v4;
        if (!result)
            break;
    }
    return result;
}

//----- (00421B20) --------------------------------------------------------
int __thiscall sub_421B20(_DWORD* this, int a2)
{
    return *(_DWORD*)(*(_DWORD*)(this[5] + 4 * a2) + 272);
}

//----- (00421B40) --------------------------------------------------------
void __thiscall sub_421B40(_DWORD* this, int a2)
{
    int v3; // esi
    int v4; // ebx

    v3 = 0;
    v4 = this[10];
    if (v4 > 0)
    {
        do
            sub_421460(*(_DWORD*)(this[9] + 4 * v3++), a2);
        while (v3 < v4);
    }
}

//----- (00421B70) --------------------------------------------------------
int __thiscall sub_421B70(int this, int a2)
{
    int v2; // esi
    int v4; // edi
    int v5; // eax
    int v6; // eax
    char* v7; // ebx
    double X; // st7
    float* v9; // edi
    int v10; // eax
    char v11; // al
    float v14; // [esp+24h] [ebp-3Ch]
    float v15; // [esp+28h] [ebp-38h]
    float v16; // [esp+44h] [ebp-1Ch]
    float v17; // [esp+48h] [ebp-18h]
    float v18; // [esp+48h] [ebp-18h]
    int v19; // [esp+48h] [ebp-18h]
    float v20; // [esp+4Ch] [ebp-14h]
    int v21; // [esp+50h] [ebp-10h]
    float v22; // [esp+54h] [ebp-Ch]
    int v24; // [esp+5Ch] [ebp-4h]

    v2 = *(_DWORD*)(a2 + 40);
    v4 = 0;
    v24 = 0;
    if (v2)
    {
        (*(void(__stdcall**)(_DWORD, int))(**(_DWORD**)ArgList + 304))(*(_DWORD*)ArgList, 324);
        (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD, int))(**(_DWORD**)ArgList + 332))(
            *(_DWORD*)ArgList,
            0,
            *(_DWORD*)(this + 52),
            28);
        (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD))(**(_DWORD**)ArgList + 340))(
            *(_DWORD*)ArgList,
            *(_DWORD*)(this + 56),
            0);
        v5 = *(_DWORD*)(*(_DWORD*)v2 + 260);
        if (v5)
        {
            sub_41BEF0((_DWORD*)dword_520A50, 0, v5, 0, 1);
            sub_41BEF0((_DWORD*)dword_520A50, 1, 0, -1, -1);
            sub_41BC00((_DWORD*)dword_520A50, 1, 1, 1, 1, 1, -1, 0);
        }
        if (*(_BYTE*)(v2 + 32))
        {
            v20 = *(float*)(v2 + 12) - *(float*)(v2 + 24) * 0.5;
            v22 = *(float*)(v2 + 16) - *(float*)(v2 + 28) * 0.5;
        }
        else
        {
            v20 = *(float*)(v2 + 12);
            v22 = *(float*)(v2 + 16);
        }
        v6 = 0;
        v21 = 0;
        do
        {
            if (*(_BYTE*)(v2 + 35) || v6)
            {
                v7 = *(char**)(v2 + 8);
                X = v20;
                v16 = v22;
                if (!v6)
                {
                    X = (double)*(int*)(v2 + 36) + v20;
                    v16 = (double)*(int*)(v2 + 40) + v22;
                }
                if (*v7)
                {
                    do
                    {
                        v17 = floor(X);
                        v16 = floor(v16);
                        v9 = (float*)sub_421DB0(*(_DWORD*)v2, *v7);
                        if (v9)
                        {
                            if (v21)
                                v10 = *(_DWORD*)(v2 + 52);
                            else
                                v10 = *(_DWORD*)(v2 + 56);
                            v15 = (double)*(int*)(v2 + 40) + v16;
                            v14 = (double)*(int*)(v2 + 36) + v17;
                            sub_421E30((_DWORD**)this, v14, v15, 0.5, v10, v9);
                            v11 = v7[1];
                            X = v17 + v9[5] - 2.0;
                            v24 += 2;
                            if (v11)
                            {
                                v18 = X;
                                X = sub_421DE0(*(_DWORD*)v2, *v7, v11) + v18;
                            }
                        }
                        else if (*v7 == 10)
                        {
                            if (v21)
                                v19 = 0;
                            else
                                v19 = *(_DWORD*)(v2 + 36);
                            X = (double)v19 + v20;
                            v16 = (double)*(int*)(*(_DWORD*)v2 + 272) + v16;
                        }
                        else
                        {
                            X = v17;
                        }
                    } while (*++v7);
                    v4 = v24;
                    v6 = v21;
                }
            }
            v21 = ++v6;
        } while (v6 < 2);
    }
    return v4;
}
// 520A50: using guessed type int dword_520A50;

//----- (00421DB0) --------------------------------------------------------
char* __stdcall sub_421DB0(int a1, char a2)
{
    char* result; // eax
    char v3; // cl

    result = *(char**)(a1 + 264);
    v3 = *result;
    if (!*result)
        return 0;
    while (v3 != a2)
    {
        v3 = result[28];
        result += 28;
        if (!v3)
            return 0;
    }
    return result;
}

//----- (00421DE0) --------------------------------------------------------
double __stdcall sub_421DE0(int a1, char a2, char a3)
{
    int v3; // eax

    v3 = *(_DWORD*)(a1 + 268);
    if (v3)
    {
        while (*(_BYTE*)v3)
        {
            if (*(_BYTE*)v3 == a2 && *(_BYTE*)(v3 + 1) == a3)
                return (double)*(int*)(*(_DWORD*)(a1 + 260) + 28) * *(float*)(v3 + 4);
            v3 += 8;
            if (!v3)
                return 0.0;
        }
    }
    return 0.0;
}

//----- (00421E30) --------------------------------------------------------
int __thiscall sub_421E30(_DWORD** this, float a2, float a3, float a4, int a5, float* a6)
{
    double v7; // st7
    double v8; // st6
    int result; // eax
    float* v10; // [esp+28h] [ebp-Ch] BYREF
    float v11; // [esp+2Ch] [ebp-8h]
    float v12; // [esp+30h] [ebp-4h]
    float v13; // [esp+38h] [ebp+4h]

    (*(void(__stdcall**)(_DWORD*, _DWORD, int, float**, _DWORD))(*this[13] + 44))(this[13], 0, 112, &v10, 0);
    v12 = a2 + 0.5;
    v11 = a3 + 0.5;
    v13 = floor(a2 + a6[5] + 0.5) + 0.5;
    v7 = floor(a3 + a6[6] + 0.5) + 0.5;
    *v10 = v12;
    v10[1] = v11;
    v10[2] = a4;
    v10[3] = 0.5;
    *((_DWORD*)v10 + 4) = a5;
    v10[5] = a6[1];
    v10[6] = a6[2];
    v10[7] = v13;
    v10[8] = v11;
    v10[9] = a4;
    v8 = v12;
    v10[10] = 0.5;
    *((_DWORD*)v10 + 11) = a5;
    v10[12] = a6[3];
    v10[13] = a6[2];
    v10[14] = v8;
    v10[15] = v7;
    v10[16] = a4;
    v10[17] = 0.5;
    *((_DWORD*)v10 + 18) = a5;
    v10[19] = a6[1];
    v10[20] = a6[4];
    v10[21] = v13;
    v10[22] = v7;
    v10[23] = a4;
    v10[24] = 0.5;
    *((_DWORD*)v10 + 25) = a5;
    v10[26] = a6[3];
    v10[27] = a6[4];
    (*(void(__stdcall**)(_DWORD*))(*this[13] + 48))(this[13]);
    (*(void(__stdcall**)(_DWORD, int, _DWORD, int, _DWORD, int))(**(_DWORD**)ArgList + 284))(
        *(_DWORD*)ArgList,
        4,
        0,
        4,
        0,
        2);
    result = dword_520A20;
    *(float*)dword_520A20 = *(float*)dword_520A20 + 1.0;
    return result;
}
// 520A20: using guessed type int dword_520A20;

//----- (00422000) --------------------------------------------------------
void __thiscall sub_422000(int this)
{
    int i; // ebp
    void* v3; // edi
    void* v4; // eax

    if (*(_BYTE*)(this + 12))
    {
        for (i = 0; i < *(_DWORD*)(this + 4); ++i)
        {
            v3 = *(void**)(*(_DWORD*)this + 4 * i);
            if (v3)
            {
                sub_4213B0(*(_DWORD*)(*(_DWORD*)this + 4 * i));
                sub_4885A6(v3);
            }
        }
    }
    memset(*(void**)this, 0, 4 * *(_DWORD*)(this + 4));
    v4 = *(void**)this;
    *(_DWORD*)(this + 4) = 0;
    sub_488CEE(v4);
    *(_DWORD*)(this + 8) = 0;
    *(_DWORD*)this = 0;
}

//----- (00422080) --------------------------------------------------------
int __cdecl sub_422080(char* FileName, _DWORD* Buffer)
{
    _BYTE* v2; // esi
    _DWORD* v3; // ecx
    const char* v4; // edx
    FILE* v5; // eax
    FILE* v6; // edi
    void* v8; // esi

    v2 = Buffer;
    v3 = Buffer;
    v4 = FileName;
    *Buffer = 0;
    v3[1] = 0;
    v3[2] = 0;
    v3[3] = 0;
    v3[4] = 0;
    v5 = fopen(v4, Mode);
    v6 = v5;
    if (!v5)
        return -1;
    sub_4898CA(&FileName, 1u, 1u, v5);
    sub_4898CA(&Buffer, 1u, 1u, v6);
    if ((_BYTE)Buffer)
        v2[2] = 1;
    else
        v2[2] = 0;
    sub_4898CA(v2, 1u, 1u, v6);
    v2[1] = *v2 && *v2 <= 3u;
    sub_4898CA(v2 + 8, 2u, 1u, v6);
    sub_4898CA(v2 + 10, 2u, 1u, v6);
    sub_4898CA(v2 + 12, 1u, 1u, v6);
    sub_4898CA(v2 + 4, 2u, 1u, v6);
    sub_4898CA(v2 + 6, 2u, 1u, v6);
    sub_4898CA(v2 + 14, 2u, 1u, v6);
    sub_4898CA(v2 + 16, 2u, 1u, v6);
    sub_4898CA(v2 + 18, 1u, 1u, v6);
    if (v2[2])
        v2[18] = 8;
    sub_4898CA(&Buffer, 1u, 1u, v6);
    v8 = operator new((unsigned __int8)FileName + 1);
    sub_4898CA(v8, (unsigned __int8)FileName, 1u, v6);
    sub_4885A6(v8);
    fclose(v6);
    return 1;
}

//----- (004221E0) --------------------------------------------------------
_DWORD* __thiscall sub_4221E0(_DWORD* this)
{
    _DWORD* result; // eax

    result = this;
    *this = 1;
    this[2] = 0;
    this[3] = 0;
    this[4] = 0;
    this[5] = 0;
    this[10] = 0;
    return result;
}

//----- (00422200) --------------------------------------------------------
void __thiscall sub_422200(int this)
{
    void* v2; // edx

    (*(void(__stdcall**)(_DWORD))(**(_DWORD**)(this + 8) + 8))(*(_DWORD*)(this + 8));
    v2 = *(void**)(this + 12);
    *(_DWORD*)(this + 8) = 0;
    sub_4885A6(v2);
}

//----- (00422230) --------------------------------------------------------
void __thiscall sub_422230(int* this)
{
    int v2; // eax
    _DWORD* v3; // ecx

    v2 = *this - 1;
    *this = v2;
    if (v2 <= 0)
    {
        v3 = (_DWORD*)this[5];
        if (v3)
            sub_4226E0(v3, this);
        if (this)
        {
            sub_422200((int)this);
            sub_4885A6(this);
        }
    }
}

//----- (00422270) --------------------------------------------------------
int __thiscall sub_422270(int this, int a2)
{
    int result; // eax

    result = (*(int(__stdcall**)(_DWORD, _DWORD, _DWORD))(**(_DWORD**)ArgList + 244))(
        *(_DWORD*)ArgList,
        0,
        *(_DWORD*)(this + 8));
    *(_BYTE*)(this + 4) = 1;
    return result;
}

//----- (00422290) --------------------------------------------------------
int __thiscall sub_422290(int this)
{
    _DWORD* v2; // eax
    _DWORD* v3; // eax
    int v4; // edi
    float v6; // [esp+0h] [ebp-38h]
    float v7; // [esp+4h] [ebp-34h]
    float v8; // [esp+8h] [ebp-30h]
    float v9; // [esp+Ch] [ebp-2Ch]

    *(_DWORD*)(this + 4) = 0;
    *(_DWORD*)(this + 8) = 0;
    *(_DWORD*)(this + 12) = 0;
    *(_BYTE*)(this + 16) = 1;
    *(_DWORD*)this = &off_499334;
    *(_DWORD*)(this + 20) = 0;
    *(_DWORD*)(this + 24) = 0;
    v2 = operator new(0x80u);
    if (v2)
        v3 = sub_412AB0(v2);
    else
        v3 = 0;
    *(_DWORD*)(this + 28) = v3;
    v4 = 512;
    if ((unsigned int)dword_5209D8 <= 0x200)
        v4 = dword_5209D8;
    v9 = (double)(unsigned int)(dword_5209D8 + v4) * 0.5;
    v8 = (double)(unsigned int)(v4 + dword_5209F4) * 0.5;
    v7 = (double)(unsigned int)(dword_5209D8 - v4) * 0.5;
    v6 = (double)(unsigned int)(dword_5209F4 - v4) * 0.5;
    sub_413090((int)v3, v6, v7, v8, v9);
    sub_428680((_DWORD*)this, *(_DWORD*)(this + 28));
    (*(void(__thiscall**)(_DWORD, _DWORD))(**(_DWORD**)(this + 28) + 24))(*(_DWORD*)(this + 28), 0);
    *(_DWORD*)(this + 32) = 0;
    return this;
}
// 499334: using guessed type _UNKNOWN *off_499334;
// 5209D8: using guessed type int dword_5209D8;
// 5209F4: using guessed type int dword_5209F4;

//----- (004223D0) --------------------------------------------------------
int __thiscall sub_4223D0(_DWORD* this)
{
    int result; // eax
    int v2; // edx

    result = this[5];
    *this = &off_499334;
    if (result)
    {
        do
        {
            v2 = *(_DWORD*)(result + 16);
            *(_DWORD*)(result + 20) = 0;
            *(_DWORD*)(result + 16) = 0;
            result = v2;
        } while (v2);
    }
    this[5] = 0;
    *this = &off_499040;
    return result;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 499334: using guessed type _UNKNOWN *off_499334;

//----- (00422400) --------------------------------------------------------
_DWORD* __thiscall sub_422400(_DWORD* this, char* String1, char a3)
{
    int v4; // esi
    char* v5; // ebx
    unsigned int v7; // ebp
    int v8; // ebx
    int v9; // esi
    WPARAM v10; // ecx
    _DWORD* v12; // eax
    _DWORD* v13; // ebp
    int v14; // edx
    int v15; // [esp+1Ch] [ebp-30h] BYREF
    char* v16; // [esp+20h] [ebp-2Ch]
    int Buffer[3]; // [esp+24h] [ebp-28h] BYREF
    __int16 v18; // [esp+32h] [ebp-1Ah]
    __int16 v19; // [esp+34h] [ebp-18h]
    char v20; // [esp+36h] [ebp-16h]
    _DWORD v21[4]; // [esp+38h] [ebp-14h] BYREF
    int v22; // [esp+48h] [ebp-4h]

    v4 = this[5];
    if (v4)
    {
        while (1)
        {
            v5 = String1;
            if (!_strcmpi(String1, *(const char**)(v4 + 12)))
                break;
            v4 = *(_DWORD*)(v4 + 16);
            if (!v4)
                goto LABEL_7;
        }
        ++ * (_DWORD*)v4;
        return (_DWORD*)v4;
    }
    else
    {
        v5 = String1;
    LABEL_7:
        sub_4229D0("-Attempting to load texture '%s'", v5);
        v7 = 23;
        if (sub_422080(v5, Buffer) < 0)
        {
            sub_4229D0("-Can't read header for '%s'", v5);
            sub_4281B0("Can't read texture '%s'", v5);
        }
        switch (v20)
        {
        case 8:
            v7 = 41;
            break;
        case 16:
        case 24:
            v7 = 23;
            if ((*(int(__stdcall**)(int, int, int, int, _DWORD, int, int))(*(_DWORD*)dword_520A14 + 40))(
                dword_520A14,
                dword_52089C,
                dword_520898,
                dword_5209E0,
                0,
                3,
                23))
            {
                v7 = 24;
            }
            break;
        case 32:
            v7 = 21;
            if ((*(int(__stdcall**)(int, int, int, int, _DWORD, int, int))(*(_DWORD*)dword_520A14 + 40))(
                dword_520A14,
                dword_52089C,
                dword_520898,
                dword_5209E0,
                0,
                3,
                21))
            {
                v7 = 26;
            }
            break;
        }
        v8 = v19;
        v9 = v18;
        if (!a3)
        {
            v10 = wParam - 1;
            if (wParam)
            {
                do
                {
                    if (v9 <= 128)
                        break;
                    if (v8 <= 128)
                        break;
                    v8 /= 2;
                    v9 /= 2;
                } while (v10--);
            }
        }
        if (sub_46D89A(
            *(int*)ArgList,
            (const WCHAR*)String1,
            v9,
            v8,
            0xFFFFFFFF,
            0,
            v7,
            1,
            (int*)0x70005,
            (int*)0x70005,
            0,
            v21,
            0,
            &v15))
        {
            sub_4229D0("-Can't createtexture for '%s'", String1);
            return 0;
        }
        else
        {
            v12 = operator new(0x2Cu);
            if (v12)
                v13 = sub_4221E0(v12);
            else
                v13 = 0;
            v13[5] = this;
            v13[4] = this[5];
            v14 = v15;
            this[5] = v13;
            v13[2] = v14;
            v16 = (char*)operator new(strlen(String1) + 1);
            v13[3] = v16;
            v13[7] = v9;
            v13[8] = v8;
            v13[9] = 2;
            switch (v22)
            {
            case 20:
                v13[9] = 3;
                break;
            case 21:
                v13[9] = 4;
                break;
            case 23:
            case 24:
            case 25:
            case 26:
                v13[9] = 2;
                break;
            case 41:
                v13[9] = 1;
                break;
            default:
                break;
            }
            *((_BYTE*)v13 + 24) = v22 == 21 || v22 == 25 || v22 == 26;
            v13[10] = v13[9] * (__int64)((double)(v8 * v9) * 1.33333);
            strcpy(v16, String1);
            sub_4229D0(aSuccessfullyLo, String1);
            return v13;
        }
    }
}
// 520898: using guessed type int dword_520898;
// 52089C: using guessed type int dword_52089C;
// 5209E0: using guessed type int dword_5209E0;
// 520A14: using guessed type int dword_520A14;

//----- (004226E0) --------------------------------------------------------
_DWORD* __thiscall sub_4226E0(_DWORD* this, _DWORD* a2)
{
    _DWORD* v3; // ecx
    _DWORD* result; // eax
    _DWORD* v5; // edx
    int v6; // ecx
    int v7; // ecx

    v3 = (_DWORD*)this[7];
    this[6] = 0;
    sub_4131B0(v3, 0);
    (*(void(__thiscall**)(_DWORD, _DWORD))(*(_DWORD*)this[7] + 24))(this[7], 0);
    result = (_DWORD*)this[5];
    v5 = 0;
    if (result)
    {
        while (1)
        {
            v6 = result[4];
            if (result == a2)
                break;
            v5 = result;
            result = (_DWORD*)result[4];
            if (!v6)
                goto LABEL_8;
        }
        if (v5)
            v5[4] = v6;
        else
            this[5] = v6;
    }
LABEL_8:
    v7 = this[8];
    if (v7)
    {
        *(_BYTE*)(v7 + 33) = 0;
        return sub_421540((void**)v7);
    }
    return result;
}

//----- (00422740) --------------------------------------------------------
int __thiscall sub_422740(_DWORD* this, int a2)
{
    int result; // eax

    for (result = this[5]; result; result = *(_DWORD*)(result + 16))
        *(_BYTE*)(result + 4) = 0;
    return result;
}

//----- (00422760) --------------------------------------------------------
int __thiscall sub_422760(_DWORD* this, _DWORD* a2, _DWORD* a3, _DWORD* a4, _DWORD* a5)
{
    int result; // eax

    *a5 = 0;
    *a4 = 0;
    *a3 = 0;
    *a2 = 0;
    for (result = this[5]; result; result = *(_DWORD*)(result + 16))
    {
        ++*a2;
        *a3 += *(_DWORD*)(result + 40);
        if (*(_BYTE*)(result + 4))
        {
            ++*a4;
            *a5 += *(_DWORD*)(result + 40);
        }
    }
    return result;
}

//----- (004227C0) --------------------------------------------------------
FILE* __thiscall sub_4227C0(_DWORD* this)
{
    int v2; // esi
    int v3; // ebx
    int i; // edi
    int v5; // eax

    sub_4229D0(aTexturesLoaded);
    v2 = this[5];
    v3 = 0;
    for (i = 0; v2; v2 = *(_DWORD*)(v2 + 16))
    {
        v5 = *(_DWORD*)(v2 + 40);
        v3 += v5;
        ++i;
        sub_4229D0("-%s (%dx%d) %dk", *(const char**)(v2 + 12), *(_DWORD*)(v2 + 28), *(_DWORD*)(v2 + 32), v5 / 1024);
    }
    return sub_4229D0("TOTAL of %d textures, %dk bytes", i, v3);
}

//----- (00422830) --------------------------------------------------------
double __cdecl sub_422830(float a1, float a2)
{
    double i; // st7
    double j; // st6
    double result; // st7

    for (i = a1; i >= 360.0; i = i - 360.0)
        ;
    for (; i < 0.0; i = i + 360.0)
        ;
    for (j = a2; j >= 360.0; j = j - 360.0)
        ;
    for (; j < 0.0; j = j + 360.0)
        ;
    result = i - j;
    if (result > 180.0)
        return 360.0 - result;
    if (result < -180.0)
        return result + 360.0;
    return result;
}

//----- (004228F0) --------------------------------------------------------
char* __cdecl sub_4228F0(char* Str)
{
    struct tm* v1; // eax
    char* result; // eax
    __time32_t Time; // [esp+8h] [ebp-4h] BYREF

    time(&Time);
    v1 = localtime(&Time);
    strcpy(Str, asctime(v1));
    result = strrchr(Str, 10);
    if (result)
        *result = 0;
    return result;
}

//----- (00422950) --------------------------------------------------------
unsigned int __cdecl sub_422950(const char* a1)
{
    unsigned int result; // eax

    result = strcmp(a1, &byte_520534);
    if (result)
    {
        if (Stream)
        {
            fclose(Stream);
            Stream = 0;
        }
        result = strlen(a1) + 1;
        qmemcpy(&byte_520534, a1, result);
    }
    return result;
}

//----- (004229D0) --------------------------------------------------------
FILE* sub_4229D0(char* Format, ...)
{
    FILE* v1; // eax
    FILE* result; // eax
    char Buffer[32]; // [esp+0h] [ebp-220h] BYREF
    CHAR OutputString[512]; // [esp+20h] [ebp-200h] BYREF
    va_list va; // [esp+228h] [ebp+8h] BYREF

    va_start(va, Format);
    if (!Stream)
    {
        if (byte_520534)
        {
            v1 = fopen(&byte_520534, aA);
            Stream = v1;
            if (v1)
                fputs(asc_4A4AA4, v1);
        }
    }
    if (_vsnprintf(OutputString, 0x1FEu, Format, va) == -1)
        OutputString[510] = 0;
    strcat(OutputString, asc_4A1F30);
    OutputDebugStringA(OutputString);
    result = Stream;
    if (Stream)
    {
        sub_4228F0(Buffer);
        fputs(Buffer, Stream);
        fputs(asc_4A4AA0, Stream);
        fputs(OutputString, Stream);
        return (FILE*)fflush(Stream);
    }
    return result;
}

//----- (00422AE0) --------------------------------------------------------
char __cdecl sub_422AE0(LPCSTR lpFileName)
{
    intptr_t v1; // eax
    int v3[70]; // [esp+0h] [ebp-118h] BYREF

    v1 = _findfirst(lpFileName, (int)v3);
    if (v1 <= -1)
        return 0;
    _findclose(v1);
    return 1;
}

//----- (00422B20) --------------------------------------------------------
char __cdecl sub_422B20(char* FileName)
{
    char result; // al
    FILE* v2; // eax

    result = sub_422AE0(FileName);
    if (result)
    {
        v2 = fopen(FileName, Mode);
        if (v2)
        {
            fclose(v2);
            return 1;
        }
        else
        {
            return 0;
        }
    }
    return result;
}

//----- (00422B60) --------------------------------------------------------
int __cdecl sub_422B60(int a1, const char* a2)
{
    int result; // eax

    dword_4A3F58 = a1;
    result = 1;
    strcpy((char*)&phkResult, a2);
    return result;
}
// 4A3F58: using guessed type int dword_4A3F58;

//----- (00422BA0) --------------------------------------------------------
INT __cdecl sub_422BA0(CHAR* lpAppName, LPCSTR lpKeyName, INT nDefault)
{
    INT v3; // esi
    INT result; // eax
    BYTE Data[4]; // [esp+4h] [ebp-Ch] BYREF
    DWORD cbData; // [esp+8h] [ebp-8h] BYREF
    DWORD Type; // [esp+Ch] [ebp-4h] BYREF

    if (dword_4A3F58)
    {
        if (sub_422C40((const char*)&phkResult, (const char**)&lpAppName, 0))
        {
            cbData = 4;
            RegQueryValueExA((HKEY)lpAppName, lpKeyName, 0, &Type, Data, &cbData);
            if (Type != 4)
                *(_DWORD*)Data = nDefault;
            RegCloseKey((HKEY)lpAppName);
            return *(_DWORD*)Data;
        }
        else
        {
            return nDefault;
        }
    }
    else
    {
        v3 = nDefault;
        result = GetPrivateProfileIntA(lpAppName, lpKeyName, nDefault, (LPCSTR)&phkResult);
        if (result < 0)
            return v3;
    }
    return result;
}
// 4A3F58: using guessed type int dword_4A3F58;

//----- (00422C40) --------------------------------------------------------
char __cdecl sub_422C40(const char* phkResult, const char** a2, char a3)
{
    char* v3; // ebx
    int v4; // edi
    const CHAR* v5; // ebp
    char* v6; // eax
    char* v7; // esi

    v3 = _strdup(phkResult);
    v4 = -2147483647;
    v5 = v3;
    while (1)
    {
        v6 = strchr(v3, 92);
        v7 = v6;
        if (v6 && *v6)
        {
            *v6 = 0;
            v7 = v6 + 1;
        }
        if (RegOpenKeyExA((HKEY)v4, v5, 0, 0x2001Fu, (PHKEY)&phkResult)
            && (!a3 || RegCreateKeyA((HKEY)v4, v5, (PHKEY)&phkResult)))
        {
            break;
        }
        if (v4 != -2147483647)
            RegCloseKey((HKEY)v4);
        v4 = (int)phkResult;
        v5 = v7;
        if (!v7 || !*v7)
        {
            *a2 = phkResult;
            sub_488CEE(v3);
            return 1;
        }
    }
    if (v4 != -2147483647)
        RegCloseKey((HKEY)v4);
    sub_488CEE(v3);
    return 0;
}

//----- (00422D00) --------------------------------------------------------
int __cdecl sub_422D00(LPCSTR lpAppName, LPCSTR lpKeyName, CHAR* nSize, LPSTR lpReturnedString, char* lpDefault)
{
    BYTE* v6; // ebx
    int v7; // esi

    if (dword_4A3F58)
    {
        v6 = (BYTE*)strcpy(lpReturnedString, lpDefault);
        if (sub_422C40((const char*)&phkResult, (const char**)&lpDefault, 0))
        {
            lpReturnedString = nSize;
            RegQueryValueExA((HKEY)lpDefault, lpKeyName, 0, (LPDWORD)&lpAppName, v6, (LPDWORD)&lpReturnedString);
            v7 = 1;
            if (lpAppName != (LPCSTR)1)
                v7 = -1;
            RegCloseKey((HKEY)lpDefault);
            return v7;
        }
        else
        {
            return -1;
        }
    }
    else
    {
        GetPrivateProfileStringA(lpAppName, lpKeyName, lpDefault, lpReturnedString, (DWORD)nSize, (LPCSTR)&phkResult);
        return 1;
    }
}
// 4A3F58: using guessed type int dword_4A3F58;

//----- (00422DC0) --------------------------------------------------------
int __cdecl sub_422DC0(HKEY hKey, LPCSTR lpValueName, int Data)
{
    int v4; // esi
    char Buffer[16]; // [esp+0h] [ebp-10h] BYREF

    if (dword_4A3F58)
    {
        if (sub_422C40((const char*)&phkResult, (const char**)&hKey, 1))
        {
            v4 = 1;
            if (RegSetValueExA(hKey, lpValueName, 0, 4u, (const BYTE*)&Data, 4u))
                v4 = -1;
            RegCloseKey(hKey);
            return v4;
        }
        else
        {
            return -1;
        }
    }
    else
    {
        sprintf(Buffer, "%d", Data);
        return sub_422E60((CHAR*)hKey, lpValueName, Buffer);
    }
}
// 4A3F58: using guessed type int dword_4A3F58;

//----- (00422E60) --------------------------------------------------------
int __cdecl sub_422E60(CHAR* lpAppName, LPCSTR lpKeyName, LPCSTR lpString)
{
    int v4; // esi

    if (!dword_4A3F58)
        return WritePrivateProfileStringA(lpAppName, lpKeyName, lpString, (LPCSTR)&phkResult) ? 1 : -1;
    if (!sub_422C40((const char*)&phkResult, (const char**)&lpAppName, 1))
        return -1;
    v4 = 1;
    if (RegSetValueExA((HKEY)lpAppName, lpKeyName, 0, 1u, (const BYTE*)lpString, strlen(lpString) + 1))
        v4 = -1;
    RegCloseKey((HKEY)lpAppName);
    return v4;
}
// 4A3F58: using guessed type int dword_4A3F58;

//----- (00422EF0) --------------------------------------------------------
bool __cdecl sub_422EF0(LPCSTR lpFileName)
{
    HANDLE FirstFileA; // eax
    _WIN32_FIND_DATAA FindFileData; // [esp+4h] [ebp-140h] BYREF

    FirstFileA = FindFirstFileA(lpFileName, &FindFileData);
    if (FirstFileA == (HANDLE)-1)
        return CreateDirectoryA(lpFileName, 0);
    FindClose(FirstFileA);
    return (FindFileData.dwFileAttributes & 0x10) != 0;
}

//----- (00422F40) --------------------------------------------------------
char __cdecl sub_422F40(const char* a1)
{
    int v1; // ebx
    CHAR RootPathName[3]; // [esp+10h] [ebp-110h] BYREF
    int v4; // [esp+13h] [ebp-10Dh]
    char v5; // [esp+17h] [ebp-109h]
    DWORD LogicalDrives; // [esp+18h] [ebp-108h]
    char v7[260]; // [esp+1Ch] [ebp-104h] BYREF

    LogicalDrives = GetLogicalDrives();
    v4 = 0;
    strcpy(RootPathName, "C:");
    v5 = 0;
    v1 = 4;
    while (1)
    {
        if ((v1 & LogicalDrives) != 0 && GetDriveTypeA(RootPathName) == 5)
        {
            strcpy(v7, RootPathName);
            strcat(v7, a1);
            if (sub_422AE0(v7))
                break;
        }
        v1 *= 2;
        ++RootPathName[0];
        if (!v1)
            return 0;
    }
    return 1;
}

//----- (00423060) --------------------------------------------------------
const void* __thiscall sub_423060(_DWORD* this, int a2)
{
    int v3; // eax
    int v4; // ecx
    double v5; // st7
    float* v6; // edx
    const void* result; // eax

    v3 = this[1] + 1;
    this[1] = v3;
    if (v3 > 249)
        v3 = 249;
    this[1] = v3;
    *(_DWORD*)(*this + 4) = a2;
    memcpy((void*)(*this + 8), (const void*)*this, 8 * this[1]);
    v4 = 1;
    v5 = 0.0;
    if ((int)this[1] > 1)
    {
        v6 = (float*)(*this + 12);
        do
        {
            v5 = v5 + *v6;
            if (v5 > 3.0)
                this[1] = v4;
            ++v4;
            v6 += 2;
        } while (v4 < this[1]);
    }
    result = (const void*)*this;
    *(_DWORD*)*this = 0;
    *(_DWORD*)(*this + 4) = 0;
    return result;
}

//----- (004230F0) --------------------------------------------------------
double __thiscall sub_4230F0(_DWORD* this)
{
    int v1; // eax
    double result; // st7
    int v3; // edx
    float* v4; // ecx

    v1 = this[1];
    result = 0.0;
    if (v1 > 1)
    {
        v3 = v1 - 1;
        v4 = (float*)(*this + 8);
        do
        {
            if (result <= *v4)
                result = *v4;
            v4 += 2;
            --v3;
        } while (v3);
    }
    return result;
}

//----- (00423120) --------------------------------------------------------
double __thiscall sub_423120(int* this)
{
    int v1; // edx
    double v2; // st7
    double v3; // st6
    int v4; // eax
    int v5; // ecx
    float* v6; // eax
    double v7; // st5

    v1 = this[1];
    v2 = 0.0;
    v3 = 0.0;
    if (v1 > 1)
    {
        v4 = *this;
        v5 = v1 - 1;
        v6 = (float*)(v4 + 8);
        do
        {
            v7 = *v6 * v6[1];
            v6 += 2;
            --v5;
            v2 = v2 + v7;
            v3 = v3 + *(v6 - 1);
        } while (v5);
    }
    if (v3 <= 0.0000099999997)
        return 0.0;
    if (v3 == 0.0)
        return 0.0;
    return v2 / v3;
}

//----- (004231A0) --------------------------------------------------------
void* sub_4231A0()
{
    void* result; // eax

    result = operator new(0x190u);
    dword_520530 = (int)result;
    return result;
}
// 520530: using guessed type int dword_520530;

//----- (004231C0) --------------------------------------------------------
int __cdecl sub_4231C0(int a1)
{
    void* v1; // eax

    if (dword_52073C < dword_4A4320)
    {
        *(_DWORD*)(dword_520530 + 4 * dword_52073C) = a1;
    }
    else
    {
        v1 = operator new(4 * dword_4A4320 + 400);
        qmemcpy(v1, (const void*)dword_520530, 4 * dword_52073C);
        dword_520530 = (int)v1;
        *((_DWORD*)v1 + dword_52073C) = a1;
    }
    return ++dword_52073C;
}
// 4A4320: using guessed type int dword_4A4320;
// 520530: using guessed type int dword_520530;
// 52073C: using guessed type int;

//----- (00423230) --------------------------------------------------------
int sub_423230()
{
    int result; // eax
    int v1; // esi

    if (!dword_52073C)
        return -1;
    v1 = dword_52073C - 1;
    result = *(_DWORD*)(dword_520530 + 4 * (rand() % (v1 + 1)));
    dword_52073C = 0;
    return result;
}
// 520530: using guessed type int dword_520530;
// 52073C: using guessed type int dword_52073C;

//----- (00423260) --------------------------------------------------------
int __cdecl sub_423260(unsigned __int8* a1, int a2, unsigned int a3)
{
    int v5; // esi

    if (!unk_520740)
    {
        unk_520740 = 1;
        sub_4232B0();
    }
    if (a2)
    {
        v5 = a2;
        do
        {
            a3 = dword_52012C[*a1++ ^ (unsigned __int8)a3] ^ (a3 >> 8);
            --v5;
        } while (v5);
    }
    return ~a3;
}
// 52012C: using guessed type int dword_52012C[255];

//----- (004232B0) --------------------------------------------------------
int sub_4232B0()
{
    unsigned int v0; // edi
    int* v1; // esi
    int v2; // eax
    int v3; // edx
    int v4; // ebx
    unsigned int v5; // eax
    int result; // eax

    v0 = 0;
    v1 = &dword_52012C;
    do
    {
        v2 = sub_423310(v0, 8);
        v3 = 8;
        v2 <<= 24;
        *v1 = v2;
        v4 = v2;
        do
        {
            v5 = (2 * v4) ^ (v4 < 0 ? 0x4C11DB7 : 0);
            --v3;
            v4 = v5;
        } while (v3);
        *v1 = v5;
        result = sub_423310(v5, 32);
        *v1++ = result;
        ++v0;
    } while ((int)v1 <= (int)&dword_520528);
    return result;
}
// 52012C: using guessed type int dword_52012C;
// 520528: using guessed type int dword_520528;

//----- (00423310) --------------------------------------------------------
int __cdecl sub_423310(unsigned int a1, char a2)
{
    int result; // eax
    int v3; // esi
    char v5; // cl

    result = 0;
    if (a2 + 1 > 1)
    {
        v3 = a2;
        v5 = a2 - 1;
        do
        {
            if ((a1 & 1) != 0)
                result |= 1 << v5;
            a1 >>= 1;
            --v5;
            --v3;
        } while (v3);
    }
    return result;
}

//----- (00423340) --------------------------------------------------------
FILE* __cdecl sub_423340(char* FileName, unsigned int a2)
{
    FILE* result; // eax
    int v3; // esi
    signed int v5; // eax
    unsigned __int8 Buffer[1024]; // [esp+4h] [ebp-400h] BYREF

    result = fopen(FileName, Mode);
    v3 = (int)result;
    if (result)
    {
        if ((result->_flag & 0x10) == 0)
        {
            do
            {
                v5 = sub_4898CA(Buffer, 1u, 0x400u, (FILE*)v3);
                if (v5 > 0)
                    a2 = sub_423260(Buffer, v5, a2);
            } while ((*(_BYTE*)(v3 + 12) & 0x10) == 0);
        }
        fclose((FILE*)v3);
        return (FILE*)a2;
    }
    return result;
}

//----- (004233C0) --------------------------------------------------------
int __thiscall sub_4233C0(int this, int a2, const char* a3)
{
    char* v4; // edx

    *(_DWORD*)(this + 4) = 0;
    *(_DWORD*)(this + 8) = 0;
    *(_DWORD*)(this + 12) = 0;
    *(_BYTE*)(this + 16) = 1;
    *(_DWORD*)(this + 24) = 0;
    *(_DWORD*)(this + 28) = 0;
    *(_DWORD*)(this + 32) = 0;
    *(_BYTE*)(this + 36) = 1;
    *(_DWORD*)(this + 40) = a2;
    *(_DWORD*)this = &off_499368;
    v4 = (char*)operator new(strlen(a3) + 1);
    *(_DWORD*)(this + 20) = v4;
    strcpy(v4, a3);
    sub_423600((_DWORD*)this);
    sub_423520(this, 0);
    return this;
}
// 499368: using guessed type _UNKNOWN *off_499368;

//----- (004234A0) --------------------------------------------------------
void __thiscall sub_4234A0(void* this)
{
    void* v2; // eax
    int i; // edi
    void* v4; // eax

    v2 = (void*)*((_DWORD*)this + 5);
    *(_DWORD*)this = &off_499368;
    sub_4885A6(v2);
    if (*((_BYTE*)this + 36))
    {
        for (i = 0; i < *((_DWORD*)this + 7); ++i)
            sub_4885A6(*(LPVOID*)(*((_DWORD*)this + 6) + 4 * i));
    }
    memset(*((void**)this + 6), 0, 4 * *((_DWORD*)this + 7));
    v4 = (void*)*((_DWORD*)this + 6);
    *((_DWORD*)this + 7) = 0;
    sub_488CEE(v4);
    *((_DWORD*)this + 8) = 0;
    *((_DWORD*)this + 6) = 0;
    *(_DWORD*)this = &off_499040;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 499368: using guessed type _UNKNOWN *off_499368;

//----- (00423520) --------------------------------------------------------
char __thiscall sub_423520(int this, char a2)
{
    int v2; // ebp
    int v3; // esi
    int v4; // ecx
    BOOL v5; // eax
    int v6; // ecx
    bool v7; // al
    int v8; // eax
    int v9; // edi
    bool v10; // al
    int v11; // ecx
    char result; // al
    int v13; // [esp+4h] [ebp-8h]
    int v14; // [esp+8h] [ebp-4h]

    v2 = 0;
    v13 = this;
    v14 = *(_DWORD*)(this + 28);
    if (v14 <= 0)
    {
        result = a2;
        *(_BYTE*)(this + 16) = a2;
    }
    else
    {
        while (1)
        {
            v3 = *(_DWORD*)(*(_DWORD*)(this + 24) + 4 * v2);
            v4 = *(_DWORD*)(v3 + 176);
            if (v4)
            {
                v5 = a2 && *(_BYTE*)(v3 + 44);
                (*(void(__thiscall**)(int, BOOL))(*(_DWORD*)v4 + 24))(v4, v5);
            }
            v6 = *(_DWORD*)(v3 + 112);
            if (v6)
            {
                v7 = a2 && *(_BYTE*)(v3 + 44);
                *(_BYTE*)(v6 + 33) = v7;
                sub_421540((void**)v6);
            }
            v8 = *(_DWORD*)(v3 + 120);
            v9 = 0;
            *(_BYTE*)(v3 + 136) = 1;
            if (v8 > 0)
            {
                do
                {
                    v10 = a2 && *(_BYTE*)(v3 + 44);
                    v11 = *(_DWORD*)(*(_DWORD*)(v3 + 116) + 4 * v9);
                    *(_BYTE*)(v11 + 33) = v10;
                    sub_421540((void**)v11);
                    ++v9;
                } while (v9 < *(_DWORD*)(v3 + 120));
            }
            result = v14;
            if (++v2 >= v14)
                break;
            this = v13;
        }
        *(_BYTE*)(v13 + 16) = a2;
    }
    return result;
}

//----- (00423600) --------------------------------------------------------
char __thiscall sub_423600(_DWORD* this)
{
    const char* v1; // eax
    char* v2; // ebp
    char* v3; // edi
    unsigned int v4; // kr08_4
    int v5; // eax
    _DWORD** v6; // esi
    char v7; // bl
    int v8; // esi
    int v9; // ecx
    int v10; // edx
    int v11; // eax
    int v12; // eax
    double v13; // st7
    double v14; // st7
    __int64 v15; // rax
    int v16; // eax
    int v17; // edx
    double v18; // st7
    int v19; // eax
    double v20; // st7
    int v21; // edx
    double v22; // st7
    int v23; // eax
    double v24; // st7
    int* v25; // esi
    int v26; // eax
    int v27; // ebx
    int v28; // edi
    void* v29; // eax
    int v30; // edx
    int v31; // eax
    int v32; // esi
    _BYTE* v33; // eax
    int v34; // ecx
    double v35; // st7
    int v36; // eax
    int v37; // eax
    double v38; // st7
    int v39; // eax
    _BYTE* v40; // eax
    int v41; // eax
    double v42; // st7
    int v43; // eax
    double v44; // st6
    _DWORD* v45; // esi
    const char* v46; // eax
    const char* v47; // eax
    int v48; // eax
    _DWORD* v49; // ecx
    _DWORD* v50; // eax
    _DWORD* v51; // eax
    int v52; // eax
    int v53; // ecx
    void* v54; // edx
    int v55; // eax
    char* v56; // eax
    int v57; // edi
    int v58; // ecx
    unsigned __int8 v60; // [esp-1Ch] [ebp-2CCh]
    unsigned __int8 v61; // [esp-18h] [ebp-2C8h]
    int v62; // [esp-18h] [ebp-2C8h]
    unsigned __int8 v63; // [esp-14h] [ebp-2C4h]
    int v64; // [esp-14h] [ebp-2C4h]
    int v65; // [esp-10h] [ebp-2C0h]
    int v66; // [esp-10h] [ebp-2C0h]
    char* String1; // [esp+4h] [ebp-2ACh] BYREF
    int v68; // [esp+8h] [ebp-2A8h]
    _DWORD* v69; // [esp+Ch] [ebp-2A4h]
    __int64 v70; // [esp+10h] [ebp-2A0h]
    int v71; // [esp+18h] [ebp-298h] BYREF
    int v72; // [esp+1Ch] [ebp-294h] BYREF
    int v73; // [esp+20h] [ebp-290h]
    int v74; // [esp+24h] [ebp-28Ch]
    int v75; // [esp+28h] [ebp-288h]
    int v76; // [esp+2Ch] [ebp-284h]
    int v77; // [esp+30h] [ebp-280h] BYREF
    int v78; // [esp+34h] [ebp-27Ch] BYREF
    int v79; // [esp+38h] [ebp-278h] BYREF
    int v80; // [esp+3Ch] [ebp-274h] BYREF
    int v81; // [esp+40h] [ebp-270h] BYREF
    int v82; // [esp+44h] [ebp-26Ch] BYREF
    int v83; // [esp+48h] [ebp-268h] BYREF
    int v84; // [esp+4Ch] [ebp-264h] BYREF
    int v85; // [esp+50h] [ebp-260h] BYREF
    int v86; // [esp+54h] [ebp-25Ch] BYREF
    int v87; // [esp+58h] [ebp-258h] BYREF
    int v88; // [esp+5Ch] [ebp-254h] BYREF
    int v89; // [esp+60h] [ebp-250h] BYREF
    int v90; // [esp+64h] [ebp-24Ch] BYREF
    float v91; // [esp+68h] [ebp-248h]
    int v92; // [esp+6Ch] [ebp-244h] BYREF
    int v93; // [esp+70h] [ebp-240h] BYREF
    int v94; // [esp+74h] [ebp-23Ch] BYREF
    float v95; // [esp+78h] [ebp-238h]
    int v96; // [esp+7Ch] [ebp-234h] BYREF
    _DWORD v97[72]; // [esp+80h] [ebp-230h] BYREF
    char Buffer[260]; // [esp+1A0h] [ebp-110h] BYREF
    int v99; // [esp+2ACh] [ebp-4h]

    v70 = (unsigned int)dword_5209F4;
    LODWORD(v70) = dword_5209D8;
    v1 = (const char*)this[5];
    v69 = this;
    v91 = ((double)(unsigned int)dword_5209F4 - 640.0) * 0.5;
    v95 = ((double)v70 - 480.0) * 0.5;
    sprintf(Buffer, "UI_%s.ini", v1);
    sub_40A1D0((int)v97, Buffer);
    v99 = 0;
    String1 = 0;
    if (sub_40AAF0(v97, aControl, 0))
    {
        while (1)
        {
            sub_40AA40((int)v97, aControl);
            v2 = (char*)operator new(0xC0u);
            memset(v2, 0, 0xC0u);
            v2[45] = 1;
            v2[44] = 1;
            sub_40AFC0(v97, aName, &String1);
            v4 = strlen(String1) + 1;
            v3 = &String1[v4];
            qmemcpy(v2, String1, 4 * (v4 >> 2));
            qmemcpy(&v2[4 * (v4 >> 2)], &v3[4 * (v4 >> 2) - v4], v4 & 3);
            sub_40AFC0(v97, aType, &String1);
            if (!_strcmpi(String1, aStatic))
            {
                *((_DWORD*)v2 + 9) = 1;
                goto LABEL_14;
            }
            if (!_strcmpi(String1, aButton))
            {
                *((_DWORD*)v2 + 9) = 2;
                goto LABEL_14;
            }
            if (!_strcmpi(String1, aEditbox))
            {
                *((_DWORD*)v2 + 9) = 3;
                goto LABEL_14;
            }
            if (!_strcmpi(String1, aCheckbox))
            {
                *((_DWORD*)v2 + 9) = 4;
                goto LABEL_14;
            }
            if (!_strcmpi(String1, aRadiobutton))
            {
                *((_DWORD*)v2 + 9) = 5;
                goto LABEL_14;
            }
            if (!_strcmpi(String1, aListbox))
                break;
            sub_4229D0("UI: control %s has an invalid type '%s'", v2, String1);
            sub_4885A6(v2);
        LABEL_116:
            if (!sub_40AAF0(v97, aControl, 0))
                goto LABEL_117;
        }
        *((_DWORD*)v2 + 9) = 6;
    LABEL_14:
        if (sub_40ABC0(v97, aEnabled, 0))
            sub_40B130((const char*)v97, aEnabled, v2 + 45);
        if (sub_40ABC0(v97, aVisible, 0))
            sub_40B130((const char*)v97, aVisible, v2 + 44);
        v5 = *((_DWORD*)v2 + 9);
        if ((v5 == 1 || v5 == 3) && sub_40ABC0(v97, aImage, 0))
        {
            sub_40AFC0(v97, aImage, &String1);
            v6 = (_DWORD**)v69;
            *((_DWORD*)v2 + 37) = sub_4242F0((_DWORD**)v69, String1);
        }
        else
        {
            v6 = (_DWORD**)v69;
        }
        if (sub_40ABC0(v97, aHotkey, 0))
        {
            sub_40AFC0(v97, aHotkey, &String1);
            v7 = 0;
            if (*String1)
            {
                if (_strcmpi(String1, aSpace))
                {
                    if (_strcmpi(String1, aEnter))
                    {
                        if (_strcmpi(String1, aEsc))
                        {
                            if (!String1[1])
                            {
                                v7 = *String1;
                                v8 = *String1;
                                if (isupper(v8))
                                    v7 = tolower(v8);
                            }
                        }
                        else
                        {
                            v7 = 27;
                        }
                    }
                    else
                    {
                        v7 = 13;
                    }
                }
                else
                {
                    v7 = 32;
                }
            }
            v6 = (_DWORD**)v69;
            v2[180] = v7;
        }
        v74 = 255;
        v73 = 255;
        v75 = 255;
        v76 = 255;
        v2[46] = 0;
        if (sub_40ABC0(v97, aColor, 0))
        {
            sub_40AFC0(v97, aColor, &String1);
            if (sscanf(String1, "%d,%d,%d,%d", &v83, &v94, &v81, &v96) == 4)
            {
                v9 = v94;
                v10 = v81;
                v74 = v83;
                v11 = v96;
                v2[46] = 1;
                v73 = v9;
                v75 = v10;
                v76 = v11;
            }
        }
        v12 = *((_DWORD*)v2 + 9);
        if (v12 == 2 || v12 == 4 || v12 == 5)
        {
            if (sub_40ABC0(v97, aNormal, 0))
            {
                sub_40AFC0(v97, aNormal, &String1);
                *((_DWORD*)v2 + 37) = sub_4242F0(v6, String1);
            }
            if (sub_40ABC0(v97, aPush, 0))
            {
                sub_40AFC0(v97, aPush, &String1);
                *((_DWORD*)v2 + 38) = sub_4242F0(v6, String1);
            }
            if (sub_40ABC0(v97, aLit, 0))
            {
                sub_40AFC0(v97, aLit, &String1);
                *((_DWORD*)v2 + 39) = sub_4242F0(v6, String1);
            }
        }
        *((_DWORD*)v2 + 13) = 0;
        *((_DWORD*)v2 + 12) = 0;
        if (sub_40ABC0(v97, aPos, 0))
        {
            sub_40B1F0((const char*)v97, aPos, (float*)&v79, (float*)&v85);
            v13 = *(float*)&v85;
            *((_DWORD*)v2 + 12) = (__int64)((double)(int)(__int64)*(float*)&v79 + v91);
            v68 = (__int64)v13;
            *((_DWORD*)v2 + 13) = (__int64)((double)v68 + v95);
        }
        *((_DWORD*)v2 + 15) = 0;
        *((_DWORD*)v2 + 14) = 0;
        if (sub_40ABC0(v97, aSize, 0))
        {
            sub_40B1F0((const char*)v97, aSize, (float*)&v87, (float*)&v93);
            v14 = *(float*)&v93;
            *((_DWORD*)v2 + 14) = (__int64)(double)(int)(__int64)*(float*)&v87;
            v68 = (__int64)v14;
            v15 = (__int64)(double)v68;
        }
        else
        {
            v16 = *((_DWORD*)v2 + 37);
            if (!v16)
                goto LABEL_54;
            *((_DWORD*)v2 + 14) = *(_DWORD*)(v16 + 308);
            LODWORD(v15) = *(_DWORD*)(v16 + 312);
        }
        *((_DWORD*)v2 + 15) = v15;
    LABEL_54:
        *((_DWORD*)v2 + 16) = 0;
        if (sub_40ABC0(v97, aZ, 0))
            sub_40AF60((const char*)v97, aZ, (float*)v2 + 16);
        v17 = *((_DWORD*)v2 + 13);
        *((_DWORD*)v2 + 17) = *((_DWORD*)v2 + 12);
        *((_DWORD*)v2 + 18) = v17;
        if (sub_40ABC0(v97, aBoundpos, 0))
        {
            sub_40B1F0((const char*)v97, aBoundpos, (float*)&v89, (float*)&v80);
            v68 = (__int64)*(float*)&v89;
            v18 = *(float*)&v80;
            *((_DWORD*)v2 + 17) = (__int64)((double)v68 + (double)*((int*)v2 + 12));
            v68 = (__int64)v18;
            *((_DWORD*)v2 + 18) = (__int64)((double)v68 + (double)*((int*)v2 + 13));
        }
        v19 = *((_DWORD*)v2 + 15);
        *((_DWORD*)v2 + 19) = *((_DWORD*)v2 + 14);
        *((_DWORD*)v2 + 20) = v19;
        if (sub_40ABC0(v97, aBoundsize, 0))
        {
            sub_40B1F0((const char*)v97, aBoundsize, (float*)&v82, (float*)&v84);
            v20 = *(float*)&v84;
            *((_DWORD*)v2 + 19) = (__int64)(double)(int)(__int64)*(float*)&v82;
            v68 = (__int64)v20;
            *((_DWORD*)v2 + 20) = (__int64)(double)v68;
        }
        if (sub_40ABC0(v97, aTextcentered, 0))
            sub_40B130((const char*)v97, aTextcentered, v2 + 104);
        v21 = *((_DWORD*)v2 + 13);
        *((_DWORD*)v2 + 21) = *((_DWORD*)v2 + 12);
        *((_DWORD*)v2 + 22) = v21;
        if (sub_40ABC0(v97, aTextpos, 0))
        {
            sub_40B1F0((const char*)v97, aTextpos, (float*)&v86, (float*)&v88);
            v68 = (__int64)*(float*)&v86;
            v22 = *(float*)&v88;
            *((_DWORD*)v2 + 21) = (__int64)((double)v68 + (double)*((int*)v2 + 12));
            v68 = (__int64)v22;
            *((_DWORD*)v2 + 22) = (__int64)((double)v68 + (double)*((int*)v2 + 13));
        }
        v23 = *((_DWORD*)v2 + 15);
        *((_DWORD*)v2 + 23) = *((_DWORD*)v2 + 14);
        *((_DWORD*)v2 + 24) = v23;
        if (sub_40ABC0(v97, aTextsize, 0))
        {
            sub_40B1F0((const char*)v97, aTextsize, (float*)&v90, (float*)&v92);
            v24 = *(float*)&v92;
            *((_DWORD*)v2 + 23) = (__int64)(double)(int)(__int64)*(float*)&v90;
            v68 = (__int64)v24;
            *((_DWORD*)v2 + 24) = (__int64)(double)v68;
        }
        *((_DWORD*)v2 + 25) = 0;
        if (sub_40ABC0(v97, aTextz, 0))
            sub_40AF60((const char*)v97, aTextz, (float*)v2 + 25);
        if (*((_DWORD*)v2 + 9) == 3)
        {
            if (sub_40ABC0(v97, aEditmaxchars, 0))
                sub_40AF00((const char*)v97, aEditmaxchars, (char**)v2 + 35);
            if (sub_40ABC0(v97, aEditrestricted, 0))
                sub_40B130((const char*)v97, aEditrestricted, v2 + 144);
        }
        v25 = (int*)(v2 + 108);
        if (*((_DWORD*)v2 + 9) == 6)
        {
            *v25 = 4;
            if (sub_40ABC0(v97, aTextfont, 0))
                sub_40AF00((const char*)v97, aTextfont, (char**)v2 + 27);
            v26 = sub_421B20(*(_DWORD**)(dword_520970 + 132), *((_DWORD*)v2 + 27));
            v27 = v26 - 2;
            if (v26 == 2)
            {
                v28 = 1;
            }
            else
            {
                v28 = *((_DWORD*)v2 + 24) / v27;
                if (v28 <= 0)
                    goto LABEL_96;
            }
            v29 = operator new(4 * v28);
            v30 = *((_DWORD*)v2 + 21);
            *((_DWORD*)v2 + 29) = v29;
            v31 = *((_DWORD*)v2 + 22);
            v32 = 0;
            *((_DWORD*)v2 + 30) = v28;
            v68 = v31;
            *(float*)&v70 = (float)v30;
            do
            {
                v33 = sub_409AD0((int*)dword_520970, *((_DWORD*)v2 + 27), 0x40u);
                v34 = v70;
                v35 = (double)v68;
                *(_DWORD*)(*((_DWORD*)v2 + 29) + 4 * v32) = v33;
                v36 = *(_DWORD*)(*((_DWORD*)v2 + 29) + 4 * v32);
                *(float*)(v36 + 16) = v35;
                *(_DWORD*)(v36 + 12) = v34;
                *(_BYTE*)(v36 + 32) = 0;
                v37 = *(_DWORD*)(*((_DWORD*)v2 + 29) + 4 * v32);
                v38 = *((float*)v2 + 25) + 1000.0;
                ++v32;
                v68 += v27;
                *(float*)(v37 + 20) = v38;
            } while (v32 < v28);
        }
        else
        {
            *v25 = 3;
            if (sub_40ABC0(v97, aTextfont, 0))
                sub_40AF00((const char*)v97, aTextfont, (char**)v2 + 27);
            if (sub_40ABC0(v97, aText, 0))
            {
                v39 = *((_DWORD*)v2 + 9);
                v77 = 255;
                v72 = 186;
                v78 = 0;
                v71 = 255;
                if (v39 == 2)
                    v71 = 191;
                if (sub_40ABC0(v97, aTextcolor, 0))
                {
                    sub_40AFC0(v97, aTextcolor, &String1);
                    sscanf(String1, "%d,%d,%d,%d", &v77, &v72, &v78, &v71);
                }
                sub_40AFC0(v97, aText, &String1);
                v40 = sub_409AD0((int*)dword_520970, *v25, 0x40u);
                v65 = v71;
                v63 = v78;
                v61 = v72;
                v60 = v77;
                *((_DWORD*)v2 + 28) = v40;
                sub_421300((int)v40, v60, v61, v63, v65);
                v41 = *((_DWORD*)v2 + 28);
                if (*((_DWORD*)v2 + 9) == 2)
                {
                    *(_BYTE*)(v41 + 35) = 0;
                }
                else
                {
                    *(_BYTE*)(v41 + 35) = 1;
                    sub_421370(*((_DWORD**)v2 + 28), 0, 0, 0, 255);
                }
                sub_421110(*((_DWORD*)v2 + 28), String1);
                if (v2[104])
                {
                    v43 = *((_DWORD*)v2 + 28);
                    v42 = (double)*((int*)v2 + 24) * 0.5 + (double)*((int*)v2 + 22);
                    v44 = (double)*((int*)v2 + 23) * 0.5 + (double)*((int*)v2 + 21);
                    *(_BYTE*)(v43 + 32) = 1;
                    *(float*)(v43 + 12) = v44;
                }
                else
                {
                    v42 = (double)*((int*)v2 + 22);
                    v43 = *((_DWORD*)v2 + 28);
                    *(float*)(v43 + 12) = (float)*((int*)v2 + 21);
                    *(_BYTE*)(v43 + 32) = 0;
                }
                *(float*)(v43 + 16) = v42;
                *(float*)(*((_DWORD*)v2 + 28) + 20) = *((float*)v2 + 25) + 1000.0;
            }
        }
    LABEL_96:
        if (sub_40ABC0(v97, aSlave1, 0))
        {
            sub_40AFC0(v97, aSlave1, &String1);
            v45 = v69;
            v46 = sub_424350(v69, String1);
            *((_DWORD*)v2 + 46) = v46;
            if (v46)
                *((_BYTE*)v46 + 45) = 0;
        }
        else
        {
            v45 = v69;
        }
        if (sub_40ABC0(v97, aSlave2, 0))
        {
            sub_40AFC0(v97, aSlave2, &String1);
            v47 = sub_424350(v45, String1);
            *((_DWORD*)v2 + 47) = v47;
            if (v47)
                *((_BYTE*)v47 + 45) = 0;
        }
        v48 = 0;
        v49 = v2 + 148;
        while (!*v49)
        {
            ++v48;
            ++v49;
            if (v48 >= 6)
            {
                if (!v2[46])
                    goto LABEL_111;
                break;
            }
        }
        v50 = operator new(0x80u);
        LODWORD(v70) = v50;
        LOBYTE(v99) = 1;
        if (v50)
            v51 = sub_412AB0(v50);
        else
            v51 = 0;
        v66 = v75;
        v64 = v73;
        v62 = v74;
        LOBYTE(v99) = 0;
        *((_DWORD*)v2 + 44) = v51;
        sub_413160((int)v51, v62, v64, v66);
        sub_413180(*((_DWORD*)v2 + 44), v76, 1);
        sub_428680(v45, *((_DWORD*)v2 + 44));
    LABEL_111:
        v52 = v45[8];
        v53 = v45[7] + 1;
        v45[7] = v53;
        if (v53 > v52)
        {
            v54 = (void*)v45[6];
            v55 = v52 + 8;
            v45[8] = v55;
            v56 = (char*)sub_488DD7(v54, 4 * v55);
            if (v56)
            {
                v57 = v45[7];
                v58 = v45[8] - v57;
                v45[6] = v56;
                memset(&v56[4 * v57], 0, 4 * v58);
            }
        }
        *(_DWORD*)(v45[6] + 4 * v45[7] - 4) = v2;
        goto LABEL_116;
    }
LABEL_117:
    v99 = -1;
    sub_40A830((int)v97);
    return 1;
}
// 423F0D: conditional instruction was optimized away because edi.4>=1
// 520970: using guessed type int dword_520970;
// 5209D8: using guessed type int dword_5209D8;
// 5209F4: using guessed type int dword_5209F4;

//----- (004242F0) --------------------------------------------------------
const char* __thiscall sub_4242F0(_DWORD** this, char* String2)
{
    return sub_426000(this[10], String2);
}

//----- (00424300) --------------------------------------------------------
const char* __thiscall sub_424300(_DWORD** this, int a2, int a3, char* String2, char a5)
{
    const char* result; // eax

    result = sub_4242F0(this, String2);
    *(_DWORD*)(a2 + 4 * a3 + 148) = result;
    if (a5)
    {
        if (result)
        {
            *(_DWORD*)(a2 + 56) = *((_DWORD*)result + 77);
            result = *(const char**)(*(_DWORD*)(a2 + 4 * a3 + 148) + 312);
            *(_DWORD*)(a2 + 60) = result;
        }
    }
    return result;
}

//----- (00424350) --------------------------------------------------------
const char* __thiscall sub_424350(_DWORD* this, char* String2)
{
    int v3; // ebp
    int v4; // esi
    const char* v5; // edi

    v3 = this[7];
    v4 = 0;
    if (v3 <= 0)
        return 0;
    while (1)
    {
        v5 = *(const char**)(this[6] + 4 * v4);
        if (!_strcmpi(v5, String2))
            break;
        if (++v4 >= v3)
            return 0;
    }
    return v5;
}

//----- (00424390) --------------------------------------------------------
int __thiscall sub_424390(_DWORD* this, int a2)
{
    return *(_DWORD*)(this[6] + 4 * a2);
}

//----- (004243A0) --------------------------------------------------------
_DWORD* __thiscall sub_4243A0(_DWORD* this)
{
    _DWORD* v2; // eax
    _DWORD* v3; // eax
    _DWORD* v4; // eax
    _DWORD* v5; // eax
    float v7; // [esp+0h] [ebp-20h]
    float v8; // [esp+0h] [ebp-20h]

    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
    *((_BYTE*)this + 16) = 1;
    this[5] = 0;
    this[6] = 0;
    this[7] = 0;
    *((_BYTE*)this + 32) = 0;
    this[9] = 0;
    this[10] = 0;
    this[11] = 0;
    *((_BYTE*)this + 48) = 0;
    *this = &off_4993AC;
    this[14] = 0;
    this[19] = 0;
    this[15] = (unsigned int)dword_5209F4 >> 1;
    this[16] = (unsigned int)dword_5209D8 >> 1;
    this[17] = 0;
    this[18] = 0;
    this[20] = 0;
    v2 = operator new(0x15Cu);
    if (v2)
        v3 = sub_41C6A0(v2);
    else
        v3 = 0;
    this[22] = v3;
    sub_41C760((int)v3, aSoundsClickWav);
    v7 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
    sub_41CFD0(this[22], v7);
    sub_41CA40(this[22]);
    v4 = operator new(0x15Cu);
    if (v4)
        v5 = sub_41C6A0(v4);
    else
        v5 = 0;
    this[21] = v5;
    sub_41C760((int)v5, aSoundsRollover);
    sub_41CA40(this[21]);
    v8 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
    sub_41CFD0(this[21], v8);
    sub_425140((int)this);
    return this;
}
// 4993AC: using guessed type _UNKNOWN *off_4993AC;
// 5209D8: using guessed type int dword_5209D8;
// 5209F4: using guessed type int dword_5209F4;

//----- (00424520) --------------------------------------------------------
void __thiscall sub_424520(int this)
{
    int i; // edi
    void(__thiscall * **v3)(_DWORD, int); // ecx
    void* v4; // eax
    int j; // edi
    void* v6; // eax

    *(_DWORD*)this = &off_4993AC;
    sub_4246F0((int*)this);
    sub_425F60(this);
    if (*(_BYTE*)(this + 48))
    {
        for (i = 0; i < *(_DWORD*)(this + 40); ++i)
        {
            v3 = *(void(__thiscall****)(_DWORD, int))(*(_DWORD*)(this + 36) + 4 * i);
            if (v3)
                (**v3)(v3, 1);
        }
    }
    memset(*(void**)(this + 36), 0, 4 * *(_DWORD*)(this + 40));
    v4 = *(void**)(this + 36);
    *(_DWORD*)(this + 40) = 0;
    sub_488CEE(v4);
    *(_DWORD*)(this + 44) = 0;
    *(_DWORD*)(this + 36) = 0;
    if (*(_BYTE*)(this + 32))
    {
        for (j = 0; j < *(_DWORD*)(this + 24); ++j)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 20) + 4 * j));
    }
    memset(*(void**)(this + 20), 0, 4 * *(_DWORD*)(this + 24));
    v6 = *(void**)(this + 20);
    *(_DWORD*)(this + 24) = 0;
    sub_488CEE(v6);
    *(_DWORD*)(this + 28) = 0;
    *(_DWORD*)(this + 20) = 0;
    *(_DWORD*)this = &off_499040;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 4993AC: using guessed type _UNKNOWN *off_4993AC;

//----- (00424630) --------------------------------------------------------
char __thiscall sub_424630(int* this)
{
    int v2; // eax
    _DWORD* v3; // eax
    _DWORD* v4; // eax
    float v6; // [esp+0h] [ebp-18h]

    v2 = this[20];
    if (!v2)
    {
        v3 = operator new(0x15Cu);
        if (v3)
            v4 = sub_41C6A0(v3);
        else
            v4 = 0;
        this[20] = (int)v4;
        sub_41C7A0((int)v4, 1);
        sub_41C760(this[20], aSoundsUiMusicW);
        sub_41C7E0((_BYTE*)this[20], 1);
        sub_41CA40(this[20]);
        v6 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
        sub_41CFD0(this[20], v6);
        LOBYTE(v2) = sub_41CD90(this[20]);
    }
    return v2;
}

//----- (004246F0) --------------------------------------------------------
void __thiscall sub_4246F0(int* this)
{
    int v2; // ecx
    void* v3; // edi

    v2 = this[20];
    if (v2)
    {
        sub_41CF50(v2);
        v3 = (void*)this[20];
        if (v3)
        {
            sub_41C700(this[20]);
            sub_4885A6(v3);
        }
        this[20] = 0;
    }
}

//----- (00424730) --------------------------------------------------------
char __thiscall sub_424730(_DWORD* this, int a2)
{
    int v3; // ecx
    double v5; // st7
    double v6; // st7
    double v7; // st7
    _DWORD* v8; // esi
    int v9; // edi
    int v10; // ebx
    double v11; // st6
    __int64 v12; // rax
    int v13; // ecx
    int v14; // edx
    int v15; // eax
    int v16; // esi
    int v17; // ecx
    int v18; // esi
    int v19; // edi
    int v20; // eax
    int v21; // edx
    int v22; // eax
    int v23; // eax
    int v24; // ecx
    int v25; // edx
    int v26; // ebx
    int v27; // eax
    int v28; // edx
    int v29; // esi
    int v30; // ecx
    int v31; // ecx
    int v32; // eax
    int v33; // edi
    int v34; // eax
    int v35; // ecx
    int v36; // eax
    int v37; // eax
    double v38; // st7
    double v39; // st6
    int v40; // eax
    int v41; // eax
    int v42; // edi
    int v43; // ebx
    int v44; // ecx
    float v45; // [esp+0h] [ebp-30h]
    float v46; // [esp+4h] [ebp-2Ch]
    float v47; // [esp+8h] [ebp-28h]
    float v48; // [esp+Ch] [ebp-24h]
    float v49; // [esp+Ch] [ebp-24h]
    float v50; // [esp+18h] [ebp-18h]
    float v51; // [esp+20h] [ebp-10h]
    float v52; // [esp+20h] [ebp-10h]
    int v53; // [esp+20h] [ebp-10h]
    int i; // [esp+20h] [ebp-10h]
    int v55; // [esp+20h] [ebp-10h]
    float v56; // [esp+24h] [ebp-Ch]
    int v57; // [esp+28h] [ebp-8h]
    int v58; // [esp+28h] [ebp-8h]
    int v59; // [esp+2Ch] [ebp-4h]
    int v60; // [esp+2Ch] [ebp-4h]

    v3 = this[20];
    if (v3)
    {
        sub_41D0C0(v3, (int)this, *(float*)(dword_520970 + 68));
        v50 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
        sub_41CFD0(this[20], v50);
    }
    if (!this[13])
        return sub_428620(this, a2);
    v51 = *(float*)(dword_520970 + 24);
    v5 = sub_408F80((float*)dword_520970, 0);
    if (v51 == 0.0)
        v56 = 0.0;
    else
        v56 = v5 / v51;
    v52 = *(float*)(dword_520970 + 24);
    v6 = sub_408F80((float*)dword_520970, 1);
    if (v52 == 0.0)
        v7 = 0.0;
    else
        v7 = v6 / v52;
    v8 = (_DWORD*)this[14];
    v9 = 0;
    v10 = 0;
    v53 = dword_5209F4;
    v59 = dword_5209D8;
    if (v8)
    {
        v9 = -v8[14];
        v10 = -v8[15];
    }
    v11 = (double)(int)this[16];
    v57 = (__int64)((double)(int)this[15] + v56);
    this[15] = v57;
    v12 = (__int64)(v11 + v7);
    this[16] = v12;
    if (v57 >= v9)
    {
        if (v57 > v53)
            this[15] = v53;
    }
    else
    {
        this[15] = v9;
    }
    if ((int)v12 >= v10)
    {
        if ((int)v12 > v59)
            this[16] = v59;
    }
    else
    {
        this[16] = v10;
    }
    if (v8)
    {
        v13 = v8[44];
        if (v13)
        {
            v14 = this[15];
            v56 = *(float*)&v14;
            v48 = (float)(this[16] + v8[15]);
            v47 = (float)(v14 + v8[14]);
            v46 = (float)(int)this[16];
            v45 = (float)v14;
            sub_413090(v13, v45, v46, v47, v48);
        }
    }
    v15 = 0;
    v60 = this[17];
    v16 = *(_DWORD*)(this[13] + 28);
    this[17] = 0;
    v58 = v16;
    for (i = 0; i < v58; ++i)
    {
        v17 = sub_424390((_DWORD*)this[13], v15);
        if (*(_BYTE*)(v17 + 44))
        {
            v18 = this[15];
            v19 = *(_DWORD*)(v17 + 68);
            if (v18 >= v19)
            {
                v20 = this[16];
                v21 = *(_DWORD*)(v17 + 72);
                if (v20 >= v21 && v18 < v19 + *(_DWORD*)(v17 + 76) && v20 < v21 + *(_DWORD*)(v17 + 80))
                {
                    v22 = this[17];
                    if (!v22 || *(float*)(v17 + 64) > (double)*(float*)(v22 + 64))
                        this[17] = v17;
                }
            }
        }
        v16 = v58;
        v15 = i + 1;
    }
    if (this[17] != v60)
    {
        (*(void(__thiscall**)(_DWORD, _DWORD))(*(_DWORD*)this[13] + 52))(this[13], this[17]);
        if (!this[18])
        {
            v23 = this[17];
            if (v23)
            {
                v24 = *(_DWORD*)(v23 + 148);
                v25 = *(_DWORD*)(v23 + 156);
                if (v24 != v25 && v24 && v25 && *(_BYTE*)(v23 + 45) && *(_BYTE*)(v23 + 44))
                {
                    sub_41CF00(this[21]);
                    v49 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
                    sub_41CFD0(this[21], v49);
                    sub_41CD90(this[21]);
                }
            }
        }
    }
    v26 = 0;
    v55 = 0;
    if (v16 > 0)
    {
        do
        {
            v27 = sub_424390((_DWORD*)this[13], v26);
            v29 = v27;
            v30 = *(_DWORD*)(v27 + 176);
            if (v30)
            {
                LOBYTE(v28) = *(_BYTE*)(v27 + 44);
                (*(void(__thiscall**)(int, int))(*(_DWORD*)v30 + 24))(v30, v28);
            }
            v31 = *(_DWORD*)(v29 + 112);
            if (v31)
            {
                *(_BYTE*)(v31 + 33) = *(_BYTE*)(v29 + 44);
                sub_421540((void**)v31);
            }
            v32 = *(_DWORD*)(v29 + 36);
            v33 = 0;
            if (v32 == 2)
            {
                if (*(_BYTE*)(v29 + 45))
                {
                    v34 = this[18];
                    if (!v34 && this[17] == v29)
                    {
                        v33 = 2;
                        goto LABEL_68;
                    }
                    if (v34 == v29)
                    {
                        if (this[17] == v29)
                        {
                            v33 = 1;
                            goto LABEL_68;
                        }
                        if (v34 == v29 && this[17] != v29)
                        {
                            v33 = 2;
                            goto LABEL_68;
                        }
                    }
                }
                v33 = 0;
            }
            else
            {
                if (v32 != 4 && v32 != 5)
                    goto LABEL_68;
                v35 = this[17];
                if (v35 != v29)
                {
                LABEL_67:
                    v33 = *(_BYTE*)(v29 + 172) != 0;
                    goto LABEL_68;
                }
                v36 = this[18];
                if (v36 && v36 != v29)
                {
                    if (v35 != v29)
                        goto LABEL_67;
                }
                else
                {
                    v33 = 2 - (*(_BYTE*)(v29 + 172) != 0);
                }
            }
        LABEL_68:
            v37 = *(_DWORD*)(v29 + 112);
            *(_DWORD*)(v29 + 40) = v33;
            if (v37)
            {
                if (*(_BYTE*)(v29 + 104))
                {
                    v38 = (double)*(int*)(v29 + 96) * 0.5 + (double)*(int*)(v29 + 88);
                    v39 = (double)*(int*)(v29 + 92) * 0.5 + (double)*(int*)(v29 + 84);
                    *(_BYTE*)(v37 + 32) = 1;
                }
                else
                {
                    v38 = (double)*(int*)(v29 + 88);
                    v39 = (double)*(int*)(v29 + 84);
                    *(_BYTE*)(v37 + 32) = 0;
                }
                *(float*)(v37 + 12) = v39;
                *(float*)(v37 + 16) = v38;
                *(float*)(*(_DWORD*)(v29 + 112) + 20) = *(float*)(v29 + 100) + 1000.0;
            }
            sub_424C80(this, v29);
            v40 = *(_DWORD*)(v29 + 184);
            if (v40)
            {
                *(_DWORD*)(v40 + 40) = v33;
                *(_BYTE*)(*(_DWORD*)(v29 + 184) + 44) = *(_BYTE*)(v29 + 44);
                *(_BYTE*)(*(_DWORD*)(v29 + 184) + 45) = *(_BYTE*)(v29 + 45);
                sub_424C80(this, *(_DWORD*)(v29 + 184));
            }
            v41 = *(_DWORD*)(v29 + 188);
            if (v41)
            {
                *(_DWORD*)(v41 + 40) = v33;
                *(_BYTE*)(*(_DWORD*)(v29 + 188) + 44) = *(_BYTE*)(v29 + 44);
                *(_BYTE*)(*(_DWORD*)(v29 + 188) + 45) = *(_BYTE*)(v29 + 45);
                sub_424C80(this, *(_DWORD*)(v29 + 188));
            }
            if (*(_DWORD*)(v29 + 36) == 6 && *(_BYTE*)(v29 + 136))
            {
                v42 = 0;
                if (*(int*)(v29 + 120) > 0)
                {
                    do
                    {
                        v43 = v42 + *(_DWORD*)(v29 + 128);
                        if (*(_DWORD*)(v29 + 124) == v43 || !*(_BYTE*)(v29 + 45))
                        {
                            LOBYTE(v56) = 1;
                            sub_421300(*(_DWORD*)(*(_DWORD*)(v29 + 116) + 4 * v42), 0xFFu, 0xBAu, 0, 255);
                            *(_BYTE*)(*(_DWORD*)(*(_DWORD*)(v29 + 116) + 4 * v42) + 35) = 1;
                            sub_421370(*(_DWORD**)(*(_DWORD*)(v29 + 116) + 4 * v42), 0, 0, 0, 255);
                        }
                        else
                        {
                            LOBYTE(v56) = 0;
                            sub_421300(*(_DWORD*)(*(_DWORD*)(v29 + 116) + 4 * v42), 0xFFu, 0xBAu, 0, 160);
                            *(_BYTE*)(*(_DWORD*)(*(_DWORD*)(v29 + 116) + 4 * v42) + 35) = 0;
                        }
                        if (v43 >= *(_DWORD*)(v29 + 132))
                        {
                            v44 = *(_DWORD*)(*(_DWORD*)(v29 + 116) + 4 * v42);
                            *(_BYTE*)(v44 + 33) = 0;
                        }
                        else
                        {
                            (*(void(__thiscall**)(_DWORD, int, int, _DWORD, float))(*(_DWORD*)this[13] + 32))(
                                this[13],
                                v29,
                                v43,
                                *(_DWORD*)(*(_DWORD*)(v29 + 116) + 4 * v42),
                                COERCE_FLOAT(LODWORD(v56)));
                            v44 = *(_DWORD*)(*(_DWORD*)(v29 + 116) + 4 * v42);
                            *(_BYTE*)(v44 + 33) = 1;
                        }
                        sub_421540((void**)v44);
                        ++v42;
                    } while (v42 < *(_DWORD*)(v29 + 120));
                    v26 = v55;
                }
                *(_BYTE*)(v29 + 136) = 0;
            }
            v55 = ++v26;
        } while (v26 < v58);
    }
    return sub_428620(this, a2);
}
// 4249EC: variable 'v28' is possibly undefined
// 520970: using guessed type int dword_520970;
// 5209D8: using guessed type int dword_5209D8;
// 5209F4: using guessed type int dword_5209F4;

//----- (00424C80) --------------------------------------------------------
void __thiscall sub_424C80(_DWORD* this, int a2)
{
    _DWORD* v4; // ecx
    int v5; // eax
    _DWORD* v6; // edi
    int v7; // eax
    int v8; // eax
    int v9; // edx
    double v10; // st7
    int v11; // ecx
    int v12; // [esp+4h] [ebp-28h]
    int v13; // [esp+8h] [ebp-24h]
    float v14; // [esp+8h] [ebp-24h]
    int v15; // [esp+Ch] [ebp-20h]
    float v16; // [esp+Ch] [ebp-20h]
    int v17; // [esp+10h] [ebp-1Ch]
    float v18; // [esp+10h] [ebp-1Ch]
    float v19; // [esp+14h] [ebp-18h]
    int v20; // [esp+14h] [ebp-18h]
    int v21; // [esp+24h] [ebp-8h]
    float v22; // [esp+30h] [ebp+4h]

    v4 = *(_DWORD**)(a2 + 176);
    if (!v4)
        return;
    if (!*(_BYTE*)(a2 + 44))
    {
        (*(void(__thiscall**)(_DWORD*, _DWORD))(*v4 + 24))(v4, 0);
        return;
    }
    v5 = *(_DWORD*)(a2 + 40);
    if (v5 <= -1 || (v6 = *(_DWORD**)(a2 + 4 * v5 + 148)) == 0)
    {
        if (*(_BYTE*)(a2 + 46))
        {
            sub_4131B0(v4, 0);
            (*(void(__thiscall**)(_DWORD, int))(**(_DWORD**)(a2 + 176) + 24))(*(_DWORD*)(a2 + 176), 1);
            goto LABEL_14;
        }
        sub_4131B0(v4, 0);
        v4 = *(_DWORD**)(a2 + 176);
    LABEL_13:
        (*(void(__thiscall**)(_DWORD*, _DWORD))(*v4 + 24))(v4, 0);
        goto LABEL_14;
    }
    v7 = v6[74];
    if (!v7 || !*(_DWORD*)(v7 + 28) || !*(_DWORD*)(v7 + 32))
        goto LABEL_13;
    (*(void(__thiscall**)(_DWORD*, int))(*v4 + 24))(v4, 1);
    sub_4131B0(*(_DWORD**)(a2 + 176), (_DWORD*)v6[74]);
    v8 = v6[74];
    v9 = v6[75];
    v21 = v6[76];
    v10 = (double)*(int*)(v8 + 32);
    v22 = (float)*(int*)(v8 + 28);
    *(float*)&v17 = (double)(v21 + v6[78]) / v10;
    *(float*)&v15 = (double)(v9 + v6[77]) / v22;
    *(float*)&v13 = (double)v21 / v10;
    *(float*)&v12 = (double)v9 / v22;
    sub_413130(*(_DWORD*)(a2 + 176), v12, v13, v15, v17);
LABEL_14:
    if (a2 != this[14])
    {
        v11 = *(_DWORD*)(a2 + 48);
        v19 = (float)(*(_DWORD*)(a2 + 52) + *(_DWORD*)(a2 + 60));
        v18 = (float)(v11 + *(_DWORD*)(a2 + 56));
        v16 = (float)*(int*)(a2 + 52);
        v14 = (float)v11;
        sub_413090(*(_DWORD*)(a2 + 176), v14, v16, v18, v19);
    }
    *(float*)&v20 = *(float*)(a2 + 64) + 1000.0;
    sub_413120(*(_DWORD*)(a2 + 176), v20);
}

//----- (00424E30) --------------------------------------------------------
char __thiscall sub_424E30(_DWORD* this, int a2)
{
    int v3; // eax
    int v4; // ebx
    int v5; // edi
    int v7; // eax
    int v8; // ecx
    int v9; // ebp
    int v10; // ebx
    _BYTE* v11; // eax
    int v12; // edi
    float v13; // [esp+0h] [ebp-14h]

    if (this[13])
    {
        if (this[19])
        {
            if (isprint((char)a2) && (v3 = this[19], *(_DWORD*)(v3 + 112)))
            {
                if (!*(_BYTE*)(v3 + 144) || !strchr(asc_4A4C9C, (char)a2))
                {
                    v4 = this[19];
                    if ((signed int)(strlen(*(const char**)(*(_DWORD*)(v4 + 112) + 8)) - 1) < *(_DWORD*)(v4 + 140))
                    {
                        sub_421280(*(_DWORD*)(v4 + 112));
                        sub_4211E0(*(_DWORD*)(this[19] + 112), a2);
                        sub_4211E0(*(_DWORD*)(this[19] + 112), 95);
                        v5 = this[19];
                        if ((__int64)*(float*)(*(_DWORD*)(v5 + 112) + 24) > *(int*)(v5 + 92))
                        {
                            sub_421280(*(_DWORD*)(v5 + 112));
                            sub_421280(*(_DWORD*)(this[19] + 112));
                            sub_4211E0(*(_DWORD*)(this[19] + 112), 95);
                            return sub_4285C0(this, a2);
                        }
                    }
                }
            }
            else if ((_BYTE)a2 == 8)
            {
                v7 = this[19];
                if (v7)
                {
                    v8 = *(_DWORD*)(v7 + 112);
                    if (v8)
                    {
                        sub_421280(v8);
                        sub_421280(*(_DWORD*)(this[19] + 112));
                        sub_4211E0(*(_DWORD*)(this[19] + 112), 95);
                        return sub_4285C0(this, a2);
                    }
                }
            }
        }
        else
        {
            if (isupper((char)a2))
                LOBYTE(a2) = tolower((char)a2);
            v9 = 0;
            v10 = *(_DWORD*)(this[13] + 28);
            if (v10 > 0)
            {
                while (1)
                {
                    v11 = (_BYTE*)sub_424390((_DWORD*)this[13], v9);
                    v12 = (int)v11;
                    if ((_BYTE)a2 == v11[180] && v11[44] && v11[45])
                        break;
                    if (++v9 >= v10)
                        return sub_4285C0(this, a2);
                }
                sub_41CF00(this[22]);
                v13 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
                sub_41CFD0(this[22], v13);
                sub_41CD90(this[22]);
                sub_426060((int)this, v12, 0);
            }
        }
    }
    return sub_4285C0(this, a2);
}

//----- (00425030) --------------------------------------------------------
char __thiscall sub_425030(_DWORD* this, int ArgList, int a3)
{
    int v4; // ecx
    int v5; // eax
    int v6; // eax
    int v7; // eax
    int v8; // ecx
    int v10; // eax
    float v11; // [esp+0h] [ebp-Ch]

    if (this[13])
    {
        if ((_BYTE)a3)
        {
            sub_41CF00(this[22]);
            v11 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
            sub_41CFD0(this[22], v11);
            sub_41CD90(this[22]);
            v4 = this[17];
            if (v4)
            {
                v5 = this[19];
                if (v5)
                {
                    if (v4 != v5)
                    {
                        v6 = *(_DWORD*)(v5 + 112);
                        if (v6)
                            sub_421280(v6);
                        this[19] = 0;
                    }
                }
            }
            v7 = this[17];
            if (!v7)
            {
            LABEL_15:
                this[18] = v7;
                return sub_4285F0(this, ArgList, a3);
            }
            if (*(_BYTE*)(v7 + 44) && *(_BYTE*)(v7 + 45))
            {
                v8 = *(_DWORD*)(v7 + 36);
                if (v8 == 6 || v8 == 3)
                {
                    sub_426060((int)this, v7, ArgList);
                    return sub_4285F0(this, ArgList, a3);
                }
                goto LABEL_15;
            }
        }
        else
        {
            v10 = this[17];
            if (v10 == this[18] && v10 && *(_BYTE*)(v10 + 44) && *(_BYTE*)(v10 + 45))
                sub_426060((int)this, v10, ArgList);
            this[18] = 0;
        }
    }
    return sub_4285F0(this, ArgList, a3);
}
// 4250C1: conditional instruction was optimized away because eax.4!=0

//----- (00425140) --------------------------------------------------------
int __thiscall sub_425140(int this)
{
    _DWORD* v2; // ebx
    unsigned int v3; // edi
    unsigned int v4; // kr50_4
    unsigned int v5; // edi
    unsigned int v6; // kr54_4
    double v7; // st7
    double v8; // st7
    int v9; // eax
    int v10; // edi
    void* v11; // edx
    int v12; // eax
    char* v13; // eax
    int v14; // edi
    int v15; // ecx
    int v16; // ebx
    int v17; // esi
    _DWORD* v18; // eax
    _DWORD* v19; // ebx
    int v20; // eax
    int v21; // esi
    void* v22; // ecx
    int v23; // eax
    char* v24; // eax
    int v25; // esi
    int v26; // ecx
    _DWORD* v27; // eax
    _DWORD* v28; // ebx
    int v29; // eax
    int v30; // esi
    int v31; // eax
    char* v32; // eax
    int v33; // esi
    int v34; // ecx
    _DWORD* v35; // eax
    _DWORD* v36; // ebx
    int v37; // eax
    int v38; // esi
    int v39; // eax
    char* v40; // eax
    int v41; // esi
    int v42; // ecx
    _DWORD* v43; // eax
    _DWORD* v44; // ebx
    int v45; // eax
    int v46; // esi
    int v47; // eax
    char* v48; // eax
    int v49; // esi
    int v50; // ecx
    _DWORD* v51; // eax
    _DWORD* v52; // ebx
    int v53; // eax
    int v54; // esi
    int v55; // eax
    char* v56; // eax
    int v57; // esi
    int v58; // ecx
    _DWORD* v59; // eax
    _DWORD* v60; // ebx
    int v61; // eax
    int v62; // esi
    int v63; // eax
    char* v64; // eax
    int v65; // esi
    int v66; // ecx
    _DWORD* v67; // eax
    _DWORD* v68; // ebx
    int v69; // eax
    int v70; // esi
    int v71; // eax
    char* v72; // eax
    int v73; // esi
    int v74; // ecx
    _DWORD* v75; // eax
    _DWORD* v76; // ebx
    int v77; // eax
    int v78; // esi
    int v79; // eax
    char* v80; // eax
    int v81; // esi
    int v82; // ecx
    _DWORD* v83; // eax
    _DWORD* v84; // ebx
    int v85; // eax
    int v86; // esi
    int v87; // eax
    char* v88; // eax
    int v89; // esi
    int v90; // ecx
    void* v91; // eax
    int v92; // ebx
    int v93; // eax
    int v94; // esi
    int v95; // eax
    char* v96; // eax
    int v97; // esi
    int v98; // ecx
    _DWORD* v99; // eax
    _DWORD* v100; // ebx
    int v101; // eax
    int v102; // esi
    int v103; // eax
    char* v104; // eax
    int v105; // esi
    int v106; // ecx
    _DWORD* v107; // eax
    _DWORD* v108; // ebx
    int v109; // eax
    int v110; // esi
    int v111; // eax
    char* v112; // eax
    int v113; // esi
    int v114; // ecx
    _DWORD* v115; // eax
    _DWORD* v116; // ebx
    int v117; // eax
    int v118; // esi
    int v119; // eax
    char* v120; // eax
    int v121; // esi
    int v122; // ecx
    _DWORD* v123; // eax
    _DWORD* v124; // ebx
    int v125; // eax
    int v126; // esi
    int v127; // eax
    char* v128; // eax
    int v129; // esi
    int v130; // ecx
    _DWORD* v131; // eax
    _DWORD* v132; // ebx
    int v133; // eax
    int v134; // esi
    int v135; // eax
    char* v136; // eax
    int v137; // esi
    int v138; // ecx
    _DWORD* v139; // eax
    _DWORD* v140; // ebx
    int v141; // eax
    int v142; // esi
    int v143; // eax
    char* v144; // eax
    int v145; // esi
    int v146; // ecx
    _DWORD* v147; // eax
    _DWORD* v148; // ebx
    int v149; // eax
    int v150; // esi
    int v151; // eax
    char* v152; // eax
    int v153; // esi
    int v154; // ecx
    _DWORD* v155; // eax
    _DWORD* v156; // ebx
    int v157; // eax
    int v158; // esi
    int v159; // eax
    char* v160; // eax
    int v161; // esi
    int v162; // ecx
    const char** v163; // eax
    const char** v164; // ebx
    int v165; // eax
    int v166; // esi
    int v167; // eax
    char* v168; // eax
    int v169; // esi
    int v170; // ecx
    int j; // [esp+10h] [ebp-140h] BYREF
    int i; // [esp+14h] [ebp-13Ch] BYREF
    int v174; // [esp+18h] [ebp-138h] BYREF
    int v175; // [esp+1Ch] [ebp-134h] BYREF
    int v176; // [esp+20h] [ebp-130h] BYREF
    _DWORD v177[72]; // [esp+24h] [ebp-12Ch] BYREF
    int v178; // [esp+14Ch] [ebp-4h]

    if (!*(_DWORD*)(this + 24))
    {
        sub_40A1D0((int)v177, aUiIni);
        v178 = 0;
        for (i = 0; sub_40AAF0(v177, aImage, 0); *(_DWORD*)(*(_DWORD*)(this + 20) + 4 * *(_DWORD*)(this + 24) - 4) = v2)
        {
            sub_40AA40((int)v177, aImage);
            v2 = operator new(0x13Cu);
            v2[74] = 0;
            sub_40AFC0(v177, aName, &i);
            v4 = strlen((const char*)i) + 1;
            v3 = i + v4;
            qmemcpy(v2, (const void*)i, 4 * (v4 >> 2));
            qmemcpy(&v2[v4 >> 2], (const void*)(v3 - v4 + 4 * (v4 >> 2)), v4 & 3);
            *((_BYTE*)v2 + 33) = 0;
            if (sub_40ABC0(v177, aFile, 0))
            {
                sub_40AFC0(v177, aFile, &i);
                v6 = strlen((const char*)i) + 1;
                v5 = i + v6;
                qmemcpy((char*)v2 + 33, (const void*)i, 4 * (v6 >> 2));
                qmemcpy((char*)&v2[(v6 >> 2) + 8] + 1, (const void*)(v5 - v6 + 4 * (v6 >> 2)), v6 & 3);
            }
            v2[76] = 0;
            v2[75] = 0;
            if (sub_40ABC0(v177, aPos, 0))
            {
                sub_40B1F0((const char*)v177, aPos, (float*)&v176, (float*)&j);
                v7 = *(float*)&j;
                v2[75] = (__int64)*(float*)&v176;
                v2[76] = (__int64)v7;
            }
            v2[78] = 0;
            v2[77] = 0;
            if (sub_40ABC0(v177, aSize, 0))
            {
                sub_40B1F0((const char*)v177, aSize, (float*)&v174, (float*)&v175);
                v8 = *(float*)&v175;
                v2[77] = (__int64)*(float*)&v174;
                v2[78] = (__int64)v8;
            }
            else
            {
                sub_4229D0("UI: can't get size for image '%s'", (const char*)v2);
            }
            v9 = *(_DWORD*)(this + 28);
            v10 = *(_DWORD*)(this + 24) + 1;
            *(_DWORD*)(this + 24) = v10;
            if (v10 > v9)
            {
                v11 = *(void**)(this + 20);
                v12 = v9 + 8;
                *(_DWORD*)(this + 28) = v12;
                v13 = (char*)sub_488DD7(v11, 4 * v12);
                if (v13)
                {
                    v14 = *(_DWORD*)(this + 24);
                    v15 = *(_DWORD*)(this + 28) - v14;
                    *(_DWORD*)(this + 20) = v13;
                    memset(&v13[4 * v14], 0, 4 * v15);
                }
            }
        }
        v178 = -1;
        sub_40A830((int)v177);
    }
    v16 = 0;
    for (j = *(int*)(this + 24); v16 < j; ++v16)
    {
        v17 = *(_DWORD*)(*(_DWORD*)(this + 20) + 4 * v16);
        if (*(_DWORD*)(v17 + 296) || !sub_422AE0((LPCSTR)(v17 + 33)))
            sub_4229D0("Can't find texture '%s'", (const char*)(v17 + 33));
        else
            *(_DWORD*)(v17 + 296) = sub_409AF0((_DWORD**)dword_520970, (char*)(v17 + 33), 1);
    }
    *(_DWORD*)(this + 52) = 0;
    v18 = operator new(0x2Cu);
    j = (int)v18;
    v178 = 1;
    if (v18)
        v19 = sub_43A740(v18, this);
    else
        v19 = 0;
    v20 = *(_DWORD*)(this + 44);
    v21 = *(_DWORD*)(this + 40) + 1;
    v178 = -1;
    *(_DWORD*)(this + 40) = v21;
    if (v21 > v20)
    {
        v22 = *(void**)(this + 36);
        v23 = v20 + 8;
        *(_DWORD*)(this + 44) = v23;
        v24 = (char*)sub_488DD7(v22, 4 * v23);
        if (v24)
        {
            v25 = *(_DWORD*)(this + 40);
            v26 = *(_DWORD*)(this + 44) - v25;
            *(_DWORD*)(this + 36) = v24;
            memset(&v24[4 * v25], 0, 4 * v26);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v19;
    sub_428680((_DWORD*)this, (int)v19);
    v27 = operator new(0x58u);
    j = (int)v27;
    v178 = 2;
    if (v27)
        v28 = sub_43A850(v27, this);
    else
        v28 = 0;
    v29 = *(_DWORD*)(this + 44);
    v30 = *(_DWORD*)(this + 40) + 1;
    v178 = -1;
    *(_DWORD*)(this + 40) = v30;
    if (v30 > v29)
    {
        v31 = v29 + 8;
        *(_DWORD*)(this + 44) = v31;
        v32 = (char*)sub_488DD7(*(LPVOID*)(this + 36), 4 * v31);
        if (v32)
        {
            v33 = *(_DWORD*)(this + 40);
            v34 = *(_DWORD*)(this + 44) - v33;
            *(_DWORD*)(this + 36) = v32;
            memset(&v32[4 * v33], 0, 4 * v34);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v28;
    sub_428680((_DWORD*)this, (int)v28);
    v35 = operator new(0x38u);
    j = (int)v35;
    v178 = 3;
    if (v35)
        v36 = sub_43AE80(v35, this);
    else
        v36 = 0;
    v37 = *(_DWORD*)(this + 44);
    v38 = *(_DWORD*)(this + 40) + 1;
    v178 = -1;
    *(_DWORD*)(this + 40) = v38;
    if (v38 > v37)
    {
        v39 = v37 + 8;
        *(_DWORD*)(this + 44) = v39;
        v40 = (char*)sub_488DD7(*(LPVOID*)(this + 36), 4 * v39);
        if (v40)
        {
            v41 = *(_DWORD*)(this + 40);
            v42 = *(_DWORD*)(this + 44) - v41;
            *(_DWORD*)(this + 36) = v40;
            memset(&v40[4 * v41], 0, 4 * v42);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v36;
    sub_428680((_DWORD*)this, (int)v36);
    v43 = operator new(0x40u);
    j = (int)v43;
    v178 = 4;
    if (v43)
        v44 = sub_43B390(v43, this);
    else
        v44 = 0;
    v45 = *(_DWORD*)(this + 44);
    v46 = *(_DWORD*)(this + 40) + 1;
    v178 = -1;
    *(_DWORD*)(this + 40) = v46;
    if (v46 > v45)
    {
        v47 = v45 + 8;
        *(_DWORD*)(this + 44) = v47;
        v48 = (char*)sub_488DD7(*(LPVOID*)(this + 36), 4 * v47);
        if (v48)
        {
            v49 = *(_DWORD*)(this + 40);
            v50 = *(_DWORD*)(this + 44) - v49;
            *(_DWORD*)(this + 36) = v48;
            memset(&v48[4 * v49], 0, 4 * v50);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v44;
    sub_428680((_DWORD*)this, (int)v44);
    v51 = operator new(0x2Cu);
    j = (int)v51;
    v178 = 5;
    if (v51)
        v52 = sub_43B6C0(v51, this);
    else
        v52 = 0;
    v53 = *(_DWORD*)(this + 44);
    v54 = *(_DWORD*)(this + 40) + 1;
    v178 = -1;
    *(_DWORD*)(this + 40) = v54;
    if (v54 > v53)
    {
        v55 = v53 + 8;
        *(_DWORD*)(this + 44) = v55;
        v56 = (char*)sub_488DD7(*(LPVOID*)(this + 36), 4 * v55);
        if (v56)
        {
            v57 = *(_DWORD*)(this + 40);
            v58 = *(_DWORD*)(this + 44) - v57;
            *(_DWORD*)(this + 36) = v56;
            memset(&v56[4 * v57], 0, 4 * v58);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v52;
    sub_428680((_DWORD*)this, (int)v52);
    v59 = operator new(0x2Cu);
    j = (int)v59;
    v178 = 6;
    if (v59)
        v60 = sub_43BA40(v59, this);
    else
        v60 = 0;
    v61 = *(_DWORD*)(this + 44);
    v62 = *(_DWORD*)(this + 40) + 1;
    v178 = -1;
    *(_DWORD*)(this + 40) = v62;
    if (v62 > v61)
    {
        v63 = v61 + 8;
        *(_DWORD*)(this + 44) = v63;
        v64 = (char*)sub_488DD7(*(LPVOID*)(this + 36), 4 * v63);
        if (v64)
        {
            v65 = *(_DWORD*)(this + 40);
            v66 = *(_DWORD*)(this + 44) - v65;
            *(_DWORD*)(this + 36) = v64;
            memset(&v64[4 * v65], 0, 4 * v66);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v60;
    sub_428680((_DWORD*)this, (int)v60);
    v67 = operator new(0x2Cu);
    j = (int)v67;
    v178 = 7;
    if (v67)
        v68 = sub_43BB70(v67, this);
    else
        v68 = 0;
    v69 = *(_DWORD*)(this + 44);
    v70 = *(_DWORD*)(this + 40) + 1;
    v178 = -1;
    *(_DWORD*)(this + 40) = v70;
    if (v70 > v69)
    {
        v71 = v69 + 8;
        *(_DWORD*)(this + 44) = v71;
        v72 = (char*)sub_488DD7(*(LPVOID*)(this + 36), 4 * v71);
        if (v72)
        {
            v73 = *(_DWORD*)(this + 40);
            v74 = *(_DWORD*)(this + 44) - v73;
            *(_DWORD*)(this + 36) = v72;
            memset(&v72[4 * v73], 0, 4 * v74);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v68;
    sub_428680((_DWORD*)this, (int)v68);
    v75 = operator new(0x34u);
    j = (int)v75;
    v178 = 8;
    if (v75)
        v76 = sub_43C730(v75, this);
    else
        v76 = 0;
    v77 = *(_DWORD*)(this + 44);
    v78 = *(_DWORD*)(this + 40) + 1;
    v178 = -1;
    *(_DWORD*)(this + 40) = v78;
    if (v78 > v77)
    {
        v79 = v77 + 8;
        *(_DWORD*)(this + 44) = v79;
        v80 = (char*)sub_488DD7(*(LPVOID*)(this + 36), 4 * v79);
        if (v80)
        {
            v81 = *(_DWORD*)(this + 40);
            v82 = *(_DWORD*)(this + 44) - v81;
            *(_DWORD*)(this + 36) = v80;
            memset(&v80[4 * v81], 0, 4 * v82);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v76;
    sub_428680((_DWORD*)this, (int)v76);
    v83 = operator new(0x2Cu);
    j = (int)v83;
    v178 = 9;
    if (v83)
        v84 = sub_43D040(v83, this);
    else
        v84 = 0;
    v85 = *(_DWORD*)(this + 44);
    v86 = *(_DWORD*)(this + 40) + 1;
    v178 = -1;
    *(_DWORD*)(this + 40) = v86;
    if (v86 > v85)
    {
        v87 = v85 + 8;
        *(_DWORD*)(this + 44) = v87;
        v88 = (char*)sub_488DD7(*(LPVOID*)(this + 36), 4 * v87);
        if (v88)
        {
            v89 = *(_DWORD*)(this + 40);
            v90 = *(_DWORD*)(this + 44) - v89;
            *(_DWORD*)(this + 36) = v88;
            memset(&v88[4 * v89], 0, 4 * v90);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v84;
    sub_428680((_DWORD*)this, (int)v84);
    v91 = operator new(0x50u);
    j = (int)v91;
    v178 = 10;
    if (v91)
        v92 = sub_43C990((int)v91, this);
    else
        v92 = 0;
    v93 = *(_DWORD*)(this + 44);
    v94 = *(_DWORD*)(this + 40) + 1;
    v178 = -1;
    *(_DWORD*)(this + 40) = v94;
    if (v94 > v93)
    {
        v95 = v93 + 8;
        *(_DWORD*)(this + 44) = v95;
        v96 = (char*)sub_488DD7(*(LPVOID*)(this + 36), 4 * v95);
        if (v96)
        {
            v97 = *(_DWORD*)(this + 40);
            v98 = *(_DWORD*)(this + 44) - v97;
            *(_DWORD*)(this + 36) = v96;
            memset(&v96[4 * v97], 0, 4 * v98);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v92;
    sub_428680((_DWORD*)this, v92);
    v99 = operator new(0x2Cu);
    j = (int)v99;
    v178 = 11;
    if (v99)
        v100 = sub_43D0D0(v99, this);
    else
        v100 = 0;
    v101 = *(_DWORD*)(this + 44);
    v102 = *(_DWORD*)(this + 40) + 1;
    v178 = -1;
    *(_DWORD*)(this + 40) = v102;
    if (v102 > v101)
    {
        v103 = v101 + 8;
        *(_DWORD*)(this + 44) = v103;
        v104 = (char*)sub_488DD7(*(LPVOID*)(this + 36), 4 * v103);
        if (v104)
        {
            v105 = *(_DWORD*)(this + 40);
            v106 = *(_DWORD*)(this + 44) - v105;
            *(_DWORD*)(this + 36) = v104;
            memset(&v104[4 * v105], 0, 4 * v106);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v100;
    sub_428680((_DWORD*)this, (int)v100);
    v107 = operator new(0x2Cu);
    j = (int)v107;
    v178 = 12;
    if (v107)
        v108 = sub_43D1D0(v107, this);
    else
        v108 = 0;
    v109 = *(_DWORD*)(this + 44);
    v110 = *(_DWORD*)(this + 40) + 1;
    v178 = -1;
    *(_DWORD*)(this + 40) = v110;
    if (v110 > v109)
    {
        v111 = v109 + 8;
        *(_DWORD*)(this + 44) = v111;
        v112 = (char*)sub_488DD7(*(LPVOID*)(this + 36), 4 * v111);
        if (v112)
        {
            v113 = *(_DWORD*)(this + 40);
            v114 = *(_DWORD*)(this + 44) - v113;
            *(_DWORD*)(this + 36) = v112;
            memset(&v112[4 * v113], 0, 4 * v114);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v108;
    sub_428680((_DWORD*)this, (int)v108);
    v115 = operator new(0x38u);
    j = (int)v115;
    v178 = 13;
    if (v115)
        v116 = sub_43D280(v115, this);
    else
        v116 = 0;
    v117 = *(_DWORD*)(this + 44);
    v118 = *(_DWORD*)(this + 40) + 1;
    v178 = -1;
    *(_DWORD*)(this + 40) = v118;
    if (v118 > v117)
    {
        v119 = v117 + 8;
        *(_DWORD*)(this + 44) = v119;
        v120 = (char*)sub_488DD7(*(LPVOID*)(this + 36), 4 * v119);
        if (v120)
        {
            v121 = *(_DWORD*)(this + 40);
            v122 = *(_DWORD*)(this + 44) - v121;
            *(_DWORD*)(this + 36) = v120;
            memset(&v120[4 * v121], 0, 4 * v122);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v116;
    sub_428680((_DWORD*)this, (int)v116);
    v123 = operator new(0x2Cu);
    j = (int)v123;
    v178 = 14;
    if (v123)
        v124 = sub_43D450(v123, this);
    else
        v124 = 0;
    v125 = *(_DWORD*)(this + 44);
    v126 = *(_DWORD*)(this + 40) + 1;
    v178 = -1;
    *(_DWORD*)(this + 40) = v126;
    if (v126 > v125)
    {
        v127 = v125 + 8;
        *(_DWORD*)(this + 44) = v127;
        v128 = (char*)sub_488DD7(*(LPVOID*)(this + 36), 4 * v127);
        if (v128)
        {
            v129 = *(_DWORD*)(this + 40);
            v130 = *(_DWORD*)(this + 44) - v129;
            *(_DWORD*)(this + 36) = v128;
            memset(&v128[4 * v129], 0, 4 * v130);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v124;
    sub_428680((_DWORD*)this, (int)v124);
    v131 = operator new(0x78u);
    j = (int)v131;
    v178 = 15;
    if (v131)
        v132 = sub_43BDB0(v131, this);
    else
        v132 = 0;
    v133 = *(_DWORD*)(this + 44);
    v134 = *(_DWORD*)(this + 40) + 1;
    v178 = -1;
    *(_DWORD*)(this + 40) = v134;
    if (v134 > v133)
    {
        v135 = v133 + 8;
        *(_DWORD*)(this + 44) = v135;
        v136 = (char*)sub_488DD7(*(LPVOID*)(this + 36), 4 * v135);
        if (v136)
        {
            v137 = *(_DWORD*)(this + 40);
            v138 = *(_DWORD*)(this + 44) - v137;
            *(_DWORD*)(this + 36) = v136;
            memset(&v136[4 * v137], 0, 4 * v138);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v132;
    sub_428680((_DWORD*)this, (int)v132);
    v139 = operator new(0x2Cu);
    j = (int)v139;
    v178 = 16;
    if (v139)
        v140 = sub_43C3D0(v139, this);
    else
        v140 = 0;
    v141 = *(_DWORD*)(this + 44);
    v142 = *(_DWORD*)(this + 40) + 1;
    v178 = -1;
    *(_DWORD*)(this + 40) = v142;
    if (v142 > v141)
    {
        v143 = v141 + 8;
        *(_DWORD*)(this + 44) = v143;
        v144 = (char*)sub_488DD7(*(LPVOID*)(this + 36), 4 * v143);
        if (v144)
        {
            v145 = *(_DWORD*)(this + 40);
            v146 = *(_DWORD*)(this + 44) - v145;
            *(_DWORD*)(this + 36) = v144;
            memset(&v144[4 * v145], 0, 4 * v146);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v140;
    sub_428680((_DWORD*)this, (int)v140);
    v147 = operator new(0x80u);
    j = (int)v147;
    v178 = 17;
    if (v147)
        v148 = sub_43DE90(v147, this);
    else
        v148 = 0;
    v149 = *(_DWORD*)(this + 44);
    v150 = *(_DWORD*)(this + 40) + 1;
    v178 = -1;
    *(_DWORD*)(this + 40) = v150;
    if (v150 > v149)
    {
        v151 = v149 + 8;
        *(_DWORD*)(this + 44) = v151;
        v152 = (char*)sub_488DD7(*(LPVOID*)(this + 36), 4 * v151);
        if (v152)
        {
            v153 = *(_DWORD*)(this + 40);
            v154 = *(_DWORD*)(this + 44) - v153;
            *(_DWORD*)(this + 36) = v152;
            memset(&v152[4 * v153], 0, 4 * v154);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v148;
    sub_428680((_DWORD*)this, (int)v148);
    v155 = operator new(0x30u);
    j = (int)v155;
    v178 = 18;
    if (v155)
        v156 = sub_43D580(v155, this);
    else
        v156 = 0;
    v157 = *(_DWORD*)(this + 44);
    v158 = *(_DWORD*)(this + 40) + 1;
    v178 = -1;
    *(_DWORD*)(this + 40) = v158;
    if (v158 > v157)
    {
        v159 = v157 + 8;
        *(_DWORD*)(this + 44) = v159;
        v160 = (char*)sub_488DD7(*(LPVOID*)(this + 36), 4 * v159);
        if (v160)
        {
            v161 = *(_DWORD*)(this + 40);
            v162 = *(_DWORD*)(this + 44) - v161;
            *(_DWORD*)(this + 36) = v160;
            memset(&v160[4 * v161], 0, 4 * v162);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v156;
    sub_428680((_DWORD*)this, (int)v156);
    v163 = (const char**)operator new(0x74u);
    j = (int)v163;
    v178 = 19;
    if (v163)
        v164 = sub_43D7C0(v163, this);
    else
        v164 = 0;
    v165 = *(_DWORD*)(this + 44);
    v166 = *(_DWORD*)(this + 40) + 1;
    v178 = -1;
    *(_DWORD*)(this + 40) = v166;
    if (v166 > v165)
    {
        v167 = v165 + 8;
        *(_DWORD*)(this + 44) = v167;
        v168 = (char*)sub_488DD7(*(LPVOID*)(this + 36), 4 * v167);
        if (v168)
        {
            v169 = *(_DWORD*)(this + 40);
            v170 = *(_DWORD*)(this + 44) - v169;
            *(_DWORD*)(this + 36) = v168;
            memset(&v168[4 * v169], 0, 4 * v170);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 36) + 4 * *(_DWORD*)(this + 40) - 4) = v164;
    return sub_428680((_DWORD*)this, (int)v164);
}
// 520970: using guessed type int dword_520970;

//----- (00425F60) --------------------------------------------------------
int __thiscall sub_425F60(int this)
{
    int v2; // ebp
    int v3; // ebx
    int v4; // edi
    int* v5; // ecx
    int i; // edi
    void* v7; // eax
    int result; // eax

    v2 = 0;
    v3 = *(_DWORD*)(this + 24);
    if (v3 > 0)
    {
        do
        {
            v4 = *(_DWORD*)(*(_DWORD*)(this + 20) + 4 * v2);
            v5 = *(int**)(v4 + 296);
            if (v5)
            {
                sub_422230(v5);
                *(_DWORD*)(v4 + 296) = 0;
            }
            ++v2;
        } while (v2 < v3);
    }
    if (*(_BYTE*)(this + 32))
    {
        for (i = 0; i < *(_DWORD*)(this + 24); ++i)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 20) + 4 * i));
    }
    memset(*(void**)(this + 20), 0, 4 * *(_DWORD*)(this + 24));
    v7 = *(void**)(this + 20);
    *(_DWORD*)(this + 24) = 0;
    sub_488CEE(v7);
    result = 0;
    *(_DWORD*)(this + 28) = 0;
    *(_DWORD*)(this + 20) = 0;
    return result;
}

//----- (00426000) --------------------------------------------------------
const char* __thiscall sub_426000(_DWORD* this, char* String2)
{
    int v3; // ebp
    int v4; // esi
    const char* v5; // edi

    v3 = this[6];
    v4 = 0;
    if (v3 <= 0)
        return 0;
    while (1)
    {
        v5 = *(const char**)(this[5] + 4 * v4);
        if (!_strcmpi(v5, String2))
            break;
        if (++v4 >= v3)
            return 0;
    }
    return v5;
}

//----- (00426040) --------------------------------------------------------
const char* __thiscall sub_426040(_DWORD* this, char* String2)
{
    _DWORD* v2; // ecx

    v2 = (_DWORD*)this[13];
    if (v2)
        return sub_424350(v2, String2);
    else
        return 0;
}

//----- (00426060) --------------------------------------------------------
char __thiscall sub_426060(int this, int a2, int ArgList)
{
    int v4; // eax
    int v5; // eax
    int v6; // edi
    int v7; // ecx
    int v8; // eax
    int v9; // ebp
    int v10; // edi
    int v11; // eax
    int v12; // eax
    int v13; // ecx

    if (!a2)
        goto LABEL_23;
    v4 = *(_DWORD*)(a2 + 36);
    if (v4 == 6)
    {
        v5 = sub_421B20(*(_DWORD**)(dword_520970 + 132), *(_DWORD*)(a2 + 108));
        v6 = *(_DWORD*)(this + 64) - *(_DWORD*)(a2 + 88);
        v7 = v5 - 2;
        if (v5 == 2)
            v8 = 1;
        else
            v8 = v6 / v7;
        v9 = *(_DWORD*)(a2 + 128);
        if (v9 + v8 >= *(_DWORD*)(a2 + 132) - 1)
        {
            v10 = *(_DWORD*)(a2 + 132) - 1;
        }
        else if (v7)
        {
            v10 = v6 / v7 + v9;
        }
        else
        {
            v10 = v9 + 1;
        }
        LOBYTE(v11) = (*(int(__thiscall**)(_DWORD, int, _DWORD, int))(**(_DWORD**)(this + 52) + 48))(
            *(_DWORD*)(this + 52),
            a2,
            *(_DWORD*)(a2 + 124),
            v10);
        if ((_BYTE)v11)
        {
            *(_DWORD*)(a2 + 124) = v10;
            *(_BYTE*)(a2 + 136) = 1;
            LOBYTE(v11) = (unsigned __int8)sub_4229D0(
                "UI: button %d clicked listbox %s item %d",
                ArgList,
                (const char*)a2,
                v10);
        }
        return v11;
    }
    if (v4 == 3)
    {
        LOBYTE(v11) = (*(int(__thiscall**)(_DWORD, int, int))(**(_DWORD**)(this + 52) + 44))(
            *(_DWORD*)(this + 52),
            a2,
            ArgList);
        if ((_BYTE)v11)
        {
            v11 = *(_DWORD*)(this + 76);
            if (v11 != a2)
            {
                if (v11)
                {
                    v12 = *(_DWORD*)(v11 + 112);
                    if (v12)
                        sub_421280(v12);
                }
                *(_DWORD*)(this + 76) = a2;
                v13 = *(_DWORD*)(a2 + 112);
                if (v13)
                    sub_4211E0(v13, 95);
                LOBYTE(v11) = (unsigned __int8)sub_4229D0("UI: button %d clicked editbox %s", ArgList, (const char*)a2);
            }
            *(_DWORD*)(this + 76) = a2;
        }
    }
    else
    {
    LABEL_23:
        sub_4229D0("UI: button %d clicked %s", ArgList, (const char*)a2);
        LOBYTE(v11) = (*(int(__thiscall**)(_DWORD, int, int))(**(_DWORD**)(this + 52) + 44))(
            *(_DWORD*)(this + 52),
            a2,
            ArgList);
        if ((_BYTE)v11)
        {
            if (a2)
            {
                v11 = *(_DWORD*)(a2 + 36);
                if (v11 == 5 || v11 == 4)
                {
                    LOBYTE(v11) = *(_BYTE*)(a2 + 172);
                    *(_BYTE*)(a2 + 172) = (_BYTE)v11 == 0;
                }
            }
        }
    }
    return v11;
}
// 520970: using guessed type int dword_520970;

//----- (004261C0) --------------------------------------------------------
char __thiscall sub_4261C0(_DWORD* this, char* String2, char a3)
{
    int v4; // ebx
    const char** v5; // edi
    int v7; // eax
    int v8; // eax
    int v9; // eax
    int v10; // [esp+10h] [ebp-4h]

    v4 = 0;
    v10 = this[10];
    if (v10 <= 0)
        return 0;
    while (1)
    {
        v5 = *(const char***)(this[9] + 4 * v4);
        if (!_strcmpi(v5[5], String2))
            break;
        if (++v4 >= v10)
            return 0;
    }
    if (!v5)
        return 0;
    v7 = this[13];
    if (v7)
    {
        sub_4229D0("UI: Deactivating dialog %s", *(const char**)(v7 + 20));
        (*(void(__thiscall**)(_DWORD))(*(_DWORD*)this[13] + 40))(this[13]);
        (*(void(__thiscall**)(_DWORD, _DWORD))(*(_DWORD*)this[13] + 24))(this[13], 0);
    }
    this[13] = v5;
    sub_4229D0("UI: Activating dialog %s", v5[5]);
    (*((void(__thiscall**)(const char**, int)) * v5 + 6))(v5, 1);
    (*((void(__thiscall**)(const char**)) * v5 + 9))(v5);
    this[14] = sub_426040(this, aCursor);
    v8 = this[19];
    if (v8)
    {
        v9 = *(_DWORD*)(v8 + 112);
        if (v9)
            sub_421280(v9);
    }
    this[19] = 0;
    if (!*(_BYTE*)(dword_520970 + 296))
        *(_BYTE*)(dword_520970 + 296) = 1;
    if (sub_450BC0())
    {
        if (!a3)
            *(_BYTE*)(dword_520970 + 20) = 1;
    }
    return 1;
}
// 520970: using guessed type int dword_520970;

//----- (004262D0) --------------------------------------------------------
int __thiscall sub_4262D0(int* this)
{
    int v2; // esi
    int result; // eax

    sub_4229D0(aUiHiding);
    sub_4246F0(this);
    v2 = this[13];
    if (v2)
    {
        this[13] = 0;
        (*(void(__thiscall**)(int))(*(_DWORD*)v2 + 40))(v2);
        (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)v2 + 24))(v2, 0);
        result = dword_520970;
        *(_BYTE*)(dword_520970 + 20) = 0;
    }
    else
    {
        *(_BYTE*)(dword_520970 + 20) = 0;
        result = dword_520970;
    }
    *(_BYTE*)(dword_520970 + 296) = 0;
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (004263C0) --------------------------------------------------------
char __stdcall sub_4263C0(int a1, int a2)
{
    return 1;
}

//----- (004263D0) --------------------------------------------------------
char __stdcall sub_4263D0(int a1, int a2, int a3)
{
    return 1;
}

//----- (004263E0) --------------------------------------------------------
_DWORD* __thiscall sub_4263E0(_DWORD* this, int a2)
{
    int v4; // ebx
    _DWORD* result; // eax
    char v6; // cl
    int v7; // [esp+10h] [ebp+4h]

    *this = a2;
    v4 = 12;
    if ((a2 & 0x10) == 0x10)
    {
        this[1] = 12;
        v4 = 24;
    }
    else
    {
        this[1] = -1;
    }
    if ((a2 & 0x40) == 0x40)
    {
        this[2] = v4;
        v4 += 4;
    }
    else
    {
        this[2] = -1;
    }
    if ((a2 & 0x80) == 0x80)
    {
        this[3] = v4;
        v4 += 4;
    }
    else
    {
        this[3] = -1;
    }
    result = 0;
    this[4] = 0;
    if ((a2 & 0x800) == 0x800)
    {
        this[4] = 8;
    }
    else if ((a2 & 0x700) == 0x700)
    {
        this[4] = 7;
    }
    else if ((a2 & 0x600) == 0x600)
    {
        this[4] = 6;
    }
    else if ((a2 & 0x500) == 0x500)
    {
        this[4] = 5;
    }
    else if ((a2 & 0x400) == 0x400)
    {
        this[4] = 4;
    }
    else if ((a2 & 0x300) == 0x300)
    {
        this[4] = 3;
    }
    else if ((a2 & 0x200) == 0x200)
    {
        this[4] = 2;
    }
    else if ((a2 & 0x100) == 0x100)
    {
        this[4] = 1;
    }
    v7 = 0;
    if ((int)this[4] <= 0)
    {
        this[21] = v4;
    }
    else
    {
        v6 = 16;
        result = this + 13;
        do
        {
            if ((a2 & (2 << v6)) == 2 << v6)
                *result = 4;
            else
                *result = 3 - (1 << v6 != (a2 & (1 << v6)));
            *(result - 8) = v4;
            v6 += 2;
            v4 += 4 * *result++;
            ++v7;
        } while (v7 < this[4]);
        this[21] = v4;
    }
    return result;
}

//----- (00426580) --------------------------------------------------------
int sub_426580()
{
    unknown_libname_1();
    return atexit(unknown_libname_2);
}
// 426590: using guessed type int unknown_libname_1();

//----- (004265C0) --------------------------------------------------------
int sub_4265C0()
{
    unknown_libname_3();
    return atexit(unknown_libname_4);
}
// 4265D0: using guessed type int unknown_libname_3();

//----- (00426600) --------------------------------------------------------
int sub_426600()
{
    unknown_libname_5();
    return atexit(unknown_libname_6);
}
// 426610: using guessed type int unknown_libname_5();

//----- (00426640) --------------------------------------------------------
int sub_426640()
{
    unknown_libname_7();
    return atexit(unknown_libname_8);
}
// 426650: using guessed type int unknown_libname_7();

//----- (00426680) --------------------------------------------------------
int sub_426680()
{
    unknown_libname_9();
    return atexit(unknown_libname_10);
}
// 426690: using guessed type int unknown_libname_9();

//----- (004266C0) --------------------------------------------------------
int sub_4266C0()
{
    unknown_libname_11();
    return atexit(unknown_libname_12);
}
// 4266D0: using guessed type int unknown_libname_11();

//----- (00426700) --------------------------------------------------------
int sub_426700()
{
    unknown_libname_13();
    return atexit(unknown_libname_14);
}
// 426710: using guessed type int unknown_libname_13();

//----- (00426740) --------------------------------------------------------
int sub_426740()
{
    unknown_libname_15();
    return atexit(unknown_libname_16);
}
// 426750: using guessed type int unknown_libname_15();

//----- (00426780) --------------------------------------------------------
int sub_426780()
{
    unknown_libname_17();
    return atexit(unknown_libname_18);
}
// 426790: using guessed type int unknown_libname_17();

//----- (004267C0) --------------------------------------------------------
int sub_4267C0()
{
    unknown_libname_19();
    return atexit(unknown_libname_20);
}
// 4267D0: using guessed type int unknown_libname_19();

//----- (00426800) --------------------------------------------------------
int sub_426800()
{
    unknown_libname_21();
    return atexit(unknown_libname_22);
}
// 426810: using guessed type int unknown_libname_21();

//----- (00426840) --------------------------------------------------------
int sub_426840()
{
    unknown_libname_23();
    return atexit(unknown_libname_24);
}
// 426850: using guessed type int unknown_libname_23();

//----- (00426880) --------------------------------------------------------
int sub_426880()
{
    unknown_libname_25();
    return atexit(unknown_libname_26);
}
// 426890: using guessed type int unknown_libname_25();

//----- (004268C0) --------------------------------------------------------
char sub_4268C0()
{
    struct hostent* v1; // eax
    int v2; // esi
    int v3; // edi
    _DWORD* v4; // eax
    _DWORD* v5; // eax
    int v6; // ebp
    int SystemMetrics; // edi
    int v8; // ebx
    int v9; // edi
    int v10; // eax
    char v11; // [esp+14h] [ebp-2B4h]
    _DWORD v12[3]; // [esp+18h] [ebp-2B0h] BYREF
    int v13; // [esp+24h] [ebp-2A4h]
    char name[260]; // [esp+28h] [ebp-2A0h] BYREF
    WSAData WSAData; // [esp+12Ch] [ebp-19Ch] BYREF
    int v16; // [esp+2C4h] [ebp-4h]

    dword_520A14 = ((int(__stdcall*)(int))Direct3DCreate8)(120);
    if (!dword_520A14)
        sub_4281B0(aDirect3dcreate);
    sub_4229D0(aCreatedD3d8Obj);
    v11 = 0;
    if (dword_52233C >= 2
        && (!_strcmpi(*(const char**)(dword_522340 + 4), aJoin)
            || !_strcmpi(*(const char**)(dword_522340 + 4), aHost)
            || !_strcmpi(*(const char**)(dword_522340 + 4), aSkipvideomode)))
    {
        v11 = 1;
    }
    if (sub_41A360(v11))
    {
        sub_4229D0(aPickedVideoMod);
        if (!sub_422BA0(AppName, aSkiplogo, 0) && sub_422AE0(MultiByteStr))
            sub_4026C0(MultiByteStr);
        strcpy(byte_520A60, aUnknown);
        if (!WSAStartup(1u, &WSAData))
        {
            if (!gethostname(name, 260))
            {
                v1 = gethostbyname(name);
                if (v1)
                    sprintf(
                        byte_520A60,
                        "%d.%d.%d.%d",
                        **(unsigned __int8**)v1->h_addr_list,
                        *((unsigned __int8*)*v1->h_addr_list + 1),
                        *((unsigned __int8*)*v1->h_addr_list + 2),
                        *((unsigned __int8*)*v1->h_addr_list + 3));
            }
            WSACleanup();
        }
        sub_4229D0("Got players ip address (%s)", byte_520A60);
        if ((_BYTE)dword_520A30)
            SetWindowLongA(dword_5209E4, -16, 281018368);
        else
            SetWindowLongA(dword_5209E4, -16, -1879048192);
        if ((*(int(__stdcall**)(int, _DWORD, _DWORD*))(*(_DWORD*)dword_520A14 + 32))(dword_520A14, 0, v12) < 0)
            sub_4281B0(aGetadapterdisp);
        sub_4229D0(aGetadapterdisp_0);
        if ((_BYTE)dword_520A30)
            dword_5209E0 = v13;
        memset(&dword_520980, 0, 0x34u);
        dword_520998 = (int)dword_5209E4;
        dword_52099C = (unsigned __int8)dword_520A30;
        dword_520994 = 1;
        dword_5209A0 = 1;
        dword_520980 = dword_5209F4;
        dword_520984 = dword_5209D8;
        if ((_BYTE)dword_520A30)
        {
            dword_5209A4 = 80;
            dword_520988 = v13;
            dword_5209AC = 0;
            dword_5209B0 = 0;
        }
        else
        {
            dword_5209A4 = dword_5209EC;
            dword_520988 = dword_5209E0;
            dword_5209AC = 0;
            dword_5209B0 = 0;
            if (!byte_520A18)
                dword_5209B0 = 0x80000000;
        }
        v2 = (_BYTE)dword_520A30 != 0 ? 1 : 3;
        while (1)
        {
            dword_52098C = v2;
            v3 = (*(int(__stdcall**)(int, _DWORD, int, HWND, int, int*, char*))(*(_DWORD*)dword_520A14 + 60))(
                dword_520A14,
                0,
                1,
                dword_5209E4,
                32,
                &dword_520980,
                ArgList);
            if (v3 >= 0)
                break;
            if (*(_DWORD*)ArgList)
                (*(void(__stdcall**)(_DWORD))(**(_DWORD**)ArgList + 8))(*(_DWORD*)ArgList);
            sub_4229D0("CreateDevice with %d back buffers failed", v2--);
            if (v2 < 1)
                goto LABEL_36;
        }
        sub_4229D0("CreateDevice with %d back buffers WORKED", v2);
    LABEL_36:
        if (v3 < 0)
        {
            switch (v3)
            {
            case -2005530516:
                sub_4281B0(aCreatedeviceFa);
            case -2005530518:
                sub_4281B0(aCreatedeviceFa_0);
            case -2005532292:
                sub_4281B0(aCreatedeviceFa_1);
            }
            sub_4281B0(aCreatedeviceFa_2);
        }
        (*(void(__stdcall**)(_DWORD, int*))(**(_DWORD**)ArgList + 28))(*(_DWORD*)ArgList, &dword_520898);
        v4 = operator new(0x7Cu);
        v16 = 0;
        if (v4)
            v5 = sub_41BB80(v4);
        else
            v5 = 0;
        dword_520A50 = (int)v5;
        v16 = -1;
        if ((_BYTE)dword_520A30)
        {
            v6 = dword_5209F4 + 2 * GetSystemMetrics(7);
            SystemMetrics = GetSystemMetrics(8);
            v8 = GetSystemMetrics(4) + dword_5209D8 + 2 * SystemMetrics;
            v9 = (GetSystemMetrics(0) - v6) / 2;
            v10 = GetSystemMetrics(1);
            MoveWindow(dword_5209E4, v9, (v10 - v8) / 2, v6, v8, 0);
        }
        SetWindowPos(dword_5209E4, 0, 0, 0, 0, 0, 0x27u);
        (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 7, 1);
        sub_4229D0(aReturningSucce);
        return 1;
    }
    else
    {
        sub_4229D0(aPickvideomodeR);
        return 0;
    }
}
// 426BA5: conditional instruction was optimized away because esi.4 is in (==1|==3)
// 520898: using guessed type int dword_520898;
// 520980: using guessed type int dword_520980;
// 520984: using guessed type int dword_520984;
// 520988: using guessed type int dword_520988;
// 52098C: using guessed type int dword_52098C;
// 520994: using guessed type int dword_520994;
// 520998: using guessed type int dword_520998;
// 52099C: using guessed type int dword_52099C;
// 5209A0: using guessed type int dword_5209A0;
// 5209A4: using guessed type int dword_5209A4;
// 5209AC: using guessed type int dword_5209AC;
// 5209B0: using guessed type int dword_5209B0;
// 5209D8: using guessed type int dword_5209D8;
// 5209E0: using guessed type int dword_5209E0;
// 5209EC: using guessed type int dword_5209EC;
// 5209F4: using guessed type int dword_5209F4;
// 520A14: using guessed type int dword_520A14;
// 520A18: using guessed type char byte_520A18;
// 520A30: using guessed type int dword_520A30;
// 520A50: using guessed type int dword_520A50;
// 52233C: using guessed type int dword_52233C;
// 522340: using guessed type int dword_522340;

//----- (00426D40) --------------------------------------------------------
void sub_426D40()
{
    void* v0; // esi

    sub_4229D0(aCleanup);
    if (dword_520970)
    {
        (*(void(__thiscall**)(int))(*(_DWORD*)dword_520970 + 36))(dword_520970);
        if (dword_520970)
            (**(void(__thiscall***)(int, int))dword_520970)(dword_520970, 1);
        dword_520970 = 0;
    }
    sub_4229D0(aGGameShutdownO);
    sub_41F390();
    sub_4229D0(aSpheredestroyW);
    sub_41F9E0();
    sub_4229D0(aSpritedestroyW);
    v0 = (void*)dword_520A00;
    if (dword_520A00)
    {
        sub_40BFD0(dword_520A00);
        sub_4885A6(v0);
    }
    sub_4229D0(aDeleteInputlay);
    sub_41C680();
    sub_4229D0(aCleanupsoundWo);
    if (*(_DWORD*)ArgList)
        (*(void(__stdcall**)(_DWORD))(**(_DWORD**)ArgList + 8))(*(_DWORD*)ArgList);
    sub_4229D0(aDeviceReleaseW);
    if (dword_520A14)
        (*(void(__stdcall**)(int))(*(_DWORD*)dword_520A14 + 8))(dword_520A14);
    sub_4229D0(aD3dReleaseWork);
    sub_4885A6((LPVOID)dword_520A50);
}
// 40BFD0: using guessed type int __thiscall sub_40BFD0(_DWORD);
// 520970: using guessed type int dword_520970;
// 520A00: using guessed type int dword_520A00;
// 520A14: using guessed type int dword_520A14;
// 520A50: using guessed type int dword_520A50;

//----- (00426E30) --------------------------------------------------------
LRESULT __stdcall sub_426E30(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    int v5; // eax

    if (Msg > 0x102)
    {
        if (Msg != 274)
        {
            if (Msg != 562)
                return DefWindowProcA(hWnd, Msg, wParam, lParam);
            goto LABEL_16;
        }
        v5 = wParam & 0xFFF0;
        if (v5 == 61760)
        {
            return 0;
        }
        else
        {
            if (v5 != 61808)
                return DefWindowProcA(hWnd, Msg, wParam, lParam);
            return 0;
        }
    }
    else
    {
        if (Msg == 258)
        {
            if (byte_5209DC && dword_520970)
                (*(void(__thiscall**)(int, WPARAM))(*(_DWORD*)dword_520970 + 8))(dword_520970, wParam);
            return DefWindowProcA(hWnd, Msg, wParam, lParam);
        }
        if (Msg != 2)
        {
            if (Msg != 5)
            {
                if (Msg != 6)
                    return DefWindowProcA(hWnd, Msg, wParam, lParam);
                if ((_WORD)wParam && !HIWORD(wParam))
                {
                LABEL_8:
                    byte_5209DC = 1;
                    return DefWindowProcA(hWnd, Msg, wParam, lParam);
                }
                goto LABEL_20;
            }
        LABEL_16:
            if (wParam != 4 && wParam != 1)
            {
                sub_4229D0(aGettingRestore);
                GetClientRect(dword_5209E4, &Rect);
                GetWindowRect(dword_5209E4, &stru_5209C8);
                goto LABEL_8;
            }
            sub_4229D0(aGettingMinimiz);
        LABEL_20:
            byte_5209DC = 0;
            return DefWindowProcA(hWnd, Msg, wParam, lParam);
        }
        PostQuitMessage(0);
        return 0;
    }
}
// 520970: using guessed type int dword_520970;
// 5209DC: using guessed type char byte_5209DC;

//----- (00426F50) --------------------------------------------------------
int __cdecl sub_426F50(int a1)
{
    sub_4229D0("Math Error Exception: %s", *(const char**)(a1 + 4));
    sub_428420();
    return 1;
}

//----- (00426F70) --------------------------------------------------------
LONG __stdcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS* ExceptionInfo)
{
    CHAR Filename[260]; // [esp+0h] [ebp-104h] BYREF

    if (!byte_520860)
    {
        byte_520860 = 1;
        if (!GetModuleFileNameA(0, Filename, 0x104u))
            Filename[0] = 0;
        sub_426FE0(ExceptionInfo->ExceptionRecord->ExceptionCode);
        sub_4229D0(aSCausedS0x04x, (char)Filename);
        sub_428420(*(_DWORD*)Filename);
    }
    return 0;
}
// 426FE0: using guessed type _DWORD __cdecl sub_426FE0(_DWORD);
// 428420: using guessed type int __cdecl sub_428420(_DWORD);
// 520860: using guessed type char byte_520860;

//----- (00426FE0) --------------------------------------------------------
char* __cdecl sub_426FE0(int a1)
{
    int v1; // eax
    int* i; // ecx
    int v4; // [esp+0h] [ebp-C0h] BYREF
    _DWORD v5[47]; // [esp+4h] [ebp-BCh]

    v4 = 1073807365;
    v5[0] = aAControlC;
    v5[1] = 1073807368;
    v5[2] = aAControlBreak;
    v5[3] = -2147483646;
    v5[4] = aADatatypeMisal;
    v5[5] = -2147483645;
    v5[6] = aABreakpoint;
    v5[7] = -1073741819;
    v5[8] = aAnAccessViolat;
    v5[9] = -1073741818;
    v5[10] = aAnInPageError;
    v5[11] = -1073741801;
    v5[12] = aANoMemory;
    v5[13] = -1073741795;
    v5[14] = aAnIllegalInstr;
    v5[15] = -1073741787;
    v5[16] = aANoncontinuabl;
    v5[17] = -1073741786;
    v5[18] = aAnInvalidDispo;
    v5[19] = -1073741684;
    v5[20] = aAArrayBoundsEx;
    v5[21] = -1073741683;
    v5[22] = aAFloatDenormal;
    v5[23] = -1073741682;
    v5[24] = aAFloatDivideBy;
    v5[25] = -1073741681;
    v5[26] = aAFloatInexactR;
    v5[27] = -1073741680;
    v5[28] = aAFloatInvalidO;
    v5[29] = -1073741679;
    v5[30] = aAFloatOverflow;
    v5[31] = -1073741678;
    v5[32] = aAFloatStackChe;
    v5[33] = -1073741677;
    v5[34] = aAFloatUnderflo;
    v5[35] = -1073741676;
    v5[36] = aAnIntegerDivid;
    v5[37] = -1073741675;
    v5[38] = aAnIntegerOverf;
    v5[39] = -1073741674;
    v5[40] = aAPrivilegedIns;
    v5[41] = -1073741571;
    v5[42] = aAStackOverflow;
    v5[43] = -1073741502;
    v5[44] = aADllInitializa;
    v5[45] = -529697949;
    v5[46] = aAMicrosoftCExc;
    v1 = 0;
    for (i = &v4; a1 != *i; i += 2)
    {
        if ((unsigned int)++v1 >= 0x18)
            return aUnknownExcepti;
    }
    return (char*)v5[2 * v1];
}

//----- (004271D0) --------------------------------------------------------
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
    int v4; // edi
    int v6; // esi
    INT v7; // eax
    HWND DesktopWindow; // eax
    int v9; // esi
    int v10; // esi
    DWORD Time; // edi
    int v12; // eax
    char v13; // al
    DWORD v14; // esi
    int v15; // eax
    int v16; // esi
    int v17; // edx
    unsigned int v18; // eax
    int* v19; // ecx
    int v20; // edx
    int v21; // esi
    double v22; // [esp+10h] [ebp-1B0h]
    double v23; // [esp+18h] [ebp-1A8h]
    char* v24; // [esp+1Ch] [ebp-1A4h]
    HINSTANCE v25; // [esp+20h] [ebp-1A0h]
    int v26; // [esp+24h] [ebp-19Ch]
    char v27; // [esp+33h] [ebp-18Dh]
    float v28; // [esp+34h] [ebp-18Ch]
    float v29; // [esp+38h] [ebp-188h]
    float v30; // [esp+3Ch] [ebp-184h]
    int v31; // [esp+40h] [ebp-180h] BYREF
    int v32; // [esp+44h] [ebp-17Ch] BYREF
    int v33; // [esp+48h] [ebp-178h] BYREF
    int v34; // [esp+4Ch] [ebp-174h]
    int v35; // [esp+50h] [ebp-170h] BYREF
    int v36; // [esp+54h] [ebp-16Ch]
    unsigned int v37; // [esp+58h] [ebp-168h]
    int v38; // [esp+5Ch] [ebp-164h]
    __int64 v39; // [esp+60h] [ebp-160h]
    WNDCLASSEXA v40; // [esp+68h] [ebp-158h] BYREF
    LPVOID v41[2]; // [esp+98h] [ebp-128h] BYREF
    struct tagMSG Msg; // [esp+A0h] [ebp-120h] BYREF
    char Buffer[260]; // [esp+BCh] [ebp-104h] BYREF

    sub_422F40(aInstallOperati);
    sub_422B60(1, aSoftwareInfogr);
    byte_520A10 = sub_422BA0(AppName, aLoadeverything, 0) != 0;
    if (sub_422BA0(AppName, aRellog, 0))
    {
        if (!sub_422EF0(aLogs))
            return 0;
        v6 = 1;
        do
        {
            v26 = v6++;
            sprintf(Buffer, "Logs\\Operation Blockade Log %04d.log", v26);
        } while (sub_422AE0(Buffer));
        sub_422950(Buffer);
    }
    GetCurrentDirectoryA(0x104u, ::Buffer);
    sub_4229D0("Working Directory: '%s'", ::Buffer);
    SetUnhandledExceptionFilter(TopLevelExceptionFilter);
    if (sub_40EBA0())
        sub_4281B0(aCouldnTInitial);
    sub_4229D0(aMeminitWorked);
    sub_422BA0(AppName, aMemorycheck, 0);
    wParam = sub_422BA0(AppName, aTexturescaledo, 0);
    v7 = sub_422BA0(AppName, aMaxparticles, 256);
    *(_DWORD*)&dword_520A44 = v7;
    if (v7 >= 512)
    {
        *(_DWORD*)&dword_520A44 = 512;
    }
    else if (v7 < 32)
    {
        *(_DWORD*)&dword_520A44 = 32;
    }
    byte_520974 = sub_422BA0(AppName, aAnimatedocean, 1) != 0;
    byte_520884 = sub_422BA0(AppName, aInvertmouse, 0) != 0;
    ::hInstance = hInstance;
    byte_520A70 = sub_422BA0(AppName, aShowcursor, 0) == 0;
    if (CoInitializeEx(0, 0))
        sub_4281B0(aCoinitializeex);
    sub_4229D0(aCoinitializeex_0);
    v40.cbSize = 48;
    v40.style = 64;
    v40.lpfnWndProc = sub_426E30;
    v40.cbClsExtra = 0;
    v40.cbWndExtra = 0;
    v40.hInstance = GetModuleHandleA(0);
    memset(&v40.hCursor, 0, 12);
    v40.lpszClassName = ClassName;
    v40.hIconSm = 0;
    v40.hIcon = LoadIconA(hInstance, (LPCSTR)0x77);
    RegisterClassExA(&v40);
    sub_4229D0(aRegisterclasse);
    v25 = ::hInstance;
    DesktopWindow = GetDesktopWindow();
    dword_5209E4 = CreateWindowExA(0, ClassName, WindowName, 0x90080000, -10, -10, 5, 5, DesktopWindow, 0, v25, 0);
    if (!dword_5209E4)
        sub_4281B0(aCanTCreateWind);
    sub_4229D0(aCreatewindowWo);
    GetClientRect(dword_5209E4, &Rect);
    GetWindowRect(dword_5209E4, &stru_5209C8);
    if (!sub_4268C0() || (v27 = 1, sub_427950(v4, hInstance) < 0))
        v27 = 0;
    sub_4229D0(aInitd3dAndInit);
    if (v27)
    {
        ShowWindow(dword_5209E4, 10);
        UpdateWindow(dword_5209E4);
        sub_427B80();
        v9 = 0;
        memset(&Msg, 0, sizeof(Msg));
        while (Msg.message != 18)
        {
            if (PeekMessageA(&Msg, 0, 0, 0, 1u))
            {
                TranslateMessage(&Msg);
                DispatchMessageA(&Msg);
            }
            else if (!byte_520885)
            {
                if (byte_5209DC && byte_520A70)
                {
                    SetCursorPos((stru_5209C8.left + stru_5209C8.right) / 2, (stru_5209C8.top + stru_5209C8.bottom) / 2);
                    ShowCursor(0);
                }
                v10 = v9 + 1;
                v36 = v10;
                Time = timeGetTime();
                if (dword_5209F0 == 1)
                {
                    v12 = sub_450BF0((_DWORD*)dword_520970, 0, 0);
                    sub_421110(v12, AppName);
                    dword_5209F0 = 2;
                }
                else if (dword_5209F0 == 2)
                {
                    sub_427EB0(*(int**)ArgList);
                    dword_5209F0 = 0;
                }
                if (v10 == 2)
                {
                    v13 = (*(int(__thiscall**)(int, char*))(*(_DWORD*)dword_520970 + 32))(dword_520970, aGameFailedToIn);
                    sub_4282E0(v13, v24);
                }
                if (dword_520A00)
                {
                    sub_40C2B0(dword_520A00, v41);
                    sub_488CEE(v41[1]);
                }
                if (v10 > 1 && dword_520970)
                    (*(void(__thiscall**)(int))(*(_DWORD*)dword_520970 + 40))(dword_520970);
                if (sub_427CB0())
                    sub_427CF0();
                v14 = timeGetTime();
                v15 = dword_520A98;
                v16 = v14 - Time;
                dword_520A9C[dword_520A98] = v16;
                v17 = (v15 + 1) % 10;
                v18 = 0;
                v19 = dword_520A9C;
                dword_520A98 = v17;
                do
                {
                    v20 = *v19++;
                    v18 += v20;
                } while ((int)v19 < (int)dword_520AC4);
                v37 = v18;
                v38 = 0;
                v28 = (double)v18 * 0.1;
                sub_422760(*(_DWORD**)(dword_520970 + 124), &v33, &v31, &v32, &v35);
                v39 = (unsigned int)v16;
                *(float*)dword_520A88 = (double)v32 + *(float*)dword_520A88;
                *(float*)dword_520850 = (double)v33 + *(float*)dword_520850;
                *(float*)dword_5209F8 = (double)v35 + *(float*)dword_5209F8;
                *(float*)dword_520858 = (double)v31 + *(float*)dword_520858;
                *(float*)&v34 = (double)v39 * 0.001;
                v21 = v34;
                sub_423060(&dword_520978, v34);
                sub_423060(&dword_520A58, v21);
                sub_423060(&dword_520A20, v21);
                sub_423060(&dword_520A88, v21);
                sub_423060(&dword_5209F8, v21);
                sub_423060(&dword_520850, v21);
                sub_423060(&dword_520858, v21);
                sub_423060(&dword_520A78, v21);
                sub_423060(dword_520A38, v21);
                sub_423060(&dword_5209C0, v21);
                sub_423060(&dword_520A08, v21);
                sub_423060(&dword_520A28, v21);
                sub_423060(&dword_520890, v21);
                if (dword_52097C <= 0)
                    v29 = 0.0;
                else
                    v29 = *(float*)(dword_520978 + 8);
                if (v28 == 0.0)
                    v30 = 0.0;
                else
                    v30 = 1000.0 / v28;
                v23 = sub_423120(&dword_520978);
                v22 = sub_4230F0(&dword_520978);
                sub_421190(
                    dword_5209B8,
                    "%.1f fps %d polys   (%.1f peak, %.1f kpolys/s avg)\n",
                    v30,
                    (unsigned int)(__int64)v29,
                    v22,
                    v23);
                v9 = v36;
            }
        }
    }
    sub_426D40();
    UnregisterClassA(ClassName, ::hInstance);
    CoUninitialize();
    sub_4229D0(aCouninitialize);
    sub_40EC30();
    sub_4229D0(aMemshutdownWor);
    return 0;
}
// 4274ED: variable 'v4' is possibly undefined
// 42764E: variable 'v24' is possibly undefined
// 520850: using guessed type int dword_520850;
// 520858: using guessed type int dword_520858;
// 520884: using guessed type char byte_520884;
// 520885: using guessed type char byte_520885;
// 520890: using guessed type int dword_520890;
// 520970: using guessed type int dword_520970;
// 520974: using guessed type char byte_520974;
// 520978: using guessed type int dword_520978;
// 52097C: using guessed type int dword_52097C;
// 5209C0: using guessed type int dword_5209C0;
// 5209DC: using guessed type char byte_5209DC;
// 5209F0: using guessed type int dword_5209F0;
// 5209F8: using guessed type int dword_5209F8;
// 520A00: using guessed type int dword_520A00;
// 520A08: using guessed type int dword_520A08;
// 520A10: using guessed type char byte_520A10;
// 520A20: using guessed type int dword_520A20;
// 520A28: using guessed type int dword_520A28;
// 520A38: using guessed type int dword_520A38[3];
// 520A58: using guessed type int dword_520A58;
// 520A70: using guessed type char byte_520A70;
// 520A78: using guessed type int dword_520A78;
// 520A88: using guessed type int dword_520A88;
// 520A98: using guessed type int dword_520A98;
// 520A9C: using guessed type int dword_520A9C[10];
// 520AC4: using guessed type int dword_520AC4[93];

//----- (004278D0) --------------------------------------------------------
int __cdecl sub_4278D0(int a1, int a2, int a3)
{
    if (dword_520970)
        (*(void(__thiscall**)(int, int, int))(*(_DWORD*)dword_520970 + 12))(dword_520970, a2, a3);
    return 0;
}
// 520970: using guessed type int dword_520970;

//----- (004278F0) --------------------------------------------------------
int __cdecl sub_4278F0(int a1, int a2, int a3)
{
    void** v4; // ecx

    if (dword_520970)
        (*(void(__thiscall**)(int, int, int))(*(_DWORD*)dword_520970 + 4))(dword_520970, a2, a3);
    if ((_BYTE)a3 && a2 != 68)
    {
        if (a2 == 67)
        {
            dword_5209F0 = 1;
            return 0;
        }
        if (a2 == 63)
        {
            v4 = (void**)dword_5209B8;
            *(_BYTE*)(dword_5209B8 + 33) = *(_BYTE*)(dword_5209B8 + 33) == 0;
            sub_421540(v4);
        }
    }
    return 0;
}
// 520970: using guessed type int dword_520970;
// 5209F0: using guessed type int dword_5209F0;

//----- (00427950) --------------------------------------------------------
int __usercall sub_427950@<eax>(int a1@<edi>, void* a2@<esi>)
{
    _DWORD* v2; // eax
    _DWORD* v3; // eax
    int v4; // ecx
    int v5; // ecx
    _DWORD* v6; // eax
    _DWORD* v7; // esi
    int v8; // ecx
    char v9; // al
    _BYTE* v10; // eax
    _BYTE* v11; // eax
    void** v12; // ecx
    _BYTE* v13; // eax
    LPVOID v15[2]; // [esp+Ch] [ebp-14h] BYREF
    int v16; // [esp+1Ch] [ebp-4h]

    dword_5209B4 = timeGetTime();
    dword_520A4C = 0;
    dword_520A80 = 0;
    sub_4229D0(aAboutToInitsou);
    sub_41C550(dword_5209E4, (int)hInstance, 0);
    sub_4229D0(aInitsoundWorke);
    v2 = operator new(0x128u);
    v16 = 0;
    if (v2)
        v3 = sub_40BF80(v2);
    else
        v3 = 0;
    v16 = -1;
    dword_520A00 = (int)v3;
    sub_40BFE0((int)v3, v15, (int)hInstance, (int)dword_5209E4, 0);
    sub_488CEE(v15[1]);
    sub_40C630((_DWORD*)dword_520A00, (int)sub_4278F0, 0);
    sub_40C660((_DWORD*)dword_520A00, (int)sub_4278D0, 0);
    sub_4229D0(aInputlayerWork);
    sub_41F2F0(v4, a2);
    sub_4229D0(aSphereinitWork);
    sub_41F8F0(v5, a1);
    sub_4229D0(aSpriteinitWork);
    sub_4229D0(aProfileinitWor);
    v6 = operator new(0x144u);
    v7 = v6;
    v16 = 1;
    if (v6)
    {
        sub_408A50(v6);
        *v7 = &off_4993D0;
        v8 = (int)v7;
    }
    else
    {
        v8 = 0;
    }
    v16 = -1;
    dword_520970 = v8;
    v9 = sub_44F6F0(v8);
    sub_4282E0(v9, aGamePreinitFai);
    sub_4229D0(aGGamePreinitWo);
    v10 = sub_409AD0((int*)dword_520970, 0, 0x800u);
    dword_52087C = (int)v10;
    *((_DWORD*)v10 + 3) = 1112014848;
    *((_DWORD*)v10 + 4) = 1112014848;
    v10[32] = 0;
    *(_DWORD*)(dword_52087C + 20) = 1148796928;
    v11 = sub_409AD0((int*)dword_520970, 1, 0x400u);
    dword_5209B8 = (int)v11;
    *((_DWORD*)v11 + 3) = 0;
    *((_DWORD*)v11 + 4) = 0;
    v11[32] = 0;
    v12 = (void**)dword_5209B8;
    *(_BYTE*)(dword_5209B8 + 33) = 0;
    sub_421540(v12);
    *(_DWORD*)(dword_5209B8 + 20) = 1148796928;
    v13 = sub_409AD0((int*)dword_520970, 1, 0x400u);
    dword_520A04 = (int)v13;
    *((_DWORD*)v13 + 3) = 0;
    *((_DWORD*)v13 + 4) = 0;
    v13[32] = 0;
    *(_DWORD*)(dword_520A04 + 20) = 1148796928;
    (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 9, 2);
    return 0;
}
// 427A35: variable 'v4' is possibly undefined
// 427A47: variable 'v5' is possibly undefined
// 4993D0: using guessed type _UNKNOWN *off_4993D0;
// 52087C: using guessed type int dword_52087C;
// 520970: using guessed type int dword_520970;
// 5209B4: using guessed type int dword_5209B4;
// 520A00: using guessed type int dword_520A00;
// 520A4C: using guessed type int dword_520A4C;
// 520A80: using guessed type int dword_520A80;

//----- (00427B80) --------------------------------------------------------
int sub_427B80()
{
    _DWORD v1[3]; // [esp+14h] [ebp-B8h] BYREF
    _DWORD v2[17]; // [esp+20h] [ebp-ACh] BYREF
    _DWORD v3[26]; // [esp+64h] [ebp-68h] BYREF

    memset(v2, 0, sizeof(v2));
    v2[4] = 1065353216;
    v2[0] = 1065353216;
    v2[5] = 1065353216;
    v2[1] = 1065353216;
    v2[6] = 1065353216;
    v2[2] = 1065353216;
    v2[7] = 1065353216;
    v2[3] = 1065353216;
    (*(void(__stdcall**)(_DWORD, _DWORD*))(**(_DWORD**)ArgList + 168))(*(_DWORD*)ArgList, v2);
    memset(v3, 0, sizeof(v3));
    v1[0] = -1082130432;
    v1[1] = -1082130432;
    v3[0] = 3;
    v3[5] = 1065353216;
    v3[6] = 1065353216;
    v3[7] = 1065353216;
    v3[1] = 1054649352;
    v3[2] = 1058055127;
    v3[3] = 1065353216;
    v1[2] = -1063256064;
    sub_46B970(&v3[16], v1);
    (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD*))(**(_DWORD**)ArgList + 176))(*(_DWORD*)ArgList, 0, v3);
    return (*(int(__stdcall**)(_DWORD, _DWORD, int))(**(_DWORD**)ArgList + 184))(*(_DWORD*)ArgList, 0, 1);
}
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);

//----- (00427CB0) --------------------------------------------------------
char sub_427CB0()
{
    int v0; // eax

    v0 = (*(int(__stdcall**)(_DWORD))(**(_DWORD**)ArgList + 12))(*(_DWORD*)ArgList);
    if (v0 == -2005530520)
        return 0;
    if (v0 == -2005530519)
    {
        (*(void(__stdcall**)(_DWORD, int*))(**(_DWORD**)ArgList + 56))(*(_DWORD*)ArgList, &dword_520980);
        sub_427B80();
    }
    return 1;
}
// 520980: using guessed type int dword_520980;

//----- (00427CF0) --------------------------------------------------------
int sub_427CF0()
{
    void** v0; // ecx
    int v1; // eax
    int v3; // [esp+80h] [ebp-4h]

    sub_41BB90((_DWORD*)dword_520A50);
    v0 = (void**)dword_52087C;
    *(_BYTE*)(dword_52087C + 33) = byte_520A90;
    sub_421540(v0);
    (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 35, 0);
    (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 140, 3);
    (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 48, 0);
    (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 34, dword_4A4DD0);
    (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 139, dword_4A4DD4);
    (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 36, dword_4A4DD8);
    v3 = dword_4A4DDC;
    (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 37, dword_4A4DDC);
    (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD, int, int, int, _DWORD))(**(_DWORD**)ArgList + 144))(
        *(_DWORD*)ArgList,
        0,
        0,
        3,
        dword_4A4DD0,
        1065353216,
        0);
    if ((*(int(__stdcall**)(_DWORD))(**(_DWORD**)ArgList + 136))(*(_DWORD*)ArgList) >= 0)
    {
        (*(void(__stdcall**)(_DWORD, int, int, int))(**(_DWORD**)ArgList + 200))(*(_DWORD*)ArgList, 8, 3, v3);
        if (dword_520970)
            *(float*)dword_520978 = (double)(*(int(__thiscall**)(int))(*(_DWORD*)dword_520970 + 44))(dword_520970)
            + *(float*)dword_520978;
        (*(void(__cdecl**)(_DWORD))(**(_DWORD**)ArgList + 140))(*(_DWORD*)ArgList);
        v1 = (*(int(__stdcall**)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(**(_DWORD**)ArgList + 60))(
            *(_DWORD*)ArgList,
            0,
            0,
            0,
            0);
        switch (v1)
        {
        case -2005530519:
            sub_4229D0(aPresentNotRese);
            if (byte_5209DC)
            {
                (*(void(__stdcall**)(_DWORD, int*))(**(_DWORD**)ArgList + 56))(*(_DWORD*)ArgList, &dword_520980);
                return 0;
            }
            break;
        case -2005530520:
            sub_4229D0(aPresentDeviceL);
            return 0;
        case -2005530516:
            sub_4229D0(aPresentInvalid);
            break;
        }
    }
    return 0;
}
// 4A4DD0: using guessed type int dword_4A4DD0;
// 4A4DD4: using guessed type int dword_4A4DD4;
// 4A4DD8: using guessed type int dword_4A4DD8;
// 4A4DDC: using guessed type int dword_4A4DDC;
// 52087C: using guessed type int dword_52087C;
// 520970: using guessed type int dword_520970;
// 520978: using guessed type int dword_520978;
// 520980: using guessed type int dword_520980;
// 5209DC: using guessed type char byte_5209DC;
// 520A50: using guessed type int dword_520A50;
// 520A90: using guessed type char byte_520A90;

//----- (00427EA0) --------------------------------------------------------
int sub_427EA0()
{
    return 0;
}

//----- (00427EB0) --------------------------------------------------------
bool __cdecl sub_427EB0(int* a1)
{
    bool result; // al
    int v2; // esi
    int v3; // eax
    int v4; // edx
    int v5; // ecx
    _DWORD* v6; // ebp
    _DWORD* v7; // esi
    int v8; // edi
    int v9; // edx
    int* v10; // eax
    int v11; // ecx
    int v12; // edx
    FILE* v13; // eax
    FILE* v14; // esi
    size_t v15; // eax
    int v16; // eax
    int v17; // [esp+54h] [ebp-16Ch] BYREF
    int v18; // [esp+58h] [ebp-168h] BYREF
    int v19; // [esp+5Ch] [ebp-164h] BYREF
    int v20; // [esp+60h] [ebp-160h]
    __int16 v21; // [esp+6Ch] [ebp-154h] BYREF
    size_t v22; // [esp+6Eh] [ebp-152h]
    __int16 v23; // [esp+72h] [ebp-14Eh]
    __int16 v24; // [esp+74h] [ebp-14Ch]
    int v25; // [esp+76h] [ebp-14Ah]
    _DWORD v26[3]; // [esp+7Ch] [ebp-144h] BYREF
    __int16 v27; // [esp+88h] [ebp-138h]
    __int16 v28; // [esp+8Ah] [ebp-136h]
    int v29; // [esp+8Ch] [ebp-134h]
    size_t ElementCount; // [esp+90h] [ebp-130h]
    int v31; // [esp+94h] [ebp-12Ch]
    int v32; // [esp+98h] [ebp-128h]
    int v33; // [esp+9Ch] [ebp-124h]
    int v34; // [esp+A0h] [ebp-120h]
    char v35[4]; // [esp+A4h] [ebp-11Ch] BYREF
    int v36; // [esp+A8h] [ebp-118h]
    int v37[4]; // [esp+ACh] [ebp-114h] BYREF
    char Buffer[260]; // [esp+BCh] [ebp-104h] BYREF

    v17 = 0;
    v18 = 0;
    result = sub_422EF0(aScreens);
    if (result)
    {
        v2 = 1;
        do
        {
            v3 = v2++;
            sprintf(Buffer, "screens\\shot%03d.tga", v3);
        } while (sub_422AE0(Buffer));
        v4 = *a1;
        v37[0] = 0;
        (*(void(__stdcall**)(int*, int*))(v4 + 36))(a1, v37);
        v5 = *a1;
        v20 = 0;
        v19 = 0;
        (*(void(__stdcall**)(int*, int*))(v5 + 24))(a1, &v18);
        if (v18)
        {
            (*(void(__stdcall**)(int, int, int*))(*(_DWORD*)v18 + 32))(v18, v37[0], &v19);
            if (v18)
            {
                (*(void(__stdcall**)(int))(*(_DWORD*)v18 + 8))(v18);
                v18 = 0;
            }
        }
        if ((*(int(__stdcall**)(int*, int, int, int, int*))(*a1 + 108))(a1, v19, v20, 21, &v17) >= 0)
        {
            if ((*(int(__stdcall**)(int*, int))(*a1 + 120))(a1, v17) >= 0)
            {
                v26[1] = v19;
                v26[0] = 40;
                ElementCount = 3 * v20 * v19;
                v26[2] = v20;
                v27 = 1;
                v28 = 24;
                v29 = 0;
                v31 = 0;
                v32 = 0;
                v33 = 0;
                v34 = 0;
                v6 = operator new(ElementCount + 1);
                if (v6)
                {
                    if ((*(int(__stdcall**)(int, char*, _DWORD, int))(*(_DWORD*)v17 + 36))(v17, v35, 0, 16) >= 0)
                    {
                        v7 = v6;
                        v8 = v20 - 1;
                        if (v20 - 1 >= 0)
                        {
                            v9 = v19;
                            do
                            {
                                v10 = (int*)(v36 + 4 * v9 * v8);
                                v11 = 0;
                                if (v9 > 0)
                                {
                                    do
                                    {
                                        v12 = *v10++;
                                        *v7 = v12;
                                        v9 = v19;
                                        v7 = (_DWORD*)((char*)v7 + 3);
                                        ++v11;
                                    } while (v11 < v19);
                                }
                                --v8;
                            } while (v8 >= 0);
                        }
                        (*(void(__stdcall**)(int))(*(_DWORD*)v17 + 40))(v17);
                        if (v17)
                        {
                            (*(void(__stdcall**)(int))(*(_DWORD*)v17 + 8))(v17);
                            v17 = 0;
                        }
                        v21 = 19778;
                        v22 = ElementCount + 54;
                        v24 = 0;
                        v23 = 0;
                        v25 = 54;
                        v13 = fopen(Buffer, aWb);
                        v14 = v13;
                        if (v13)
                        {
                            if (sub_48A21D(&v21, 0xEu, 1u, v13))
                            {
                                if (sub_48A21D(v26, 0x28u, 1u, v14))
                                {
                                    v15 = sub_48A21D(v6, 1u, ElementCount, v14);
                                    if (v15 >= ElementCount)
                                    {
                                        fclose(v14);
                                        sub_4885A6(v6);
                                        v16 = sub_450BF0((_DWORD*)dword_520970, 0, 1082130432);
                                        sub_421190(v16, "'%s' written", Buffer);
                                        return 1;
                                    }
                                    else
                                    {
                                        return 0;
                                    }
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                            else
                            {
                                return 0;
                            }
                        }
                        else
                        {
                            sub_4229D0("Function \"Screenshot\": The file \"%s\" could not be created.", Buffer);
                            return 0;
                        }
                    }
                    else
                    {
                        sub_4229D0(aFunctionScreen_2);
                        return 0;
                    }
                }
                else
                {
                    sub_4229D0(aFunctionScreen_1);
                    return 0;
                }
            }
            else
            {
                sub_4229D0(aFunctionScreen_0);
                return 0;
            }
        }
        else
        {
            sub_4229D0(aFunctionScreen);
            return 0;
        }
    }
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (004281B0) --------------------------------------------------------
void __noreturn sub_4281B0(char* Format, ...)
{
    int v1; // esi
    int v2; // edi
    int SystemMetrics; // eax
    CHAR Text[512]; // [esp+0h] [ebp-200h] BYREF
    va_list va; // [esp+208h] [ebp+8h] BYREF

    va_start(va, Format);
    if (_vsnprintf(Text, 0x1FEu, Format, va) == -1)
        Text[510] = 0;
    strcat(Text, asc_4A1F30);
    sub_4229D0("FatalError failed: '%s'", Text);
    if (dword_5209E4 && !(_BYTE)dword_520A30)
    {
        SetWindowLongA(dword_5209E4, -16, 281018368);
        SetWindowPos(dword_5209E4, 0, 0, 0, 0, 0, 0x27u);
        v1 = GetSystemMetrics(4) + 100;
        v2 = (GetSystemMetrics(0) - 100) / 2;
        SystemMetrics = GetSystemMetrics(1);
        SetWindowPos(dword_5209E4, 0, v2, (SystemMetrics - v1) / 2, 100, v1, 0x24u);
    }
    ShowCursor(1);
    MessageBoxA(0, Text, aOperationBlock_0, 0x10u);
    if (dword_5209E4)
        SendMessageA(dword_5209E4, 0x10u, 0, 0);
    exit(1);
}
// 520A30: using guessed type int dword_520A30;

//----- (004282E0) --------------------------------------------------------
char sub_4282E0(char a1, char* Format, ...)
{
    char result; // al
    int v3; // esi
    int v4; // edi
    int SystemMetrics; // eax
    CHAR Text[512]; // [esp+0h] [ebp-200h] BYREF
    va_list va; // [esp+20Ch] [ebp+Ch] BYREF

    va_start(va, Format);
    result = a1;
    if (!a1)
    {
        if (_vsnprintf(Text, 0x1FEu, Format, va) == -1)
            Text[510] = 0;
        strcat(Text, asc_4A1F30);
        sub_4229D0("FatalCondition failed: '%s'", Text);
        if (dword_5209E4 && !(_BYTE)dword_520A30)
        {
            SetWindowLongA(dword_5209E4, -16, 281018368);
            SetWindowPos(dword_5209E4, 0, 0, 0, 0, 0, 0x27u);
            v3 = GetSystemMetrics(4) + 100;
            v4 = (GetSystemMetrics(0) - 100) / 2;
            SystemMetrics = GetSystemMetrics(1);
            SetWindowPos(dword_5209E4, 0, v4, (SystemMetrics - v3) / 2, 100, v3, 0x24u);
        }
        ShowCursor(1);
        MessageBoxA(0, Text, aOperationBlock_0, 0x10u);
        if (dword_5209E4)
            SendMessageA(dword_5209E4, 0x10u, 0, 0);
        exit(1);
    }
    return result;
}
// 520A30: using guessed type int dword_520A30;

//----- (00428420) --------------------------------------------------------
void sub_428420()
{
    int v0; // eax
    int v1; // eax
    int v2; // eax
    int v3; // eax
    int* v4; // [esp+0h] [ebp-460h] BYREF
    int** v5; // [esp+4h] [ebp-45Ch] BYREF
    CHAR Filename[500]; // [esp+8h] [ebp-458h] BYREF
    char Buffer[600]; // [esp+1FCh] [ebp-264h] BYREF
    int v8; // [esp+45Ch] [ebp-4h]

    sub_429090(Filename, 500);
    sub_428860(&v4, Filename);
    v8 = 0;
    v0 = sub_428F20((int*)&v4) - 1;
    if (v0)
    {
        v1 = v0 - 1;
        if (v1)
        {
            if (v1 == 1)
            {
                v2 = sub_428F60((int*)&v4);
                sprintf(Buffer, "Parse error in map file %s(%i)\n", Filename, v2);
            }
        }
        else
        {
            v3 = sub_428F60((int*)&v4);
            sprintf(Buffer, "Error while reading map file %s(%i)\n", Filename, v3);
        }
    }
    else
    {
        sprintf(Buffer, "Failed to open map file %s\n", Filename);
    }
    if (!sub_428F20((int*)&v4))
    {
        v5 = &v4;
        sub_429B40((void**)&v5, 1, 1, 16, Buffer, 600);
    }
    sub_4229D0("Stack Trace:\n%s", Buffer);
    v8 = -1;
    sub_428E30((int*)&v4);
}

//----- (00428580) --------------------------------------------------------
void __thiscall sub_428580(void* this)
{
    *(_DWORD*)this = &off_4993D0;
    sub_408B70(this);
}
// 4993D0: using guessed type _UNKNOWN *off_4993D0;

//----- (00428590) --------------------------------------------------------
char __thiscall sub_428590(_DWORD* this, int a2, int a3)
{
    int i; // esi
    char result; // al

    for (i = this[3]; i; i = *(_DWORD*)(i + 8))
    {
        result = *(_BYTE*)(i + 16);
        if (result)
            result = (*(int(__thiscall**)(int, int, int))(*(_DWORD*)i + 4))(i, a2, a3);
    }
    return result;
}

//----- (004285C0) --------------------------------------------------------
char __thiscall sub_4285C0(_DWORD* this, int a2)
{
    int i; // esi
    char result; // al

    for (i = this[3]; i; i = *(_DWORD*)(i + 8))
    {
        result = *(_BYTE*)(i + 16);
        if (result)
            result = (*(int(__thiscall**)(int, int))(*(_DWORD*)i + 8))(i, a2);
    }
    return result;
}

//----- (004285F0) --------------------------------------------------------
char __thiscall sub_4285F0(_DWORD* this, int a2, int a3)
{
    int i; // esi
    char result; // al

    for (i = this[3]; i; i = *(_DWORD*)(i + 8))
    {
        result = *(_BYTE*)(i + 16);
        if (result)
            result = (*(int(__thiscall**)(int, int, int))(*(_DWORD*)i + 12))(i, a2, a3);
    }
    return result;
}

//----- (00428620) --------------------------------------------------------
char __thiscall sub_428620(_DWORD* this, int a2)
{
    int i; // esi
    char result; // al

    for (i = this[3]; i; i = *(_DWORD*)(i + 8))
    {
        result = *(_BYTE*)(i + 16);
        if (result)
            result = (*(int(__thiscall**)(int, int))(*(_DWORD*)i + 16))(i, a2);
    }
    return result;
}

//----- (00428650) --------------------------------------------------------
char __thiscall sub_428650(int this)
{
    char result; // al
    int i; // ecx

    result = *(_BYTE*)(this + 16);
    for (i = *(_DWORD*)(this + 4); result; i = *(_DWORD*)(i + 4))
    {
        if (!i)
            break;
        result = *(_BYTE*)(i + 16) != 0;
    }
    return result;
}
// 428660: conditional instruction was optimized away because al.1!=0

//----- (00428680) --------------------------------------------------------
int __thiscall sub_428680(_DWORD* this, int a2)
{
    int v2; // edx
    int i; // eax
    int result; // eax

    v2 = this[3];
    if (v2)
    {
        for (i = *(_DWORD*)(v2 + 8); i; i = *(_DWORD*)(i + 8))
            v2 = i;
        result = a2;
        *(_DWORD*)(v2 + 8) = a2;
        *(_DWORD*)(a2 + 8) = 0;
        *(_DWORD*)(a2 + 4) = this;
    }
    else
    {
        result = a2;
        this[3] = a2;
        *(_DWORD*)(a2 + 8) = 0;
        *(_DWORD*)(a2 + 4) = this;
    }
    return result;
}

//----- (004286C0) --------------------------------------------------------
int __thiscall sub_4286C0(_DWORD* this, int a2)
{
    int result; // eax
    int v3; // edx

    result = this[3];
    v3 = 0;
    if (result)
    {
        while (result != a2)
        {
            v3 = result;
            result = *(_DWORD*)(result + 8);
            if (!result)
            {
                *(_DWORD*)(a2 + 4) = 0;
                return result;
            }
        }
        if (v3)
        {
            *(_DWORD*)(v3 + 8) = *(_DWORD*)(result + 8);
        }
        else
        {
            result = *(_DWORD*)(result + 8);
            this[3] = result;
        }
        *(_DWORD*)(a2 + 4) = 0;
    }
    else
    {
        *(_DWORD*)(a2 + 4) = 0;
    }
    return result;
}
// 4286E8: conditional instruction was optimized away because eax.4!=0

//----- (00428720) --------------------------------------------------------
void __thiscall sub_428720(_DWORD* this)
{
    int v2; // esi
    int i; // edi
    int j; // eax

    v2 = this[3];
    for (i = 0; v2; v2 = this[3])
    {
        for (j = *(_DWORD*)(v2 + 8); j; j = *(_DWORD*)(j + 8))
        {
            i = v2;
            v2 = j;
        }
        if (i)
            *(_DWORD*)(i + 8) = 0;
        if (v2 == this[3])
            this[3] = 0;
        sub_428720(v2);
        (**(void(__thiscall***)(int, int))v2)(v2, 1);
    }
}
// 42875B: conditional instruction was optimized away because esi.4!=0

//----- (00428780) --------------------------------------------------------
int __cdecl sub_428780(LPWSTR lpWideCharStr, LPCCH lpMultiByteStr, unsigned int a3)
{
    unsigned int v3; // esi
    int result; // eax

    if (lpWideCharStr && lpMultiByteStr)
    {
        v3 = a3;
        if (a3 == -1)
            v3 = strlen(lpMultiByteStr) + 1;
        result = MultiByteToWideChar(0, 0, lpMultiByteStr, -1, lpWideCharStr, v3 - 1);
        lpWideCharStr[v3 - 1] = 0;
    }
    return result;
}

//----- (004287D0) --------------------------------------------------------
void __cdecl sub_4287D0(LPSTR lpMultiByteStr, wchar_t* String, size_t a3)
{
    size_t v3; // esi

    if (lpMultiByteStr && String)
    {
        v3 = a3;
        if (a3 == -1)
            v3 = wcslen(String) + 1;
        WideCharToMultiByte(0, 0, String, -1, lpMultiByteStr, v3 - 1, 0, 0);
        lpMultiByteStr[v3 - 1] = 0;
    }
}

//----- (00428820) --------------------------------------------------------
LPCCH __cdecl sub_428820(LPWSTR lpWideCharStr, LPCCH lpMultiByteStr, unsigned int a3)
{
    LPCCH result; // eax

    if (lpWideCharStr)
    {
        result = lpMultiByteStr;
        if (lpMultiByteStr)
            return (LPCCH)sub_428780(lpWideCharStr, lpMultiByteStr, a3);
    }
    return result;
}

//----- (00428840) --------------------------------------------------------
void __cdecl sub_428840(LPSTR lpMultiByteStr, wchar_t* String, size_t a3)
{
    if (lpMultiByteStr)
    {
        if (String)
            sub_4287D0(lpMultiByteStr, String, a3);
    }
}

//----- (00428860) --------------------------------------------------------
int** __thiscall sub_428860(int** this, char* FileName)
{
    int** v2; // ebx
    int* v3; // eax
    int* v4; // esi
    int v5; // ebp
    int v6; // ebx
    void* v7; // eax
    int v8; // ebx
    char* v9; // ebp
    char* v10; // eax
    char* v11; // eax
    void* v13; // eax
    int v15; // [esp+Ch] [ebp-838h]
    int v16; // [esp+Ch] [ebp-838h]
    char Str[256]; // [esp+18h] [ebp-82Ch] BYREF
    char Source[256]; // [esp+118h] [ebp-72Ch] BYREF
    char v20[1024]; // [esp+218h] [ebp-62Ch] BYREF
    char v21[272]; // [esp+618h] [ebp-22Ch] BYREF
    char v22[272]; // [esp+728h] [ebp-11Ch] BYREF
    int v23; // [esp+840h] [ebp-4h]

    v2 = this;
    v3 = (int*)operator new(0x128u);
    v4 = v3;
    v23 = 0;
    if (v3)
    {
        *v3 = 0;
        v3[65] = 0;
        v3[66] = 0;
        v3[67] = 0;
        v3[68] = 0;
        v3[69] = 0;
        v3[70] = 0;
        sub_429DE0(v3 + 71, FileName);
        LOBYTE(v23) = 3;
        v4[72] = 0;
        sub_429E70(v4 + 71, (_BYTE*)v4 + 4, 256);
        if (sub_429E70(v4 + 71, v20, 1024))
        {
            do
            {
                if (!strcmp(aPreferred, v20))
                {
                    sub_428D50(v4, aLoad);
                    sub_428D50(v4, aAddress);
                    sub_428D50(v4, aIs);
                    *v4 = sub_42A0E0(v4 + 71);
                }
                else if (!strcmp(aStart, v20))
                {
                    sub_428D50(v4, aLength);
                    sub_428D50(v4, aName);
                    sub_428D50(v4, aClass);
                    sub_42A400(v4 + 71);
                    if (!sub_428C90(v4))
                    {
                        do
                        {
                            v5 = sub_42A0E0(v4 + 71);
                            sub_428DE0(v4, 58);
                            v6 = sub_42A0E0(v4 + 71);
                            v15 = sub_42A0E0(v4 + 71);
                            sub_428DE0(v4, 72);
                            sub_429E70(v4 + 71, Source, 256);
                            v7 = sub_429A90(v21, v5, v6, v15, Source);
                            sub_4291F0(v4 + 65, v7);
                        } while (!sub_428CD0(v4) && !sub_428C90(v4));
                    }
                }
                else if (!strcmp(aAddress_0, v20))
                {
                    sub_428D50(v4, aPublics);
                    sub_428D50(v4, aBy);
                    sub_428D50(v4, aValue);
                    sub_428D50(v4, aRvaBase);
                    sub_428D50(v4, aLibObject);
                    sub_42A400(v4 + 71);
                    if (!sub_428C90(v4))
                    {
                        do
                        {
                            v8 = sub_42A0E0(v4 + 71);
                            sub_428DE0(v4, 58);
                            v16 = sub_42A0E0(v4 + 71);
                            sub_429E70(v4 + 71, Str, 256);
                            v9 = Str;
                            v10 = strstr(Str, SubStr);
                            if (v10)
                                *v10 = 0;
                            while (isdigit(*v9) || *v9 == 63 || *v9 == 36)
                                ++v9;
                            v11 = v9;
                            if (*v9)
                            {
                                do
                                {
                                    if (*v11 == 64)
                                        *v11 = 46;
                                } while (*++v11);
                            }
                            v13 = sub_429A90(v22, v8, v16, 0, v9);
                            sub_4291F0(v4 + 68, v13);
                        } while (!sub_428CD0(v4) && !sub_428C90(v4));
                    }
                }
                else
                {
                    sub_42A070(v4 + 71);
                }
            } while (sub_429E70(v4 + 71, v20, 1024));
            v2 = this;
        }
        sub_429310((char*)v4[65], (char*)(v4[65] + 272 * v4[66]));
        sub_429310((char*)v4[68], (char*)(v4[68] + 272 * v4[69]));
        *v2 = v4;
        return v2;
    }
    else
    {
        *v2 = 0;
        return v2;
    }
}

//----- (00428C90) --------------------------------------------------------
int __thiscall sub_428C90(_DWORD* this)
{
    int result; // eax
    int v2; // eax
    int v3; // eax

    result = this[72];
    if (!result)
    {
        v2 = sub_428EB0(this + 71) - 1;
        if (v2)
        {
            v3 = v2 - 1;
            if (v3)
            {
                if (v3 == 1)
                    return 3;
                else
                    return 0;
            }
            else
            {
                return 2;
            }
        }
        else
        {
            return 1;
        }
    }
    return result;
}

//----- (00428CD0) --------------------------------------------------------
bool __thiscall sub_428CD0(_DWORD* this)
{
    _DWORD* v1; // esi
    char v3; // [esp+7h] [ebp-1h] BYREF

    v1 = this + 71;
    sub_42A070(this + 71);
    while (sub_42A560(v1, &v3))
    {
        if (!isspace(v3))
            break;
        if (v3 == 10)
            break;
        sub_42A4F0(v1, &v3);
    }
    return sub_42A560(v1, &v3) && v3 == 10;
}

//----- (00428D50) --------------------------------------------------------
int __thiscall sub_428D50(_DWORD* this, const char* a2)
{
    void* v3; // ebp
    int result; // eax
    char v5[256]; // [esp+10h] [ebp-100h] BYREF

    v3 = this + 71;
    sub_429E70(this + 71, v5, 256);
    result = strcmp(a2, v5);
    if (result)
    {
        this[72] = 3;
        result = sub_42A5C0(v3);
        this[73] = result;
    }
    return result;
}

//----- (00428DE0) --------------------------------------------------------
char __thiscall sub_428DE0(_DWORD* this, char a2)
{
    void* v3; // edi
    int v4; // eax
    char v6; // [esp+Bh] [ebp-1h] BYREF

    v3 = this + 71;
    if (!sub_42A4F0(this + 71, &v6) || (LOBYTE(v4) = a2, v6 != a2))
    {
        this[72] = 3;
        v4 = sub_42A5C0(v3);
        this[73] = v4;
    }
    return v4;
}

//----- (00428E30) --------------------------------------------------------
void __thiscall sub_428E30(int* this)
{
    void* v1; // esi

    v1 = (void*)*this;
    if (*this)
    {
        sub_428E50(*this);
        sub_4885A6(v1);
    }
}

//----- (00428E50) --------------------------------------------------------
void __thiscall sub_428E50(int this)
{
    sub_429E40((FILE***)(this + 284));
    sub_4885A6(*(LPVOID*)(this + 272));
    sub_4885A6(*(LPVOID*)(this + 260));
}

//----- (00428EB0) --------------------------------------------------------
int __thiscall sub_428EB0(void* this)
{
    return **(_DWORD**)this;
}

//----- (00428EC0) --------------------------------------------------------
int __thiscall sub_428EC0(void* this, int a2)
{
    return 272 * a2 + *(_DWORD*)(*(_DWORD*)this + 260);
}

//----- (00428EE0) --------------------------------------------------------
int __thiscall sub_428EE0(void* this, int a2)
{
    return 272 * a2 + *(_DWORD*)(*(_DWORD*)this + 272);
}

//----- (00428F00) --------------------------------------------------------
int __thiscall sub_428F00(void* this)
{
    return *(_DWORD*)(*(_DWORD*)this + 264);
}

//----- (00428F10) --------------------------------------------------------
int __thiscall sub_428F10(void* this)
{
    return *(_DWORD*)(*(_DWORD*)this + 276);
}

//----- (00428F20) --------------------------------------------------------
int __thiscall sub_428F20(int* this)
{
    int v1; // ecx
    int result; // eax
    int v3; // eax
    int v4; // eax

    v1 = *this;
    result = *(_DWORD*)(v1 + 288);
    if (!result)
    {
        v3 = sub_428EB0((void*)(v1 + 284)) - 1;
        if (v3)
        {
            v4 = v3 - 1;
            if (v4)
            {
                if (v4 == 1)
                    return 3;
                else
                    return 0;
            }
            else
            {
                return 2;
            }
        }
        else
        {
            return 1;
        }
    }
    return result;
}

//----- (00428F60) --------------------------------------------------------
int __thiscall sub_428F60(int* this)
{
    int v1; // eax

    v1 = *this;
    if (*(_DWORD*)(*this + 288))
        return *(_DWORD*)(v1 + 292);
    else
        return sub_42A5C0((void*)(v1 + 284));
}

//----- (00428F80) --------------------------------------------------------
int __thiscall sub_428F80(void* this, int a2)
{
    int v2; // ebp
    _DWORD* v4; // edi
    int v5; // esi
    int v6; // esi
    int v7; // esi
    int v8; // eax
    int v9; // ebp
    int v10; // esi
    int v11; // esi
    int v13; // [esp+10h] [ebp-118h]
    int v14; // [esp+14h] [ebp-114h]
    _DWORD v15[68]; // [esp+18h] [ebp-110h] BYREF

    v2 = 0;
    v13 = 0;
    if (sub_428F00(this) <= 0)
        return -1;
    while (1)
    {
        v4 = (_DWORD*)sub_428EC0(this, v2);
        v14 = sub_429AD0(v4);
        v5 = sub_429AD0(v4) << 12;
        v6 = sub_429AE0(v4) + v5;
        v7 = sub_428EB0(this) + v6;
        v8 = v7 + sub_429AF0(v4);
        if (a2 < v7 || a2 >= v8)
            goto LABEL_9;
        v9 = sub_428F10(this) - 1;
        if (v9 >= 0)
            break;
    LABEL_8:
        v2 = v13;
    LABEL_9:
        v13 = ++v2;
        if (v2 >= sub_428F00(this))
            return -1;
    }
    while (1)
    {
        qmemcpy(v15, (const void*)sub_428EE0(this, v9), sizeof(v15));
        if (sub_429AD0(v15) == v14)
        {
            v10 = sub_429AD0(v15) << 12;
            v11 = sub_428EB0(this) + v10;
            if (sub_429AE0(v15) + v11 <= a2)
                return v9;
        }
        if (--v9 < 0)
            goto LABEL_8;
    }
}

//----- (00429090) --------------------------------------------------------
int __cdecl sub_429090(LPSTR lpFilename, int a2)
{
    HMODULE ModuleHandleA; // eax
    signed int ModuleFileNameA; // eax
    CHAR* v4; // edi
    int result; // eax

    *lpFilename = 0;
    ModuleHandleA = GetModuleHandleA(0);
    ModuleFileNameA = GetModuleFileNameA(ModuleHandleA, lpFilename, a2 - 1);
    lpFilename[ModuleFileNameA] = 0;
    if (ModuleFileNameA > 3)
    {
        v4 = &lpFilename[ModuleFileNameA - 4];
        if (!strcmp(v4, aExe) || !strcmp(v4, aExe_0) || !strcmp(v4, aDll) || !strcmp(v4, aDll_0))
            *v4 = 0;
    }
    result = 0;
    if ((int)(strlen(lpFilename) + 4) < a2)
        strcat(lpFilename, aMap);
    return result;
}

//----- (004291F0) --------------------------------------------------------
int __thiscall sub_4291F0(_DWORD* this, const void* a2)
{
    int v3; // eax
    int result; // eax

    v3 = this[1] + 1;
    if (v3 > this[2])
        sub_429240((int)this, v3);
    qmemcpy((void*)(*this + 272 * this[1]), a2, 0x110u);
    result = this[1] + 1;
    this[1] = result;
    return result;
}

//----- (00429240) --------------------------------------------------------
void __thiscall sub_429240(int this, int a2)
{
    int v2; // esi
    Concurrency::details::TaskStack* v4; // eax
    Concurrency::details::TaskStack* v5; // ebp
    int v6; // esi
    Concurrency::details::TaskStack* v7; // edi
    int v8; // esi
    int v9; // edx
    int v10; // eax

    v2 = a2 + 1;
    if (a2 + 1 >= 8)
    {
        if (v2 < 2 * *(_DWORD*)(this + 8))
            v2 = 2 * *(_DWORD*)(this + 8);
    }
    else
    {
        v2 = 8;
    }
    *(_DWORD*)(this + 8) = v2;
    v4 = (Concurrency::details::TaskStack*)operator new(272 * v2);
    v5 = v4;
    if (v4)
    {
        v6 = v2 - 1;
        v7 = v4;
        if (v6 >= 0)
        {
            v8 = v6 + 1;
            do
            {
                Concurrency::details::TaskStack::TaskStack(v7);
                v7 = (Concurrency::details::TaskStack*)((char*)v7 + 272);
                --v8;
            } while (v8);
        }
    }
    else
    {
        v5 = 0;
    }
    v9 = 0;
    if (*(int*)(this + 4) > 0)
    {
        v10 = 0;
        do
        {
            ++v9;
            qmemcpy((char*)v5 + v10, (const void*)(*(_DWORD*)this + v10), 0x110u);
            v10 += 272;
        } while (v9 < *(_DWORD*)(this + 4));
    }
    sub_4885A6(*(LPVOID*)this);
    *(_DWORD*)this = v5;
}

//----- (00429310) --------------------------------------------------------
unsigned int __cdecl sub_429310(char* a1, char* a2)
{
    unsigned int result; // eax
    char* v3; // ebx
    void* v4; // edi
    char* j; // ebx
    char* i; // eax
    char* v7; // eax
    char* v8; // ebx
    unsigned int v9; // eax
    _DWORD* v10; // esi
    char* v11; // ebp
    char* v12; // edi
    char* v13; // edi
    char* v14; // esi
    char* v15; // esi
    char* v16; // ebx
    void* v17; // edi
    char* m; // ebx
    char* k; // eax
    char* v20; // ebp
    char* v21; // ebx
    void* ii; // edi
    char* v23; // [esp+10h] [ebp-668h]
    char* v24; // [esp+10h] [ebp-668h]
    char* v25; // [esp+10h] [ebp-668h]
    char* n; // [esp+10h] [ebp-668h]
    char* v27; // [esp+14h] [ebp-664h]
    char* v28; // [esp+14h] [ebp-664h]
    char* v29; // [esp+14h] [ebp-664h]
    _DWORD v30[68]; // [esp+18h] [ebp-660h] BYREF
    _DWORD v31[68]; // [esp+128h] [ebp-550h] BYREF
    _DWORD v32[68]; // [esp+238h] [ebp-440h] BYREF
    _DWORD v33[68]; // [esp+348h] [ebp-330h] BYREF
    _BYTE v34[272]; // [esp+458h] [ebp-220h] BYREF
    _BYTE v35[272]; // [esp+568h] [ebp-110h] BYREF

    result = (unsigned int)((unsigned __int64)(2021161081LL * (a2 - a1)) >> 32) >> 31;
    if ((a2 - a1) / 272 <= 16)
    {
        if (a1 != a2)
        {
            v3 = a1 + 272;
            v23 = a1 + 272;
            if (a1 + 272 != a2)
            {
                v27 = a1;
                do
                {
                    qmemcpy(v31, v3, sizeof(v31));
                    if (sub_429B10(v31, a1))
                    {
                        for (i = v3; i != a1; qmemcpy(i + 272, i, 0x110u))
                            i -= 272;
                        qmemcpy(a1, v31, 0x110u);
                    }
                    else
                    {
                        qmemcpy(v30, v31, sizeof(v30));
                        v4 = v3;
                        for (j = v27; sub_429B10(v30, j); j -= 272)
                        {
                            qmemcpy(v4, j, 0x110u);
                            v4 = j;
                        }
                        v3 = v23;
                        qmemcpy(v4, v30, 0x110u);
                    }
                    result = (unsigned int)a2;
                    v3 += 272;
                    v23 = v3;
                    v27 += 272;
                } while (v3 != a2);
            }
        }
        return result;
    }
    v7 = a2;
    v8 = a1;
    v28 = a2;
    v24 = a1;
    while (1)
    {
        qmemcpy(v32, v7 - 272, sizeof(v32));
        v9 = (int)((unsigned __int64)(2021161081LL * (v7 - v8)) >> 32) >> 7;
        qmemcpy(v31, &v8[272 * ((int)((v9 >> 31) + v9) / 2)], sizeof(v31));
        qmemcpy(v33, v8, sizeof(v33));
        if (sub_429B10(v33, v31))
        {
            if (sub_429B10(v31, v32))
                goto LABEL_23;
            v10 = v32;
            if (!sub_429B10(v33, v32))
                v10 = v33;
        }
        else if (sub_429B10(v33, v32))
        {
            v10 = v33;
        }
        else
        {
            v10 = v32;
            if (!sub_429B10(v31, v32))
                LABEL_23:
            v10 = v31;
        }
        v11 = v28;
        qmemcpy(v34, v10, sizeof(v34));
        qmemcpy(v30, v34, sizeof(v30));
        while (1)
        {
            for (; sub_429B10(v8, v30); v8 += 272)
                ;
            for (v11 -= 272; sub_429B10(v30, v11); v11 -= 272)
                ;
            if (v11 <= v8)
                break;
            qmemcpy(v35, v8, sizeof(v35));
            v12 = v8;
            v8 += 272;
            qmemcpy(v12, v11, 0x110u);
            qmemcpy(v11, v35, 0x110u);
        }
        v13 = v28;
        v14 = v24;
        if ((v28 - v8) / 272 > (v8 - v24) / 272)
        {
            sub_429820(v24, v8);
            v24 = v8;
            v14 = v8;
        }
        else
        {
            sub_429820(v8, v28);
            v28 = v8;
            v13 = v8;
        }
        if ((v13 - v14) / 272 <= 16)
            break;
        v8 = v24;
        v7 = v28;
    }
    v15 = a2;
    result = (unsigned int)(a1 + 4352);
    v16 = a1 + 272;
    v29 = a1 + 272;
    if (a1 + 272 != a1 + 4352)
    {
        v25 = a1;
        do
        {
            qmemcpy(v31, v16, sizeof(v31));
            if (sub_429B10(v31, a1))
            {
                for (k = v16; k != a1; qmemcpy(k + 272, k, 0x110u))
                    k -= 272;
                qmemcpy(a1, v31, 0x110u);
            }
            else
            {
                qmemcpy(v30, v31, sizeof(v30));
                v17 = v16;
                for (m = v25; sub_429B10(v30, m); m -= 272)
                {
                    qmemcpy(v17, m, 0x110u);
                    v17 = m;
                }
                v16 = v29;
                qmemcpy(v17, v30, 0x110u);
            }
            v16 += 272;
            result = (unsigned int)(a1 + 4352);
            v29 = v16;
            v25 += 272;
        } while (v16 != a1 + 4352);
        v15 = a2;
    }
    v20 = (char*)result;
    if ((char*)result != v15)
    {
        v21 = (char*)(result - 272);
        for (n = (char*)(result - 272); ; v21 = n)
        {
            qmemcpy(v30, v20, sizeof(v30));
            for (ii = v20; sub_429B10(v30, v21); v21 -= 272)
            {
                qmemcpy(ii, v21, 0x110u);
                ii = v21;
            }
            result = (unsigned int)a2;
            v20 += 272;
            qmemcpy(ii, v30, 0x110u);
            n += 272;
            if (v20 == a2)
                break;
        }
    }
    return result;
}

//----- (00429820) --------------------------------------------------------
unsigned int __cdecl sub_429820(_DWORD* a1, _DWORD* a2)
{
    _DWORD* v2; // ebx
    _DWORD* v3; // ebp
    unsigned int result; // eax
    int v5; // edx
    _DWORD* v6; // esi
    void* v7; // edi
    char* v8; // edi
    char* v9; // esi
    _DWORD v10[68]; // [esp+8h] [ebp-660h] BYREF
    _DWORD v11[68]; // [esp+118h] [ebp-550h] BYREF
    _DWORD v12[68]; // [esp+228h] [ebp-440h] BYREF
    _DWORD v13[68]; // [esp+338h] [ebp-330h] BYREF
    _BYTE v14[272]; // [esp+448h] [ebp-220h] BYREF
    _BYTE v15[272]; // [esp+558h] [ebp-110h] BYREF

    v2 = a1;
    v3 = a2;
    result = (unsigned int)((unsigned __int64)(2021161081LL * ((char*)a2 - (char*)a1)) >> 32) >> 31;
    v5 = ((char*)a2 - (char*)a1) / 272;
    if (v5 > 16)
    {
        while (1)
        {
            qmemcpy(v10, v3 - 68, sizeof(v10));
            qmemcpy(v11, &v2[68 * (v5 / 2)], sizeof(v11));
            qmemcpy(v12, v2, sizeof(v12));
            if (sub_429B10(v12, v11))
            {
                if (sub_429B10(v11, v10))
                    goto LABEL_11;
                v6 = v10;
                if (!sub_429B10(v12, v10))
                    v6 = v12;
            }
            else if (sub_429B10(v12, v10))
            {
                v6 = v12;
            }
            else
            {
                v6 = v10;
                if (!sub_429B10(v11, v10))
                    LABEL_11:
                v6 = v11;
            }
            qmemcpy(v14, v6, sizeof(v14));
            qmemcpy(v13, v14, sizeof(v13));
            while (1)
            {
                for (; sub_429B10(v2, v13); v2 += 68)
                    ;
                for (v3 -= 68; sub_429B10(v13, v3); v3 -= 68)
                    ;
                if (v3 <= v2)
                    break;
                qmemcpy(v15, v2, sizeof(v15));
                v7 = v2;
                v2 += 68;
                qmemcpy(v7, v3, 0x110u);
                qmemcpy(v3, v15, 0x110u);
            }
            v8 = (char*)a2;
            v9 = (char*)a1;
            if (((char*)a2 - (char*)v2) / 272 > ((char*)v2 - (char*)a1) / 272)
            {
                sub_429820(a1, v2);
                a1 = v2;
                v9 = (char*)v2;
            }
            else
            {
                sub_429820(v2, a2);
                a2 = v2;
                v8 = (char*)v2;
            }
            result = 2021161081 * (v8 - v9);
            v5 = (v8 - v9) / 272;
            if (v5 <= 16)
                return result;
            v3 = a2;
            v2 = a1;
        }
    }
    return result;
}

//----- (00429A90) --------------------------------------------------------
void* __thiscall sub_429A90(void* this, int a2, int a3, int a4, char* Source)
{
    *(_DWORD*)this = a2;
    *((_DWORD*)this + 1) = a3;
    *((_DWORD*)this + 2) = a4;
    strncpy((char*)this + 12, Source, 0x100u);
    *((_BYTE*)this + 268) = 0;
    return this;
}

//----- (00429AD0) --------------------------------------------------------
int __thiscall sub_429AD0(void* this)
{
    return *(_DWORD*)this;
}

//----- (00429AE0) --------------------------------------------------------
int __thiscall sub_429AE0(_DWORD* this)
{
    return this[1];
}

//----- (00429AF0) --------------------------------------------------------
int __thiscall sub_429AF0(_DWORD* this)
{
    return this[2];
}

//----- (00429B00) --------------------------------------------------------
char* __thiscall sub_429B00(char* this)
{
    return this + 12;
}

//----- (00429B10) --------------------------------------------------------
bool __thiscall sub_429B10(_DWORD* this, _DWORD* a2)
{
    if (*this < *a2)
        return 1;
    if (*this <= *a2)
        return this[1] < a2[1];
    return 0;
}

//----- (00429B40) --------------------------------------------------------
int __cdecl sub_429B40(void** a1, int a2, int a3, int a4, char* a5, int a6)
{
    int* i; // esi
    int v7; // edi
    int v8; // esi
    void** v9; // ebp
    int v10; // ecx
    int result; // eax
    int v12; // esi
    int v13; // ebp
    int v14; // ebx
    void** v15; // edi
    int v16; // edx
    char* v17; // eax
    bool v18; // cc
    char* v19; // [esp-18h] [ebp-1E0h]
    int v20; // [esp-14h] [ebp-1DCh]
    int v21; // [esp+0h] [ebp-1C8h]
    int v22; // [esp+0h] [ebp-1C8h]
    int* v23; // [esp+4h] [ebp-1C4h]
    int v24; // [esp+8h] [ebp-1C0h]
    int* v25; // [esp+Ch] [ebp-1BCh]
    void* v26; // [esp+Ch] [ebp-1BCh]
    int v27; // [esp+10h] [ebp-1B8h]
    char Buffer[308]; // [esp+14h] [ebp-1B4h] BYREF
    char v29; // [esp+148h] [ebp-80h] BYREF

    if (a4 > 32)
        a4 = 32;
    v24 = 0;
    v21 = a3;
    if (a3 < a4)
    {
        for (i = (int*)&v29; ; i = v25)
        {
            v7 = sub_429DD0();
            *i = v7;
            v25 = i + 1;
            v8 = 0;
            ++v24;
            if (a2 <= 0)
                break;
            v9 = a1;
            while (sub_428F80(*v9, v7) == -1)
            {
                ++v8;
                ++v9;
                if (v8 >= a2)
                    goto LABEL_12;
            }
            if (++v21 >= a4)
                break;
        }
    }
LABEL_12:
    v10 = a6;
    if (a6 > 0)
        *a5 = 0;
    result = 0;
    v27 = 0;
    v22 = a3;
    if (a3 < v24)
    {
        v23 = (int*)&Buffer[4 * (v24 - a3) + 304];
        do
        {
            v12 = 0;
            v13 = -1;
            v14 = *v23;
            v26 = 0;
            if (a2 > 0)
            {
                v15 = a1;
                while (1)
                {
                    v13 = sub_428F80(*v15, v14);
                    if (v13 != -1)
                        break;
                    ++v12;
                    ++v15;
                    if (v12 >= a2)
                        goto LABEL_22;
                }
                v26 = a1[v12];
            }
        LABEL_22:
            Buffer[0] = 0;
            if (a3 - 1 < v22)
            {
                v16 = v22 - (a3 - 1);
                do
                {
                    strcat(Buffer, asc_4A5C78);
                    --v16;
                } while (v16);
            }
            v20 = *v23;
            if (v26)
            {
                v17 = (char*)sub_428EE0(v26, v13);
                v19 = sub_429B00(v17);
                sprintf(&Buffer[strlen(Buffer)], "%s (%x)\n", v19, v20);
            }
            else
            {
                sprintf(&Buffer[strlen(Buffer)], a0xX, v20);
            }
            v27 += strlen(Buffer);
            if (v27 < a6)
                strcat(a5, Buffer);
            v18 = ++v22 < v24;
            --v23;
        } while (v18);
        result = v27;
        v10 = a6;
    }
    if (result >= v10)
    {
        if (v10 > 0)
            a5[v10 - 1] = 0;
    }
    else
    {
        a5[result] = 0;
    }
    return result;
}

//----- (00429DD0) --------------------------------------------------------
int sub_429DD0()
{
    return 0;
}

//----- (00429DE0) --------------------------------------------------------
_DWORD* __thiscall sub_429DE0(_DWORD* this, char* FileName)
{
    _DWORD* v3; // esi
    FILE* v4; // eax

    v3 = operator new(0x10u);
    if (v3)
    {
        *v3 = 0;
        v3[1] = 1;
        *((_BYTE*)v3 + 8) = 0;
        *((_BYTE*)v3 + 9) = 0;
        v4 = fopen(FileName, aRt);
        v3[3] = v4;
        if (!v4)
            *v3 = 1;
        *this = v3;
        return this;
    }
    else
    {
        *this = 0;
        return this;
    }
}

//----- (00429E40) --------------------------------------------------------
void __thiscall sub_429E40(FILE*** this)
{
    FILE** v1; // esi

    v1 = *this;
    if (*this)
    {
        if (v1[3])
        {
            fclose(v1[3]);
            v1[3] = 0;
        }
        sub_4885A6(v1);
    }
}

//----- (00429E70) --------------------------------------------------------
bool __thiscall sub_429E70(_DWORD* this, _BYTE* a2, int a3)
{
    _DWORD* v3; // esi
    int v5; // eax
    char v6; // al
    _BYTE* v7; // edi
    int v8; // eax
    char v9; // bl
    int v10; // ecx
    int v11; // eax
    char v12; // al
    char v13; // [esp+7h] [ebp-5h] BYREF
    int v14; // [esp+8h] [ebp-4h]

    v3 = (_DWORD*)*this;
    if (*(_DWORD*)*this)
        return 0;
    do
    {
        if (!*((_BYTE*)v3 + 8))
        {
            v5 = getc((FILE*)v3[3]);
            if (v5 == -1)
            {
                if ((*(_BYTE*)(v3[3] + 12) & 0x20) != 0)
                    *v3 = 2;
            }
            else
            {
                *((_BYTE*)v3 + 8) = 1;
                *((_BYTE*)v3 + 9) = v5;
            }
        }
        if (!*((_BYTE*)v3 + 8))
            break;
        v13 = *((_BYTE*)v3 + 9);
        if (!isspace(v13) || *v3)
            break;
        v6 = sub_42A010(v3, &v13);
        *((_BYTE*)v3 + 8) = 0;
        if (v6 && v13 == 10)
            ++v3[1];
    } while (!*v3);
    v7 = a2;
    v14 = 0;
    while (!*v3)
    {
        if (!*((_BYTE*)v3 + 8))
        {
            v8 = getc((FILE*)v3[3]);
            if (v8 == -1)
            {
                if ((*(_BYTE*)(v3[3] + 12) & 0x20) != 0)
                    *v3 = 2;
            }
            else
            {
                *((_BYTE*)v3 + 8) = 1;
                *((_BYTE*)v3 + 9) = v8;
            }
        }
        if (!*((_BYTE*)v3 + 8))
            break;
        v9 = *((_BYTE*)v3 + 9);
        if (isspace(v9))
            break;
        if ((int)&v7[1 - (_DWORD)a2] < a3)
        {
            v10 = v14;
            *v7++ = v9;
            v14 = v10 + 1;
        }
        if (*v3)
            break;
        if (!*((_BYTE*)v3 + 8))
        {
            v11 = getc((FILE*)v3[3]);
            if (v11 == -1)
            {
                if ((*(_BYTE*)(v3[3] + 12) & 0x20) != 0)
                    *v3 = 2;
            }
            else
            {
                *((_BYTE*)v3 + 8) = 1;
                *((_BYTE*)v3 + 9) = v11;
            }
        }
        v12 = *((_BYTE*)v3 + 8);
        if (v12)
            v9 = *((_BYTE*)v3 + 9);
        *((_BYTE*)v3 + 8) = 0;
        if (v12)
        {
            if (v9 == 10)
                ++v3[1];
        }
    }
    if (a3 > 0)
        a2[v14] = 0;
    return v14 > 0;
}

//----- (0042A010) --------------------------------------------------------
char __thiscall sub_42A010(void* this, _BYTE* a2)
{
    int v4; // eax

    if (*(_DWORD*)this)
        return 0;
    if (*((_BYTE*)this + 8))
        goto LABEL_9;
    v4 = getc(*((FILE**)this + 3));
    if (v4 == -1)
    {
        if ((*(_BYTE*)(*((_DWORD*)this + 3) + 12) & 0x20) != 0)
            *(_DWORD*)this = 2;
    }
    else
    {
        *((_BYTE*)this + 8) = 1;
        *((_BYTE*)this + 9) = v4;
    }
    if (*((_BYTE*)this + 8))
        LABEL_9:
    *a2 = *((_BYTE*)this + 9);
    return *((_BYTE*)this + 8);
}

//----- (0042A070) --------------------------------------------------------
void __thiscall sub_42A070(_DWORD* this)
{
    _DWORD* v1; // esi
    char v2; // bl
    int v3; // eax
    char v4; // al
    char v5; // [esp+Bh] [ebp-1h]

    v1 = (_DWORD*)*this;
    if (!*(_DWORD*)*this)
    {
        v2 = v5;
        while (!*v1)
        {
            if (!*((_BYTE*)v1 + 8))
            {
                v3 = getc((FILE*)v1[3]);
                if (v3 == -1)
                {
                    if ((*(_BYTE*)(v1[3] + 12) & 0x20) != 0)
                        *v1 = 2;
                }
                else
                {
                    *((_BYTE*)v1 + 8) = 1;
                    *((_BYTE*)v1 + 9) = v3;
                }
            }
            v4 = *((_BYTE*)v1 + 8);
            if (v4)
                v2 = *((_BYTE*)v1 + 9);
            *((_BYTE*)v1 + 8) = 0;
            if (!v4)
                break;
            if (v2 == 10)
            {
                ++v1[1];
                return;
            }
        }
    }
}
// 42A07A: variable 'v5' is possibly undefined

//----- (0042A0E0) --------------------------------------------------------
int __thiscall sub_42A0E0(_DWORD* this)
{
    _DWORD* v1; // esi
    int v3; // eax
    int v4; // eax
    int v5; // edi
    int v6; // eax
    char v7; // al
    char v8; // [esp+Ah] [ebp-2h] BYREF
    char v9; // [esp+Bh] [ebp-1h] BYREF

    v1 = (_DWORD*)*this;
    if (*(_DWORD*)*this)
        return 0;
    do
    {
        if (!*((_BYTE*)v1 + 8))
        {
            v3 = getc((FILE*)v1[3]);
            if (v3 == -1)
            {
                if ((*(_BYTE*)(v1[3] + 12) & 0x20) != 0)
                    *v1 = 2;
            }
            else
            {
                *((_BYTE*)v1 + 8) = 1;
                *((_BYTE*)v1 + 9) = v3;
            }
        }
        if (!*((_BYTE*)v1 + 8))
            break;
        v9 = *((_BYTE*)v1 + 9);
        if (!isspace(v9))
            break;
        sub_42A390(v1, &v9);
    } while (!*v1);
    sub_42A370(v1);
    if (*v1)
        goto LABEL_50;
    if (!*((_BYTE*)v1 + 8))
    {
        v4 = getc((FILE*)v1[3]);
        if (v4 == -1)
        {
            if ((*(_BYTE*)(v1[3] + 12) & 0x20) != 0)
                *v1 = 2;
        }
        else
        {
            *((_BYTE*)v1 + 8) = 1;
            *((_BYTE*)v1 + 9) = v4;
        }
    }
    if (*((_BYTE*)v1 + 8) && (v8 = *((_BYTE*)v1 + 9), isalnum(v8)))
    {
        v5 = 0;
        while (!*v1)
        {
            if (!*((_BYTE*)v1 + 8))
            {
                v6 = getc((FILE*)v1[3]);
                if (v6 == -1)
                {
                    if ((*(_BYTE*)(v1[3] + 12) & 0x20) != 0)
                        *v1 = 2;
                }
                else
                {
                    *((_BYTE*)v1 + 8) = 1;
                    *((_BYTE*)v1 + 9) = v6;
                }
            }
            if (!*((_BYTE*)v1 + 8))
                break;
            v8 = *((_BYTE*)v1 + 9);
            switch (v8)
            {
            case '0':
                v5 *= 16;
                goto LABEL_45;
            case '1':
                v5 = 16 * v5 + 1;
                goto LABEL_45;
            case '2':
                v5 = 16 * v5 + 2;
                goto LABEL_45;
            case '3':
                v5 = 16 * v5 + 3;
                goto LABEL_45;
            case '4':
                v5 = 16 * v5 + 4;
                goto LABEL_45;
            case '5':
                v5 = 16 * v5 + 5;
                goto LABEL_45;
            case '6':
                v5 = 16 * v5 + 6;
                goto LABEL_45;
            case '7':
                v5 = 16 * v5 + 7;
                goto LABEL_45;
            case '8':
                v5 = 16 * v5 + 8;
                goto LABEL_45;
            case '9':
                v5 = 16 * v5 + 9;
                goto LABEL_45;
            case 'A':
            case 'a':
                v5 = 16 * v5 + 10;
                goto LABEL_45;
            case 'B':
            case 'b':
                v5 = 16 * v5 + 11;
                goto LABEL_45;
            case 'C':
            case 'c':
                v5 = 16 * v5 + 12;
                goto LABEL_45;
            case 'D':
            case 'd':
                v5 = 16 * v5 + 13;
                goto LABEL_45;
            case 'E':
            case 'e':
                v5 = 16 * v5 + 14;
                goto LABEL_45;
            case 'F':
            case 'f':
                v5 = 16 * v5 + 15;
            LABEL_45:
                if (*v1)
                    return v5;
                v7 = sub_42A010(v1, &v8);
                *((_BYTE*)v1 + 8) = 0;
                if (v7)
                {
                    if (v8 == 10)
                        ++v1[1];
                }
                break;
            default:
                return v5;
            }
        }
        return v5;
    }
    else
    {
    LABEL_50:
        *v1 = 3;
        return 0;
    }
}

//----- (0042A370) --------------------------------------------------------
char __thiscall sub_42A370(_DWORD* this)
{
    int v1; // eax

    if (*this)
        LOBYTE(v1) = 1;
    else
        return (*(_DWORD*)(this[3] + 12) >> 4) & 1;
    return v1;
}

//----- (0042A390) --------------------------------------------------------
char __thiscall sub_42A390(void* this, _BYTE* a2)
{
    char result; // al
    char v4; // al
    bool v5; // zf
    int v6; // eax

    if (*(_DWORD*)this)
        return 0;
    v4 = *((_BYTE*)this + 8);
    v5 = v4 == 0;
    if (!v4)
    {
        v6 = getc(*((FILE**)this + 3));
        if (v6 == -1)
        {
            if ((*(_BYTE*)(*((_DWORD*)this + 3) + 12) & 0x20) != 0)
                *(_DWORD*)this = 2;
        }
        else
        {
            *((_BYTE*)this + 8) = 1;
            *((_BYTE*)this + 9) = v6;
        }
        v5 = *((_BYTE*)this + 8) == 0;
    }
    if (!v5)
        *a2 = *((_BYTE*)this + 9);
    result = *((_BYTE*)this + 8);
    *((_BYTE*)this + 8) = 0;
    if (result)
    {
        if (*a2 == 10)
            ++*((_DWORD*)this + 1);
    }
    return result;
}

//----- (0042A400) --------------------------------------------------------
bool __thiscall sub_42A400(_DWORD* this)
{
    _DWORD* v1; // esi
    int v3; // eax
    char v4; // bl
    int v5; // eax
    char v6; // al

    v1 = (_DWORD*)*this;
    if (*(_DWORD*)*this)
        return 0;
    while (!*v1)
    {
        if (!*((_BYTE*)v1 + 8))
        {
            v3 = getc((FILE*)v1[3]);
            if (v3 == -1)
            {
                if ((*(_BYTE*)(v1[3] + 12) & 0x20) != 0)
                    *v1 = 2;
            }
            else
            {
                *((_BYTE*)v1 + 8) = 1;
                *((_BYTE*)v1 + 9) = v3;
            }
        }
        if (!*((_BYTE*)v1 + 8))
            break;
        v4 = *((_BYTE*)v1 + 9);
        if (!isspace(v4) || *v1)
            break;
        if (!*((_BYTE*)v1 + 8))
        {
            v5 = getc((FILE*)v1[3]);
            if (v5 == -1)
            {
                if ((*(_BYTE*)(v1[3] + 12) & 0x20) != 0)
                    *v1 = 2;
            }
            else
            {
                *((_BYTE*)v1 + 8) = 1;
                *((_BYTE*)v1 + 9) = v5;
            }
        }
        v6 = *((_BYTE*)v1 + 8);
        if (v6)
            v4 = *((_BYTE*)v1 + 9);
        *((_BYTE*)v1 + 8) = 0;
        if (v6)
        {
            if (v4 == 10)
                ++v1[1];
        }
    }
    return !*v1 && (*(_DWORD*)(v1[3] + 12) & 0x10) == 0;
}

//----- (0042A4F0) --------------------------------------------------------
char __thiscall sub_42A4F0(_DWORD* this, _BYTE* a2)
{
    _DWORD* v2; // esi
    char result; // al
    char v4; // al
    bool v5; // zf
    int v6; // eax

    v2 = (_DWORD*)*this;
    if (*(_DWORD*)*this)
        return 0;
    v4 = *((_BYTE*)v2 + 8);
    v5 = v4 == 0;
    if (!v4)
    {
        v6 = getc((FILE*)v2[3]);
        if (v6 == -1)
        {
            if ((*(_BYTE*)(v2[3] + 12) & 0x20) != 0)
                *v2 = 2;
        }
        else
        {
            *((_BYTE*)v2 + 8) = 1;
            *((_BYTE*)v2 + 9) = v6;
        }
        v5 = *((_BYTE*)v2 + 8) == 0;
    }
    if (!v5)
        *a2 = *((_BYTE*)v2 + 9);
    result = *((_BYTE*)v2 + 8);
    *((_BYTE*)v2 + 8) = 0;
    if (result)
    {
        if (*a2 == 10)
            ++v2[1];
    }
    return result;
}

//----- (0042A560) --------------------------------------------------------
char __thiscall sub_42A560(_DWORD* this, _BYTE* a2)
{
    _DWORD* v2; // esi
    int v4; // eax

    v2 = (_DWORD*)*this;
    if (*(_DWORD*)*this)
        return 0;
    if (*((_BYTE*)v2 + 8))
        goto LABEL_9;
    v4 = getc((FILE*)v2[3]);
    if (v4 == -1)
    {
        if ((*(_BYTE*)(v2[3] + 12) & 0x20) != 0)
            *v2 = 2;
    }
    else
    {
        *((_BYTE*)v2 + 8) = 1;
        *((_BYTE*)v2 + 9) = v4;
    }
    if (*((_BYTE*)v2 + 8))
        LABEL_9:
    *a2 = *((_BYTE*)v2 + 9);
    return *((_BYTE*)v2 + 8);
}

//----- (0042A5C0) --------------------------------------------------------
int __thiscall sub_42A5C0(void* this)
{
    return *(_DWORD*)(*(_DWORD*)this + 4);
}

//----- (0042A5F0) --------------------------------------------------------
float* __thiscall sub_42A5F0(float* this, char* a2)
{
    char* v2; // edi
    double v4; // st7
    double v5; // st7
    double v6; // st7
    double v7; // st7
    const char* v8; // ecx
    const char* v10; // [esp-8h] [ebp-2Ch]
    int v11[5]; // [esp+10h] [ebp-14h] BYREF

    v2 = a2;
    v11[1] = (int)this;
    sub_468FF0(this, a2);
    v10 = (const char*)*((_DWORD*)this + 1);
    v11[4] = 0;
    *(_DWORD*)this = &off_499400;
    sub_4229D0("Started to load %s in %s", v10, v2 + 16);
    sub_40AFC0(v2, aBullettype, &a2);
    sub_469160((int)this, (_DWORD*)this + 73, a2, aBullet);
    sub_40B1B0(v2, aRof, this + 74);
    v4 = this[74];
    if (v4 == 0.0)
        v5 = 0.0;
    else
        v5 = 60.0 / v4;
    this[74] = v5;
    v6 = this[75];
    if (v6 == 0.0)
        v7 = 0.0;
    else
        v7 = 60.0 / v6;
    v8 = (const char*)*((_DWORD*)this + 1);
    this[75] = v7;
    sub_4229D0("Finished loading %s in %s", v8, v2 + 16);
    sub_40AF60(v2, aVelocity, this + 76);
    this[77] = 0.0;
    if (sub_40ABC0(v2, aFireeffect, 0))
    {
        sub_40AFC0(v2, aFireeffect, v11);
        sub_469160((int)this, (_DWORD*)this + 77, (const char*)v11[0], aEffect);
    }
    return this;
}
// 499400: using guessed type _UNKNOWN *off_499400;

//----- (0042A770) --------------------------------------------------------
int __thiscall sub_42A770(void* this)
{
    *(_DWORD*)this = &off_499400;
    return sub_4690A0(this);
}
// 499400: using guessed type _UNKNOWN *off_499400;

//----- (0042A780) --------------------------------------------------------
int __usercall sub_42A780@<eax>(_DWORD* a1@<ecx>, int a2@<ebp>)
{
    sub_42A7C0((int)a1, a2);
    return sub_4690E0(a1);
}

//----- (0042A7A0) --------------------------------------------------------
int __thiscall sub_42A7A0(_DWORD* this)
{
    sub_42A840(this);
    return sub_469120(this);
}

//----- (0042A7C0) --------------------------------------------------------
int __usercall sub_42A7C0@<eax>(int a1@<ecx>, int a2@<ebp>)
{
    int result; // eax
    char* v4; // eax
    unsigned int i; // edi

    result = *(_DWORD*)(a1 + 564);
    if (!result)
    {
        v4 = sub_4069C0(*(_DWORD*)(dword_520970 + 128), a2, (char*)(a1 + 301));
        *(_DWORD*)(a1 + 564) = v4;
        sub_4282E0(v4 != 0, "failed to load model %s, see file %s", (const char*)(a1 + 301), (const char*)(a1 + 16));
        for (i = 0; ; ++i)
        {
            result = *(_DWORD*)(a1 + 612);
            if (!result || i >= (*(_DWORD*)(a1 + 616) - result) >> 2)
                break;
            sub_403C80(*(_DWORD**)(a1 + 564), *(_DWORD*)(result + 4 * i), 1);
        }
    }
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (0042A840) --------------------------------------------------------
void __thiscall sub_42A840(_DWORD* this)
{
    _DWORD* v2; // ecx

    v2 = (_DWORD*)this[141];
    if (v2)
    {
        sub_403B70(v2);
        this[141] = 0;
    }
}

//----- (0042A860) --------------------------------------------------------
int __thiscall sub_42A860(int this)
{
    int i; // ebp
    int v3; // edi
    void* v4; // eax

    *(_DWORD*)this = &off_49940C;
    sub_42A840((_DWORD*)this);
    sub_4885A6(*(LPVOID*)(this + 980));
    *(_DWORD*)(this + 980) = 0;
    *(_DWORD*)(this + 984) = 0;
    *(_DWORD*)(this + 988) = 0;
    if (*(_BYTE*)(this + 944))
    {
        for (i = 0; i < *(_DWORD*)(this + 936); ++i)
        {
            v3 = *(_DWORD*)(*(_DWORD*)(this + 932) + 4 * i);
            if (v3)
            {
                sub_4885A6(*(LPVOID*)(v3 + 8));
                *(_DWORD*)(v3 + 8) = 0;
                *(_DWORD*)(v3 + 12) = 0;
                *(_DWORD*)(v3 + 16) = 0;
                sub_4885A6((LPVOID)v3);
            }
        }
    }
    memset(*(void**)(this + 932), 0, 4 * *(_DWORD*)(this + 936));
    v4 = *(void**)(this + 932);
    *(_DWORD*)(this + 936) = 0;
    sub_488CEE(v4);
    *(_DWORD*)(this + 940) = 0;
    *(_DWORD*)(this + 932) = 0;
    `eh vector destructor iterator'((void *)(this + 624), 0x18u, 5, (void (__thiscall *)(void *))sub_42A9D0);
        sub_4885A6(*(LPVOID*)(this + 612));
    *(_DWORD*)(this + 612) = 0;
    *(_DWORD*)(this + 616) = 0;
    *(_DWORD*)(this + 620) = 0;
    return sub_4690A0((void*)this);
}
// 49940C: using guessed type _UNKNOWN *off_49940C;

//----- (0042A9D0) --------------------------------------------------------
void __thiscall sub_42A9D0(LPVOID* this)
{
    sub_4885A6(this[3]);
    this[3] = 0;
    this[4] = 0;
    this[5] = 0;
}

//----- (0042AA30) --------------------------------------------------------
int __fastcall sub_42AA30(int a1, int a2, char* k)
{
    char* v3; // edi
    char v5; // cl
    const char* v6; // edx
    const char* v7; // eax
    char* v8; // ecx
    char* v9; // edi
    unsigned int v10; // kr08_4
    char* v11; // esi
    unsigned int v12; // ecx
    int v13; // esi
    int* v14; // eax
    int v15; // esi
    int* v16; // eax
    int v17; // esi
    int* v18; // eax
    int v19; // esi
    int* v20; // eax
    int v21; // esi
    int* v22; // eax
    int v23; // esi
    int* v24; // eax
    int v25; // esi
    int* v26; // eax
    int v27; // ecx
    int v28; // edi
    _BYTE* v29; // eax
    int v30; // esi
    const char* v31; // eax
    char* v32; // ebx
    char* v33; // ecx
    _BYTE* v34; // esi
    int v35; // edi
    int v36; // eax
    int v37; // ecx
    _DWORD* v38; // eax
    int v39; // esi
    bool v40; // zf
    _DWORD* v41; // eax
    _DWORD* v42; // eax
    int v43; // esi
    char* v44; // ebx
    _DWORD* v45; // eax
    int v46; // esi
    int v47; // esi
    int v48; // ecx
    int v49; // edi
    int v50; // ebx
    _DWORD* v51; // eax
    int v52; // esi
    int v53; // edx
    unsigned int j; // eax
    _BYTE* v55; // eax
    int v56; // esi
    int v57; // eax
    int v58; // esi
    int v59; // edi
    int v60; // eax
    unsigned int v61; // ecx
    unsigned int v62; // edx
    int v63; // edx
    int v64; // ecx
    _BYTE* v65; // eax
    int v66; // ecx
    int v67; // esi
    int* v68; // eax
    int v69; // esi
    int v70; // eax
    const char* v71; // ecx
    char* v72; // edi
    double v73; // st7
    int v74; // eax
    int v75; // ecx
    double v76; // st7
    _DWORD* v77; // eax
    _DWORD* v78; // esi
    _DWORD* v79; // eax
    const char* v80; // edi
    int* v81; // ebx
    int v82; // eax
    bool v83; // al
    char* v84; // ebx
    char* v85; // ecx
    int v86; // eax
    int v87; // ecx
    _DWORD* v88; // esi
    int* v89; // eax
    const char* v90; // eax
    int v91; // esi
    int v92; // edi
    const void* v93; // eax
    char* v94; // edi
    char m; // al
    int v96; // eax
    int v97; // ebx
    int*** v98; // ecx
    _DWORD* v99; // eax
    _DWORD* v100; // esi
    int v101; // eax
    int v102; // ecx
    int v103; // eax
    char* v104; // eax
    int v105; // edi
    int v106; // ecx
    char* v107; // edi
    int v108; // ecx
    _DWORD* v109; // eax
    int v110; // esi
    _DWORD* v111; // esi
    int* v112; // eax
    char* v113; // eax
    int v114; // esi
    int v115; // edi
    const void* v116; // eax
    char* v117; // ecx
    char n; // al
    int v119; // edi
    char* v120; // esi
    float* v121; // eax
    int v122; // ecx
    double v123; // st7
    int v124; // eax
    _DWORD* v125; // eax
    int v126; // ecx
    _DWORD* v127; // eax
    int v128; // esi
    _BYTE* v129; // eax
    int v130; // esi
    _BYTE* v131; // eax
    int v132; // esi
    _DWORD* v133; // eax
    _DWORD* v134; // edi
    int v135; // ecx
    unsigned int v136; // ebx
    int v137; // eax
    bool v138; // sf
    int v139; // eax
    _DWORD* v140; // ebx
    int v141; // eax
    _DWORD* ii; // eax
    char v143; // al
    int v144; // ecx
    int v145; // eax
    int v146; // eax
    _DWORD* v147; // eax
    int v148; // esi
    unsigned int v150; // [esp-4h] [ebp-4Ch]
    unsigned int v151; // [esp-4h] [ebp-4Ch]
    char v152; // [esp+13h] [ebp-35h] BYREF
    char* String1; // [esp+14h] [ebp-34h] BYREF
    char ArgList[4]; // [esp+18h] [ebp-30h] BYREF
    char v155[4]; // [esp+1Ch] [ebp-2Ch]
    int v156; // [esp+20h] [ebp-28h]
    int v157; // [esp+24h] [ebp-24h] BYREF
    int i; // [esp+28h] [ebp-20h] BYREF
    int v159; // [esp+2Ch] [ebp-1Ch] BYREF
    int v160; // [esp+30h] [ebp-18h] BYREF
    int v161[2]; // [esp+34h] [ebp-14h] BYREF
    int v162; // [esp+44h] [ebp-4h]

    v3 = k;
    v161[1] = a1;
    sub_468FF0((void*)a1, k);
    v162 = 0;
    *(_BYTE*)(a1 + 608) = (_BYTE)k;
    *(_DWORD*)(a1 + 612) = 0;
    *(_DWORD*)(a1 + 616) = 0;
    *(_DWORD*)(a1 + 620) = 0;
    LOBYTE(v162) = 1;
    `eh vector constructor iterator'((void *)(a1 + 624), 0x18u, 5, sub_42CA00, (void (__thiscall *)(void *))sub_42A9D0);
        * (_DWORD*)(a1 + 932) = 0;
    *(_DWORD*)(a1 + 936) = 0;
    *(_DWORD*)(a1 + 940) = 0;
    *(_BYTE*)(a1 + 944) = 1;
    v5 = (char)k;
    *(_DWORD*)(a1 + 980) = 0;
    *(_BYTE*)(a1 + 976) = v5;
    *(_DWORD*)(a1 + 984) = 0;
    *(_DWORD*)(a1 + 988) = 0;
    *(_DWORD*)a1 = &off_49940C;
    v6 = *(const char**)(a1 + 4);
    LOBYTE(v162) = 4;
    *(_DWORD*)v155 = v3 + 16;
    sub_4229D0("Started to load %s in %s", v6, v3 + 16);
    sub_40AFC0(v3, aType_0, &String1);
    if (!strcmp(String1, aFighter))
    {
        *(_DWORD*)(a1 + 292) = 0;
    }
    else if (!strcmp(String1, aTransport))
    {
        *(_DWORD*)(a1 + 292) = 1;
    }
    else if (!strcmp(String1, aBomber))
    {
        *(_DWORD*)(a1 + 292) = 2;
    }
    else if (!strcmp(String1, aDiveBomber))
    {
        *(_DWORD*)(a1 + 292) = 3;
    }
    else if (!strcmp(String1, aKamikaze))
    {
        *(_DWORD*)(a1 + 292) = 4;
    }
    else if (!strcmp(String1, aV1))
    {
        *(_DWORD*)(a1 + 292) = 5;
    }
    else
    {
        sub_40A120(0, "invalid airplane type %s, see %s : %s", String1, *(const char**)(a1 + 4), *(const char**)v155);
    }
    *(_DWORD*)(a1 + 296) = 1065353216;
    if (sub_40ABC0(v3, aUnitvalue, 0))
        sub_40AF60(v3, aUnitvalue, (float*)(a1 + 296));
    sub_40AFC0(v3, aScoringgroup, &String1);
    v7 = sub_462480(*(_DWORD**)(dword_520970 + 280), String1);
    v8 = String1;
    *(_DWORD*)(a1 + 592) = v7;
    sub_4282E0(v7 != 0, "Airplane type %s: couldn't find scoring groups %s", *(const char**)(a1 + 4), v8);
    *(_BYTE*)(a1 + 300) = 0;
    if (sub_40ABC0(v3, aGoodguy, 0))
        sub_40B130(v3, aGoodguy, (_BYTE*)(a1 + 300));
    sub_40AFC0(v3, aModelfile, &String1);
    v10 = strlen(String1) + 1;
    v9 = &String1[v10];
    qmemcpy((void*)(a1 + 301), String1, 4 * (v10 >> 2));
    v11 = &v9[4 * (v10 >> 2) - v10];
    v12 = v10 & 3;
    qmemcpy((void*)(a1 + 301 + 4 * (v10 >> 2)), v11, v12);
    v13 = (int)&v11[v12];
    *(_DWORD*)(a1 + 564) = 0;
    if (!sub_46A3A0(*(_BYTE**)(dword_520970 + 200), (LPCSTR)(a1 + 301)))
        sub_42A7C0(a1, a1);
    if (!sub_46A490(*(_BYTE**)(dword_520970 + 200)))
        sub_4066C0(
            *(_DWORD**)(a1 + 564),
            v13,
            (_DWORD*)(a1 + 580),
            (float*)(a1 + 568),
            (float*)(a1 + 584),
            (float*)(a1 + 572),
            (float*)(a1 + 588),
            (float*)(a1 + 576));
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v14 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v15 = *(_DWORD*)(dword_520970 + 200);
        v160 = (__int64)*(float*)(a1 + 580);
        v14 = (int*)sub_46A4C0(v15, &v160, 4u);
    }
    v160 = *v14;
    *(float*)(a1 + 580) = (float)v160;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v16 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v17 = *(_DWORD*)(dword_520970 + 200);
        v160 = (__int64)*(float*)(a1 + 584);
        v16 = (int*)sub_46A4C0(v17, &v160, 4u);
    }
    v160 = *v16;
    *(float*)(a1 + 584) = (float)v160;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v18 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v19 = *(_DWORD*)(dword_520970 + 200);
        v160 = (__int64)*(float*)(a1 + 588);
        v18 = (int*)sub_46A4C0(v19, &v160, 4u);
    }
    v160 = *v18;
    *(float*)(a1 + 588) = (float)v160;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v20 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v21 = *(_DWORD*)(dword_520970 + 200);
        v160 = (__int64)*(float*)(a1 + 568);
        v20 = (int*)sub_46A4C0(v21, &v160, 4u);
    }
    v160 = *v20;
    *(float*)(a1 + 568) = (float)v160;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v22 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v23 = *(_DWORD*)(dword_520970 + 200);
        v160 = (__int64)*(float*)(a1 + 572);
        v22 = (int*)sub_46A4C0(v23, &v160, 4u);
    }
    v160 = *v22;
    *(float*)(a1 + 572) = (float)v160;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v24 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v25 = *(_DWORD*)(dword_520970 + 200);
        v160 = (__int64)*(float*)(a1 + 576);
        v24 = (int*)sub_46A4C0(v25, &v160, 4u);
    }
    v160 = *v24;
    *(float*)(a1 + 576) = (float)v160;
    *(_DWORD*)(a1 + 596) = 0;
    *(_DWORD*)(a1 + 600) = 1163575296;
    *(_DWORD*)(a1 + 604) = 1142292480;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v26 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v27 = *(_DWORD*)(dword_520970 + 200);
        v160 = *(_DWORD*)(*(_DWORD*)(a1 + 564) + 8);
        v26 = (int*)sub_46A4C0(v27, &v160, 4u);
    }
    v28 = *v26;
    for (i = 0; i < v28; ++i)
    {
        if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
        {
            v29 = (_BYTE*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
        }
        else
        {
            v30 = *(_DWORD*)(dword_520970 + 200);
            v31 = (const char*)sub_405C20(*(_DWORD**)(a1 + 564), i);
            v152 = _strcmpi(v31, aThrust) == 0;
            v29 = (_BYTE*)sub_46A4C0(v30, &v152, 4u);
        }
        if (*v29)
            sub_44F190(a1 + 608, *(_DWORD**)(a1 + 616), 1u, &i);
    }
    if (!*(_BYTE*)(a1 + 300))
    {
        v156 = 0;
        while (1)
        {
            v32 = 0;
            *(_DWORD*)ArgList = 0;
            switch (v156)
            {
            case 0:
                v32 = aFuselage;
                goto LABEL_58;
            case 1:
                v32 = aRightwing;
                goto LABEL_58;
            case 2:
                v32 = aLeftwing;
                goto LABEL_58;
            case 3:
                v32 = aNose;
                goto LABEL_58;
            case 4:
                v32 = aTail;
            LABEL_58:
                *(_DWORD*)ArgList = v32;
                break;
            default:
                break;
            }
            v33 = k;
            v34 = (_BYTE*)(a1 + 8 * (3 * v156 + 78));
            *v34 = 0;
            if (!sub_40ABC0(v33, v32, 0))
                goto LABEL_121;
            *v34 = 1;
            sub_40AFC0(k, v32, &String1);
            v160 = 0;
            v35 = a1 + 24 * v156;
            v159 = v35;
            v36 = *(_DWORD*)(v35 + 636);
            if (!v36)
                break;
            if (!((*(_DWORD*)(v35 + 640) - v36) >> 2))
            {
                v37 = (*(_DWORD*)(v35 + 640) - v36) >> 2;
            LABEL_64:
                sub_44F190(v35 + 632, *(_DWORD**)(v35 + 640), 1 - v37, &v160);
                goto LABEL_67;
            }
            if ((unsigned int)sub_4481C0((_DWORD*)(v35 + 632)) > 1)
                sub_448300((_DWORD*)(v35 + 632), (_DWORD*)(*(_DWORD*)(v35 + 636) + 4), *(int**)(v35 + 640));
        LABEL_67:
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v38 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v39 = *(_DWORD*)(dword_520970 + 200);
                v160 = sub_405A30(*(_DWORD**)(a1 + 564), String1, -1, 1);
                v38 = (_DWORD*)sub_46A4C0(v39, &v160, 4u);
            }
            **(_DWORD**)(v35 + 636) = *v38;
            v40 = sub_46A490(*(_BYTE**)(dword_520970 + 200)) == 0;
            v41 = *(_DWORD**)(v35 + 636);
            if (v40)
                sub_40A120(
                    *v41 != -1,
                    "airplane section %s not found, see %s : %s",
                    v32,
                    *(const char**)(a1 + 4),
                    *(const char**)v155);
            else
                sub_40A120(*v41 != -1, aDeleteTheCorru);
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v42 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v43 = *(_DWORD*)(dword_520970 + 200);
                v160 = sub_405A30(*(_DWORD**)(a1 + 564), asc_4A6264, **(_DWORD**)(v35 + 636), 1);
                v42 = (_DWORD*)sub_46A4C0(v43, &v160, 4u);
            }
            *(_DWORD*)(v35 + 628) = *v42;
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
                sub_40A120(*(_DWORD*)(v35 + 628) != -1, aDeleteTheCorru);
            else
                sub_40A120(
                    *(_DWORD*)(v35 + 628) != -1,
                    "failed to find collision node for %s, in model %s, see file %s",
                    v32,
                    (const char*)(*(_DWORD*)(a1 + 564) + 60),
                    *(const char**)v155);
            if (v156)
            {
                v44 = (char*)operator new(strlen(String1) + 6);
                *(_DWORD*)v44 = dword_4A621C;
                v44[4] = byte_4A6220;
                strcpy(v44 + 5, String1);
                if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
                {
                    v45 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
                }
                else
                {
                    v46 = *(_DWORD*)(dword_520970 + 200);
                    v160 = sub_405A30(*(_DWORD**)(a1 + 564), v44, **(_DWORD**)(a1 + 636), 1);
                    v45 = (_DWORD*)sub_46A4C0(v46, &v160, 4u);
                }
                v47 = v156;
                *(_DWORD*)(a1 + 4 * v156 + 744) = *v45;
                if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
                    sub_40A120(*(_DWORD*)(a1 + 4 * v47 + 744) != -1, aDeleteTheCorru);
                else
                    sub_40A120(
                        *(_DWORD*)(a1 + 4 * v47 + 744) != -1,
                        "failed to load smoke node for %s, see file %s",
                        *(const char**)ArgList,
                        *(const char**)v155);
                sub_4885A6(v44);
            }
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v160 = *(_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v48 = *(_DWORD*)(dword_520970 + 200);
                v160 = *(_DWORD*)(*(_DWORD*)(a1 + 564) + 8);
                v160 = *(_DWORD*)sub_46A4C0(v48, &v160, 4u);
            }
            v49 = v159;
            *(_DWORD*)ArgList = **(_DWORD**)(v159 + 636) + 1;
            v50 = *(_DWORD*)ArgList;
            if (*(int*)ArgList < v160)
            {
                while (1)
                {
                    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
                    {
                        v51 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
                    }
                    else
                    {
                        v52 = *(_DWORD*)(dword_520970 + 200);
                        v161[0] = sub_405BB0(*(_DWORD**)(a1 + 564), v50);
                        v51 = (_DWORD*)sub_46A4C0(v52, v161, 4u);
                    }
                    if (*v51 != **(_DWORD**)(v49 + 636))
                        goto LABEL_121;
                    v53 = *(_DWORD*)(a1 + 612);
                    for (j = 0; v53 && j < (*(_DWORD*)(a1 + 616) - v53) >> 2; ++j)
                    {
                        if (*(_DWORD*)(*(_DWORD*)(a1 + 612) + 4 * j) == v50)
                            goto LABEL_120;
                    }
                    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
                    {
                        v55 = (_BYTE*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
                    }
                    else
                    {
                        v56 = *(_DWORD*)(dword_520970 + 200);
                        v152 = sub_405BE0(*(_DWORD**)(a1 + 564), v50);
                        v55 = (_BYTE*)sub_46A4C0(v56, &v152, 4u);
                    }
                    if (*v55)
                        break;
                LABEL_120:
                    *(_DWORD*)ArgList = ++v50;
                    if (v50 >= v160)
                        goto LABEL_121;
                }
                v57 = *(_DWORD*)(v49 + 636);
                v58 = v49 + 632;
                if (v57)
                    v59 = (*(_DWORD*)(v49 + 640) - v57) >> 2;
                else
                    v59 = 0;
                v60 = *(_DWORD*)(v58 + 4);
                v161[0] = 0;
                v61 = v59 + 1;
                if (v60)
                    v62 = (*(_DWORD*)(v58 + 8) - v60) >> 2;
                else
                    v62 = 0;
                if (v62 < v61)
                {
                    if (v60)
                        v63 = (*(_DWORD*)(v58 + 8) - v60) >> 2;
                    else
                        v63 = 0;
                    sub_44F190(v58, *(_DWORD**)(v58 + 8), v61 - v63, v161);
                    goto LABEL_118;
                }
                if (v60)
                {
                    if (v61 < (*(_DWORD*)(v58 + 8) - v60) >> 2)
                        sub_448300((_DWORD*)v58, (_DWORD*)(v60 + 4 * v61), *(int**)(v58 + 8));
                LABEL_118:
                    v50 = *(_DWORD*)ArgList;
                }
                v64 = v159;
                *(_DWORD*)(*(_DWORD*)(v159 + 636) + 4 * v59) = v50;
                v49 = v64;
                goto LABEL_120;
            }
        LABEL_121:
            if (++v156 >= 5)
                goto LABEL_129;
        }
        v37 = 0;
        goto LABEL_64;
    }
    v65 = (_BYTE*)(a1 + 624);
    v66 = 5;
    do
    {
        *v65 = 0;
        v65 += 24;
        --v66;
    } while (v66);
    *(_BYTE*)(a1 + 624) = 1;
    v67 = *(_DWORD*)(a1 + 636);
    nullsub_8(v67, *(_DWORD*)(a1 + 640));
    *(_DWORD*)(a1 + 640) = v67;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v68 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v69 = *(_DWORD*)(dword_520970 + 200);
        v161[0] = sub_405A30(*(_DWORD**)(a1 + 564), asc_4A6264, -1, 1);
        v68 = (int*)sub_46A4C0(v69, v161, 4u);
    }
    v70 = *v68;
    v71 = *(const char**)v155;
    *(_DWORD*)(a1 + 628) = v70;
    sub_40A120(
        v70 != -1,
        "failed to find collision node '*' for good guy airplane %s, see %s",
        *(const char**)(a1 + 4),
        v71);
LABEL_129:
    v72 = k;
    sub_40AF60(k, aHealth, (float*)&v157);
    if (*(_BYTE*)(a1 + 300))
    {
        *(float*)(a1 + 764) = *(float*)&v157;
    }
    else
    {
        *(float*)(a1 + 764) = *(float*)&v157 * 0.34999999;
        v73 = *(float*)&v157 * 0.1;
        *(float*)(a1 + 768) = v73;
        *(float*)(a1 + 772) = v73;
        *(float*)(a1 + 776) = *(float*)&v157 * 0.25;
        *(float*)(a1 + 780) = *(float*)&v157 * 0.2;
    }
    *(_DWORD*)(a1 + 784) = 0;
    *(_DWORD*)(a1 + 788) = 0;
    *(_DWORD*)(a1 + 792) = 0;
    *(_DWORD*)(a1 + 796) = 0;
    v74 = *(_DWORD*)(a1 + 292);
    if (!v74 || v74 == 3 || v74 == 2)
    {
        *(_DWORD*)(a1 + 784) = 1140457472;
        if (sub_40ABC0(v72, aFormationscale, 0))
            sub_40AF60(v72, aFormationscale, (float*)(a1 + 784));
        *(_DWORD*)(a1 + 788) = 1120403456;
        if (sub_40ABC0(v72, aFormationhorzv, 0))
            sub_40AF60(v72, aFormationhorzv, (float*)(a1 + 788));
        *(_DWORD*)(a1 + 792) = 1120403456;
        if (sub_40ABC0(v72, aFormationvertv, 0))
            sub_40AF60(v72, aFormationvertv, (float*)(a1 + 792));
        *(_DWORD*)(a1 + 796) = 1167867904;
        if (sub_40ABC0(v72, aFormationbreak, 0))
            sub_40AF60(v72, aFormationbreak, (float*)(a1 + 796));
    }
    if (sub_40ABC0(v72, aSpeed, 0))
    {
        sub_40AF60(v72, aSpeed, (float*)(a1 + 804));
        *(_DWORD*)(a1 + 800) = *(_DWORD*)(a1 + 804);
        *(_DWORD*)(a1 + 808) = *(_DWORD*)(a1 + 804);
    }
    if (sub_40ABC0(v72, aSpeedr, 0))
        sub_40AF60(v72, aSpeedr, (float*)(a1 + 800));
    if (sub_40ABC0(v72, aSpeeds, 0))
        sub_40AF60(v72, aSpeeds, (float*)(a1 + 804));
    if (sub_40ABC0(v72, aSpeedv, 0))
        sub_40AF60(v72, aSpeedv, (float*)(a1 + 808));
    *(_DWORD*)(a1 + 812) = 0;
    if (sub_40ABC0(v72, aStartdist, 0))
        sub_40AF60(v72, aStartdist, (float*)(a1 + 812));
    sub_40B1D0(v72, aAltitude, (float*)(a1 + 816), (float*)(a1 + 820));
    sub_40B1D0(v72, aRange, (float*)(a1 + 824), (float*)(a1 + 828));
    if (*(_DWORD*)(a1 + 292) == 2)
    {
        *(_DWORD*)(a1 + 824) = 0;
        *(_DWORD*)(a1 + 828) = 1232348160;
    }
    v75 = *(_DWORD*)(a1 + 292);
    *(_DWORD*)(a1 + 832) = 0;
    *(_DWORD*)(a1 + 836) = 0;
    *(_DWORD*)(a1 + 840) = 0;
    *(_DWORD*)(a1 + 844) = 0;
    *(_DWORD*)(a1 + 848) = 0;
    *(_DWORD*)(a1 + 852) = 0;
    if (!v75 || v75 == 3 || v75 == 4)
    {
        sub_40B1B0(v72, aDivealtitude, (float*)(a1 + 832));
        sub_40B1B0(v72, aDiverange, (float*)(a1 + 840));
        sub_40AF60(v72, aDivecloserange, (float*)(a1 + 848));
        sub_40AF60(v72, aDiveyawrange, (float*)(a1 + 852));
        *(float*)(a1 + 852) = *(float*)(a1 + 852) * 0.017453292;
    }
    if (*(_DWORD*)(a1 + 292) == 5)
        sub_40B1B0(v72, aDiverange, (float*)(a1 + 840));
    sub_40AF60(v72, aPathsegmenttim, (float*)(a1 + 864));
    sub_40AF60(v72, aHorizontalvari, (float*)(a1 + 868));
    *(float*)(a1 + 868) = *(float*)(a1 + 868) * 0.017453292;
    sub_40AF60(v72, aVerticalvariat, (float*)(a1 + 872));
    v76 = *(float*)(a1 + 872) * 0.017453292;
    *(_DWORD*)(a1 + 876) = 1065353216;
    *(float*)(a1 + 872) = v76;
    if (sub_40ABC0(v72, aRollfactor, 0))
        sub_40AF60(v72, aRollfactor, (float*)(a1 + 876));
    v77 = operator new(0x148u);
    v78 = v77;
    v161[0] = (int)v77;
    LOBYTE(v162) = 5;
    if (v77)
    {
        sub_468FA0((int)v77);
        *v78 = &off_499224;
        v79 = v78;
    }
    else
    {
        v79 = 0;
    }
    v80 = *(const char**)v155;
    v81 = (int*)(a1 + 880);
    LOBYTE(v162) = 4;
    *(_DWORD*)(a1 + 880) = v79;
    v79[3] = aPath;
    strcpy((char*)(*(_DWORD*)(a1 + 880) + 16), v80);
    *(_DWORD*)(*v81 + 292) = *(_DWORD*)(a1 + 800);
    *(_DWORD*)(*v81 + 296) = *(_DWORD*)(a1 + 864);
    *(_DWORD*)(*v81 + 300) = *(_DWORD*)(a1 + 868);
    *(_DWORD*)(*v81 + 304) = *(_DWORD*)(a1 + 872);
    *(_DWORD*)(*v81 + 308) = *(_DWORD*)(a1 + 824);
    *(_DWORD*)(*v81 + 312) = *(_DWORD*)(a1 + 828);
    *(_DWORD*)(*v81 + 316) = *(_DWORD*)(a1 + 816);
    *(_DWORD*)(*v81 + 320) = *(_DWORD*)(a1 + 820);
    v82 = *(_DWORD*)(a1 + 292);
    v83 = !v82 || v82 == 3 || v82 == 4;
    *(_BYTE*)(*v81 + 324) = v83;
    sub_469700(*(_DWORD**)(dword_520970 + 200), *v81, aCustumPath);
    sub_469160(a1, (_DWORD*)(a1 + 880), 0, 0);
    v84 = k;
    v85 = k;
    *(_DWORD*)(a1 + 884) = 0;
    if (sub_40ABC0(v85, aPlanesmokeeffe, 0))
    {
        sub_40AFC0(v84, aPlanesmokeeffe, &String1);
        sub_469160(a1, (_DWORD*)(a1 + 884), String1, aEffect);
    }
    *(_DWORD*)(a1 + 888) = 0;
    if (sub_40ABC0(v84, aPlanefireeffec, 0))
    {
        sub_40AFC0(v84, aPlanefireeffec, &String1);
        sub_469160(a1, (_DWORD*)(a1 + 888), String1, aEffect);
    }
    *(_DWORD*)(a1 + 892) = 0;
    if (sub_40ABC0(v84, aPlaneexplodeef, 0))
    {
        sub_40AFC0(v84, aPlaneexplodeef, &String1);
        sub_469160(a1, (_DWORD*)(a1 + 892), String1, aEffect);
    }
    *(_DWORD*)(a1 + 896) = 0;
    if (sub_40ABC0(v84, aPlanesputteref, 0))
    {
        sub_40AFC0(v84, aPlanesputteref, &String1);
        sub_469160(a1, (_DWORD*)(a1 + 896), String1, aEffect);
    }
    *(_DWORD*)(a1 + 900) = 0;
    if (sub_40ABC0(v84, aBigimpacts, 0))
    {
        sub_40AFC0(v84, aBigimpacts, &String1);
        sub_469160(a1, (_DWORD*)(a1 + 900), String1, aImpacts);
    }
    *(_DWORD*)(a1 + 904) = 0;
    if (sub_40ABC0(v84, aSmallimpacts, 0))
    {
        sub_40AFC0(v84, aSmallimpacts, &String1);
        sub_469160(a1, (_DWORD*)(a1 + 904), String1, aImpacts);
    }
    *(_DWORD*)(a1 + 908) = 0;
    if (sub_40ABC0(v84, aEnginesound, 0))
    {
        sub_40AFC0(v84, aEnginesound, &String1);
        sub_469160(a1, (_DWORD*)(a1 + 908), String1, aSoundEffect);
    }
    *(_DWORD*)(a1 + 912) = 0;
    if (sub_40ABC0(v84, aRumblesound, 0))
    {
        sub_40AFC0(v84, aRumblesound, &String1);
        sub_469160(a1, (_DWORD*)(a1 + 912), String1, aSoundEffect);
    }
    *(_DWORD*)(a1 + 916) = 0;
    if (sub_40ABC0(v84, aSputtersound, 0))
    {
        sub_40AFC0(v84, aSputtersound, &String1);
        sub_469160(a1, (_DWORD*)(a1 + 916), String1, aSoundEffect);
    }
    v86 = *(_DWORD*)(a1 + 292);
    switch (v86)
    {
    case 0:
        *(_DWORD*)(a1 + 920) = 0;
        if (sub_40ABC0(v84, aSpecialattackt, 0))
            sub_40AF60(v84, aSpecialattackt, (float*)(a1 + 920));
        sub_40B1B0(v84, aTimetillattack, (float*)(a1 + 924));
        if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
        {
            v160 = *(_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
        }
        else
        {
            v87 = *(_DWORD*)(dword_520970 + 200);
            v161[0] = *(_DWORD*)(*(_DWORD*)(a1 + 564) + 8);
            v160 = *(_DWORD*)sub_46A4C0(v87, v161, 4u);
        }
        for (k = 0; (int)k < v160; ++k)
        {
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v88 = *(_DWORD**)(dword_520970 + 200);
                v89 = (int*)sub_46A4A0(v88, 4);
                v90 = (const char*)sub_46A4A0(v88, *v89);
            }
            else
            {
                v91 = *(_DWORD*)(dword_520970 + 200);
                v161[0] = strlen((const char*)sub_405C20(*(_DWORD**)(a1 + 564), (int)k));
                ++v161[0];
                v92 = *(_DWORD*)(dword_520970 + 200);
                v150 = *(_DWORD*)sub_46A4C0(v91, v161, 4u);
                v93 = (const void*)sub_405C20(*(_DWORD**)(a1 + 564), (int)k);
                v90 = (const char*)sub_46A4C0(v92, v93, v150);
            }
            v94 = (char*)v90;
            if (!_strnicmp(v90, aGun, 3u))
            {
                for (m = *v94; m; m = *++v94)
                {
                    if (m >= 48 && m <= 57)
                        break;
                    if (m == 45)
                        break;
                    if (m == 46)
                        break;
                }
                v159 = sub_48A1BB(v94);
                v96 = *(_DWORD*)(a1 + 936);
                v97 = 0;
                if (v96 > 0)
                {
                    v98 = *(int****)(a1 + 932);
                    do
                    {
                        if (**v98 == &v159)
                            break;
                        ++v97;
                        ++v98;
                    } while (v97 < v96);
                }
                if (v97 >= v96)
                {
                    v99 = operator new(0x14u);
                    if (v99)
                    {
                        v100 = v99;
                        *((_BYTE*)v99 + 4) = (_BYTE)k;
                        v99[2] = 0;
                        v99[3] = 0;
                        v99[4] = 0;
                    }
                    else
                    {
                        v100 = 0;
                    }
                    v101 = *(_DWORD*)(a1 + 940);
                    v102 = *(_DWORD*)(a1 + 936) + 1;
                    *(_DWORD*)(a1 + 936) = v102;
                    if (v102 > v101)
                    {
                        v103 = v101 + 8;
                        *(_DWORD*)(a1 + 940) = v103;
                        v104 = (char*)sub_488DD7(*(LPVOID*)(a1 + 932), 4 * v103);
                        if (v104)
                        {
                            v105 = *(_DWORD*)(a1 + 936);
                            v106 = *(_DWORD*)(a1 + 940) - v105;
                            *(_DWORD*)(a1 + 932) = v104;
                            memset(&v104[4 * v105], 0, 4 * v106);
                        }
                    }
                    *(_DWORD*)(*(_DWORD*)(a1 + 932) + 4 * *(_DWORD*)(a1 + 936) - 4) = v100;
                    v107 = (char*)operator new(0x40u);
                    sprintf(v107, "Airplane Gun %d", v159);
                    sub_469160(a1, v100, v107, aAirplaneGun);
                    sub_4885A6(v107);
                }
                v108 = *(_DWORD*)(*(_DWORD*)(a1 + 932) + 4 * v97);
                sub_44F190(v108 + 4, *(_DWORD**)(v108 + 12), 1u, &k);
            }
        }
        break;
    case 1:
        break;
    case 2:
        sub_40AF60(v84, aRangeopendoors, (float*)(a1 + 948));
        sub_40B1B0(v84, aRangedropbombs, (float*)(a1 + 952));
        if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
        {
            v109 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
        }
        else
        {
            v110 = *(_DWORD*)(dword_520970 + 200);
            v161[0] = sub_405A30(*(_DWORD**)(a1 + 564), aBay, -1, 1);
            v109 = (_DWORD*)sub_46A4C0(v110, v161, 4u);
        }
        *(_DWORD*)(a1 + 964) = *v109;
        if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            sub_40A120(*(_DWORD*)(a1 + 964) != -1, aExtradataDatHa);
        else
            sub_40A120(
                *(_DWORD*)(a1 + 964) != -1,
                "failed to find bomb bay node in model %s",
                (const char*)(*(_DWORD*)(a1 + 564) + 60));
        if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
        {
            v111 = *(_DWORD**)(dword_520970 + 200);
            v112 = (int*)sub_46A4A0(v111, 4);
            v113 = (char*)sub_46A4A0(v111, *v112);
        }
        else
        {
            v114 = *(_DWORD*)(dword_520970 + 200);
            v161[0] = strlen((const char*)sub_405C20(*(_DWORD**)(a1 + 564), *(_DWORD*)(a1 + 964)));
            ++v161[0];
            v115 = *(_DWORD*)(dword_520970 + 200);
            v151 = *(_DWORD*)sub_46A4C0(v114, v161, 4u);
            v116 = (const void*)sub_405C20(*(_DWORD**)(a1 + 564), *(_DWORD*)(a1 + 964));
            v113 = (char*)sub_46A4C0(v115, v116, v151);
        }
        v117 = v113;
        for (n = *v113; n; n = *++v117)
        {
            if (n >= 48 && n <= 57)
                break;
            if (n == 45)
                break;
            if (n == 46)
                break;
        }
        if (*v117)
        {
            v119 = sub_48A1BB(v117);
            v120 = (char*)operator new(0x40u);
            sprintf(v120, "Airplane Gun %d", v119);
            sub_469160(a1, (_DWORD*)(a1 + 960), v120, aAirplaneGun);
            sub_4885A6(v120);
        }
        else if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
        {
            sub_40A120(0, aTheFileExtrada);
        }
        else
        {
            sub_40A120(
                0,
                "failed to find bomb bay id number for a bomb bay in model file %s",
                (const char*)(*(_DWORD*)(a1 + 564) + 60));
        }
        *(_DWORD*)(a1 + 968) = 0;
        if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
        {
            v121 = (float*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
        }
        else
        {
            v122 = *(_DWORD*)(dword_520970 + 200);
            v161[0] = **(int**)(*(_DWORD*)(a1 + 564) + 48);
            v121 = (float*)sub_46A4C0(v122, v161, 4u);
        }
        v123 = *v121;
        v124 = *(_DWORD*)(a1 + 964);
        *(float*)(a1 + 972) = v123;
        while (1)
        {
            while (1)
            {
                *(_DWORD*)ArgList = v124 + 1;
                if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
                {
                    v125 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
                }
                else
                {
                    v126 = *(_DWORD*)(dword_520970 + 200);
                    v161[0] = *(_DWORD*)(*(_DWORD*)(a1 + 564) + 8);
                    v125 = (_DWORD*)sub_46A4C0(v126, v161, 4u);
                }
                if (*(int*)ArgList >= *v125
                    || (!sub_46A490(*(_BYTE**)(dword_520970 + 200))
                        ? (v128 = *(_DWORD*)(dword_520970 + 200),
                            v161[0] = sub_405BB0(*(_DWORD**)(a1 + 564), *(int*)ArgList),
                            v127 = (_DWORD*)sub_46A4C0(v128, v161, 4u))
                        : (v127 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4)),
                        *v127 < *(_DWORD*)(a1 + 964)))
                {
                    v143 = sub_46A490(*(_BYTE**)(dword_520970 + 200));
                    v144 = *(_DWORD*)(a1 + 980);
                    if (v143)
                    {
                        if (v144)
                            v146 = (*(_DWORD*)(a1 + 984) - v144) >> 2;
                        else
                            v146 = 0;
                        sub_40A120(v146 != 0, aTheExtradataDa);
                    }
                    else
                    {
                        if (v144)
                            v145 = (*(_DWORD*)(a1 + 984) - v144) >> 2;
                        else
                            v145 = 0;
                        sub_40A120(
                            v145 != 0,
                            "a bomber did not have any drop point nodes, see %s : %s : %s",
                            (const char*)(*(_DWORD*)(a1 + 564) + 60),
                            *(const char**)(a1 + 4),
                            *(const char**)v155);
                    }
                    *(_DWORD*)(a1 + 992) = 0;
                    if (sub_40ABC0(v84, aBombbayeffect, 0))
                    {
                        sub_40AFC0(v84, aBombbayeffect, &String1);
                        sub_469160(a1, (_DWORD*)(a1 + 992), String1, aEffect);
                    }
                    goto LABEL_301;
                }
                if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
                {
                    v129 = (_BYTE*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
                }
                else
                {
                    v130 = *(_DWORD*)(dword_520970 + 200);
                    v152 = sub_405BE0(*(_DWORD**)(a1 + 564), *(int*)ArgList);
                    v129 = (_BYTE*)sub_46A4C0(v130, &v152, 4u);
                }
                if (!*v129)
                {
                    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
                    {
                        v131 = (_BYTE*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
                    }
                    else
                    {
                        v132 = *(_DWORD*)(dword_520970 + 200);
                        v152 = sub_405C00(*(_DWORD**)(a1 + 564), *(int*)ArgList);
                        v131 = (_BYTE*)sub_46A4C0(v132, &v152, 4u);
                    }
                    if (!*v131)
                        break;
                }
            LABEL_273:
                v124 = *(_DWORD*)ArgList;
            }
            v133 = *(_DWORD**)(a1 + 984);
            v134 = v133;
            if ((*(_DWORD*)(a1 + 988) - (int)v133) >> 2)
            {
                sub_448B80(v133, v133, v133 + 1);
                sub_44B480(*(_DWORD**)(a1 + 984), (_DWORD*)(1 - ((*(_DWORD*)(a1 + 984) - (int)v134) >> 2)), ArgList);
                for (ii = *(_DWORD**)(a1 + 984); v134 != ii; ++v134)
                    *v134 = *(_DWORD*)ArgList;
                v84 = k;
                *(_DWORD*)(a1 + 984) += 4;
                goto LABEL_273;
            }
            v135 = *(_DWORD*)(a1 + 980);
            if (!v135 || (v136 = ((int)v133 - v135) >> 2, v136 <= 1))
                v136 = 1;
            v137 = sub_4481C0((_DWORD*)(a1 + 976));
            v138 = (int)(v136 + v137) < 0;
            v139 = v136 + v137;
            v160 = v139;
            if (v138)
                v139 = 0;
            v140 = operator new(4 * v139);
            v161[0] = (int)sub_448B80(*(_DWORD**)(a1 + 980), v134, v140);
            sub_44B480((_DWORD*)v161[0], (_DWORD*)1, ArgList);
            sub_448B80(v134, *(_DWORD**)(a1 + 984), (_DWORD*)(v161[0] + 4));
            nullsub_8(*(_DWORD*)(a1 + 980), *(_DWORD*)(a1 + 984));
            sub_4885A6(*(LPVOID*)(a1 + 980));
            *(_DWORD*)(a1 + 988) = &v140[v160];
            v141 = (int)&v140[sub_4481C0((_DWORD*)(a1 + 976)) + 1];
            *(_DWORD*)(a1 + 980) = v140;
            v84 = k;
            *(_DWORD*)(a1 + 984) = v141;
            v124 = *(_DWORD*)ArgList;
        }
    case 3:
        sub_40B1B0(v84, aTimetilldive, (float*)(a1 + 996));
        if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
        {
            v147 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
        }
        else
        {
            v148 = *(_DWORD*)(dword_520970 + 200);
            k = (char*)sub_405A30(*(_DWORD**)(a1 + 564), aBomb, -1, 1);
            v147 = (_DWORD*)sub_46A4C0(v148, &k, 4u);
        }
        *(_DWORD*)(a1 + 1004) = *v147;
        if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            sub_40A120(*(_DWORD*)(a1 + 1004) != -1, aTheExtradataDa);
        else
            sub_40A120(
                *(_DWORD*)(a1 + 1004) != -1,
                "could not find a bomb node for a DiveBomber, see %s : %s : %s",
                (const char*)(*(_DWORD*)(a1 + 564) + 60),
                *(const char**)(a1 + 4),
                *(const char**)v155);
        sub_40AFC0(v84, aDivebombbullet, v161);
        sub_469160(a1, (_DWORD*)(a1 + 1008), (const char*)v161[0], aBullet);
        *(_DWORD*)(a1 + 1012) = 0;
        if (sub_40ABC0(v84, aDivesound, 0))
        {
            sub_40AFC0(v84, aDivesound, &String1);
            sub_469160(a1, (_DWORD*)(a1 + 1012), String1, aSoundEffect);
        }
        if (*(_BYTE*)(a1 + 300))
            sub_40B1B0(v84, aRangedroptorpe, (float*)(a1 + 1016));
        break;
    case 4:
        sub_40B1B0(v84, aTimetillkamika, (float*)(a1 + 1024));
        break;
    case 5:
        sub_40AF60(v84, aSplashdamage, (float*)(a1 + 1032));
        sub_40AF60(v84, aSplashradius, (float*)(a1 + 1036));
        break;
    default:
        sub_40A120(0, "airplane type invalid, see file %s", *(const char**)v155);
        break;
    }
LABEL_301:
    sub_42A840((_DWORD*)a1);
    sub_4229D0("Finished loading %s in %s", *(const char**)(a1 + 4), *(const char**)v155);
    return a1;
}
// 42B201: conditional instruction was optimized away because eax.4!=0
// 499224: using guessed type _UNKNOWN *off_499224;
// 49940C: using guessed type _UNKNOWN *off_49940C;
// 4A621C: using guessed type int dword_4A621C;
// 4A6220: using guessed type char byte_4A6220;
// 520970: using guessed type int dword_520970;

//----- (0042CA00) --------------------------------------------------------
void __thiscall sub_42CA00(_BYTE* this)
{
    this[8] = HIBYTE(this);
    *((_DWORD*)this + 3) = 0;
    *((_DWORD*)this + 4) = 0;
    *((_DWORD*)this + 5) = 0;
}

//----- (0042CA20) --------------------------------------------------------
int __fastcall sub_42CA20(int a1)
{
    int result; // eax

    result = a1;
    *(_DWORD*)(a1 + 4) = 0;
    *(_DWORD*)(a1 + 8) = 0;
    *(_DWORD*)(a1 + 12) = 0;
    *(_BYTE*)(a1 + 16) = 1;
    *(_BYTE*)(a1 + 20) = HIBYTE(a1);
    *(_DWORD*)(a1 + 24) = 0;
    *(_DWORD*)(a1 + 28) = 0;
    *(_DWORD*)(a1 + 32) = 0;
    *(_BYTE*)(a1 + 36) = HIBYTE(a1);
    *(_DWORD*)(a1 + 40) = 0;
    *(_DWORD*)(a1 + 44) = 0;
    *(_DWORD*)(a1 + 48) = 0;
    *(_DWORD*)a1 = &off_49941C;
    return result;
}
// 49941C: using guessed type _UNKNOWN *off_49941C;

//----- (0042CB00) --------------------------------------------------------
char __thiscall sub_42CB00(void* this)
{
    sub_4113F0((_DWORD*)dword_4F5CC4, (int)this, 65280, 256, 0);
    return 1;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (0042CB20) --------------------------------------------------------
char __thiscall sub_42CB20(_DWORD* this, int a2)
{
    return sub_428620(this, a2);
}

//----- (0042CB30) --------------------------------------------------------
void __thiscall sub_42CB30(_DWORD* this, int ArgList, int a3)
{
    int v3; // ebp
    int v4; // edi
    int v6; // eax
    char v7; // al
    float* v8; // edi
    double v9; // st7
    double v10; // st6
    float v11; // ecx
    long double v12; // st7
    int v13; // edi
    int v14; // esi
    double v15; // st6
    double v16; // st7
    double v17; // st7
    _DWORD* v18; // edx
    int v19; // ebp
    _DWORD* v20; // ecx
    int v21; // esi
    double v22; // st7
    float* v23; // edi
    int v24; // ebx
    double v25; // st6
    float v26; // ebp
    long double v27; // st7
    int v28; // ecx
    _DWORD* v29; // edx
    char v30; // al
    int* v31; // edi
    double v32; // st7
    int v33; // ebp
    double v34; // st6
    int v35; // edi
    _DWORD* v36; // esi
    _DWORD* v37; // ecx
    int v38; // esi
    char v39; // bl
    int i; // esi
    int v41; // esi
    float* v42; // edi
    float* v43; // eax
    double v44; // st7
    double v45; // st6
    int v46; // esi
    double v47; // st7
    double v48; // st6
    double v49; // st7
    double v50; // st6
    double v51; // st7
    double v52; // st7
    double v53; // st6
    double v54; // st7
    double v55; // st7
    double v56; // st6
    double v57; // st7
    char v58; // al
    float* v59; // edi
    double v60; // st7
    double v61; // st6
    long double v62; // st7
    int v63; // edi
    int v64; // esi
    double v65; // st7
    double v66; // st7
    double v67; // st7
    _DWORD* v68; // eax
    int v69; // ebp
    _DWORD* v70; // ecx
    int v71; // esi
    double v72; // st7
    double v73; // st6
    long double v74; // st7
    int v75; // ecx
    int v76; // ecx
    _DWORD* v77; // eax
    int v78; // ebp
    double v79; // st7
    double v80; // st6
    long double v81; // st7
    double v82; // st7
    float v83; // edx
    float v84; // ecx
    long double v85; // st7
    double v86; // st7
    char* v87; // ecx
    int j; // esi
    double v89; // st7
    double v90; // st6
    int v91; // esi
    char* v92; // ecx
    double v93; // st7
    float v94; // edx
    float v95; // [esp+10h] [ebp-21Ch]
    float v96; // [esp+10h] [ebp-21Ch]
    int v97; // [esp+10h] [ebp-21Ch]
    float v98; // [esp+10h] [ebp-21Ch]
    float v99; // [esp+10h] [ebp-21Ch]
    float v100; // [esp+10h] [ebp-21Ch]
    float v101; // [esp+10h] [ebp-21Ch]
    float v102; // [esp+10h] [ebp-21Ch]
    float v103; // [esp+10h] [ebp-21Ch]
    float v104; // [esp+10h] [ebp-21Ch]
    char v105; // [esp+17h] [ebp-215h]
    char v106; // [esp+17h] [ebp-215h]
    char v107; // [esp+17h] [ebp-215h]
    float v108; // [esp+18h] [ebp-214h]
    float v109; // [esp+18h] [ebp-214h]
    float v110; // [esp+18h] [ebp-214h]
    int v111; // [esp+18h] [ebp-214h]
    float v112; // [esp+18h] [ebp-214h]
    float v113; // [esp+18h] [ebp-214h]
    float v114; // [esp+18h] [ebp-214h]
    float v115; // [esp+18h] [ebp-214h]
    float v116; // [esp+1Ch] [ebp-210h]
    float v117; // [esp+1Ch] [ebp-210h]
    float v118; // [esp+1Ch] [ebp-210h]
    float v119; // [esp+1Ch] [ebp-210h]
    float v120; // [esp+1Ch] [ebp-210h]
    float v121; // [esp+20h] [ebp-20Ch]
    int v122; // [esp+20h] [ebp-20Ch]
    float v123; // [esp+20h] [ebp-20Ch]
    float v124; // [esp+20h] [ebp-20Ch]
    float v125; // [esp+20h] [ebp-20Ch]
    float v126; // [esp+20h] [ebp-20Ch]
    float v127; // [esp+20h] [ebp-20Ch]
    float v128; // [esp+20h] [ebp-20Ch]
    float v129; // [esp+20h] [ebp-20Ch]
    float v130; // [esp+24h] [ebp-208h] BYREF
    float v131; // [esp+28h] [ebp-204h]
    float v132; // [esp+2Ch] [ebp-200h]
    float v133; // [esp+30h] [ebp-1FCh]
    float v134; // [esp+34h] [ebp-1F8h] BYREF
    float v135; // [esp+38h] [ebp-1F4h]
    float v136; // [esp+3Ch] [ebp-1F0h]
    int v137; // [esp+40h] [ebp-1ECh]
    float v138; // [esp+44h] [ebp-1E8h] BYREF
    float v139; // [esp+48h] [ebp-1E4h]
    float v140; // [esp+4Ch] [ebp-1E0h]
    float v141; // [esp+50h] [ebp-1DCh] BYREF
    float v142; // [esp+54h] [ebp-1D8h]
    float v143; // [esp+58h] [ebp-1D4h]
    int v144; // [esp+5Ch] [ebp-1D0h] BYREF
    float v145; // [esp+60h] [ebp-1CCh]
    float v146; // [esp+64h] [ebp-1C8h]
    float v147; // [esp+68h] [ebp-1C4h]
    float v148; // [esp+6Ch] [ebp-1C0h] BYREF
    float v149; // [esp+70h] [ebp-1BCh]
    float v150; // [esp+74h] [ebp-1B8h]
    float v151; // [esp+78h] [ebp-1B4h] BYREF
    float v152; // [esp+7Ch] [ebp-1B0h]
    char* v153; // [esp+80h] [ebp-1ACh]
    int v154; // [esp+84h] [ebp-1A8h]
    float v155; // [esp+88h] [ebp-1A4h] BYREF
    float v156; // [esp+8Ch] [ebp-1A0h]
    float v157; // [esp+90h] [ebp-19Ch]
    float v158; // [esp+94h] [ebp-198h]
    float v159; // [esp+98h] [ebp-194h]
    float v160; // [esp+9Ch] [ebp-190h]
    float v161; // [esp+A0h] [ebp-18Ch]
    float v162; // [esp+A4h] [ebp-188h] BYREF
    float v163; // [esp+A8h] [ebp-184h]
    int v164; // [esp+B4h] [ebp-178h]
    int v165; // [esp+B8h] [ebp-174h]
    int v166; // [esp+BCh] [ebp-170h]
    float v167; // [esp+C0h] [ebp-16Ch]
    float v168; // [esp+C4h] [ebp-168h]
    float v169; // [esp+C8h] [ebp-164h]
    float v170; // [esp+CCh] [ebp-160h]
    float v171; // [esp+D0h] [ebp-15Ch]
    float v172; // [esp+D4h] [ebp-158h]
    float v173; // [esp+D8h] [ebp-154h]
    float v174; // [esp+DCh] [ebp-150h]
    float v175; // [esp+E4h] [ebp-148h]
    float v176; // [esp+E8h] [ebp-144h]
    _DWORD v177[3]; // [esp+F0h] [ebp-13Ch] BYREF
    float v178; // [esp+FCh] [ebp-130h]
    float v179; // [esp+100h] [ebp-12Ch]
    float v180; // [esp+108h] [ebp-124h]
    float v181; // [esp+10Ch] [ebp-120h]
    float v182; // [esp+114h] [ebp-118h]
    float v183; // [esp+118h] [ebp-114h]
    float v184; // [esp+120h] [ebp-10Ch]
    float v185; // [esp+124h] [ebp-108h]
    float v186; // [esp+12Ch] [ebp-100h]
    float v187; // [esp+130h] [ebp-FCh]
    float v188; // [esp+138h] [ebp-F4h]
    float v189; // [esp+13Ch] [ebp-F0h]
    float v190; // [esp+144h] [ebp-E8h]
    float v191; // [esp+148h] [ebp-E4h]
    float v192; // [esp+150h] [ebp-DCh]
    float v193; // [esp+154h] [ebp-D8h]
    float v194; // [esp+15Ch] [ebp-D0h]
    float v195; // [esp+160h] [ebp-CCh]
    float v196; // [esp+168h] [ebp-C4h]
    float v197; // [esp+16Ch] [ebp-C0h]
    float v198; // [esp+174h] [ebp-B8h]
    float v199; // [esp+178h] [ebp-B4h]
    float v200; // [esp+180h] [ebp-ACh]
    float v201; // [esp+184h] [ebp-A8h]
    float v202; // [esp+18Ch] [ebp-A0h]
    float v203; // [esp+190h] [ebp-9Ch]
    float v204; // [esp+198h] [ebp-94h]
    float v205; // [esp+19Ch] [ebp-90h]
    float v206[3]; // [esp+1A4h] [ebp-88h] BYREF
    float v207; // [esp+1B0h] [ebp-7Ch]
    float v208; // [esp+1B4h] [ebp-78h]
    float v209[3]; // [esp+1BCh] [ebp-70h] BYREF
    float v210; // [esp+1C8h] [ebp-64h]
    float v211; // [esp+1CCh] [ebp-60h]
    float v212[3]; // [esp+1D4h] [ebp-58h] BYREF
    float v213; // [esp+1E0h] [ebp-4Ch]
    float v214; // [esp+1E4h] [ebp-48h]
    float v215; // [esp+1ECh] [ebp-40h]
    float v216; // [esp+1F0h] [ebp-3Ch]
    float v217; // [esp+1F8h] [ebp-34h]
    float v218; // [esp+1FCh] [ebp-30h]
    _DWORD v219[7]; // [esp+204h] [ebp-28h] BYREF
    int v220; // [esp+228h] [ebp-4h]

    v3 = ArgList;
    v4 = 0;
    if (ArgList <= 0)
        return;
    sub_4229D0("adding %d %s", ArgList, *(const char**)(a3 + 4));
    v6 = *(_DWORD*)(a3 + 292);
    switch (v6)
    {
    case 0:
        if (ArgList > 4)
        {
            do
            {
                v7 = v3;
                if (v3 >= 4)
                    v7 = 4;
                sub_42CB30(v7, a3);
                v3 -= 4;
            } while (v3 > 0);
            return;
        }
        v121 = fabs((double)rand() * 0.000030518509);
        v8 = &v162;
        do
        {
            *(_DWORD*)v8++ = sub_42FCC0(this, *(float*)&a3, v121, -1);
            --v3;
        } while (v3);
        if (*(float*)(a3 + 812) == 0.0)
            v9 = 40000.0;
        else
            v9 = *(float*)(a3 + 812);
        v122 = 0;
        v10 = *(float*)(*(_DWORD*)(LODWORD(v162) + 468) + 4288) * *(float*)(*(_DWORD*)(LODWORD(v162) + 468) + 4284);
        v145 = v9 + v10 + v10;
        do
        {
            v11 = *(float*)(a3 + 816);
            v147 = *(float*)(a3 + 820);
            if (v11 == v147)
                v133 = v11;
            else
                v133 = fabs((double)rand() * 0.000030518509) * (v147 - v11) + v11;
            v108 = *(float*)(a3 + 828) * -0.5;
            *(float*)&v137 = *(float*)(a3 + 828) * 0.5;
            if (v108 == *(float*)&v137)
                v12 = v108;
            else
                v12 = fabs((double)rand() * 0.000030518509) * (*(float*)&v137 - v108) + v108;
            v13 = 0;
            v109 = v12;
            *(float*)&v144 = v12;
            v146 = v133;
            while (1)
            {
                v14 = *((_DWORD*)&v162 + v13);
                v106 = 0;
                sub_4164A0(*(_DWORD*)(v14 + 468), 0);
                v130 = *(float*)&v144;
                v131 = v145;
                v132 = v146;
                if (v13)
                {
                    switch (v13)
                    {
                    case 1:
                        v15 = *(float*)(a3 + 784);
                        v149 = *(float*)(a3 + 784);
                        v130 = v15 + v109;
                        v131 = v149 + v131;
                        break;
                    case 2:
                        v16 = -*(float*)(a3 + 784);
                        v156 = *(float*)(a3 + 784);
                        v130 = v16 + v109;
                        v131 = v156 + v131;
                        break;
                    case 3:
                        v17 = *(float*)(a3 + 784) * -2.0;
                        v152 = *(float*)(a3 + 784) * 3.0;
                        v130 = v17 + v109;
                        v131 = v131 + v152;
                        break;
                    }
                }
                else
                {
                    v131 = v145;
                    v130 = v109;
                }
                if (!sub_416350(*(_DWORD*)(v14 + 468), &v130, 1))
                    break;
                v18 = *(_DWORD**)(v14 + 468);
                v138 = 0.0;
                v18 += 30;
                v139 = -1.0;
                *v18 = 0;
                v140 = 0.0;
                v18[1] = -1082130432;
                v19 = 0;
                v18[2] = 0;
                do
                {
                    v141 = 0.0;
                    v142 = -1.0;
                    v143 = 0.0;
                    if (!sub_4196F0(*(_DWORD*)(v14 + 468), &v141, 3.1415927, COERCE_FLOAT(1), 1, 0))
                        break;
                    if (*(float*)(sub_417140(*(_DWORD**)(v14 + 468), 0) + 4) < (double)*(float*)(a3 + 796))
                    {
                        v106 = 1;
                        break;
                    }
                } while (++v19 < 100);
                v20 = *(_DWORD**)(v14 + 468);
                v158 = *(float*)(a3 + 788);
                sub_419A30(v20, v158, 0.0, v158);
                if (!v106)
                    break;
                if (++v13 >= ArgList)
                    goto LABEL_199;
            }
            ++v122;
        } while (v122 < 100);
    LABEL_199:
        sub_4229D0("done adding %d %s", ArgList, *(const char**)(a3 + 4));
        return;
    case 1:
        if (ArgList > 1)
        {
            do
            {
                sub_42CB30(1, a3);
                --v3;
            } while (v3);
            return;
        }
        v95 = fabs((double)rand() * 0.000030518509);
        v21 = sub_42FCC0(this, *(float*)&a3, v95, -1);
        if (*(float*)(a3 + 812) == 0.0)
            v22 = 40000.0;
        else
            v22 = *(float*)(a3 + 812);
        v23 = (float*)a3;
        v24 = 0;
        v25 = *(float*)(*(_DWORD*)(v21 + 468) + 4288) * *(float*)(*(_DWORD*)(v21 + 468) + 4284);
        v135 = v22 + v25 + v25;
        v26 = v135;
        do
        {
            v116 = v23[204];
            v123 = v23[205];
            if (v116 == v123)
                v137 = *((int*)v23 + 204);
            else
                *(float*)&v137 = fabs((double)rand() * 0.000030518509) * (v123 - v116) + v116;
            v110 = v23[207] * -0.5;
            v133 = v23[207] * 0.5;
            if (v110 == v133)
                v27 = v110;
            else
                v27 = fabs((double)rand() * 0.000030518509) * (v133 - v110) + v110;
            v134 = v27;
            v136 = *(float*)&v137;
            sub_4164A0(*(_DWORD*)(v21 + 468), 0);
            v28 = *(_DWORD*)(v21 + 468);
            v141 = v134;
            v142 = v26;
            v143 = *(float*)&v137;
            if (sub_416350(v28, &v141, 1))
            {
                v29 = *(_DWORD**)(v21 + 468);
                v130 = 0.0;
                v29 += 30;
                v131 = -1.0;
                *v29 = 0;
                v132 = 0.0;
                v29[1] = -1082130432;
                v29[2] = 0;
                if (sub_416F80(*(_DWORD**)(v21 + 468), 0))
                    goto LABEL_199;
                v23 = (float*)a3;
            }
            ++v24;
        } while (v24 < 100);
        goto LABEL_199;
    case 2:
        if (ArgList > 7)
        {
            do
            {
                v30 = v3;
                if (v3 >= 7)
                    v30 = 7;
                sub_42CB30(v30, a3);
                v3 -= 7;
            } while (v3 > 0);
            return;
        }
        v96 = fabs((double)rand() * 0.000030518509);
        v31 = v219;
        do
        {
            *v31++ = sub_42FCC0(this, *(float*)&a3, v96, -1);
            --v3;
        } while (v3);
        if (*(float*)(a3 + 812) == 0.0)
            v32 = 40000.0;
        else
            v32 = *(float*)(a3 + 812);
        v33 = v219[0];
        *(float*)&v137 = 0.0;
        v34 = *(float*)(*(_DWORD*)(v219[0] + 468) + 4288) * *(float*)(*(_DWORD*)(v219[0] + 468) + 4284);
        v147 = v34 + v34 + v32;
        while (1)
        {
            v35 = ArgList;
            v36 = v219;
            do
            {
                sub_4164A0(*(_DWORD*)(*v36++ + 468), 0);
                --v35;
            } while (v35);
            v117 = *(float*)(a3 + 816);
            v124 = *(float*)(a3 + 820);
            if (v117 == v124)
                v133 = *(float*)(a3 + 816);
            else
                v133 = fabs((double)rand() * 0.000030518509) * (v124 - v117) + v117;
            v97 = rand();
            v168 = v147;
            *(float*)&v177[1] = v147;
            *(float*)&v177[2] = v133;
            v169 = v133;
            v167 = fabs((double)v97 * 0.000030518509) * 5000.0 - 2500.0;
            *(float*)v177 = v167;
            if (!sub_416350(*(_DWORD*)(v33 + 468), v177, 1))
                goto LABEL_199;
            v37 = *(_DWORD**)(v33 + 468);
            *(float*)&v144 = 0.0;
            v37 += 30;
            v145 = -1.0;
            *v37 = 0;
            v146 = 0.0;
            v38 = 0;
            v37[1] = -1082130432;
            v37[2] = 0;
            while (1)
            {
                v206[0] = 0.0;
                v206[1] = -1.0;
                v206[2] = 0.0;
                if (!sub_4196F0(*(_DWORD*)(v33 + 468), v206, 3.1415927, COERCE_FLOAT(1), 1, 0))
                    goto LABEL_113;
                if (*(float*)(sub_417140(*(_DWORD**)(v33 + 468), 0) + 4) < -10000.0)
                    break;
                if (++v38 >= 100)
                    goto LABEL_113;
            }
            v39 = 0;
            for (i = 0; i < 100; ++i)
            {
                v209[0] = 0.0;
                v209[1] = 1.0;
                v209[2] = 0.0;
                if (!sub_4196F0(*(_DWORD*)(v33 + 468), v209, 3.1415927, COERCE_FLOAT(1), 1, 0))
                    break;
                if (*(float*)(sub_417140(*(_DWORD**)(v33 + 468), 0) + 4) > 10000.0)
                {
                    v39 = 1;
                    break;
                }
            }
            v111 = 0;
            if (*(int*)(*(_DWORD*)(v33 + 468) + 4132) > 0)
                break;
            if (v39)
                goto LABEL_199;
        LABEL_113:
            if (++v137 >= 100)
                goto LABEL_199;
        }
        v41 = 0;
        while (1)
        {
            v42 = (float*)sub_417120(*(void**)(v33 + 468), v41);
            if (v41 <= 2)
            {
                v164 = 0;
                v165 = -1082130432;
                v166 = 0;
                v134 = 0.0;
                v135 = -1.0;
                v136 = 0.0;
            }
            else
            {
                v43 = (float*)sub_417120(*(void**)(v33 + 468), v41 - 1);
                v44 = v42[2] - v43[2];
                v45 = v42[1] - v43[1];
                v212[0] = *v42 - *v43;
                v212[1] = v45;
                v212[2] = v44;
                sub_46B970(&v134, v212);
            }
            v46 = 1;
            v140 = 0.0;
            v138 = v135 - 0.0;
            v139 = 0.0 - v134;
            if (ArgList > 1)
                break;
        LABEL_110:
            v41 = v111 + 1;
            v111 = v41;
            if (v41 >= *(_DWORD*)(*(_DWORD*)(v33 + 468) + 4132))
                goto LABEL_199;
        }
        while (1)
        {
            v130 = *v42;
            v131 = v42[1];
            v132 = v42[2];
            if (v46 == 1)
                break;
            switch (v46)
            {
            case 2:
                v51 = -*(float*)(a3 + 784);
                v210 = v134 * v51;
                v211 = v51 * v135;
                v170 = v210 + v210;
                v171 = v211 + v211;
                v172 = v51 * v136 + v51 * v136;
                v184 = v51 * v138;
                v185 = v51 * v139;
                v204 = v184 + v170;
                v205 = v185 + v171;
                v49 = v51 * v140 + v172;
                v130 = v204 + v130;
                v50 = v131 + v205;
                goto LABEL_107;
            case 3:
                v52 = -*(float*)(a3 + 784);
                v188 = v52 * v134;
                v189 = v52 * v135;
                v207 = v188 * 4.0;
                v208 = v189 * 4.0;
                v53 = *(float*)(a3 + 784);
                v217 = v53 * v138;
                v218 = v53 * v139;
                v192 = v217 + v217;
                v193 = v218 + v218;
                v196 = v192 + v207;
                v197 = v193 + v208;
                v49 = v52 * v136 * 4.0 + v53 * v140 + v53 * v140;
                v130 = v196 + v130;
                v50 = v131 + v197;
                goto LABEL_107;
            case 4:
                v54 = -*(float*)(a3 + 784);
                v213 = v54 * v134;
                v214 = v54 * v135;
                v159 = v213 * 4.0;
                v160 = v214 * 4.0;
                v161 = v54 * v136 * 4.0;
                v175 = v54 * v138;
                v176 = v54 * v139;
                v178 = v175 + v175;
                v179 = v176 + v176;
                v182 = v178 + v159;
                v183 = v179 + v160;
                v49 = v54 * v140 + v54 * v140 + v161;
                v130 = v182 + v130;
                v50 = v131 + v183;
                goto LABEL_107;
            case 5:
                v55 = -*(float*)(a3 + 784);
                v186 = v55 * v134;
                v187 = v55 * v135;
                v198 = v186 * 6.0;
                v199 = v187 * 6.0;
                v56 = *(float*)(a3 + 784);
                v190 = v56 * v138;
                v191 = v56 * v139;
                v194 = v190 * 3.0;
                v195 = v191 * 3.0;
                v202 = v194 + v198;
                v203 = v195 + v199;
                v49 = v55 * v136 * 6.0 + v56 * v140 * 3.0;
                v130 = v202 + v130;
                v50 = v131 + v203;
                goto LABEL_107;
            case 6:
                v57 = -*(float*)(a3 + 784);
                v162 = v57 * v134;
                v163 = v57 * v135;
                v141 = v162 * 6.0;
                v142 = v163 * 6.0;
                v143 = v57 * v136 * 6.0;
                v151 = v57 * v138;
                v152 = v57 * v139;
                v155 = v151 * 3.0;
                v156 = v152 * 3.0;
                v148 = v155 + v141;
                v149 = v156 + v142;
                v49 = v57 * v140 * 3.0 + v143;
                v130 = v148 + v130;
                v50 = v131 + v149;
                goto LABEL_107;
            }
        LABEL_108:
            if (!sub_416350(*(_DWORD*)(v219[v46] + 468), &v130, 1))
                goto LABEL_113;
            if (++v46 >= ArgList)
                goto LABEL_110;
        }
        v47 = -*(float*)(a3 + 784);
        v215 = v134 * v47;
        v216 = v47 * v135;
        v200 = v215 + v215;
        v201 = v216 + v216;
        v48 = *(float*)(a3 + 784);
        v173 = v48 * v138;
        v174 = v48 * v139;
        v180 = v173 + v200;
        v181 = v174 + v201;
        v49 = v47 * v136 + v47 * v136 + v48 * v140;
        v130 = v180 + v130;
        v50 = v131 + v181;
    LABEL_107:
        v131 = v50;
        v132 = v132 + v49;
        goto LABEL_108;
    }
    if (v6 != 3)
    {
        if (v6 == 4)
        {
            if (ArgList > 1)
            {
                do
                {
                    sub_42CB30(1, a3);
                    --v3;
                } while (v3);
                return;
            }
            v99 = fabs((double)rand() * 0.000030518509);
            v71 = sub_42FCC0(this, *(float*)&a3, v99, -1);
            if (*(float*)(a3 + 812) == 0.0)
                v72 = 40000.0;
            else
                v72 = *(float*)(a3 + 812);
            v73 = *(float*)(*(_DWORD*)(v71 + 468) + 4288) * *(float*)(*(_DWORD*)(v71 + 468) + 4284);
            v142 = v72 + v73 + v73;
            do
            {
                v119 = *(float*)(a3 + 816);
                v126 = *(float*)(a3 + 820);
                if (v119 == v126)
                    v137 = *(int*)(a3 + 816);
                else
                    *(float*)&v137 = fabs((double)rand() * 0.000030518509) * (v126 - v119) + v119;
                v114 = *(float*)(a3 + 828) * -0.5;
                v133 = *(float*)(a3 + 828) * 0.5;
                if (v114 == v133)
                    v74 = v114;
                else
                    v74 = fabs((double)rand() * 0.000030518509) * (v133 - v114) + v114;
                v75 = *(_DWORD*)(v71 + 468);
                v141 = v74;
                v143 = *(float*)&v137;
                sub_4164A0(v75, 0);
                v150 = *(float*)&v137;
                v76 = *(_DWORD*)(v71 + 468);
                v148 = v141;
                v149 = v142;
                if (sub_416350(v76, &v148, 1))
                {
                    v77 = *(_DWORD**)(v71 + 468);
                    v141 = 0.0;
                    v77 += 30;
                    v142 = -1.0;
                    *v77 = 0;
                    v143 = 0.0;
                    v77[1] = -1082130432;
                    v77[2] = 0;
                    goto LABEL_199;
                }
                ++v4;
            } while (v4 < 100);
        }
        else
        {
            if (v6 != 5)
                goto LABEL_199;
            if (ArgList > 1)
            {
                do
                {
                    sub_42CB30(1, a3);
                    --v3;
                } while (v3);
                return;
            }
            v100 = fabs((double)rand() * 0.000030518509);
            v78 = sub_42FCC0(this, *(float*)&a3, v100, -1);
            if (*(float*)(a3 + 812) == 0.0)
                v79 = 40000.0;
            else
                v79 = *(float*)(a3 + 812);
            v80 = *(float*)(*(_DWORD*)(v78 + 468) + 4288) * *(float*)(*(_DWORD*)(v78 + 468) + 4284);
            v127 = *(float*)(a3 + 828);
            v133 = v80 + v80 + v79;
            if (0.0 == v127)
                v81 = 0.0;
            else
                v81 = fabs((double)rand() * 0.000030518509) * v127;
            v145 = v81;
            *(float*)&v144 = 0.0;
            v146 = 0.0;
            v101 = fabs((double)rand() * 0.000030518509) * 6.2831855;
            sub_401000((float*)&v144, v101);
            v82 = sub_468BE0((int*)*(_DWORD*)(dword_520970 + 260), v144, SLODWORD(v145), 0);
            v83 = *(float*)(a3 + 816);
            v84 = *(float*)(a3 + 820);
            v146 = v82;
            if (v83 == v84)
                v115 = v83;
            else
                v115 = (v84 - v83) * fabs((double)rand() * 0.000030518509) + v83;
            v120 = *(float*)(a3 + 840);
            v128 = *(float*)(a3 + 844);
            if (v120 == v128)
                v85 = v120;
            else
                v85 = fabs((double)rand() * 0.000030518509) * (v128 - v120) + v120;
            v102 = v85 + v145;
            v148 = *(float*)&v144;
            v138 = *(float*)&v144 - *(float*)&v144;
            v139 = v102 - v145;
            v140 = v115 - v146;
            sub_46B970(&v138, &v138);
            v86 = *(float*)(*(_DWORD*)(v78 + 468) + 4288) * *(float*)(*(_DWORD*)(v78 + 468) + 4284);
            LOBYTE(v151) = v105;
            v152 = 0.0;
            v153 = 0;
            v154 = 0;
            v138 = v138 * v86;
            v139 = v86 * v139;
            v140 = v86 * v140;
            v220 = 0;
            v103 = v139 + v139;
            v129 = v138 + v138;
            v148 = *(float*)&v144 - v129;
            v149 = v145 - v103;
            v150 = v146 - (v140 + v140);
            sub_45C920(&v151, 0, 1u, &v148);
            v87 = v153;
            for (j = 0; j < 100; ++j)
            {
                v89 = v140 + *((float*)v87 - 1);
                v90 = v139 + *((float*)v87 - 2);
                v148 = v138 + *((float*)v87 - 3);
                v149 = v90;
                v150 = v89;
                sub_45C920(&v151, v87, 1u, &v148);
                v87 = v153;
                if (*((float*)v153 - 1) >= (double)v115)
                    break;
            }
            v91 = 0;
            *((float*)v153 - 1) = v115;
            v92 = v153;
            v104 = *(float*)(*(_DWORD*)(v78 + 468) + 4288) * *(float*)(*(_DWORD*)(v78 + 468) + 4284);
            do
            {
                v93 = *((float*)v92 - 1);
                v94 = *((float*)v92 - 3);
                v156 = v104 + *((float*)v92 - 2);
                v155 = v94;
                v157 = v93;
                sub_45C920(&v151, v92, 1u, &v155);
                v92 = v153;
                if (*((float*)v153 - 2) >= (double)v133)
                    break;
                ++v91;
            } while (v91 < 100);
            while (v152 != 0.0 && (int)&v92[-LODWORD(v152)] / 12)
            {
                sub_416350(*(_DWORD*)(v78 + 468), (_DWORD*)v92 - 3, 0);
                v92 = v153 - 12;
                v153 -= 12;
            }
            v220 = -1;
            sub_4885A6((LPVOID)LODWORD(v152));
            v152 = 0.0;
            v153 = 0;
            v154 = 0;
        }
        goto LABEL_199;
    }
    if (ArgList <= 4)
    {
        v98 = fabs((double)rand() * 0.000030518509);
        v59 = &v162;
        do
        {
            *(_DWORD*)v59++ = sub_42FCC0(this, *(float*)&a3, v98, -1);
            --v3;
        } while (v3);
        if (*(float*)(a3 + 812) == 0.0)
            v60 = 40000.0;
        else
            v60 = *(float*)(a3 + 812);
        v147 = 0.0;
        v61 = *(float*)(*(_DWORD*)(LODWORD(v162) + 468) + 4288) * *(float*)(*(_DWORD*)(LODWORD(v162) + 468) + 4284);
        v142 = v60 + v61 + v61;
        while (1)
        {
            v118 = *(float*)(a3 + 816);
            v125 = *(float*)(a3 + 820);
            if (v118 == v125)
                v137 = *(int*)(a3 + 816);
            else
                *(float*)&v137 = fabs((double)rand() * 0.000030518509) * (v125 - v118) + v118;
            v112 = *(float*)(a3 + 828) * -0.5;
            v133 = *(float*)(a3 + 828) * 0.5;
            if (v112 == v133)
                v62 = v112;
            else
                v62 = fabs((double)rand() * 0.000030518509) * (v133 - v112) + v112;
            v113 = v62;
            v141 = v62;
            v63 = 0;
            v143 = *(float*)&v137;
            while (1)
            {
                v64 = *((_DWORD*)&v162 + v63);
                v107 = 0;
                sub_4164A0(*(_DWORD*)(v64 + 468), 0);
                v134 = v141;
                v135 = v142;
                v136 = v143;
                if (v63)
                {
                    if (v63 != 1)
                    {
                        if (v63 == 2)
                        {
                            v66 = *(float*)(a3 + 784);
                            v156 = v66 * -2.0;
                            v134 = v66 + v113;
                            v135 = v135 + v156;
                        }
                        else if (v63 == 3)
                        {
                            v67 = -*(float*)(a3 + 784);
                            v152 = *(float*)(a3 + 784) * -2.0;
                            v134 = v67 + v113;
                            v135 = v135 + v152;
                        }
                        goto LABEL_143;
                    }
                    v65 = -*(float*)(a3 + 784);
                }
                else
                {
                    v65 = *(float*)(a3 + 784);
                }
                v134 = v65 + v113;
            LABEL_143:
                if (!sub_416350(*(_DWORD*)(v64 + 468), &v134, 1))
                    break;
                v68 = *(_DWORD**)(v64 + 468);
                v159 = 0.0;
                v68 += 30;
                v160 = -1.0;
                *v68 = 0;
                v161 = 0.0;
                v68[1] = -1082130432;
                v69 = 0;
                v68[2] = 0;
                do
                {
                    v148 = 0.0;
                    v149 = -1.0;
                    v150 = 0.0;
                    if (!sub_4196F0(*(_DWORD*)(v64 + 468), &v148, 3.1415927, COERCE_FLOAT(1), 1, 0))
                        break;
                    if (*(float*)(sub_417140(*(_DWORD**)(v64 + 468), 0) + 4) < (double)*(float*)(a3 + 796))
                    {
                        v107 = 1;
                        break;
                    }
                } while (++v69 < 100);
                v70 = *(_DWORD**)(v64 + 468);
                v158 = *(float*)(a3 + 788);
                sub_419A30(v70, v158, 0.0, v158);
                if (!v107)
                    break;
                if (++v63 >= ArgList)
                    goto LABEL_199;
            }
            ++LODWORD(v147);
            if (SLODWORD(v147) >= 100)
                goto LABEL_199;
        }
    }
    do
    {
        v58 = v3;
        if (v3 >= 4)
            v58 = 4;
        sub_42CB30(v58, a3);
        v3 -= 4;
    } while (v3 > 0);
}
// 42CD03: conditional instruction was optimized away because %ArgList.4>=1
// 42CF07: conditional instruction was optimized away because %var_215.1==1
// 42D1BF: conditional instruction was optimized away because %ArgList.4>=1
// 42DC3C: conditional instruction was optimized away because %ArgList.4>=1
// 42DE45: conditional instruction was optimized away because %var_215.1==1
// 42CBCA: conditional instruction was optimized away because %ArgList.4 is in (1..4)
// 42D14C: conditional instruction was optimized away because %ArgList.4 is in (1..7)
// 42DAF1: conditional instruction was optimized away because %ArgList.4 is in (1..4)
// 42E24E: variable 'v105' is possibly undefined
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);
// 520970: using guessed type int dword_520970;

//----- (0042E480) --------------------------------------------------------
void __thiscall sub_42E480(_DWORD* this, int ArgList, int a3, void* a4)
{
    int v5; // edi
    float v6; // ebx
    _DWORD* v7; // esi
    _DWORD* v8; // eax
    int v9; // ebx
    double v10; // st7
    int v11; // ebp
    double v12; // st6
    _DWORD* v13; // esi
    int v14; // edi
    float v15; // eax
    long double v16; // st7
    double v17; // st6
    _DWORD* v18; // ecx
    int v19; // esi
    int v20; // eax
    float v21; // edx
    int v22; // eax
    char v23; // bl
    int v24; // esi
    int v25; // edx
    int v26; // edi
    float* v27; // ebx
    float* v28; // eax
    double v29; // st7
    double v30; // st6
    int v31; // esi
    double v32; // st7
    double v33; // st7
    double v34; // st7
    double v35; // st7
    double v36; // st7
    double v37; // st7
    double v38; // st7
    double v39; // st7
    double v40; // st7
    double v41; // st7
    float* v42; // eax
    float* v43; // eax
    float* v44; // eax
    int v45; // ecx
    float v46; // [esp+0h] [ebp-228h]
    int v47; // [esp+8h] [ebp-220h]
    int v48; // [esp+8h] [ebp-220h]
    int v49; // [esp+8h] [ebp-220h]
    int v50; // [esp+8h] [ebp-220h]
    int v51; // [esp+8h] [ebp-220h]
    int v52; // [esp+8h] [ebp-220h]
    int v53; // [esp+8h] [ebp-220h]
    int v54; // [esp+8h] [ebp-220h]
    int v55; // [esp+8h] [ebp-220h]
    int v56; // [esp+8h] [ebp-220h]
    int v57; // [esp+8h] [ebp-220h]
    int v58; // [esp+8h] [ebp-220h]
    int v59; // [esp+8h] [ebp-220h]
    int v60; // [esp+8h] [ebp-220h]
    int v61; // [esp+8h] [ebp-220h]
    int v62; // [esp+8h] [ebp-220h]
    int v63; // [esp+8h] [ebp-220h]
    int v64; // [esp+8h] [ebp-220h]
    int v65; // [esp+8h] [ebp-220h]
    int v66; // [esp+8h] [ebp-220h]
    int v67; // [esp+8h] [ebp-220h]
    float v68; // [esp+8h] [ebp-220h]
    int v69; // [esp+Ch] [ebp-21Ch]
    int v70; // [esp+Ch] [ebp-21Ch]
    int v71; // [esp+Ch] [ebp-21Ch]
    int v72; // [esp+Ch] [ebp-21Ch]
    int v73; // [esp+Ch] [ebp-21Ch]
    int v74; // [esp+Ch] [ebp-21Ch]
    int v75; // [esp+Ch] [ebp-21Ch]
    int v76; // [esp+Ch] [ebp-21Ch]
    int v77; // [esp+Ch] [ebp-21Ch]
    int v78; // [esp+Ch] [ebp-21Ch]
    int v79; // [esp+Ch] [ebp-21Ch]
    int v80; // [esp+Ch] [ebp-21Ch]
    int v81; // [esp+Ch] [ebp-21Ch]
    int v82; // [esp+Ch] [ebp-21Ch]
    int v83; // [esp+Ch] [ebp-21Ch]
    int v84; // [esp+Ch] [ebp-21Ch]
    int v85; // [esp+Ch] [ebp-21Ch]
    int v86; // [esp+Ch] [ebp-21Ch]
    int v87; // [esp+Ch] [ebp-21Ch]
    int v88; // [esp+Ch] [ebp-21Ch]
    int v89; // [esp+Ch] [ebp-21Ch]
    int v90; // [esp+10h] [ebp-218h]
    int v91; // [esp+10h] [ebp-218h]
    int v92; // [esp+10h] [ebp-218h]
    int v93; // [esp+10h] [ebp-218h]
    int v94; // [esp+10h] [ebp-218h]
    int v95; // [esp+10h] [ebp-218h]
    int v96; // [esp+10h] [ebp-218h]
    int v97; // [esp+10h] [ebp-218h]
    int v98; // [esp+10h] [ebp-218h]
    int v99; // [esp+10h] [ebp-218h]
    int v100; // [esp+10h] [ebp-218h]
    int v101; // [esp+10h] [ebp-218h]
    int v102; // [esp+10h] [ebp-218h]
    int v103; // [esp+10h] [ebp-218h]
    int v104; // [esp+10h] [ebp-218h]
    int v105; // [esp+10h] [ebp-218h]
    int v106; // [esp+10h] [ebp-218h]
    int v107; // [esp+10h] [ebp-218h]
    int v108; // [esp+10h] [ebp-218h]
    int v109; // [esp+10h] [ebp-218h]
    int v110; // [esp+10h] [ebp-218h]
    float* v111; // [esp+10h] [ebp-218h]
    float* v112; // [esp+10h] [ebp-218h]
    float v113; // [esp+24h] [ebp-204h] BYREF
    float v114; // [esp+28h] [ebp-200h]
    float v115; // [esp+2Ch] [ebp-1FCh]
    float v116; // [esp+30h] [ebp-1F8h] BYREF
    float v117; // [esp+34h] [ebp-1F4h]
    float v118; // [esp+38h] [ebp-1F0h]
    float v119; // [esp+3Ch] [ebp-1ECh]
    float v120; // [esp+40h] [ebp-1E8h] BYREF
    float v121; // [esp+44h] [ebp-1E4h]
    float v122; // [esp+48h] [ebp-1E0h]
    float v123; // [esp+4Ch] [ebp-1DCh]
    int v124; // [esp+50h] [ebp-1D8h]
    float v125; // [esp+54h] [ebp-1D4h]
    float v126; // [esp+58h] [ebp-1D0h]
    float v127; // [esp+5Ch] [ebp-1CCh] BYREF
    float v128; // [esp+60h] [ebp-1C8h]
    float v129; // [esp+64h] [ebp-1C4h]
    float v130; // [esp+68h] [ebp-1C0h]
    float v131; // [esp+6Ch] [ebp-1BCh]
    int v132; // [esp+70h] [ebp-1B8h]
    float v133; // [esp+74h] [ebp-1B4h]
    float v134; // [esp+78h] [ebp-1B0h]
    float v135; // [esp+7Ch] [ebp-1ACh]
    float v136; // [esp+80h] [ebp-1A8h]
    float v137; // [esp+84h] [ebp-1A4h]
    float v138; // [esp+88h] [ebp-1A0h]
    float v139; // [esp+8Ch] [ebp-19Ch]
    float v140; // [esp+90h] [ebp-198h]
    int v141; // [esp+94h] [ebp-194h]
    float v142[3]; // [esp+98h] [ebp-190h] BYREF
    float v143[4]; // [esp+A4h] [ebp-184h] BYREF
    float v144; // [esp+B4h] [ebp-174h]
    float v145; // [esp+B8h] [ebp-170h]
    float v146; // [esp+BCh] [ebp-16Ch] BYREF
    float v147; // [esp+C0h] [ebp-168h]
    float v148; // [esp+C4h] [ebp-164h]
    float v149[3]; // [esp+C8h] [ebp-160h] BYREF
    float v150[3]; // [esp+D4h] [ebp-154h] BYREF
    float v151[3]; // [esp+E0h] [ebp-148h] BYREF
    float v152[3]; // [esp+ECh] [ebp-13Ch] BYREF
    float v153; // [esp+F8h] [ebp-130h] BYREF
    float v154; // [esp+FCh] [ebp-12Ch]
    float v155; // [esp+100h] [ebp-128h]
    float v156[4]; // [esp+104h] [ebp-124h] BYREF
    float v157; // [esp+114h] [ebp-114h]
    float v158; // [esp+118h] [ebp-110h]
    float v159[3]; // [esp+11Ch] [ebp-10Ch] BYREF
    float v160[3]; // [esp+128h] [ebp-100h] BYREF
    float v161[3]; // [esp+134h] [ebp-F4h] BYREF
    float v162[3]; // [esp+140h] [ebp-E8h] BYREF
    float v163[3]; // [esp+14Ch] [ebp-DCh] BYREF
    float v164[3]; // [esp+158h] [ebp-D0h] BYREF
    float v165[3]; // [esp+164h] [ebp-C4h] BYREF
    float v166; // [esp+170h] [ebp-B8h]
    float v167; // [esp+174h] [ebp-B4h]
    float v168; // [esp+17Ch] [ebp-ACh] BYREF
    float v169; // [esp+180h] [ebp-A8h]
    float v170; // [esp+184h] [ebp-A4h]
    float v171[3]; // [esp+188h] [ebp-A0h] BYREF
    float v172[3]; // [esp+194h] [ebp-94h] BYREF
    _DWORD v173[3]; // [esp+1A0h] [ebp-88h] BYREF
    float v174[3]; // [esp+1ACh] [ebp-7Ch] BYREF
    float v175[3]; // [esp+1B8h] [ebp-70h] BYREF
    float v176[3]; // [esp+1C4h] [ebp-64h] BYREF
    _DWORD v177[7]; // [esp+1D0h] [ebp-58h] BYREF
    float v178[3]; // [esp+1ECh] [ebp-3Ch] BYREF
    float v179[3]; // [esp+1F8h] [ebp-30h] BYREF
    float v180[3]; // [esp+204h] [ebp-24h] BYREF
    float v181[3]; // [esp+210h] [ebp-18h] BYREF
    float v182[3]; // [esp+21Ch] [ebp-Ch] BYREF

    if (ArgList > 0)
    {
        sub_4229D0("SpecialAttackBombingRun: %d %s", ArgList, (const char*)a3);
        v119 = fabs((double)rand() * 0.000030518509);
        v5 = ArgList;
        v6 = v119;
        v7 = v177;
        do
        {
            v8 = (_DWORD*)sub_42FCC0(this, *(float*)&a3, v6, -1);
            *v7 = v8;
            v8 += 104;
            ++v7;
            --v5;
            *v8 = *(_DWORD*)a4;
            v8[1] = *((_DWORD*)a4 + 1);
            v8[2] = *((_DWORD*)a4 + 2);
        } while (v5);
        v9 = ArgList;
        if (*(float*)(a3 + 812) == 0.0)
            v10 = 40000.0;
        else
            v10 = *(float*)(a3 + 812);
        v11 = v177[0];
        v119 = 0.0;
        v12 = *(float*)(*(_DWORD*)(v177[0] + 468) + 4288) * *(float*)(*(_DWORD*)(v177[0] + 468) + 4284);
        v125 = v12 + v12 + v10;
        do
        {
            v13 = v177;
            v14 = v9;
            do
            {
                sub_4164A0(*(_DWORD*)(*v13++ + 468), 0);
                --v14;
            } while (v14);
            v15 = *(float*)(a3 + 820);
            v123 = *(float*)(a3 + 816);
            v126 = v15;
            if (v123 == v15)
            {
                v16 = v123;
            }
            else
            {
                v124 = rand();
                v16 = fabs((double)v124 * 0.000030518509) * (v126 - v123) + v123;
            }
            v17 = -*(float*)a4;
            v157 = -*((float*)a4 + 1);
            v158 = -*((float*)a4 + 2);
            v144 = v157 * v125;
            v137 = v144;
            v145 = v158 * v125;
            *(float*)&v173[1] = v144;
            v136 = v17 * v125;
            *(float*)v173 = v136;
            v138 = v145 + v16;
            *(float*)&v173[2] = v138;
            if (!sub_416350(*(_DWORD*)(v11 + 468), v173, 1))
                break;
            v18 = (_DWORD*)(*(_DWORD*)(v11 + 468) + 120);
            *v18 = *(_DWORD*)a4;
            v18[1] = *((_DWORD*)a4 + 1);
            v19 = 0;
            v18[2] = *((_DWORD*)a4 + 2);
            while (sub_4196F0(*(_DWORD*)(v11 + 468), (float*)a4, 3.1415927, COERCE_FLOAT(1), 1, 0))
            {
                v20 = sub_417140(*(_DWORD**)(v11 + 468), 0);
                v139 = *(float*)v20;
                v21 = *(float*)(v20 + 4);
                v22 = *(_DWORD*)(v20 + 8);
                v140 = v21;
                v141 = v22;
                if (v139 * *(float*)a4 + v21 * *((float*)a4 + 1) > 10000.0)
                {
                    v23 = 0;
                    v127 = 0.0;
                    v128 = -1.0;
                    v129 = 0.0;
                    v24 = 0;
                    while (sub_4196F0(*(_DWORD*)(v11 + 468), &v127, 3.1415927, COERCE_FLOAT(1), 1, 0))
                    {
                        if (v129 * *(float*)(*(_DWORD*)(v11 + 468) + 128)
                            + v128 * *(float*)(*(_DWORD*)(v11 + 468) + 124)
                            + v127 * *(float*)(*(_DWORD*)(v11 + 468) + 120) > 0.99000001)
                        {
                            v23 = 1;
                            break;
                        }
                        if (++v24 >= 100)
                            break;
                    }
                    v25 = *(_DWORD*)(v11 + 468);
                    v26 = 0;
                    v124 = 0;
                    if (*(int*)(v25 + 4132) <= 0)
                    {
                        if (v23)
                            return;
                    }
                    else
                    {
                        while (1)
                        {
                            v27 = (float*)sub_417120(*(void**)(v11 + 468), v26);
                            if (v26 <= 2)
                            {
                                v116 = *(float*)a4;
                                v117 = *((float*)a4 + 1);
                                v118 = *((float*)a4 + 2);
                            }
                            else
                            {
                                v28 = (float*)sub_417120(*(void**)(v11 + 468), v26 - 1);
                                v29 = v27[2] - v28[2];
                                v30 = v27[1] - v28[1];
                                v149[0] = *v27 - *v28;
                                v149[1] = v30;
                                v149[2] = v29;
                                sub_46B970(&v116, v149);
                            }
                            v132 = 0;
                            v122 = 0.0;
                            v31 = 1;
                            v130 = v117 - 0.0;
                            v120 = v130;
                            v131 = 0.0 - v116;
                            v121 = v131;
                            if (ArgList > 1)
                                break;
                        LABEL_45:
                            v45 = *(_DWORD*)(v11 + 468);
                            v124 = ++v26;
                            if (v26 >= *(_DWORD*)(v45 + 4132))
                                return;
                        }
                        while (1)
                        {
                            v113 = *v27;
                            v114 = v27[1];
                            v115 = v27[2];
                            switch (v31)
                            {
                            case 1:
                                v32 = -*(float*)(a3 + 784);
                                v166 = v116 * v32;
                                v167 = v117 * v32;
                                v133 = v166 + v166;
                                v134 = v167 + v167;
                                v135 = v32 * v118 + v32 * v118;
                                v33 = *(float*)(a3 + 784);
                                *(float*)&v90 = v122 * v33;
                                *(float*)&v69 = v121 * v33;
                                *(float*)&v47 = v120 * v33;
                                sub_40F4A0(v151, v47, v69, v90);
                                *(float*)&v91 = v151[2] + v135;
                                *(float*)&v70 = v151[1] + v134;
                                *(float*)&v48 = v151[0] + v133;
                                sub_40F4A0(v175, v48, v70, v91);
                                v113 = v175[0] + v113;
                                v114 = v114 + v175[1];
                                v115 = v115 + v175[2];
                                break;
                            case 2:
                                v34 = -*(float*)(a3 + 784);
                                *(float*)&v92 = v118 * v34;
                                *(float*)&v71 = v117 * v34;
                                *(float*)&v49 = v116 * v34;
                                sub_40F4A0(&v153, v49, v71, v92);
                                *(float*)&v93 = v155 + v155;
                                *(float*)&v72 = v154 + v154;
                                *(float*)&v50 = v153 + v153;
                                sub_40F4A0(v174, v50, v72, v93);
                                v35 = -*(float*)(a3 + 784);
                                *(float*)&v94 = v122 * v35;
                                *(float*)&v73 = v121 * v35;
                                *(float*)&v51 = v35 * v120;
                                sub_40F4A0(v142, v51, v73, v94);
                                *(float*)&v95 = v174[2] + v142[2];
                                *(float*)&v74 = v174[1] + v142[1];
                                *(float*)&v52 = v174[0] + v142[0];
                                sub_40F4A0(v172, v52, v74, v95);
                                v113 = v172[0] + v113;
                                v114 = v114 + v172[1];
                                v115 = v115 + v172[2];
                                break;
                            case 3:
                                v36 = -*(float*)(a3 + 784);
                                *(float*)&v96 = v118 * v36;
                                *(float*)&v75 = v117 * v36;
                                *(float*)&v53 = v36 * v116;
                                sub_40F4A0(v160, v53, v75, v96);
                                *(float*)&v97 = v160[2] * 4.0;
                                *(float*)&v76 = v160[1] * 4.0;
                                *(float*)&v54 = v160[0] * 4.0;
                                sub_40F4A0(v162, v54, v76, v97);
                                v37 = *(float*)(a3 + 784);
                                *(float*)&v98 = v122 * v37;
                                *(float*)&v77 = v121 * v37;
                                *(float*)&v55 = v37 * v120;
                                sub_40F4A0(&v168, v55, v77, v98);
                                *(float*)&v99 = v170 + v170;
                                *(float*)&v78 = v169 + v169;
                                *(float*)&v56 = v168 + v168;
                                sub_40F4A0(v171, v56, v78, v99);
                                *(float*)&v100 = v162[2] + v171[2];
                                *(float*)&v79 = v162[1] + v171[1];
                                *(float*)&v57 = v162[0] + v171[0];
                                sub_40F4A0(v164, v57, v79, v100);
                                v113 = v164[0] + v113;
                                v114 = v114 + v164[1];
                                v115 = v115 + v164[2];
                                break;
                            case 4:
                                v38 = -*(float*)(a3 + 784);
                                *(float*)&v101 = v118 * v38;
                                *(float*)&v80 = v117 * v38;
                                *(float*)&v58 = v38 * v116;
                                sub_40F4A0(v143, v58, v80, v101);
                                *(float*)&v102 = v143[2] * 4.0;
                                *(float*)&v81 = v143[1] * 4.0;
                                *(float*)&v59 = v143[0] * 4.0;
                                sub_40F4A0(v150, v59, v81, v102);
                                v39 = -*(float*)(a3 + 784);
                                *(float*)&v103 = v122 * v39;
                                *(float*)&v82 = v121 * v39;
                                *(float*)&v60 = v39 * v120;
                                sub_40F4A0(&v146, v60, v82, v103);
                                *(float*)&v104 = v148 + v148;
                                *(float*)&v83 = v147 + v147;
                                *(float*)&v61 = v146 + v146;
                                sub_40F4A0(v152, v61, v83, v104);
                                *(float*)&v105 = v150[2] + v152[2];
                                *(float*)&v84 = v150[1] + v152[1];
                                *(float*)&v62 = v150[0] + v152[0];
                                sub_40F4A0(v156, v62, v84, v105);
                                v113 = v156[0] + v113;
                                v114 = v114 + v156[1];
                                v115 = v115 + v156[2];
                                break;
                            case 5:
                                v40 = -*(float*)(a3 + 784);
                                *(float*)&v106 = v118 * v40;
                                *(float*)&v85 = v117 * v40;
                                *(float*)&v63 = v40 * v116;
                                sub_40F4A0(v159, v63, v85, v106);
                                *(float*)&v107 = v159[2] * 6.0;
                                *(float*)&v86 = v159[1] * 6.0;
                                *(float*)&v64 = v159[0] * 6.0;
                                sub_40F4A0(v163, v64, v86, v107);
                                v41 = *(float*)(a3 + 784);
                                *(float*)&v108 = v122 * v41;
                                *(float*)&v87 = v121 * v41;
                                *(float*)&v65 = v41 * v120;
                                sub_40F4A0(v161, v65, v87, v108);
                                *(float*)&v109 = v161[2] * 3.0;
                                *(float*)&v88 = v161[1] * 3.0;
                                *(float*)&v66 = v161[0] * 3.0;
                                sub_40F4A0(v165, v66, v88, v109);
                                *(float*)&v110 = v163[2] + v165[2];
                                *(float*)&v89 = v163[1] + v165[1];
                                *(float*)&v67 = v163[0] + v165[0];
                                sub_40F4A0(v176, v67, v89, v110);
                                sub_418E20(&v113, v176);
                                break;
                            case 6:
                                v68 = -*(float*)(a3 + 784);
                                v42 = sub_4162F0(&v116, v182, v68);
                                v111 = sub_4162F0(v42, v181, 6.0);
                                v46 = -*(float*)(a3 + 784);
                                v43 = sub_4162F0(&v120, v180, v46);
                                v44 = sub_4162F0(v43, v179, 3.0);
                                v112 = sub_4162C0(v44, v178, v111);
                                sub_418E20(&v113, v112);
                                break;
                            }
                            if (!sub_416350(*(_DWORD*)(v177[v31] + 468), &v113, 1))
                                break;
                            if (++v31 >= ArgList)
                            {
                                v26 = v124;
                                goto LABEL_45;
                            }
                        }
                    }
                    v9 = ArgList;
                    break;
                }
                if (++v19 >= 100)
                    break;
            }
            ++LODWORD(v119);
        } while (SLODWORD(v119) < 100);
    }
}
// 42E56D: conditional instruction was optimized away because ebx.4>=1
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);

//----- (0042EF80) --------------------------------------------------------
void __thiscall sub_42EF80(_DWORD* this, int ArgList, int a3, float* a4)
{
    int v4; // edi
    int* v5; // esi
    double v6; // st7
    int v7; // esi
    double v8; // st6
    long double v9; // st7
    double v10; // st6
    int v11; // ebp
    int v12; // esi
    double v13; // st5
    double v14; // st7
    _DWORD* v15; // edx
    int v16; // eax
    double v17; // st7
    double v18; // st6
    long double v19; // st7
    int v20; // eax
    double v21; // st6
    char v22; // [esp+13h] [ebp-115h]
    int v23; // [esp+14h] [ebp-114h]
    float v24; // [esp+18h] [ebp-110h]
    float v25; // [esp+1Ch] [ebp-10Ch]
    float v26; // [esp+24h] [ebp-104h]
    int v27; // [esp+24h] [ebp-104h]
    float v28; // [esp+28h] [ebp-100h]
    float v29; // [esp+2Ch] [ebp-FCh]
    float v31; // [esp+30h] [ebp-F8h]
    float v32; // [esp+34h] [ebp-F4h]
    float v33; // [esp+38h] [ebp-F0h]
    float v34; // [esp+3Ch] [ebp-ECh]
    float v35; // [esp+40h] [ebp-E8h]
    float v36; // [esp+44h] [ebp-E4h]
    float v37; // [esp+48h] [ebp-E0h] BYREF
    float v38; // [esp+4Ch] [ebp-DCh]
    float v39; // [esp+50h] [ebp-D8h]
    float v40; // [esp+54h] [ebp-D4h]
    float v41; // [esp+58h] [ebp-D0h]
    float v42; // [esp+5Ch] [ebp-CCh]
    float v43; // [esp+60h] [ebp-C8h]
    float v44; // [esp+64h] [ebp-C4h]
    float v45; // [esp+68h] [ebp-C0h]
    float v46; // [esp+6Ch] [ebp-BCh]
    float v47; // [esp+70h] [ebp-B8h]
    float v48; // [esp+74h] [ebp-B4h]
    float v49; // [esp+78h] [ebp-B0h]
    float v50; // [esp+7Ch] [ebp-ACh]
    float v51; // [esp+80h] [ebp-A8h]
    float v52; // [esp+84h] [ebp-A4h]
    float v53; // [esp+88h] [ebp-A0h]
    float v54; // [esp+8Ch] [ebp-9Ch]
    float v55; // [esp+90h] [ebp-98h]
    float v56; // [esp+94h] [ebp-94h]
    float v57; // [esp+98h] [ebp-90h]
    float v58; // [esp+9Ch] [ebp-8Ch]
    float v59; // [esp+A0h] [ebp-88h]
    float v60; // [esp+A4h] [ebp-84h]
    float v61; // [esp+A8h] [ebp-80h]
    float v62; // [esp+ACh] [ebp-7Ch]
    float v63; // [esp+B0h] [ebp-78h]
    float v64; // [esp+B4h] [ebp-74h]
    float v65; // [esp+B8h] [ebp-70h]
    float v66; // [esp+BCh] [ebp-6Ch]
    float v67; // [esp+C0h] [ebp-68h]
    float v68; // [esp+C4h] [ebp-64h]
    float v69; // [esp+C8h] [ebp-60h]
    int v70; // [esp+CCh] [ebp-5Ch]
    float v71; // [esp+D4h] [ebp-54h]
    float v72; // [esp+D8h] [ebp-50h]
    float v73; // [esp+E0h] [ebp-48h]
    float v74; // [esp+E4h] [ebp-44h]
    float v75; // [esp+ECh] [ebp-3Ch]
    float v76; // [esp+F0h] [ebp-38h]
    float v77; // [esp+F8h] [ebp-30h]
    float v78; // [esp+FCh] [ebp-2Ch]
    float v79; // [esp+104h] [ebp-24h]
    float v80; // [esp+108h] [ebp-20h]
    _DWORD v81[7]; // [esp+10Ch] [ebp-1Ch] BYREF

    v4 = ArgList;
    if (ArgList > 0)
    {
        sub_4229D0("SpecialAttackTorpedoRun: %d %s", ArgList, (const char*)a3);
        v26 = fabs((double)rand() * 0.000030518509);
        v5 = v81;
        do
        {
            *v5++ = sub_42FCC0(this, *(float*)&a3, v26, -1);
            --v4;
        } while (v4);
        if (*(float*)(a3 + 812) == 0.0)
            v6 = 40000.0;
        else
            v6 = *(float*)(a3 + 812);
        v7 = 0;
        v27 = 0;
        v8 = *(float*)(*(_DWORD*)(v81[0] + 468) + 4288) * *(float*)(*(_DWORD*)(v81[0] + 468) + 4284);
        v28 = v8 + v8 + v6;
        do
        {
            v33 = *(float*)(a3 + 832);
            v36 = *(float*)(a3 + 836);
            if (v33 == v36)
                v9 = v33;
            else
                v9 = fabs((double)rand() * 0.000030518509) * (v36 - v33) + v33;
            if (v7 > 50)
                v9 = fabs((double)rand() * 0.000030518509) * 1000.0 + 3000.0;
            v10 = -*a4;
            v79 = -a4[1];
            v80 = -a4[2];
            v11 = 0;
            v75 = v79 * v28;
            v41 = v75;
            v76 = v80 * v28;
            v40 = v10 * v28;
            v42 = v76 + v9;
            while (1)
            {
                v12 = v81[v11];
                v22 = 0;
                sub_4164A0(*(_DWORD*)(v12 + 468), 0);
                v13 = a4[1] - 0.0;
                v37 = v40;
                v46 = v13;
                v38 = v41;
                v39 = v42;
                v47 = 0.0 - *a4;
                v48 = 0.0;
                if (v11)
                {
                    switch (v11)
                    {
                    case 1:
                        v65 = *(float*)(a3 + 784);
                        v24 = v65;
                        v66 = *(float*)(a3 + 784) * -2.0;
                        v67 = 0.0;
                        v25 = v66;
                        break;
                    case 2:
                        v62 = -*(float*)(a3 + 784);
                        v24 = v62;
                        v63 = *(float*)(a3 + 784) * -2.0;
                        v64 = 0.0;
                        v25 = v63;
                        break;
                    case 3:
                        v58 = *(float*)(a3 + 784) + *(float*)(a3 + 784);
                        v24 = v58;
                        v59 = *(float*)(a3 + 784) * -4.0;
                        v60 = 0.0;
                        v25 = v59;
                        break;
                    case 4:
                        v52 = *(float*)(a3 + 784) * -2.0;
                        v24 = v52;
                        v53 = *(float*)(a3 + 784) * -4.0;
                        v54 = 0.0;
                        v25 = v53;
                        break;
                    case 5:
                        v55 = *(float*)(a3 + 784) * 3.0;
                        v24 = v55;
                        v56 = *(float*)(a3 + 784) * -6.0;
                        v57 = 0.0;
                        v25 = v56;
                        break;
                    case 6:
                        v43 = *(float*)(a3 + 784) * -3.0;
                        v24 = v43;
                        v44 = *(float*)(a3 + 784) * -6.0;
                        v45 = 0.0;
                        v25 = v44;
                        break;
                    }
                }
                else
                {
                    v49 = 0.0;
                    v50 = 0.0;
                    v51 = 0.0;
                    v24 = 0.0;
                    v25 = 0.0;
                }
                v14 = v25 * *a4;
                v73 = v25 * a4[1];
                v74 = v25 * a4[2];
                v71 = v47 * v24;
                v72 = v48 * v24;
                v77 = v71 + v73;
                v78 = v72 + v74;
                v37 = v14 + v46 * v24 + v40;
                v38 = v38 + v77;
                v39 = v39 + v78;
                if (!sub_416350(*(_DWORD*)(v12 + 468), &v37, 1))
                    break;
                v15 = (_DWORD*)(*(_DWORD*)(v12 + 468) + 120);
                *v15 = *(_DWORD*)a4;
                v15[1] = *((_DWORD*)a4 + 1);
                v15[2] = *((_DWORD*)a4 + 2);
                v32 = *(float*)(a3 + 840);
                v34 = *(float*)(a3 + 844);
                v35 = v32 == v34 ? *(float*)(a3 + 840) : fabs((double)rand() * 0.000030518509) * (v34 - v32) + v32;
                v23 = 0;
                while (sub_4196F0(*(_DWORD*)(v12 + 468), a4, 3.1415927, COERCE_FLOAT(1), 1, 0))
                {
                    v16 = sub_417140(*(_DWORD**)(v12 + 468), 0);
                    v68 = *(float*)v16;
                    v17 = v68 * *a4;
                    v69 = *(float*)(v16 + 4);
                    v18 = v69 * a4[1];
                    v70 = *(_DWORD*)(v16 + 8);
                    if (v17 + v18 > v35)
                    {
                        v22 = 1;
                        break;
                    }
                    if (++v23 >= 100)
                        break;
                }
                v61 = *(float*)(a3 + 788);
                sub_419A30(*(_DWORD**)(v12 + 468), v61, 0.0, v61);
                if (!v22)
                    break;
                *(_DWORD*)(v12 + 1308) = 1;
                *(_DWORD*)(v12 + 1412) = 1;
                v29 = *(float*)(a3 + 1016);
                v31 = *(float*)(a3 + 1020);
                if (v29 == v31)
                    v19 = v29;
                else
                    v19 = fabs((double)rand() * 0.000030518509) * (v31 - v29) + v29;
                v20 = *(_DWORD*)(v12 + 468);
                ++v11;
                v21 = *(float*)(v20 + 4288) * *(float*)(v20 + 4284);
                *(float*)(v12 + 1416) = (v19 + v28 - (v21 + v21)) / *(float*)(v20 + 4284);
                if (v11 >= ArgList)
                    return;
            }
            v7 = ++v27;
        } while (v27 < 100);
    }
}
// 42F127: conditional instruction was optimized away because %ArgList.4>=1
// 42F5FC: conditional instruction was optimized away because %var_115.1==1
// 42F398: variable 'v25' is possibly undefined
// 42F3CD: variable 'v24' is possibly undefined

//----- (0042F620) --------------------------------------------------------
void __thiscall sub_42F620(_DWORD* this, int ArgList, int a3)
{
    int v3; // edi
    int* v4; // esi
    double v5; // st7
    double v6; // st6
    long double v7; // st7
    int v8; // edi
    int v9; // esi
    double v10; // st7
    double v11; // st7
    double v12; // st7
    double v13; // st7
    double v14; // st7
    double v15; // st7
    _DWORD* v16; // ecx
    int v17; // ebx
    char v18; // [esp+13h] [ebp-E5h]
    float v19; // [esp+14h] [ebp-E4h]
    float v20; // [esp+18h] [ebp-E0h]
    float v21; // [esp+20h] [ebp-D8h]
    int v22; // [esp+20h] [ebp-D8h]
    float v24; // [esp+24h] [ebp-D4h]
    float v25; // [esp+28h] [ebp-D0h]
    float v26; // [esp+30h] [ebp-C8h] BYREF
    float v27; // [esp+34h] [ebp-C4h]
    float v28; // [esp+38h] [ebp-C0h]
    float v29; // [esp+3Ch] [ebp-BCh]
    float v30; // [esp+40h] [ebp-B8h]
    int v31; // [esp+44h] [ebp-B4h]
    float v32; // [esp+48h] [ebp-B0h]
    float v33; // [esp+4Ch] [ebp-ACh]
    int v34; // [esp+50h] [ebp-A8h]
    float v35; // [esp+54h] [ebp-A4h]
    float v36; // [esp+58h] [ebp-A0h]
    int v37; // [esp+5Ch] [ebp-9Ch]
    int v38; // [esp+60h] [ebp-98h]
    int v39; // [esp+64h] [ebp-94h]
    int v40; // [esp+68h] [ebp-90h]
    float v41; // [esp+6Ch] [ebp-8Ch]
    float v42; // [esp+70h] [ebp-88h]
    float v43; // [esp+74h] [ebp-84h]
    float v44; // [esp+78h] [ebp-80h]
    float v45; // [esp+7Ch] [ebp-7Ch]
    int v46; // [esp+80h] [ebp-78h]
    int v47; // [esp+84h] [ebp-74h]
    int v48; // [esp+88h] [ebp-70h]
    int v49; // [esp+8Ch] [ebp-6Ch]
    float v50; // [esp+90h] [ebp-68h]
    float v51; // [esp+94h] [ebp-64h]
    int v52; // [esp+98h] [ebp-60h]
    float v53; // [esp+9Ch] [ebp-5Ch]
    float v54; // [esp+A0h] [ebp-58h]
    int v55; // [esp+A4h] [ebp-54h]
    float v56; // [esp+A8h] [ebp-50h]
    float v57; // [esp+ACh] [ebp-4Ch]
    float v58; // [esp+B0h] [ebp-48h]
    float v59; // [esp+B4h] [ebp-44h]
    float v60; // [esp+BCh] [ebp-3Ch]
    float v61; // [esp+C0h] [ebp-38h]
    float v62[4]; // [esp+C4h] [ebp-34h] BYREF
    float v63; // [esp+D4h] [ebp-24h]
    float v64; // [esp+D8h] [ebp-20h]
    _DWORD v65[7]; // [esp+DCh] [ebp-1Ch] BYREF

    v3 = ArgList;
    if (ArgList > 0)
    {
        sub_4229D0("SpecialAttackAirStrike: %d %s", ArgList, (const char*)a3);
        v21 = fabs((double)rand() * 0.000030518509);
        v4 = v65;
        do
        {
            *v4++ = sub_42FCC0(this, *(float*)&a3, v21, -1);
            --v3;
        } while (v3);
        if (*(float*)(a3 + 812) == 0.0)
            v5 = 40000.0;
        else
            v5 = *(float*)(a3 + 812);
        v22 = 0;
        v57 = 0.0;
        v6 = *(float*)(*(_DWORD*)(v65[0] + 468) + 4288) * *(float*)(*(_DWORD*)(v65[0] + 468) + 4284);
        v58 = -(v5 + v6 + v6);
        do
        {
            v25 = *(float*)(a3 + 816);
            v24 = *(float*)(a3 + 820);
            if (v25 == v24)
                v7 = v25;
            else
                v7 = fabs((double)rand() * 0.000030518509) * (v24 - v25) + v25;
            v8 = 0;
            v59 = v7;
            while (1)
            {
                v9 = v65[v8];
                v18 = 0;
                sub_4164A0(*(_DWORD*)(v9 + 468), 0);
                v26 = v57;
                v27 = v58;
                v28 = v59;
                if (v8)
                {
                    switch (v8)
                    {
                    case 1:
                        v29 = *(float*)(a3 + 784);
                        v10 = *(float*)(a3 + 784) * -2.0;
                        v31 = 0;
                        v19 = v29;
                        v30 = v10;
                        v20 = v30;
                        break;
                    case 2:
                        v44 = -*(float*)(a3 + 784);
                        v11 = *(float*)(a3 + 784) * -2.0;
                        v46 = 0;
                        v19 = v44;
                        v45 = v11;
                        v20 = v45;
                        break;
                    case 3:
                        v12 = *(float*)(a3 + 784) + *(float*)(a3 + 784);
                        v55 = 0;
                        v53 = v12;
                        v19 = v53;
                        v54 = *(float*)(a3 + 784) * -4.0;
                        v20 = v54;
                        break;
                    case 4:
                        v13 = *(float*)(a3 + 784) * -2.0;
                        v52 = 0;
                        v50 = v13;
                        v19 = v50;
                        v51 = *(float*)(a3 + 784) * -4.0;
                        v20 = v51;
                        break;
                    case 5:
                        v14 = *(float*)(a3 + 784) * 3.0;
                        v34 = 0;
                        v32 = v14;
                        v19 = v32;
                        v33 = *(float*)(a3 + 784) * -6.0;
                        v20 = v33;
                        break;
                    case 6:
                        v15 = *(float*)(a3 + 784) * -3.0;
                        v37 = 0;
                        v35 = v15;
                        v19 = v35;
                        v36 = *(float*)(a3 + 784) * -6.0;
                        v20 = v36;
                        break;
                    }
                }
                else
                {
                    v38 = 0;
                    v39 = 0;
                    v40 = 0;
                    v19 = 0.0;
                    v20 = 0.0;
                }
                v41 = 0.0;
                v42 = v20;
                v43 = 0.0;
                v60 = 0.0;
                v61 = 0.0;
                v63 = (float)0.0 + v20;
                v64 = (float)0.0 + (float)0.0;
                v26 = v19 + (float)0.0;
                v27 = v27 + v63;
                v28 = v28 + v64;
                if (!sub_416350(*(_DWORD*)(v9 + 468), &v26, 1))
                    break;
                v16 = *(_DWORD**)(v9 + 468);
                v47 = 0;
                v16 += 30;
                v48 = 1065353216;
                *v16 = 0;
                v49 = 0;
                v17 = 0;
                v16[1] = 1065353216;
                v16[2] = 0;
                do
                {
                    v62[0] = 0.0;
                    v62[1] = 1.0;
                    v62[2] = 0.0;
                    if (!sub_4196F0(*(_DWORD*)(v9 + 468), v62, 3.1415927, COERCE_FLOAT(1), 1, 0))
                        break;
                    if (-*(float*)(a3 + 796) < *(float*)(sub_417140(*(_DWORD**)(v9 + 468), 0) + 4))
                    {
                        v18 = 1;
                        break;
                    }
                } while (++v17 < 100);
                v56 = *(float*)(a3 + 788);
                sub_419A30(*(_DWORD**)(v9 + 468), v56, 0.0, v56);
                *(float*)(v9 + 412) = (double)(*(_DWORD*)(*(_DWORD*)(v9 + 468) + 4132) - 5)
                    * *(float*)(*(_DWORD*)(v9 + 468) + 4288);
                if (!v18)
                    break;
                if (++v8 >= ArgList)
                    return;
            }
            ++v22;
        } while (v22 < 100);
    }
}
// 42F74D: conditional instruction was optimized away because %ArgList.4>=1
// 42FB15: conditional instruction was optimized away because %var_E5.1==1
// 42F980: variable 'v20' is possibly undefined
// 42F989: variable 'v19' is possibly undefined

//----- (0042FB40) --------------------------------------------------------
int __thiscall sub_42FB40(_DWORD* this, int* a2, int* a3, int a4, float* a5)
{
    int result; // eax
    unsigned int i; // esi
    int v8; // ecx
    int v9; // edx

    result = 0;
    for (i = 0; ; ++i)
    {
        v8 = this[6];
        if (!v8 || i >= (this[7] - v8) >> 2)
            break;
        v9 = *(_DWORD*)(v8 + 4 * i);
        if (*(_BYTE*)(v9 + 16))
        {
            if (*(_BYTE*)(a4 + 8) != *(_BYTE*)(*(_DWORD*)(v9 + 428) + 300))
                result = sub_430BC0(*(_DWORD*)(v8 + 4 * i), a2, a3, a4, a5);
            if (result)
                break;
        }
    }
    return result;
}

//----- (0042FBB0) --------------------------------------------------------
int __thiscall sub_42FBB0(_DWORD* this, int* a2, float a3, float a4, int a5, int a6)
{
    unsigned int i; // edi
    int result; // eax
    int v9; // ecx

    for (i = 0; ; ++i)
    {
        result = this[6];
        if (!result || i >= (this[7] - result) >> 2)
            break;
        v9 = *(_DWORD*)(result + 4 * i);
        if (*(_BYTE*)(v9 + 16))
        {
            if ((_BYTE)a6 != *(_BYTE*)(*(_DWORD*)(v9 + 428) + 300))
                sub_430DC0(v9, a2, a3, a4, a5, a6);
        }
    }
    return result;
}

//----- (0042FC10) --------------------------------------------------------
unsigned int __thiscall sub_42FC10(_DWORD* this, int a2)
{
    __int16 v2; // ax
    float v4; // edi
    unsigned int result; // eax
    int v6; // ecx
    int v7; // ecx
    float v8; // [esp+0h] [ebp-14h]

    v2 = *(_WORD*)(a2 + 12);
    if (v2 == 257)
    {
        v4 = *(float*)(*(_DWORD*)(*(_DWORD*)(dword_520970 + 200) + 20) + 4 * *(_DWORD*)(*(_DWORD*)(a2 + 16) + 6));
        v8 = fabs((double)rand() * 0.000030518509);
        return sub_42FCC0(this, v4, v8, -1);
    }
    else
    {
        result = v2 & 0xFF00;
        if (result == 256)
        {
            v6 = this[6];
            for (result = 0; v6 && result < (this[7] - v6) >> 2; ++result)
            {
                if (*(_DWORD*)(*(_DWORD*)(this[6] + 4 * result) + 392) == *(__int16*)(*(_DWORD*)(a2 + 16) + 6))
                {
                    v7 = *(_DWORD*)(this[6] + 4 * result);
                    return (*(int(__thiscall**)(int, int))(*(_DWORD*)v7 + 28))(v7, a2);
                }
            }
        }
    }
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (0042FCC0) --------------------------------------------------------
int __thiscall sub_42FCC0(_DWORD* this, float a2, float a3, int a4)
{
    void* v5; // eax
    int v6; // eax
    _DWORD* v8; // [esp-Ch] [ebp-34h]
    int v9; // [esp-4h] [ebp-2Ch]
    _DWORD v10[2]; // [esp+8h] [ebp-20h] BYREF
    _WORD v11[3]; // [esp+10h] [ebp-18h] BYREF
    int v12; // [esp+16h] [ebp-12h]
    int v13; // [esp+24h] [ebp-4h]

    v5 = operator new(0x900u);
    v10[1] = v5;
    v13 = 0;
    if (v5)
        v6 = sub_42FEB0((int)v5, a2, a3);
    else
        v6 = 0;
    v10[0] = v6;
    v8 = (_DWORD*)this[7];
    v13 = -1;
    sub_44F190((int)(this + 5), v8, 1u, v10);
    *(_DWORD*)(v10[0] + 392) = this[13];
    v9 = v10[0];
    ++this[13];
    sub_428680(this, v9);
    *(_BYTE*)(v10[0] + 460) = a4 <= -1;
    if (*(_BYTE*)(dword_4F5CC4 + 936))
    {
        v12 = *(_DWORD*)(LODWORD(a2) + 8);
        sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x101, v11, 10, 15, 0);
    }
    else if (*(_BYTE*)(dword_4F5CC4 + 937))
    {
        (*(void(__thiscall**)(_DWORD, _DWORD))(*(_DWORD*)v10[0] + 24))(v10[0], 0);
    }
    return v10[0];
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (0042FDD0) --------------------------------------------------------
int __thiscall sub_42FDD0(_DWORD* this)
{
    int v2; // eax
    int v3; // ebx
    int i; // edi
    void(__thiscall * **v5)(_DWORD, int); // ecx
    int result; // eax

    v2 = this[6];
    if (v2)
        v3 = (this[7] - v2) >> 2;
    else
        v3 = 0;
    for (i = 0; i < v3; ++i)
    {
        sub_428720(*(_DWORD**)(this[6] + 4 * i));
        sub_4286C0(this, *(_DWORD*)(this[6] + 4 * i));
        v5 = *(void(__thiscall****)(_DWORD, int))(this[6] + 4 * i);
        if (v5)
            (**v5)(v5, 1);
    }
    result = this[7];
    this[7] = this[6];
    this[13] = 0;
    return result;
}

//----- (0042FE50) --------------------------------------------------------
char __thiscall sub_42FE50(_DWORD* this)
{
    int v1; // eax
    int v2; // edx
    int v3; // esi
    char result; // al
    int i; // edi
    int v6; // ecx

    v1 = this[6];
    if (v1)
        v2 = (this[7] - v1) >> 2;
    else
        v2 = 0;
    v3 = 0;
    result = 1;
    if (v2 > 0)
    {
        for (i = this[6]; ; i += 4)
        {
            if (*(_BYTE*)(*(_DWORD*)i + 396))
            {
                v6 = *(_DWORD*)(*(_DWORD*)i + 428);
                if (*(_DWORD*)(v6 + 292) != 1 && !*(_BYTE*)(v6 + 300))
                    break;
            }
            if (++v3 >= v2)
                return result;
        }
        return 0;
    }
    return result;
}

//----- (0042FEB0) --------------------------------------------------------
int __thiscall sub_42FEB0(int this, float a2, float a3)
{
    char v4; // al
    char v5; // cl
    char v6; // dl
    float v7; // esi
    float v8; // ecx
    float v9; // eax
    _DWORD* v10; // eax
    int v11; // eax
    _DWORD* v12; // eax
    int v13; // eax
    int v14; // ecx
    int v15; // edx
    _BYTE* v16; // eax
    int* v17; // eax
    int v18; // eax
    int v19; // ecx
    int v20; // edx
    _BYTE* v21; // eax
    int* v22; // eax
    int v23; // eax
    int v24; // ecx
    int v25; // edx
    _BYTE* v26; // eax
    int* v27; // eax
    _DWORD* v28; // ecx
    int v29; // eax
    _DWORD* v30; // eax
    int v31; // edx
    float v32; // ecx
    int v33; // eax
    int v34; // eax
    int v35; // ecx
    float v36; // ecx
    long double v37; // st7
    int v38; // eax
    int v39; // esi
    unsigned int v40; // edx
    int v41; // eax
    unsigned int v42; // ecx
    int v43; // ecx
    unsigned int i; // ecx
    int v45; // eax
    int v46; // ecx
    int v47; // edx
    int v48; // eax
    int v49; // eax
    int v50; // eax
    int v51; // ecx
    unsigned int v52; // eax
    int v53; // edx
    int v54; // esi
    unsigned int v55; // ecx
    int v56; // ecx
    unsigned int v57; // edi
    int v58; // eax
    float v59; // ecx
    long double v60; // st7
    int v61; // eax
    int v62; // ecx
    int v63; // edx
    _BYTE* v64; // eax
    int* v65; // eax
    float v66; // ecx
    _DWORD* v68; // [esp+10h] [ebp-28h] BYREF
    int v69; // [esp+14h] [ebp-24h] BYREF
    int v70; // [esp+18h] [ebp-20h]
    int v71; // [esp+1Ch] [ebp-1Ch]
    int v72; // [esp+20h] [ebp-18h] BYREF
    int v73; // [esp+24h] [ebp-14h]
    int v74; // [esp+28h] [ebp-10h]
    int v75; // [esp+34h] [ebp-4h]

    v71 = this;
    sub_401270(this);
    v75 = 0;
    Iostream_init::Iostream_init((Iostream_init*)(this + 472));
    v4 = LOBYTE(a2);
    *(_DWORD*)(this + 1368) = 0;
    *(_BYTE*)(this + 1364) = v4;
    *(_DWORD*)(this + 1372) = 0;
    *(_DWORD*)(this + 1376) = 0;
    v5 = LOBYTE(a2);
    *(_DWORD*)(this + 1400) = 0;
    *(_BYTE*)(this + 1396) = v5;
    *(_DWORD*)(this + 1404) = 0;
    *(_DWORD*)(this + 1408) = 0;
    Iostream_init::Iostream_init((Iostream_init*)(this + 1432));
    v6 = LOBYTE(a2);
    *(_DWORD*)(this + 2288) = 0;
    *(_BYTE*)(this + 2284) = v6;
    *(_DWORD*)(this + 2292) = 0;
    *(_DWORD*)(this + 2296) = 0;
    v7 = a2;
    *(_DWORD*)this = &off_499458;
    LOBYTE(v75) = 5;
    sub_4229D0("Adding new airplane '%s'", *(const char**)(LODWORD(v7) + 4));
    v8 = a3;
    *(_DWORD*)(this + 392) = -1;
    *(float*)(this + 464) = v8;
    *(float*)(this + 428) = v7;
    sub_4282E0(
        *(_DWORD*)(LODWORD(v7) + 564) != 0,
        "model for %s not loaded, try deleting ExtraData.dat",
        *(const char**)(LODWORD(v7) + 4));
    v9 = COERCE_FLOAT(operator new(0x34u));
    a2 = v9;
    LOBYTE(v75) = 6;
    if (v9 == 0.0)
        v10 = 0;
    else
        v10 = sub_406B00((_DWORD*)LODWORD(v9), *(_DWORD*)(LODWORD(v7) + 564), 0);
    LOBYTE(v75) = 5;
    *(_DWORD*)(this + 432) = v10;
    sub_428680((_DWORD*)this, (int)v10);
    v72 = 0;
    v73 = 1203982336;
    v74 = 1195593728;
    *(_DWORD*)(this + 1312) = 0;
    v11 = v74;
    *(_DWORD*)(this + 1316) = 1203982336;
    *(_DWORD*)(this + 1320) = v11;
    v12 = sub_415270(*(_DWORD*)(dword_520970 + 244), *(_DWORD*)(LODWORD(v7) + 880));
    *(_DWORD*)(this + 468) = v12;
    v12[1071] = *(_DWORD*)(*(_DWORD*)(this + 428) + 4 * *(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 20) + 800);
    a2 = *(float*)(LODWORD(v7) + 876);
    sub_41C060((_DWORD*)(this + 472), 1065353216, SLODWORD(a2), SLODWORD(a2));
    v13 = *(_DWORD*)(this + 428);
    *(_DWORD*)(this + 2300) = 0;
    *(_DWORD*)(this + 2268) = 2;
    *(_DWORD*)(this + 2272) = 0;
    v14 = *(_DWORD*)(v13 + 908);
    if (v14)
    {
        sub_4282E0(
            *(_BYTE*)(v14 + 301),
            "engine sound did not set 'engine = true', see %s : %s",
            *(const char**)(v13 + 4),
            (const char*)(v13 + 16));
        v15 = *(_DWORD*)(this + 428);
        v72 = 0;
        v73 = 0;
        v74 = 0;
        sub_44D850(*(_DWORD*)(v15 + 908), (float*)&v72, &v68, &v69);
        if (v68)
        {
            v16 = (_BYTE*)sub_41E2D0(*(_DWORD**)(dword_520970 + 120), v68, 0, 1);
            *(_DWORD*)(this + 2272) = v16;
            if (v16)
            {
                sub_41D8A0(v16, *(_BYTE*)(*(_DWORD*)(*(_DWORD*)(this + 428) + 908) + 330));
                sub_41D8B0(
                    *(_DWORD**)(this + 2272),
                    *(_DWORD*)v69,
                    *(_DWORD*)(v69 + 12),
                    *(_DWORD*)(v69 + 20),
                    *(_DWORD*)(v69 + 4),
                    *(_DWORD*)(v69 + 8),
                    *(_DWORD*)(v69 + 16));
                v17 = *(int**)(*(_DWORD*)(this + 428) + 908);
                sub_41D900(
                    *(_DWORD**)(this + 2272),
                    *(_DWORD*)(*(_DWORD*)(this + 468) + 4284),
                    v17[76],
                    v17[77],
                    v17[78],
                    v17[79],
                    v17[80],
                    v17[81]);
            }
        }
    }
    v18 = *(_DWORD*)(this + 428);
    *(_DWORD*)(this + 2276) = 0;
    v19 = *(_DWORD*)(v18 + 912);
    if (v19)
    {
        sub_4282E0(
            *(_BYTE*)(v19 + 301),
            "rumble sound did not set 'engine = true', see %s : %s",
            *(const char**)(v18 + 4),
            (const char*)(v18 + 16));
        v20 = *(_DWORD*)(this + 428);
        v72 = 0;
        v73 = 0;
        v74 = 0;
        sub_44D850(*(_DWORD*)(v20 + 912), (float*)&v72, &v68, &v69);
        if (v68)
        {
            v21 = (_BYTE*)sub_41E2D0(*(_DWORD**)(dword_520970 + 120), v68, 0, 1);
            *(_DWORD*)(this + 2276) = v21;
            if (v21)
            {
                sub_41D8A0(v21, *(_BYTE*)(*(_DWORD*)(*(_DWORD*)(this + 428) + 912) + 330));
                sub_41D8B0(
                    *(_DWORD**)(this + 2276),
                    *(_DWORD*)v69,
                    *(_DWORD*)(v69 + 12),
                    *(_DWORD*)(v69 + 20),
                    *(_DWORD*)(v69 + 4),
                    *(_DWORD*)(v69 + 8),
                    *(_DWORD*)(v69 + 16));
                v22 = *(int**)(*(_DWORD*)(this + 428) + 912);
                sub_41D900(
                    *(_DWORD**)(this + 2276),
                    *(_DWORD*)(*(_DWORD*)(this + 468) + 4284),
                    v22[76],
                    v22[77],
                    v22[78],
                    v22[79],
                    v22[80],
                    v22[81]);
            }
        }
    }
    v23 = *(_DWORD*)(this + 428);
    *(_DWORD*)(this + 2280) = 0;
    v24 = *(_DWORD*)(v23 + 916);
    if (v24)
    {
        sub_4282E0(
            *(_BYTE*)(v24 + 301),
            "sputter sound did not set 'engine = true', see %s : %s",
            *(const char**)(v23 + 4),
            (const char*)(v23 + 16));
        v25 = *(_DWORD*)(this + 428);
        v72 = 0;
        v73 = 0;
        v74 = 0;
        sub_44D850(*(_DWORD*)(v25 + 916), (float*)&v72, &v68, &v69);
        if (v68)
        {
            v26 = (_BYTE*)sub_41E2D0(*(_DWORD**)(dword_520970 + 120), v68, 0, 1);
            *(_DWORD*)(this + 2280) = v26;
            if (v26)
            {
                sub_41D8A0(v26, *(_BYTE*)(*(_DWORD*)(*(_DWORD*)(this + 428) + 916) + 330));
                sub_41D8B0(
                    *(_DWORD**)(this + 2280),
                    *(_DWORD*)v69,
                    *(_DWORD*)(v69 + 12),
                    *(_DWORD*)(v69 + 20),
                    *(_DWORD*)(v69 + 4),
                    *(_DWORD*)(v69 + 8),
                    *(_DWORD*)(v69 + 16));
                v27 = *(int**)(*(_DWORD*)(this + 428) + 916);
                sub_41D900(
                    *(_DWORD**)(this + 2280),
                    *(_DWORD*)(*(_DWORD*)(this + 468) + 4284),
                    v27[76],
                    v27[77],
                    v27[78],
                    v27[79],
                    v27[80],
                    v27[81]);
            }
        }
    }
    if (!*(_BYTE*)(dword_4F5CC4 + 937))
        sub_4317B0((_DWORD*)this, 0);
    v28 = *(_DWORD**)(this + 432);
    *(_BYTE*)(this + 396) = 1;
    sub_407250(v28);
    sub_4074B0(*(_DWORD**)(this + 432), 0);
    *(_DWORD*)(*(_DWORD*)(this + 432) + 36) = 1065353216;
    *(_BYTE*)(*(_DWORD*)(this + 432) + 48) = 1;
    v29 = *(_DWORD*)(this + 2300);
    *(_BYTE*)(this + 436) = 1;
    *(_BYTE*)(this + 437) = 1;
    if (v29)
        *(_BYTE*)(v29 + 32) = 1;
    v30 = *(_DWORD**)(this + 428);
    *(_DWORD*)(this + 440) = v30[191];
    *(_DWORD*)(this + 444) = v30[192];
    *(_DWORD*)(this + 448) = v30[193];
    *(_DWORD*)(this + 452) = v30[194];
    *(_DWORD*)(this + 456) = v30[195];
    v31 = *(_DWORD*)(this + 2288);
    a2 = *(float*)(this + 2292);
    v32 = *(float*)(this + 2292);
    *(_DWORD*)(this + 2292) = v31;
    *(_BYTE*)(this + 460) = 1;
    a2 = v32;
    v33 = *(_DWORD*)(this + 428);
    if (*(_BYTE*)(dword_4F5CC4 + 937))
        sub_415770(*(_DWORD*)(this + 468), (float*)(v33 + 568), (float*)(v33 + 580), this, 0);
    else
        sub_415770(*(_DWORD*)(this + 468), (float*)(v33 + 568), (float*)(v33 + 580), this, (int)sub_433790);
    *(_DWORD*)(*(_DWORD*)(this + 468) + 4144) = 0;
    *(_BYTE*)(*(_DWORD*)(this + 468) + 4148) = 0;
    v34 = *(_DWORD*)(this + 428);
    *(_DWORD*)(this + 1356) = 0;
    v35 = *(_DWORD*)(v34 + 292);
    if (v35)
    {
        switch (v35)
        {
        case 1:
            v46 = *(_DWORD*)(this + 468);
            *(_DWORD*)(this + 1308) = 2;
            *(_BYTE*)(v46 + 4316) = 0;
            break;
        case 2:
            v47 = *(_DWORD*)(this + 468);
            *(_DWORD*)(this + 1308) = 1;
            *(_BYTE*)(v47 + 4316) = 0;
            v48 = *(_DWORD*)(this + 428);
            *(_DWORD*)(this + 1388) = 0;
            *(_DWORD*)(this + 1392) = 0;
            sub_4072A0(*(_DWORD**)(this + 432), *(_DWORD*)(v48 + 964), 0, 1);
            v49 = *(_DWORD*)(this + 428);
            a2 = 0.0;
            v50 = v49 + 976;
            v51 = *(_DWORD*)(v50 + 4);
            if (v51)
                v52 = (*(_DWORD*)(v50 + 8) - v51) >> 2;
            else
                v52 = 0;
            v53 = *(_DWORD*)(this + 1400);
            v54 = this + 1396;
            if (v53)
                v55 = (*(_DWORD*)(this + 1404) - v53) >> 2;
            else
                v55 = 0;
            if (v55 >= v52)
            {
                if (v53 && v52 < (*(_DWORD*)(this + 1404) - v53) >> 2)
                {
                    v54 = this + 1396;
                    a2 = *(float*)(this + 1404);
                    *(_DWORD*)(this + 1404) = v53 + 4 * v52;
                }
            }
            else
            {
                if (v53)
                    v56 = (*(_DWORD*)(this + 1404) - v53) >> 2;
                else
                    v56 = 0;
                sub_44F190(this + 1396, *(_DWORD**)(this + 1404), v52 - v56, &a2);
            }
            v57 = 0;
            while (1)
            {
                v58 = *(_DWORD*)(v54 + 4);
                if (!v58 || v57 >= (*(_DWORD*)(v54 + 8) - v58) >> 2)
                    break;
                a2 = *(float*)(*(_DWORD*)(*(_DWORD*)(this + 428) + 960) + 300);
                if (0.0 == a2)
                {
                    ++v57;
                    *(float*)(*(_DWORD*)(this + 1400) + 4 * v57 - 4) = 0.0;
                }
                else
                {
                    a3 = COERCE_FLOAT(rand());
                    ++v57;
                    *(float*)(*(_DWORD*)(this + 1400) + 4 * v57 - 4) = fabs((double)SLODWORD(a3) * 0.000030518509) * a2;
                }
            }
            break;
        case 3:
            *(_DWORD*)(this + 1308) = 0;
            *(_DWORD*)(this + 1412) = 0;
            v59 = *(float*)(v34 + 1000);
            a2 = *(float*)(v34 + 996);
            a3 = v59;
            if (a2 == v59)
            {
                v60 = a2;
            }
            else
            {
                v70 = rand();
                v60 = fabs((double)v70 * 0.000030518509) * (a3 - a2) + a2;
            }
            v61 = *(_DWORD*)(this + 428);
            *(_DWORD*)(this + 1424) = 0;
            *(float*)(this + 1416) = v60;
            v62 = *(_DWORD*)(v61 + 1012);
            if (v62)
            {
                sub_4282E0(
                    *(_BYTE*)(v62 + 301),
                    "dive sound did not set 'engine = true', see %s : %s",
                    *(const char**)(v61 + 4),
                    (const char*)(v61 + 16));
                v63 = *(_DWORD*)(this + 428);
                v72 = 0;
                v73 = 0;
                v74 = 0;
                sub_44D850(*(_DWORD*)(v63 + 1012), (float*)&v72, &v68, &v69);
                if (v68)
                {
                    v64 = (_BYTE*)sub_41E2D0(*(_DWORD**)(dword_520970 + 120), v68, 0, 1);
                    *(_DWORD*)(this + 1424) = v64;
                    if (v64)
                    {
                        sub_41D8A0(v64, *(_BYTE*)(*(_DWORD*)(*(_DWORD*)(this + 428) + 1012) + 330));
                        sub_41D8B0(
                            *(_DWORD**)(this + 1424),
                            *(_DWORD*)v69,
                            *(_DWORD*)(v69 + 12),
                            *(_DWORD*)(v69 + 20),
                            *(_DWORD*)(v69 + 4),
                            *(_DWORD*)(v69 + 8),
                            *(_DWORD*)(v69 + 16));
                        v65 = *(int**)(*(_DWORD*)(this + 428) + 1012);
                        sub_41D900(
                            *(_DWORD**)(this + 1424),
                            *(_DWORD*)(*(_DWORD*)(this + 468) + 4284),
                            v65[76],
                            v65[77],
                            v65[78],
                            v65[79],
                            v65[80],
                            v65[81]);
                    }
                }
            }
            break;
        case 4:
            *(_DWORD*)(this + 1308) = 0;
            v66 = *(float*)(v34 + 1028);
            a2 = *(float*)(v34 + 1024);
            a3 = v66;
            if (a2 == v66)
            {
                *(float*)(this + 1428) = a2;
            }
            else
            {
                v70 = rand();
                *(float*)(this + 1428) = fabs((double)v70 * 0.000030518509) * (a3 - a2) + a2;
            }
            break;
        case 5:
            *(_DWORD*)(this + 1308) = 6;
            break;
        }
    }
    else
    {
        *(_DWORD*)(this + 1308) = 0;
        *(_DWORD*)(this + 1356) = *(_DWORD*)(v34 + 920);
        v36 = *(float*)(v34 + 928);
        a2 = *(float*)(v34 + 924);
        a3 = v36;
        if (a2 == v36)
        {
            v37 = a2;
        }
        else
        {
            v70 = rand();
            v37 = fabs((double)v70 * 0.000030518509) * (a3 - a2) + a2;
        }
        v38 = *(_DWORD*)(this + 428);
        v39 = this + 1364;
        *(float*)(this + 1360) = v37;
        a2 = 0.0;
        v40 = *(_DWORD*)(v38 + 936);
        v41 = *(_DWORD*)(this + 1368);
        if (v41)
            v42 = (*(_DWORD*)(this + 1372) - v41) >> 2;
        else
            v42 = 0;
        if (v42 >= v40)
        {
            if (v41 && v40 < (*(_DWORD*)(this + 1372) - v41) >> 2)
            {
                v39 = this + 1364;
                a2 = *(float*)(this + 1372);
                *(_DWORD*)(this + 1372) = v41 + 4 * v40;
            }
        }
        else
        {
            if (v41)
                v43 = (*(_DWORD*)(this + 1372) - v41) >> 2;
            else
                v43 = 0;
            sub_44F190(this + 1364, *(_DWORD**)(this + 1372), v40 - v43, &a2);
        }
        for (i = 0; ; *(_DWORD*)(*(_DWORD*)(this + 1368) + 4 * i - 4) = 0)
        {
            v45 = *(_DWORD*)(v39 + 4);
            if (!v45 || i >= (*(_DWORD*)(v39 + 8) - v45) >> 2)
                break;
            ++i;
        }
        *(_DWORD*)(this + 1380) = 0;
        *(_DWORD*)(this + 1384) = 0;
    }
    sub_4229D0("Done adding new airplane '%s'", *(const char**)(*(_DWORD*)(this + 428) + 4));
    return this;
}
// 499458: using guessed type _UNKNOWN *off_499458;
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (00430A90) --------------------------------------------------------
int __thiscall sub_430A90(int this)
{
    void* v2; // ecx

    *(_DWORD*)this = &off_499458;
    v2 = *(void**)(this + 468);
    if (v2)
    {
        sub_415910(v2);
        *(_DWORD*)(this + 468) = 0;
    }
    sub_4229D0("Deleting airplane '%s'", *(const char**)(*(_DWORD*)(this + 428) + 4));
    sub_4317B0((_DWORD*)this, 2);
    if (*(_DWORD*)(this + 2300))
        sub_409850(dword_520970, *(int***)(this + 2300));
    sub_4885A6(*(LPVOID*)(this + 2288));
    *(_DWORD*)(this + 2288) = 0;
    *(_DWORD*)(this + 2292) = 0;
    *(_DWORD*)(this + 2296) = 0;
    nullsub_1(this + 1432);
    sub_4885A6(*(LPVOID*)(this + 1400));
    *(_DWORD*)(this + 1400) = 0;
    *(_DWORD*)(this + 1404) = 0;
    *(_DWORD*)(this + 1408) = 0;
    sub_4885A6(*(LPVOID*)(this + 1368));
    *(_DWORD*)(this + 1368) = 0;
    *(_DWORD*)(this + 1372) = 0;
    *(_DWORD*)(this + 1376) = 0;
    nullsub_1(this + 472);
    return sub_4013F0((_DWORD*)this);
}
// 415760: using guessed type int __thiscall nullsub_1(_DWORD);
// 499458: using guessed type _UNKNOWN *off_499458;
// 520970: using guessed type int dword_520970;

//----- (00430BC0) --------------------------------------------------------
int __thiscall sub_430BC0(int this, int* a2, int* a3, int a4, float* a5)
{
    float v5; // ebp
    int* v7; // ebx
    int v8; // edx
    int v9; // esi
    _DWORD* v10; // eax
    int v11; // edx
    int v12; // eax
    int v13; // edx
    int v14; // ecx
    int v16; // [esp+Ch] [ebp-64h]
    _WORD v17[4]; // [esp+10h] [ebp-60h] BYREF
    int v18; // [esp+18h] [ebp-58h]
    int v19; // [esp+1Ch] [ebp-54h]
    int v20; // [esp+20h] [ebp-50h]
    int v21; // [esp+24h] [ebp-4Ch]
    int v22; // [esp+28h] [ebp-48h]
    char v23; // [esp+2Ch] [ebp-44h]
    int v24[16]; // [esp+30h] [ebp-40h] BYREF

    v5 = *(float*)&a4;
    v16 = *(_DWORD*)(*(_DWORD*)(a4 + 4) + 300);
    if (!*(_BYTE*)(this + 16))
        return 0;
    v7 = (int*)a5;
    if (!sub_407710(*(float**)(this + 432), *a2, a2[1], a2[2], *a3, a3[1], a3[2], &a4, a5))
        return 0;
    v8 = *(_DWORD*)(this + 428);
    v9 = 0;
    v10 = (_DWORD*)(v8 + 628);
    while (!*((_BYTE*)v10 - 4) || a4 != *v10)
    {
        ++v9;
        v10 += 6;
        if (v9 >= 5)
            goto LABEL_13;
    }
    if (*(_BYTE*)(dword_4F5CC4 + 936) || *(_BYTE*)(dword_4F5CC4 + 937))
    {
        if (!*(_BYTE*)(LODWORD(v5) + 124))
        {
            v17[3] = *(_WORD*)(this + 392);
            v18 = v9;
            v19 = *v7;
            v20 = v7[1];
            v11 = *(_DWORD*)(LODWORD(v5) + 4);
            v21 = v7[2];
            v23 = *(_BYTE*)(v11 + 312);
            v22 = v16;
            sub_4117D0(dword_4F5CC4, (int**)0x103, v17, 29, 2, 10000);
        }
    }
    else
    {
        sub_4229D0("%s hit on section %d", *(const char**)(v8 + 4), v9);
        v12 = *(_DWORD*)(LODWORD(v5) + 4);
        LOBYTE(v13) = *(_BYTE*)(v12 + 312);
        sub_430F00(this, v9, v7, *(float*)(v12 + 300), v13);
    }
LABEL_13:
    v14 = *(_DWORD*)(this + 432);
    memset(&v24[11], 0, 16);
    memset(&v24[6], 0, 16);
    memset(&v24[1], 0, 16);
    v24[15] = 1065353216;
    v24[10] = 1065353216;
    v24[5] = 1065353216;
    v24[0] = 1065353216;
    sub_407690(v14, a4, v24);
    sub_46C5C5((float*)v7, (float*)v7, (float*)v24);
    return 5;
}
// 430CF5: variable 'v13' is possibly undefined
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (00430DC0) --------------------------------------------------------
char __thiscall sub_430DC0(int this, int* a2, float a3, float a4, int a5, int a6)
{
    int v6; // ebx
    int v7; // edi
    int i; // ebp
    int v10; // eax
    float v12; // [esp+0h] [ebp-44h]
    int v13; // [esp+18h] [ebp-2Ch] BYREF
    int v14; // [esp+1Ch] [ebp-28h]
    int v15; // [esp+20h] [ebp-24h]
    _WORD v16[4]; // [esp+24h] [ebp-20h] BYREF
    int v17; // [esp+2Ch] [ebp-18h]
    int v18; // [esp+30h] [ebp-14h]
    int v19; // [esp+34h] [ebp-10h]
    int v20; // [esp+38h] [ebp-Ch]
    float v21; // [esp+3Ch] [ebp-8h]
    char v22; // [esp+40h] [ebp-4h]

    v6 = a5;
    v7 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    for (i = 0; i < 120; i += 24)
    {
        v10 = *(_DWORD*)(this + 428);
        if (*(_BYTE*)(v10 + i + 624))
        {
            LOBYTE(v10) = sub_407F00(*(_DWORD*)(this + 432), *(_DWORD*)(v10 + i + 628), a2, a3, &v13, (float*)&a5);
            if ((_BYTE)v10)
            {
                sub_4229D0("%s splashed on section %d", *(const char**)(*(_DWORD*)(this + 428) + 4), v7);
                if (*(_BYTE*)(dword_4F5CC4 + 936) || *(_BYTE*)(dword_4F5CC4 + 937))
                {
                    v16[3] = *(_WORD*)(this + 392);
                    v19 = v14;
                    v21 = *(float*)&a5 * a4;
                    v18 = v13;
                    v17 = v7;
                    v20 = v15;
                    v22 = v6;
                    LOBYTE(v10) = sub_4117D0(dword_4F5CC4, (int**)0x103, v16, 29, 2, 10000);
                }
                else
                {
                    sub_4229D0("%s hit on section %d", *(const char**)(*(_DWORD*)(this + 428) + 4), v7);
                    v12 = *(float*)&a5 * a4;
                    LOBYTE(v10) = sub_430F00(this, v7, &v13, v12, v6);
                }
            }
        }
        ++v7;
    }
    return v10;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (00430F00) --------------------------------------------------------
char __thiscall sub_430F00(int this, int a2, int* a3, float a4, int a5)
{
    char v6; // bl
    double v7; // st7
    int v8; // eax
    int v9; // ecx
    float* v10; // ecx

    v6 = 0;
    sub_4229D0("%s applying %0.1f damage on section %d", *(const char**)(*(_DWORD*)(this + 428) + 4), a4, a2);
    if (*(float*)(this + 4 * a2 + 440) > 0.0)
    {
        v7 = *(float*)(this + 4 * a2 + 440) - a4;
        *(float*)(this + 4 * a2 + 440) = v7;
        if (v7 <= 0.0)
            v6 = sub_431040(this, a2);
    }
    v8 = *(_DWORD*)(this + 428);
    v9 = *(_DWORD*)(v8 + 884);
    if (v9)
        sub_44E040(
            *(char**)(dword_520970 + 240),
            v9,
            this + 1340,
            *(_DWORD*)(this + 432),
            *(float*)(v8 + 24 * a2 + 628),
            a3);
    v10 = *(float**)(this + 428);
    if (v10[194] * 0.5 > *(float*)(this + 452)
        || v10[191] * 0.5 > *(float*)(this + 440)
        || v10[192] * 0.5 > *(float*)(this + 444)
        || v10[193] * 0.5 > *(float*)(this + 448)
        || v10[195] * 0.5 > *(float*)(this + 456))
    {
        sub_4317B0((_DWORD*)this, 1);
    }
    return v6;
}
// 520970: using guessed type int dword_520970;

//----- (00431040) --------------------------------------------------------
char __thiscall sub_431040(int this, int a2)
{
    int v3; // edi
    unsigned int i; // ebp
    int v5; // eax
    int v6; // ecx
    int j; // ebp
    unsigned int k; // edi
    int v9; // edx
    int v10; // ecx
    int v11; // ebx
    int v12; // ebp
    int v13; // ebx
    float* v14; // eax
    int v15; // ebx
    int v16; // edx
    unsigned int v17; // ebx
    int v18; // ebp
    int v19; // eax
    int v20; // ecx
    int v21; // eax
    int v22; // edi
    int v23; // edx
    unsigned int v24; // eax
    unsigned int v25; // ebp
    int v26; // ebp
    int v27; // edi
    float* v28; // ecx
    long double v29; // st7
    long double v30; // st7
    double v31; // st7
    float* v32; // eax
    int v33; // eax
    int v34; // eax
    int v35; // eax
    int v36; // eax
    int v37; // ebx
    int v38; // edi
    float* v39; // ebp
    int v41; // [esp-Ch] [ebp-74h]
    char v42; // [esp+13h] [ebp-55h]
    unsigned int v43; // [esp+14h] [ebp-54h]
    int v44; // [esp+14h] [ebp-54h]
    int v45; // [esp+18h] [ebp-50h]
    int v46; // [esp+18h] [ebp-50h]
    float v47; // [esp+1Ch] [ebp-4Ch]
    float v48; // [esp+20h] [ebp-48h]
    float v49; // [esp+24h] [ebp-44h]
    float v50; // [esp+28h] [ebp-40h]
    float v51; // [esp+2Ch] [ebp-3Ch]
    float v52; // [esp+30h] [ebp-38h] BYREF
    float v53; // [esp+34h] [ebp-34h]
    float v54; // [esp+38h] [ebp-30h]
    int v55; // [esp+3Ch] [ebp-2Ch] BYREF
    int v56; // [esp+40h] [ebp-28h]
    int v57; // [esp+44h] [ebp-24h]
    char v58[32]; // [esp+48h] [ebp-20h] BYREF

    v42 = sub_4333C0(this, 1);
    if (*(_BYTE*)(this + 460))
    {
        v3 = a2;
    }
    else
    {
        v3 = 0;
        *(_BYTE*)(this + 460) = 1;
        a2 = 0;
    }
    if (*(_BYTE*)(this + 436))
    {
        sub_4229D0("%s destroyed (because section %d destroyed)", *(const char**)(*(_DWORD*)(this + 428) + 4), v3);
        for (i = 0; ; ++i)
        {
            v5 = *(_DWORD*)(this + 428);
            v6 = *(_DWORD*)(v5 + 612);
            if (!v6 || i >= (*(_DWORD*)(v5 + 616) - v6) >> 2)
                break;
            sub_408640(*(_DWORD**)(this + 432), *(_DWORD*)(v6 + 4 * i), 0);
        }
        for (j = 0; j < 120; j += 24)
        {
            if (j != 24 && j != 48)
            {
                for (k = 0; ; ++k)
                {
                    v9 = *(_DWORD*)(this + 428);
                    v10 = *(_DWORD*)(v9 + j + 636);
                    if (!v10 || k >= (*(_DWORD*)(v9 + j + 640) - v10) >> 2)
                        break;
                    sub_407650(*(_DWORD**)(this + 432), *(_DWORD*)(v10 + 4 * k), 1);
                }
                v3 = a2;
            }
        }
        *(_DWORD*)(this + 1308) = 6;
        if (!*(_BYTE*)(dword_4F5CC4 + 937))
        {
            v11 = v3;
            if (*(_BYTE*)(*(_DWORD*)(this + 428) + 300))
                v11 = rand() % 4 + 1;
            if (v11)
            {
                sub_4164A0(*(_DWORD*)(this + 468), 6);
                if (v11 > 0)
                {
                    if (v11 <= 2)
                    {
                        *(float*)&v45 = *(float*)(*(_DWORD*)(this + 468) + 4284)
                            * *(float*)(*(_DWORD*)(this + 428) + 876)
                            * 7.0;
                        sub_41C060((_DWORD*)(this + 472), 1112014848, v45, v45);
                        sub_41C0B0(this + 472, *(float*)(*(_DWORD*)(this + 428) + 876));
                        sub_41C0B0(this + 472, *(float*)(*(_DWORD*)(this + 428) + 876));
                        sub_41C0B0(this + 472, *(float*)(*(_DWORD*)(this + 428) + 876));
                    }
                    else if (v11 == 3)
                    {
                        *(_DWORD*)(*(_DWORD*)(this + 468) + 4300) = 0;
                        *(float*)(*(_DWORD*)(this + 468) + 4304) = *(float*)(*(_DWORD*)(this + 468) + 4304)
                            + *(float*)(*(_DWORD*)(this + 468) + 4304);
                        *(_DWORD*)(*(_DWORD*)(this + 468) + 4308) = -981860352;
                        *(_DWORD*)(*(_DWORD*)(this + 468) + 4312) = -985956352;
                    }
                }
                v12 = 0;
                v13 = v11 - 1;
                while (1)
                {
                    switch (v13)
                    {
                    case 0:
                        *(float*)(*(_DWORD*)(this + 468) + 4284) = sin(*(float*)(*(_DWORD*)(this + 468) + 4296)) * 600.0
                            + *(float*)(*(_DWORD*)(this + 468) + 4284);
                        sub_419910(*(_DWORD*)(this + 468), -0.30000001, -1.0, COERCE_FLOAT(1), 0, 0);
                        break;
                    case 1:
                        *(float*)(*(_DWORD*)(this + 468) + 4284) = sin(*(float*)(*(_DWORD*)(this + 468) + 4296)) * 600.0
                            + *(float*)(*(_DWORD*)(this + 468) + 4284);
                        sub_419910(*(_DWORD*)(this + 468), 0.30000001, -1.0, COERCE_FLOAT(1), 0, 0);
                        break;
                    case 2:
                        sub_418E50(*(_DWORD*)(this + 468), 0, 0.0);
                        break;
                    case 3:
                        *(float*)(*(_DWORD*)(this + 468) + 4284) = sin(
                            *(float*)(*(_DWORD*)(this + 468) + 4296)
                            + *(float*)(*(_DWORD*)(this + 468) + 4296))
                            * 600.0
                            + *(float*)(*(_DWORD*)(this + 468) + 4284);
                        sub_419910(*(_DWORD*)(this + 468), 0.0, -2.0, COERCE_FLOAT(1), 0, 0);
                        break;
                    default:
                        break;
                    }
                    if (*(float*)(sub_417140(*(_DWORD**)(this + 468), 0) + 8) < -2000.0)
                        break;
                    if (++v12 >= 500)
                    {
                        v14 = (float*)sub_417140(*(_DWORD**)(this + 468), 0);
                        v15 = 10;
                        v52 = *v14;
                        v53 = v14[1];
                        v54 = -3000.0;
                        do
                        {
                            sub_416350(*(_DWORD*)(this + 468), &v52, 0);
                            --v15;
                        } while (v15);
                        break;
                    }
                }
            }
        }
    }
    v16 = *(_DWORD*)(this + 428);
    *(_BYTE*)(this + 436) = 0;
    if (!*(_BYTE*)(v16 + 300))
    {
        v17 = 0;
        v18 = 24 * v3;
        v43 = 0;
        v46 = 24 * v3;
        while (1)
        {
            v19 = v18 + *(_DWORD*)(this + 428);
            v20 = *(_DWORD*)(v19 + 636);
            if (!v20 || v17 >= (*(_DWORD*)(v19 + 640) - v20) >> 2)
                break;
            sub_407390(*(_DWORD**)(this + 432), *(_DWORD*)(v20 + 4 * v17), 1);
            sub_407460(*(_DWORD**)(this + 432), *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 428) + v18 + 636) + 4 * v17));
            v21 = *(_DWORD*)(this + 2288);
            if (v21)
                v22 = (*(_DWORD*)(this + 2292) - v21) >> 5;
            else
                v22 = 0;
            v23 = *(_DWORD*)(this + 2288);
            v24 = v22 + 1;
            if (v23)
                v25 = (*(_DWORD*)(this + 2292) - v23) >> 5;
            else
                v25 = 0;
            if (v25 >= v24)
            {
                if (v23)
                {
                    if (v24 < (*(_DWORD*)(this + 2292) - v23) >> 5)
                        sub_434200((_DWORD*)(this + 2284), (char*)(v23 + 32 * v24), *(char**)(this + 2292));
                    v17 = v43;
                }
            }
            else
            {
                if (v23)
                    v26 = (*(_DWORD*)(this + 2292) - v23) >> 5;
                else
                    v26 = 0;
                sub_433F70((_DWORD*)(this + 2284), *(char**)(this + 2292), v24 - v26, v58);
            }
            v27 = 32 * v22;
            *(_DWORD*)(v27 + *(_DWORD*)(this + 2288)) = *(_DWORD*)(*(_DWORD*)(v46 + *(_DWORD*)(this + 428) + 636)
                + 4 * v17);
            v44 = rand();
            v28 = (float*)(v27 + *(_DWORD*)(this + 2288) + 4);
            v29 = fabs((double)v44 * 0.000030518509) * 0.59999996 + 0.69999999;
            v49 = v29 * *(float*)(this + 1340);
            v50 = v29 * *(float*)(this + 1344);
            v30 = v29 * *(float*)(this + 1348);
            *v28 = v49;
            v51 = v30;
            v28[1] = v50;
            v28[2] = v51;
            if (a2 == 1 || a2 == 2)
                *(_DWORD*)(v27 + *(_DWORD*)(this + 2288) + 16) = -1021968384;
            else
                *(_DWORD*)(v27 + *(_DWORD*)(this + 2288) + 16) = 0;
            v48 = fabs((double)rand() * 0.000030518509);
            v47 = fabs((double)rand() * 0.000030518509);
            v31 = (double)rand();
            v32 = (float*)(v27 + *(_DWORD*)(this + 2288) + 20);
            v52 = fabs(v31 * 0.000030518509) * 3.1415927 - 1.5707964;
            *v32 = v52;
            v53 = v47 * 3.1415927 - 1.5707964;
            v32[1] = v53;
            v54 = v48 * 3.1415927 - 1.5707964;
            v32[2] = v54;
            v33 = *(_DWORD*)(this + 428);
            if (*(_DWORD*)(v33 + 888))
            {
                v55 = 0;
                v56 = 0;
                v57 = 0;
                sub_44E040(
                    *(char**)(dword_520970 + 240),
                    *(_DWORD*)(v33 + 888),
                    this + 1340,
                    *(_DWORD*)(this + 432),
                    *(float*)(*(_DWORD*)(v46 + v33 + 636) + 4 * v17),
                    &v55);
            }
            v18 = v46;
            v3 = a2;
            v43 = ++v17;
        }
    }
    if (!v3 || *(float*)(this + 440) > 0.0)
    {
        v34 = *(_DWORD*)(this + 428);
        if (*(_DWORD*)(v34 + 892))
        {
            v41 = *(_DWORD*)(this + 432);
            v55 = 0;
            v56 = 0;
            v57 = 0;
            sub_44E040(*(char**)(dword_520970 + 240), *(_DWORD*)(v34 + 892), this + 1340, v41, 0.0, &v55);
        }
    }
    if (v3)
    {
        if (*(float*)(this + 440) > 0.0)
        {
            v35 = *(_DWORD*)(this + 428);
            if (*(_DWORD*)(v35 + 888))
            {
                v55 = 0;
                v56 = 0;
                v57 = 0;
                sub_44E040(
                    *(char**)(dword_520970 + 240),
                    *(_DWORD*)(v35 + 888),
                    this + 1340,
                    *(_DWORD*)(this + 432),
                    *(float*)(v35 + 4 * v3 + 744),
                    &v55);
            }
        }
    }
    if (*(_BYTE*)(*(_DWORD*)(this + 428) + 300))
    {
        if (!v3)
            goto LABEL_80;
    }
    else if (!v3)
    {
        v36 = *(_DWORD*)(this + 2300);
        *(_BYTE*)(this + 437) = 0;
        if (v36)
            *(_BYTE*)(v36 + 32) = 0;
        v37 = 0;
        v38 = 624;
        v39 = (float*)(this + 440);
        do
        {
            if (*(_BYTE*)(v38 + *(_DWORD*)(this + 428)) && *v39 > 0.0)
            {
                *v39 = 0.0;
                sub_431040(v37);
            }
            v38 += 24;
            ++v37;
            ++v39;
        } while (v38 < 744);
        goto LABEL_80;
    }
    if (v3 != 3)
    {
        sub_4317B0((_DWORD*)this, 1);
        return v42;
    }
LABEL_80:
    sub_4317B0((_DWORD*)this, 2);
    return v42;
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (004317B0) --------------------------------------------------------
int __thiscall sub_4317B0(_DWORD* this, int a2)
{
    int result; // eax
    int v4; // ecx
    int v5; // ecx
    int v6; // ecx
    int v7; // ecx
    int v8[3]; // [esp+Ch] [ebp-Ch] BYREF

    result = this[107];
    if (*(_DWORD*)(result + 896) && !this[567] && a2 == 1)
    {
        memset(v8, 0, sizeof(v8));
        result = sub_44E040(
            *(char**)(dword_520970 + 240),
            *(_DWORD*)(result + 896),
            (int)(this + 335),
            this[108],
            **(float**)(result + 636),
            v8);
    }
    v4 = this[568];
    this[567] = a2;
    if (v4 && a2)
    {
        result = sub_41D9A0(v4);
        this[568] = 0;
    }
    v5 = this[569];
    if (v5 && this[567])
    {
        result = sub_41D9A0(v5);
        this[569] = 0;
    }
    v6 = this[570];
    if (v6 && this[567] == 2)
    {
        result = sub_41D9A0(v6);
        this[570] = 0;
    }
    if (*(_DWORD*)(this[107] + 292) == 3)
    {
        v7 = this[356];
        if (v7)
        {
            if (this[567] == 2)
            {
                result = sub_41D9A0(v7);
                this[356] = 0;
            }
        }
    }
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (004318B0) --------------------------------------------------------
char __thiscall sub_4318B0(_DWORD* this)
{
    int v2; // ecx
    int v3; // ecx
    int v4; // edx
    int v5; // eax
    int v6; // ecx
    _DWORD* v7; // ecx
    int v8; // ecx
    int v9; // eax
    int v10; // ecx
    int v11; // edx
    int v12; // eax
    int v13; // ecx
    int v14; // ecx
    int v15; // edx
    int v16; // eax
    int v17; // ecx
    int v18; // edx
    _DWORD* v19; // ecx
    int v20; // eax
    int v21; // ecx
    int v22; // eax
    int v23; // edx
    int v24; // eax
    int v25; // edx
    int v26; // eax
    int v28; // [esp+4h] [ebp-18h] BYREF
    int v29; // [esp+8h] [ebp-14h]
    int v30; // [esp+Ch] [ebp-10h]
    int v31; // [esp+10h] [ebp-Ch] BYREF
    int v32; // [esp+14h] [ebp-8h]
    int v33; // [esp+18h] [ebp-4h]

    if (!this[567])
    {
        v2 = this[568];
        if (v2)
        {
            sub_41D840(v2);
            v3 = this[336];
            v4 = this[337];
            v28 = this[335];
            v5 = this[328];
            v29 = v3;
            v6 = this[329];
            v31 = v5;
            v32 = v6;
            v30 = v4;
            v7 = (_DWORD*)this[568];
            v33 = this[330];
            sub_41D960(v7, &v31, &v28);
        }
        if (!this[567])
        {
            v8 = this[569];
            if (v8)
            {
                sub_41D840(v8);
                v9 = this[336];
                v10 = this[337];
                v31 = this[335];
                v11 = this[328];
                v32 = v9;
                v12 = this[329];
                v33 = v10;
                v13 = this[330];
                v28 = v11;
                v29 = v12;
                v30 = v13;
                sub_41D960((_DWORD*)this[569], &v28, &v31);
            }
        }
    }
    if (this[567] == 1)
    {
        v14 = this[570];
        if (v14)
        {
            sub_41D840(v14);
            v15 = this[336];
            v16 = this[337];
            v31 = this[335];
            v17 = this[328];
            v32 = v15;
            v18 = this[329];
            v28 = v17;
            v29 = v18;
            v33 = v16;
            v19 = (_DWORD*)this[570];
            v30 = this[330];
            sub_41D960(v19, &v28, &v31);
        }
    }
    v20 = this[107];
    if (*(_DWORD*)(v20 + 292) == 3)
    {
        v21 = this[356];
        if (v21)
        {
            LOBYTE(v20) = *(_BYTE*)(v21 + 16);
            if ((_BYTE)v20)
            {
                v22 = this[336];
                v31 = this[335];
                v23 = this[337];
                v32 = v22;
                v24 = this[328];
                v33 = v23;
                v25 = this[329];
                v28 = v24;
                v26 = this[330];
                v29 = v25;
                v30 = v26;
                LOBYTE(v20) = sub_41D960((_DWORD*)v21, &v28, &v31);
            }
        }
    }
    return v20;
}

//----- (00431A70) --------------------------------------------------------
char __thiscall sub_431A70(int this, int a2)
{
    double v3; // st7
    float* v4; // edi
    double v5; // st7
    int v6; // ecx
    int v8; // eax
    float v9; // eax
    int v10; // eax
    int v11; // eax
    char v12; // al
    double v13; // st6
    double v14; // st7
    double v15; // st7
    double v16; // st6
    double v17; // st7
    double v18; // st6
    double v19; // st5
    int v20; // ecx
    int v21; // edx
    int v22; // eax
    double v23; // st6
    double v24; // st5
    float v25; // eax
    float v26; // ecx
    int v27; // eax
    int v28; // eax
    unsigned __int8 v30; // c0
    unsigned __int8 v31; // c3
    int v32; // ecx
    int v33; // eax
    double v34; // st7
    int v35; // ecx
    int v36; // ecx
    int v37; // eax
    char v38; // cl
    double v39; // st7
    int v40; // eax
    long double v41; // st7
    int v42; // ebx
    int v43; // eax
    int v44; // edi
    int v45; // esi
    int v46; // eax
    int v47; // edi
    int v48; // eax
    int v49; // ebx
    int v50; // esi
    unsigned int j; // esi
    int v52; // eax
    float* v53; // edi
    int v54; // eax
    long double v55; // st7
    unsigned int k; // edi
    int v57; // eax
    int v58; // ecx
    int v59; // eax
    double v60; // st7
    int v61; // ecx
    _DWORD* v62; // eax
    double v63; // st7
    double v64; // st6
    int v65; // eax
    int v66; // eax
    int v67; // ecx
    double v68; // st7
    int v69; // eax
    int v70; // ecx
    double v71; // st7
    unsigned int i; // esi
    int v73; // ecx
    int v74; // eax
    long double v75; // st7
    int v76; // edx
    int v77; // eax
    double v78; // st7
    int v79; // ecx
    double v80; // st7
    int v81; // edx
    _DWORD* v82; // ecx
    int v83; // edx
    int v84; // ecx
    double v85; // st7
    int v86; // edi
    unsigned int v87; // esi
    int m; // ebx
    int v89; // eax
    int v90; // ecx
    double v91; // st7
    double v92; // st6
    double v93; // st5
    float* v94; // ecx
    long double v95; // st4
    float v96; // edx
    int v97; // eax
    double v98; // st6
    float* v99; // eax
    int v100; // eax
    float v101; // edx
    int v102; // eax
    float* v103; // eax
    int v104; // edx
    int* v105; // eax
    int v106; // edx
    int v107; // eax
    float v108; // eax
    int v109; // eax
    int v110; // esi
    int v111; // eax
    char* v112; // edx
    const void* v113; // esi
    int v114; // ecx
    int v115; // eax
    double v116; // st7
    double v117; // st5
    double v118; // st6
    double v119; // st7
    double v120; // st7
    double v121; // st6
    float* v122; // eax
    double v123; // st7
    double v124; // st6
    double v125; // st5
    double v126; // st4
    float v127; // eax
    float v128; // edx
    float v129; // edx
    float v130; // ecx
    float v131; // ecx
    float v132; // eax
    _DWORD* v133; // ecx
    int v134; // eax
    double v135; // st7
    int v136; // esi
    float v137; // [esp+4h] [ebp-FCh]
    float v138; // [esp+8h] [ebp-F8h]
    float v139; // [esp+Ch] [ebp-F4h]
    float v140; // [esp+20h] [ebp-E0h]
    float v141; // [esp+20h] [ebp-E0h]
    int v142; // [esp+24h] [ebp-DCh] BYREF
    int v143; // [esp+28h] [ebp-D8h] BYREF
    int v144; // [esp+2Ch] [ebp-D4h] BYREF
    float v145; // [esp+30h] [ebp-D0h]
    float v146; // [esp+34h] [ebp-CCh]
    int v147; // [esp+38h] [ebp-C8h] BYREF
    float v148; // [esp+3Ch] [ebp-C4h]
    float v149; // [esp+40h] [ebp-C0h]
    int v150; // [esp+44h] [ebp-BCh] BYREF
    float v151; // [esp+48h] [ebp-B8h]
    float v152; // [esp+4Ch] [ebp-B4h]
    int v153; // [esp+50h] [ebp-B0h] BYREF
    int v154; // [esp+54h] [ebp-ACh] BYREF
    float v155; // [esp+58h] [ebp-A8h]
    float v156; // [esp+5Ch] [ebp-A4h]
    int v157; // [esp+60h] [ebp-A0h] BYREF
    float v158; // [esp+64h] [ebp-9Ch]
    float v159; // [esp+68h] [ebp-98h]
    int v160; // [esp+6Ch] [ebp-94h] BYREF
    float v161; // [esp+70h] [ebp-90h]
    float v162; // [esp+74h] [ebp-8Ch]
    int v163; // [esp+78h] [ebp-88h]
    int v164; // [esp+7Ch] [ebp-84h]
    int v165; // [esp+80h] [ebp-80h]
    int v166; // [esp+84h] [ebp-7Ch]
    float v167; // [esp+88h] [ebp-78h]
    float v168; // [esp+8Ch] [ebp-74h]
    float v169; // [esp+90h] [ebp-70h]
    int v170; // [esp+94h] [ebp-6Ch]
    int v171; // [esp+98h] [ebp-68h]
    float v172; // [esp+9Ch] [ebp-64h]
    float v173; // [esp+A0h] [ebp-60h]
    float v174; // [esp+A4h] [ebp-5Ch]
    int v175; // [esp+A8h] [ebp-58h]
    int v176; // [esp+ACh] [ebp-54h] BYREF
    int v177; // [esp+B0h] [ebp-50h]
    _BYTE v178[5]; // [esp+B4h] [ebp-4Ch]
    __int16 v179; // [esp+B9h] [ebp-47h]
    __int16 v180; // [esp+BBh] [ebp-45h]
    __int16 v181; // [esp+BDh] [ebp-43h]
    char v182; // [esp+BFh] [ebp-41h]
    int v183[16]; // [esp+C0h] [ebp-40h] BYREF

    if (*(float*)(this + 464) > 0.0)
    {
        v3 = *(float*)(this + 464) - *(float*)&a2;
        *(float*)(this + 464) = v3;
        if (v3 >= 0.0)
            return sub_428620((_DWORD*)this, a2);
        *(_DWORD*)(this + 464) = 0;
    }
    if (!*(_BYTE*)(this + 436) && !*(_BYTE*)(this + 437))
        goto LABEL_38;
    if (*(_BYTE*)(this + 460))
    {
        v4 = (float*)(this + 1336);
        v150 = *(int*)(this + 1312);
        v151 = *(float*)(this + 1316);
        v152 = *(float*)(this + 1320);
        sub_4159B0(
            *(_DWORD*)(this + 468),
            *(float*)&a2,
            (_DWORD*)(this + 1312),
            (_DWORD*)(this + 1324),
            (float*)(this + 1336),
            this + 1340,
            (float*)(this + 1352));
        v5 = sub_41C200((float*)(this + 472), *(float*)&a2) * *v4;
        *(float*)&v147 = 0.0;
        v148 = 0.0;
        v149 = 0.0;
        *v4 = v5;
        if (sub_468CA0(*(int**)(dword_520970 + 260), (float*)&v150, (int*)(this + 1312), (float*)&v147, &v143))
        {
            if (!*(_BYTE*)(this + 436) || *(_DWORD*)(*(_DWORD*)(this + 428) + 292) == 5)
            {
                if (*(float*)&v143 == NAN)
                {
                    v6 = 0;
                }
                else if (*(float*)&v143 == 0.0)
                {
                    v6 = 1;
                }
                else if (v143 == 1)
                {
                    v6 = 3;
                }
                else if (v143 == 2)
                {
                    v6 = 2;
                }
                else
                {
                    v6 = 2;
                    if (v143 != 3)
                        v6 = v144;
                }
                v8 = *(_DWORD*)(*(_DWORD*)(this + 428) + 900);
                if (v8 && (v9 = *(float*)(v8 + 4 * v6 + 292), v9 != 0.0)
                    || (v10 = *(_DWORD*)(*(_DWORD*)(dword_520970 + 276) + 20)) != 0
                    && (v9 = *(float*)(v10 + 4 * v6 + 292), v9 != 0.0))
                {
                    *(float*)&v157 = 0.0;
                    v158 = 0.0;
                    v159 = 0.0;
                    sub_44DF20(*(char**)(dword_520970 + 240), v9, COERCE_FLOAT(&v147), (float*)&v157);
                }
                v11 = *(_DWORD*)(this + 428);
                if (*(_DWORD*)(v11 + 292) == 5)
                    sub_44AE60(&v147, *(_DWORD*)(v11 + 1036), *(float*)(v11 + 1032), 1, 0);
            }
        }
        else if (*(float*)(this + 1320) >= -1000.0)
        {
            v12 = 0;
            goto LABEL_29;
        }
        v12 = 1;
    LABEL_29:
        if (!*(_BYTE*)(dword_4F5CC4 + 937) || *(_DWORD*)(*(_DWORD*)(this + 428) + 292) == 5)
        {
            if (!v12)
                goto LABEL_38;
        }
        else if (!v12 || *(_BYTE*)(this + 436))
        {
        LABEL_38:
            if (*(_BYTE*)(this + 460))
            {
                sub_46BEE6((float*)v183, *(float*)(this + 1336));
                v13 = *(float*)(this + 1328) - 0.0;
                v149 = 0.0;
                v146 = 0.0;
                *(float*)&v147 = v13;
                v14 = 0.0 - *(float*)(this + 1324);
                v144 = v147;
                v148 = v14;
                v145 = v148;
                sub_46B970(&v144, &v144);
                v15 = v145 * *(float*)(this + 1332);
                v16 = v146 * *(float*)(this + 1328);
                v160 = v144;
                v17 = v15 - v16;
                v18 = v146 * *(float*)(this + 1324);
                v19 = *(float*)&v144 * *(float*)(this + 1332);
                v20 = *(_DWORD*)(this + 1324);
                v161 = v145;
                v21 = *(_DWORD*)(this + 1328);
                v162 = v146;
                v22 = *(_DWORD*)(this + 1332);
                v164 = v20;
                v165 = v21;
                v166 = v22;
                v151 = v18 - v19;
                v23 = *(float*)&v144 * *(float*)(this + 1328);
                v24 = v145 * *(float*)(this + 1324);
                v25 = *(float*)(this + 1312);
                v169 = v151;
                v26 = *(float*)(this + 1316);
                v172 = v25;
                v173 = v26;
                v152 = v23 - v24;
                v168 = v17;
                v170 = LODWORD(v152);
                v174 = *(float*)(this + 1320);
                v163 = 0;
                v167 = 0.0;
                v171 = 0;
                v175 = 1065353216;
                sub_46B97C(&v160, v183, &v160);
                sub_4073F0(*(_DWORD**)(this + 432), 0, &v160);
            }
            goto LABEL_40;
        }
        sub_4229D0("Airplane %s went underground", *(const char**)(*(_DWORD*)(this + 428) + 4));
        *(_BYTE*)(this + 436) = 0;
        *(_BYTE*)(this + 437) = 0;
        sub_4333C0(this, 0);
        (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)this + 24))(this, 0);
        goto LABEL_38;
    }
LABEL_40:
    if (*(_BYTE*)(this + 436)
        || *(_BYTE*)(this + 437)
        || (v27 = *(_DWORD*)(this + 2288)) != 0 && ((*(_DWORD*)(this + 2292) - v27) & 0xFFFFFFE0) != 0)
    {
        v28 = *(_DWORD*)(this + 1308);
        if ((v28 == 1 || v28 == 2)
            && *(float*)(this + 1320) * *(float*)(this + 1348)
            + *(float*)(this + 1316) * *(float*)(this + 1344)
            + *(float*)(this + 1312) * *(float*)(this + 1340) > 0.0
            && !(v30 | v31)
            && !*(_BYTE*)(dword_4F5CC4 + 937))
        {
            (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)this + 24))(this, 0);
            sub_4333C0(this, 0);
            if (*(_BYTE*)(dword_4F5CC4 + 936))
            {
                HIWORD(v145) = *(_WORD*)(this + 392);
                sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x105, &v144, 8, 7, 10000);
            }
        }
    }
    else
    {
        (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)this + 24))(this, 0);
        sub_4333C0(this, 0);
    }
    if (*(_BYTE*)(this + 436))
    {
        v32 = *(_DWORD*)(this + 428);
        v33 = *(_DWORD*)(v32 + 292);
        if (v33)
        {
            if (v33 != 1)
            {
                if (v33 == 2)
                {
                    if (*(_BYTE*)(v32 + 300))
                    {
                        v150 = *(int*)(this + 1312);
                        v151 = *(float*)(this + 1316);
                        v63 = v151 * *(float*)(this + 420);
                        v64 = *(float*)&v150 * *(float*)(this + 416);
                        v152 = *(float*)(this + 1320);
                        v140 = -(v63 + v64);
                    }
                    else
                    {
                        v140 = *(float*)(this + 1316);
                    }
                    if (!*(_DWORD*)(this + 1388) && v140 < (double)*(float*)(v32 + 948))
                    {
                        v65 = *(_DWORD*)(this + 432);
                        *(_DWORD*)(this + 1388) = 1;
                        *(float*)&v150 = 0.0;
                        v151 = 0.0;
                        v152 = 0.0;
                        sub_44E040(*(char**)(dword_520970 + 240), *(_DWORD*)(v32 + 992), this + 1340, v65, 0.0, &v150);
                    }
                    if (*(_DWORD*)(this + 1388) == 1 && v140 < (double)*(float*)(*(_DWORD*)(this + 428) + 956))
                        *(_DWORD*)(this + 1388) = 2;
                    if (*(_DWORD*)(this + 1388) == 2 && v140 < (double)*(float*)(*(_DWORD*)(this + 428) + 952))
                        *(_DWORD*)(this + 1388) = 3;
                    v66 = *(_DWORD*)(this + 1388);
                    if (v66 == 1 || v66 == 2)
                    {
                        v67 = *(_DWORD*)(this + 428);
                        if (*(float*)(this + 1392) < (double)*(float*)(v67 + 972))
                        {
                            v68 = *(float*)&a2 + *(float*)(this + 1392);
                            *(float*)(this + 1392) = v68;
                            if (v68 >= *(float*)(v67 + 972))
                                v68 = *(float*)(v67 + 972);
                            *(float*)&v143 = v68;
                            *(float*)(this + 1392) = v68;
                            sub_4072A0(*(_DWORD**)(this + 432), *(_DWORD*)(v67 + 964), v143, 1);
                        }
                    }
                    v69 = *(_DWORD*)(this + 1388);
                    if (!v69 || v69 == 3)
                    {
                        v70 = *(_DWORD*)(this + 428);
                        if (*(float*)(this + 1392) > (double)*(float*)(v70 + 968))
                        {
                            v71 = *(float*)(this + 1392) - *(float*)&a2;
                            *(float*)(this + 1392) = v71;
                            if (v71 <= *(float*)(v70 + 968))
                                v71 = *(float*)(v70 + 968);
                            *(float*)&v143 = v71;
                            *(float*)(this + 1392) = v71;
                            sub_4072A0(*(_DWORD**)(this + 432), *(_DWORD*)(v70 + 964), v143, 1);
                        }
                    }
                    if (*(_DWORD*)(this + 1388) == 2 && *(float*)(this + 1392) == *(float*)(*(_DWORD*)(this + 428) + 972))
                    {
                        for (i = 0; ; ++i)
                        {
                            v73 = *(_DWORD*)(*(_DWORD*)(this + 428) + 980);
                            if (!v73 || i >= (*(_DWORD*)(*(_DWORD*)(this + 428) + 984) - v73) >> 2)
                                break;
                            *(float*)(*(_DWORD*)(this + 1400) + 4 * i) = *(float*)(*(_DWORD*)(this + 1400) + 4 * i)
                                - *(float*)&a2;
                            if (*(float*)(*(_DWORD*)(this + 1400) + 4 * i) <= 0.0)
                            {
                                v74 = *(_DWORD*)(*(_DWORD*)(this + 428) + 960);
                                v140 = *(float*)(v74 + 296);
                                v143 = *(int*)(v74 + 300);
                                if (v140 == *(float*)&v143)
                                {
                                    v75 = v140;
                                }
                                else
                                {
                                    v153 = rand();
                                    v75 = fabs((double)v153 * 0.000030518509) * (*(float*)&v143 - v140) + v140;
                                }
                                *(float*)(*(_DWORD*)(this + 1400) + 4 * i) = v75;
                                v76 = *(_DWORD*)(this + 428);
                                v174 = 0.0;
                                v173 = 0.0;
                                v172 = 0.0;
                                v171 = 0;
                                v169 = 0.0;
                                v168 = 0.0;
                                v167 = 0.0;
                                v166 = 0;
                                v164 = 0;
                                v163 = 0;
                                v162 = 0.0;
                                v161 = 0.0;
                                v175 = 1065353216;
                                v170 = 1065353216;
                                v165 = 1065353216;
                                v160 = 1065353216;
                                sub_407690(*(_DWORD*)(this + 432), *(_DWORD*)(*(_DWORD*)(v76 + 980) + 4 * i), &v160);
                                sub_4010D0(&v176, (int)&v160);
                                sub_44A440(
                                    *(char**)(dword_520970 + 276),
                                    *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 428) + 960) + 292),
                                    &v176,
                                    (_DWORD*)(this + 1340),
                                    *(_BYTE*)(*(_DWORD*)(this + 428) + 300),
                                    0);
                            }
                        }
                    }
                }
                else if (v33 == 3)
                {
                    v77 = *(_DWORD*)(this + 1412);
                    if (v77)
                    {
                        if (v77 == 1)
                        {
                            if (*(float*)(this + 1416) > 0.0)
                            {
                                v79 = *(_DWORD*)(this + 1424);
                                *(float*)(this + 1416) = *(float*)(this + 1416) - *(float*)&a2;
                                if (v79)
                                {
                                    if (!*(_BYTE*)(v79 + 16))
                                    {
                                        v80 = *(float*)(this + 1420) - *(float*)&a2;
                                        *(float*)(this + 1420) = v80;
                                        if (v80 <= 0.0)
                                            sub_41D840(v79);
                                    }
                                }
                                if (*(float*)(this + 1416) <= 0.0)
                                {
                                    v81 = *(_DWORD*)(this + 428);
                                    v82 = *(_DWORD**)(this + 432);
                                    *(_DWORD*)(this + 1412) = 2;
                                    sub_408640(v82, *(_DWORD*)(v81 + 1004), 0);
                                    v83 = *(_DWORD*)(this + 428);
                                    v174 = 0.0;
                                    v173 = 0.0;
                                    v172 = 0.0;
                                    v171 = 0;
                                    v169 = 0.0;
                                    v168 = 0.0;
                                    v167 = 0.0;
                                    v166 = 0;
                                    v164 = 0;
                                    v163 = 0;
                                    v162 = 0.0;
                                    v161 = 0.0;
                                    v175 = 1065353216;
                                    v170 = 1065353216;
                                    v165 = 1065353216;
                                    v160 = 1065353216;
                                    sub_407690(*(_DWORD*)(this + 432), *(_DWORD*)(v83 + 1004), &v160);
                                    *(float*)&v147 = 0.0;
                                    v148 = 0.0;
                                    v149 = 0.0;
                                    sub_46C5C5((float*)&v147, (float*)&v147, (float*)&v160);
                                    sub_44A440(
                                        *(char**)(dword_520970 + 276),
                                        *(_DWORD*)(*(_DWORD*)(this + 428) + 1008),
                                        &v147,
                                        (_DWORD*)(this + 1340),
                                        *(_BYTE*)(*(_DWORD*)(this + 428) + 300),
                                        0);
                                }
                            }
                        }
                        else if (v77 == 2 && !*(_DWORD*)(this + 1308) && *(float*)(this + 1320) >= (double)*(float*)(v32 + 816))
                        {
                            v84 = *(_DWORD*)(this + 468);
                            *(_DWORD*)(this + 1308) = 1;
                            *(_BYTE*)(v84 + 4316) = 0;
                        }
                    }
                    else
                    {
                        v78 = *(float*)(this + 1416) - *(float*)&a2;
                        *(float*)(this + 1416) = v78;
                        if (v78 <= 0.0)
                        {
                            *(_DWORD*)(this + 1412) = 1;
                            *(_DWORD*)(this + 1308) = 3;
                            *(_DWORD*)(this + 1416) = 0;
                        }
                    }
                }
                else if (v33 == 4 && *(float*)(this + 1428) > 0.0)
                {
                    v85 = *(float*)(this + 1428) - *(float*)&a2;
                    *(float*)(this + 1428) = v85;
                    if (v85 <= 0.0)
                        *(_DWORD*)(this + 1308) = 4;
                }
            }
        }
        else
        {
            if (*(float*)(this + 1356) > 0.0)
            {
                v34 = *(float*)(this + 1356) - *(float*)&a2;
                *(float*)(this + 1356) = v34;
                if (v34 <= 0.0)
                {
                    v35 = *(_DWORD*)(this + 468);
                    *(_DWORD*)(this + 1356) = 0;
                    *(_DWORD*)(this + 1308) = 1;
                    sub_4164A0(v35, 10);
                }
            }
            if (*(_DWORD*)(this + 1308) == 1 || sub_45F480(*(_DWORD*)(dword_520970 + 280)) <= 0.0)
            {
                if (*(_DWORD*)(this + 1308) == 5 && sub_45F480(*(_DWORD*)(dword_520970 + 280)) <= 0.0)
                {
                    v38 = *(_BYTE*)(*(_DWORD*)(this + 428) + 300);
                    *(_DWORD*)(this + 1380) = 0;
                    *(_DWORD*)(this + 1308) = v38 != 0;
                }
                else if (!*(_DWORD*)(this + 1308) && *(float*)(this + 1360) > 0.0)
                {
                    v39 = *(float*)(this + 1360) - *(float*)&a2;
                    *(float*)(this + 1360) = v39;
                    if (v39 <= 0.0)
                    {
                        v40 = *(_DWORD*)(this + 428);
                        *(_DWORD*)(this + 1308) = 3;
                        v140 = *(float*)(v40 + 924);
                        v143 = *(int*)(v40 + 928);
                        if (v140 == *(float*)&v143)
                        {
                            v41 = v140;
                        }
                        else
                        {
                            v153 = rand();
                            v41 = fabs((double)v153 * 0.000030518509) * (*(float*)&v143 - v140) + v140;
                        }
                        *(float*)(this + 1360) = v41;
                    }
                }
            }
            else
            {
                v36 = *(_DWORD*)(this + 468);
                *(_DWORD*)(this + 1308) = 5;
                v37 = *(_DWORD*)(v36 + 4276);
                if (*(_DWORD*)(v36 + 4132) > v37)
                    sub_4164A0(v36, v37);
            }
            HIBYTE(v142) = 0;
            v42 = *(_DWORD*)(dword_520970 + 208);
            v43 = *(_DWORD*)(v42 + 24);
            if (v43)
                v44 = (*(_DWORD*)(v42 + 28) - v43) >> 2;
            else
                v44 = 0;
            v45 = 0;
            if (v44 > 0)
            {
                while (1)
                {
                    v46 = *(_DWORD*)(*(_DWORD*)(v42 + 24) + 4 * v45);
                    if (*(_BYTE*)(v46 + 396))
                    {
                        if (*(_BYTE*)(*(_DWORD*)(this + 428) + 300) != *(_BYTE*)(*(_DWORD*)(v46 + 428) + 300))
                        {
                            *(float*)&v147 = *(float*)(v46 + 1312) - *(float*)(this + 1312);
                            v148 = *(float*)(v46 + 1316) - *(float*)(this + 1316);
                            v149 = *(float*)(v46 + 1320) - *(float*)(this + 1320);
                            sub_46B970(&v147, &v147);
                            if (sub_401100((float*)(this + 1324), (float*)&v147) < 0.15707964)
                                break;
                        }
                    }
                    if (++v45 >= v44)
                        goto LABEL_81;
                }
                HIBYTE(v142) = 1;
            }
        LABEL_81:
            if (!*(_BYTE*)(*(_DWORD*)(this + 428) + 300))
            {
                v47 = 0;
                v48 = *(_DWORD*)(dword_520970 + 280);
                v49 = *(_DWORD*)(v48 + 524);
                if (v49 > 0)
                {
                    v50 = v48 + 2352;
                    while (1)
                    {
                        v150 = *(int*)v50;
                        v151 = *(float*)(v50 + 4);
                        v152 = *(float*)(v50 + 8);
                        if (sub_40E420((float*)(this + 1312), (float*)(this + 1324), (float*)&v150) <= 90000.0)
                            break;
                        ++v47;
                        v50 += 52;
                        if (v47 >= v49)
                            goto LABEL_88;
                    }
                    HIBYTE(v142) = 1;
                }
            }
        LABEL_88:
            if (*(_BYTE*)(*(_DWORD*)(this + 428) + 300) && *(float*)(this + 412) > 0.0)
            {
                *(float*)(this + 412) = *(float*)(this + 412) - *(float*)&a2;
            }
            else if (HIBYTE(v142))
            {
                sub_406BE0(&v160);
                for (j = 0; ; ++j)
                {
                    v52 = *(_DWORD*)(this + 1368);
                    if (!v52 || j >= (*(_DWORD*)(this + 1372) - v52) >> 2)
                        break;
                    if (*(float*)(v52 + 4 * j) > 0.0)
                        *(float*)(v52 + 4 * j) = *(float*)(v52 + 4 * j) - *(float*)&a2;
                    v53 = (float*)(*(_DWORD*)(this + 1368) + 4 * j);
                    if (*v53 <= 0.0)
                    {
                        v54 = **(_DWORD**)(*(_DWORD*)(*(_DWORD*)(this + 428) + 932) + 4 * j);
                        v140 = *(float*)(v54 + 296);
                        v143 = *(int*)(v54 + 300);
                        if (v140 == *(float*)&v143)
                        {
                            v55 = v140;
                        }
                        else
                        {
                            v153 = rand();
                            v55 = fabs((double)v153 * 0.000030518509) * (*(float*)&v143 - v140) + v140;
                        }
                        *v53 = v55 + *v53;
                        for (k = 0; ; ++k)
                        {
                            v57 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 428) + 932) + 4 * j);
                            v58 = *(_DWORD*)(v57 + 8);
                            if (!v58 || k >= (*(_DWORD*)(v57 + 12) - v58) >> 2)
                                break;
                            sub_407690(*(_DWORD*)(this + 432), *(_DWORD*)(*(_DWORD*)(v57 + 8) + 4 * k), &v160);
                            *(float*)&v147 = 0.0;
                            v148 = 0.0;
                            v149 = 0.0;
                            *(float*)&v154 = 0.0;
                            v155 = 0.0;
                            v156 = 0.0;
                            sub_46C5C5((float*)&v154, (float*)&v154, (float*)&v160);
                            v59 = *(_DWORD*)(this + 428);
                            *(float*)&v150 = 0.0;
                            v151 = 0.0;
                            v152 = 1.0;
                            v60 = *(float*)(**(_DWORD**)(*(_DWORD*)(v59 + 932) + 4 * j) + 304);
                            *(float*)&v157 = v60 * *(float*)(this + 1324);
                            v158 = v60 * *(float*)(this + 1328);
                            v159 = v60 * *(float*)(this + 1332);
                            sub_449C40(
                                *(char**)(dword_520970 + 276),
                                *(_DWORD*)(**(_DWORD**)(*(_DWORD*)(v59 + 932) + 4 * j) + 292),
                                &v154,
                                &v157,
                                *(_BYTE*)(v59 + 300),
                                0,
                                0.0,
                                (int)&v150);
                            v61 = *(_DWORD*)(this + 428);
                            *(float*)&v144 = 0.0;
                            v145 = 0.0;
                            v146 = 0.0;
                            v62 = *(_DWORD**)(*(_DWORD*)(v61 + 932) + 4 * j);
                            sub_44E040(
                                *(char**)(dword_520970 + 240),
                                *(_DWORD*)(*v62 + 308),
                                this + 1340,
                                *(_DWORD*)(this + 432),
                                *(float*)(v62[2] + 4 * k),
                                &v144);
                        }
                    }
                }
            }
        }
    }
    *(float*)&v86 = v140;
    *(float*)&v87 = 0.0;
    *(float*)&v143 = 0.0;
    for (m = 0; ; m += 32)
    {
        v89 = *(_DWORD*)(this + 2288);
        if (!v89 || v87 >= (*(_DWORD*)(this + 2292) - v89) >> 5)
            break;
        *(float*)(m + v89 + 12) = *(float*)(m + v89 + 12) - *(float*)&a2 * 300.0;
        v90 = *(_DWORD*)(this + 2288);
        v91 = *(float*)(m + v90 + 12);
        v92 = *(float*)(m + v90 + 8);
        v93 = *(float*)(m + v90 + 4);
        v94 = (float*)(m + v90 + 4);
        v95 = sqrt(v93 * v93 + v92 * v92 + v91 * v91);
        if (v95 == 0.0)
        {
            *(float*)&v147 = 0.0;
            v148 = 0.0;
            v149 = 0.0;
            *v94 = 0.0;
            v96 = v149;
            v94[1] = 0.0;
            v94[2] = v96;
        }
        else
        {
            *v94 = 1.0 / v95 * *v94;
            v94[1] = 1.0 / v95 * v94[1];
            v94[2] = 1.0 / v95 * v94[2];
        }
        v97 = *(_DWORD*)(this + 2288);
        v98 = *(float*)&a2 * *(float*)(v97 + m + 16);
        v99 = (float*)(m + v97);
        v99[1] = (v95 + v98) * v99[1];
        v99[2] = (v95 + v98) * v99[2];
        v99[3] = (v95 + v98) * v99[3];
        sub_407430(*(_DWORD**)(this + 432), *(_DWORD*)(m + *(_DWORD*)(this + 2288)), (char*)&v160);
        v100 = sub_4010C0((int)&v160);
        v157 = *(int*)v100;
        v158 = *(float*)(v100 + 4);
        v101 = *(float*)(v100 + 8);
        v102 = *(_DWORD*)(this + 2288);
        v159 = v101;
        v103 = (float*)(m + v102);
        v139 = *(float*)&a2 * v103[7];
        v138 = *(float*)&a2 * v103[6];
        v137 = *(float*)&a2 * v103[5];
        sub_46C69B((float*)v183, v137, v138, v139);
        sub_46B97C(&v160, v183, &v160);
        v104 = *(_DWORD*)(this + 2288);
        v172 = *(float*)&a2 * *(float*)(m + v104 + 4) + v172;
        v173 = *(float*)&a2 * *(float*)(m + v104 + 8) + v173;
        v174 = *(float*)&a2 * *(float*)(m + v104 + 12) + v174;
        v105 = (int*)sub_4010C0((int)&v160);
        v176 = *v105;
        v177 = v105[1];
        v106 = *(_DWORD*)(this + 2288);
        *(_DWORD*)v178 = v105[2];
        sub_4073F0(*(_DWORD**)(this + 432), *(_DWORD*)(m + v106), &v160);
        *(float*)&v150 = 0.0;
        v151 = 0.0;
        v152 = 0.0;
        if (!sub_468CA0(*(int**)(dword_520970 + 260), (float*)&v157, (int*)(this + 1312), (float*)&v150, &v153))
        {
            if (*(float*)v178 >= -1000.0)
                goto LABEL_190;
            goto LABEL_186;
        }
        if (v153 == -1)
        {
            *(float*)&v86 = 0.0;
        }
        else if (v153)
        {
            if (v153 == 1)
            {
                v86 = 3;
            }
            else
            {
                if (v153 != 2 && v153 != 3)
                    goto LABEL_180;
                v86 = 2;
            }
        }
        else
        {
            v86 = 1;
        }
        v140 = *(float*)&v86;
    LABEL_180:
        v107 = *(_DWORD*)(*(_DWORD*)(this + 428) + 904);
        if (v107 && (v108 = *(float*)(v107 + 4 * v86 + 292), v108 != 0.0)
            || (v109 = *(_DWORD*)(*(_DWORD*)(dword_520970 + 276) + 20)) != 0
            && (v108 = *(float*)(v109 + 4 * v86 + 292), v108 != 0.0))
        {
            *(float*)&v154 = 0.0;
            v155 = 0.0;
            v156 = 0.0;
            sub_44DF20(*(char**)(dword_520970 + 240), v108, COERCE_FLOAT(&v150), (float*)&v154);
        }
    LABEL_186:
        sub_408640(*(_DWORD**)(this + 432), *(_DWORD*)(m + *(_DWORD*)(this + 2288)), 0);
        v110 = *(_DWORD*)(this + 2288);
        v144 = *(int*)(this + 2292);
        v111 = v110 + m + 32;
        if (v111 != v144)
        {
            v112 = (char*)(v110 + m);
            do
            {
                v113 = (const void*)v111;
                v111 += 32;
                qmemcpy(v112, v113, 0x20u);
                v112 += 32;
            } while (v111 != v144);
        }
        *(float*)&v86 = v140;
        v87 = v143 - 1;
        v144 = *(_DWORD*)(this + 2292) - 32;
        *(float*)(this + 2292) = *(float*)&v144;
        m -= 32;
    LABEL_190:
        v143 = ++v87;
    }
    v114 = *(_DWORD*)(this + 2300);
    if (v114)
    {
        v115 = *(_DWORD*)(this + 428);
        v116 = *(float*)(v115 + 600);
        v117 = v116 - (v116 - 2000.0);
        v144 = *(int*)(v115 + 604);
        if (v117 == 0.0)
            v118 = 0.0;
        else
            v118 = (*(float*)(this + 1320) - (v116 - 2000.0)) / v117;
        v141 = (1.0 - v118 + 1.0) * 0.5;
        if (v141 < 1.0)
        {
            if (v141 <= 0.0)
                v141 = 0.0;
        }
        else
        {
            v141 = 1.0;
        }
        v119 = 1.0 - (*(float*)(this + 1320) - v116) * 0.0049999999;
        if (v119 < 1.0)
        {
            if (v119 <= 0.0)
                v119 = 0.0;
        }
        else
        {
            v119 = 1.0;
        }
        *(float*)(v114 + 16) = v141 * *(float*)&v144;
        *(float*)(*(_DWORD*)(this + 2300) + 28) = v119;
        v120 = *(float*)(this + 1320);
        v121 = *(float*)(this + 1316);
        v122 = (float*)(*(_DWORD*)(this + 2300) + 4);
        *v122 = *(float*)(this + 1312);
        v122[1] = v121;
        v122[2] = v120;
        *(float*)(*(_DWORD*)(this + 2300) + 20) = -atan2(*(float*)(this + 1324), *(float*)(this + 1328));
    }
    sub_4318B0((_DWORD*)this);
    if (sub_408F30((_DWORD*)dword_520970) == this)
    {
        sub_407430(*(_DWORD**)(this + 432), 0, (char*)&v160);
        sub_401450((_DWORD*)this);
        *(float*)&v154 = 0.0;
        v155 = -1000.0;
        v156 = 500.0;
        *(float*)&v147 = 0.0;
        v148 = 0.0;
        v149 = 300.0;
        *(float*)&v144 = 0.0;
        v145 = 0.0;
        v146 = 1.0;
        sub_46C5C5((float*)&v154, (float*)&v154, (float*)&v160);
        sub_46C5C5((float*)&v147, (float*)&v147, (float*)&v160);
        sub_46B976((float*)&v144, (float*)&v144, (float*)&v160);
        sub_46B970(&v144, &v144);
        v123 = *(float*)&v147 - *(float*)&v154;
        v124 = v148 - v155;
        v125 = v149 - v156;
        *(float*)&v157 = v146 * v124 - v145 * v125;
        v158 = v125 * *(float*)&v144 - v146 * v123;
        v126 = v145 * v123 - v124 * *(float*)&v144;
        *(float*)&v150 = v125 * v158 - v124 * v126;
        v151 = v126 * v123 - v125 * *(float*)&v157;
        v144 = v150;
        v145 = v151;
        v152 = v124 * *(float*)&v157 - v158 * v123;
        v146 = v152;
        sub_46B970(&v144, &v144);
        v127 = v155;
        *(float*)(this + 32) = *(float*)&v154;
        v128 = v156;
        *(float*)(this + 36) = v127;
        *(float*)(this + 40) = v128;
        v129 = v148;
        *(float*)(this + 44) = *(float*)&v147;
        v130 = v149;
        *(float*)(this + 48) = v129;
        *(float*)(this + 52) = v130;
        v131 = v145;
        *(float*)(this + 56) = *(float*)&v144;
        v132 = v146;
        *(float*)(this + 60) = v131;
        *(float*)(this + 64) = v132;
    }
    if (*(_BYTE*)(dword_4F5CC4 + 936))
    {
        if (*(_BYTE*)(this + 460))
        {
            v133 = *(_DWORD**)(this + 468);
            if (v133)
            {
                HIWORD(v177) = *(_WORD*)(this + 392);
                if (sub_4176E0(v133, &v143, &v150, (_BYTE*)&v142 + 3, 8))
                {
                    do
                    {
                        v134 = *(_DWORD*)(this + 468);
                        v135 = *(float*)(v134 + 16);
                        v136 = *(_DWORD*)(v134 + 4136);
                        *(_WORD*)v178 = v143;
                        *(_WORD*)&v178[3] = (__int64)(*(float*)&v150 * 0.5);
                        v179 = (__int64)(v151 * 0.5);
                        v180 = (__int64)(v152 * 0.5);
                        v178[2] = HIBYTE(v142);
                        v181 = v136;
                        v182 = (__int64)(v135 * 255.0);
                        sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x102, &v176, 20, 8, 5000);
                    } while (sub_4176E0(*(_DWORD**)(this + 468), &v143, &v150, (_BYTE*)&v142 + 3, 8));
                }
            }
        }
    }
    return sub_428620((_DWORD*)this, a2);
}
// 431F6C: variable 'v30' is possibly undefined
// 431F6C: variable 'v31' is possibly undefined
// 432BAD: variable 'v140' is possibly undefined
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (00433360) --------------------------------------------------------
int __thiscall sub_433360(int this, int a2)
{
    int* v3; // ecx
    int result; // eax
    int v5; // ecx

    if (!(_BYTE)a2)
    {
        v3 = *(int**)(this + 468);
        if (v3)
        {
            if (v3[1033] > 0)
            {
                sub_415910(v3);
                *(_DWORD*)(this + 468) = 0;
            }
        }
    }
    result = *(_DWORD*)(this + 2300);
    if (result)
        *(_BYTE*)(result + 32) = a2;
    v5 = *(_DWORD*)(this + 432);
    if (v5)
        result = (*(int(__thiscall**)(int, int))(*(_DWORD*)v5 + 24))(v5, a2);
    *(_BYTE*)(this + 16) = a2;
    return result;
}

//----- (004333C0) --------------------------------------------------------
char __thiscall sub_4333C0(int this, int a2)
{
    int v3; // eax
    int v4; // esi
    int v5; // esi
    int v6; // eax

    sub_4317B0((_DWORD*)this, 2);
    if (!*(_BYTE*)(this + 396))
        return 0;
    if (!*(_BYTE*)(dword_4F5CC4 + 937) && (_BYTE)a2)
        sub_462520(*(_DWORD**)(dword_520970 + 280), *(_DWORD*)(*(_DWORD*)(this + 428) + 592), dword_5216E8);
    v3 = *(_DWORD*)(this + 428);
    *(_BYTE*)(this + 396) = 0;
    sub_45A420(*(float**)(dword_520970 + 236), v3, a2, *(_DWORD*)(v3 + 292) == 1, 1);
    v4 = *(_DWORD*)(this + 428);
    if (*(_BYTE*)(v4 + 300))
    {
        v5 = *(_DWORD*)(v4 + 292);
        if (v5)
        {
            if (v5 == 3)
                v6 = 1;
            else
                v6 = (v5 != 2) + 2;
        }
        else
        {
            v6 = 0;
        }
        sub_45F350(*(_DWORD**)(dword_520970 + 280), v6, a2);
    }
    return 1;
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;
// 5216E8: using guessed type int dword_5216E8;

//----- (004334A0) --------------------------------------------------------
char __stdcall sub_4334A0(int a1, char a2)
{
    char result; // al

    result = dword_4F5CC4;
    if (!*(_BYTE*)(dword_4F5CC4 + 936) && !*(_BYTE*)(dword_4F5CC4 + 937))
    {
        result = a2;
        if (a2)
        {
            if (a1 == 211)
                return sub_408F30((_DWORD*)dword_520970);
        }
    }
    return result;
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (004334E0) --------------------------------------------------------
void __thiscall sub_4334E0(int this, float a2)
{
    int v3; // esi
    int v5; // ecx
    int v6; // edx
    double v7; // st7
    int v8; // edx
    int v9; // eax
    int v10; // ebp
    char v11; // bl
    char v12; // al
    _DWORD* v13; // eax
    int v14; // eax
    int v15; // edx
    int v16; // ecx
    int v17; // edx
    int v18; // ecx
    int v19; // edx
    _DWORD* v20; // eax
    int v21; // eax
    const char* v22; // [esp-8h] [ebp-4Ch]
    const char* v23; // [esp-8h] [ebp-4Ch]
    const char* v24; // [esp-4h] [ebp-48h]
    const char* v25; // [esp-4h] [ebp-48h]
    unsigned __int8 v26; // [esp+10h] [ebp-34h]
    float v27[3]; // [esp+14h] [ebp-30h] BYREF
    _WORD v28[4]; // [esp+20h] [ebp-24h] BYREF
    int v29; // [esp+28h] [ebp-1Ch]
    int v30; // [esp+2Ch] [ebp-18h]
    int v31; // [esp+30h] [ebp-14h]
    int v32; // [esp+34h] [ebp-10h]
    int v33; // [esp+38h] [ebp-Ch]
    char v34; // [esp+3Ch] [ebp-8h]
    int v35; // [esp+3Dh] [ebp-7h]
    int v36; // [esp+48h] [ebp+4h]
    int v37; // [esp+48h] [ebp+4h]
    float v38; // [esp+48h] [ebp+4h]
    char v39; // [esp+48h] [ebp+4h]

    v3 = *(_DWORD*)(LODWORD(a2) + 16);
    switch (*(_WORD*)(LODWORD(a2) + 12))
    {
    case 0x102:
        if (*(_BYTE*)(dword_4F5CC4 + 937))
        {
            v5 = *(_DWORD*)(this + 468);
            if (v5)
            {
                v36 = *(__int16*)(v3 + 13);
                v6 = *(__int16*)(v3 + 15);
                v27[0] = (double)*(__int16*)(v3 + 11) + (double)*(__int16*)(v3 + 11);
                v7 = (double)v36;
                v37 = v6;
                v26 = *(_BYTE*)(v3 + 10);
                v8 = *(unsigned __int8*)(v3 + 19);
                v9 = *(__int16*)(v3 + 8);
                v27[1] = v7 + v7;
                v10 = *(__int16*)(v3 + 17);
                v27[2] = (double)v37 + (double)v37;
                v38 = (double)v8 * 0.0039215689;
                v11 = sub_417190(v5, v9, v27, v26);
                sub_415930(*(_DWORD*)(this + 468), v10, v38);
                if (v11)
                {
                    sub_4317B0((_DWORD*)this, 0);
                    (*(void(__thiscall**)(int, int))(*(_DWORD*)this + 24))(this, 1);
                }
            }
        }
        break;
    case 0x103:
        if (*(_BYTE*)(dword_4F5CC4 + 936))
        {
            dword_5216E8 = *(_DWORD*)(LODWORD(a2) + 4);
            v12 = sub_430F00(this, *(_DWORD*)(v3 + 8), (int*)(v3 + 12), *(float*)(v3 + 24), *(_BYTE*)(v3 + 28));
            v39 = v12;
            if (v12)
            {
                v13 = sub_411B60(dword_4F5CC4, *(_DWORD*)(LODWORD(a2) + 4));
                if (v13)
                {
                    v24 = *(const char**)(*(_DWORD*)(this + 428) + 4);
                    v22 = (const char*)(v13 + 3);
                    v14 = sub_436A90(*(_DWORD*)(dword_520970 + 224));
                    sub_421190(v14, "%s shot down a %s", v22, v24);
                }
                sub_411BB0(dword_4F5CC4, *(_DWORD*)(LODWORD(a2) + 4));
                v12 = v39;
            }
            v15 = *(_DWORD*)(v3 + 8);
            v28[3] = *(_WORD*)(this + 392);
            v16 = *(_DWORD*)(v3 + 12);
            v29 = v15;
            v17 = *(_DWORD*)(v3 + 16);
            v30 = v16;
            v18 = *(_DWORD*)(v3 + 20);
            v31 = v17;
            v19 = *(_DWORD*)(v3 + 24);
            v32 = v18;
            LOBYTE(v18) = *(_BYTE*)(v3 + 28);
            v33 = v19;
            v34 = v18;
            if (v12)
                v35 = *(_DWORD*)(LODWORD(a2) + 4);
            else
                v35 = 0;
            sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x104, v28, 33, 11, 0);
            dword_5216E8 = 0;
        }
        break;
    case 0x104:
        sub_430F00(this, *(_DWORD*)(v3 + 8), (int*)(v3 + 12), *(float*)(v3 + 24), *(_BYTE*)(v3 + 28));
        if (*(_DWORD*)(v3 + 29))
        {
            v20 = sub_411B60(dword_4F5CC4, *(_DWORD*)(v3 + 29));
            if (v20)
            {
                v25 = *(const char**)(*(_DWORD*)(this + 428) + 4);
                v23 = (const char*)(v20 + 3);
                v21 = sub_436A90(*(_DWORD*)(dword_520970 + 224));
                sub_421190(v21, "%s shot down a %s", v23, v25);
            }
            sub_411BB0(dword_4F5CC4, *(_DWORD*)(v3 + 29));
        }
        break;
    case 0x105:
        if (*(_BYTE*)(dword_4F5CC4 + 937))
        {
            (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)this + 24))(this, 0);
            sub_4333C0(this, 0);
        }
        break;
    default:
        return;
    }
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;
// 5216E8: using guessed type int dword_5216E8;

//----- (00433790) --------------------------------------------------------
char __cdecl sub_433790(int a1)
{
    int v1; // ebp
    int v2; // eax
    int v3; // ecx
    int v5; // eax
    int v6; // eax
    int v7; // ebx
    int v8; // eax
    int v9; // ebp
    int j; // edi
    int v11; // eax
    int v12; // eax
    int v13; // ecx
    int v14; // edi
    int v15; // ebx
    double v16; // st7
    double v17; // st6
    double v18; // st7
    double v19; // st6
    double v20; // st6
    double v21; // st5
    float* v22; // eax
    double v23; // st7
    double v24; // st7
    double v25; // st7
    int v26; // eax
    int v27; // eax
    unsigned __int8 v29; // c0
    unsigned __int8 v30; // c3
    _DWORD* v31; // eax
    char v32; // bl
    float* v33; // eax
    int v34; // ebp
    int v35; // eax
    unsigned __int8 v37; // c0
    unsigned __int8 v38; // c3
    int i; // edi
    float* v40; // eax
    int v41; // ecx
    float v42; // [esp-20h] [ebp-4Ch]
    float v43; // [esp+0h] [ebp-2Ch]
    int v44; // [esp+0h] [ebp-2Ch]
    int v45; // [esp+8h] [ebp-24h] BYREF
    float v46; // [esp+Ch] [ebp-20h]
    float v47; // [esp+10h] [ebp-1Ch]
    float v48; // [esp+14h] [ebp-18h]
    float v49; // [esp+18h] [ebp-14h]
    float v50; // [esp+1Ch] [ebp-10h]
    int v51; // [esp+20h] [ebp-Ch] BYREF
    float v52; // [esp+24h] [ebp-8h]
    float v53; // [esp+28h] [ebp-4h]

    v1 = 0;
    if (!*(_DWORD*)(a1 + 1308) || sub_417160(*(_DWORD**)(a1 + 468)) > 0)
        return sub_418E50(*(_DWORD*)(a1 + 468), 1, COERCE_FLOAT(1));
    v2 = *(_DWORD*)(a1 + 1308);
    switch (v2)
    {
    case 1:
        v3 = *(_DWORD*)(a1 + 468);
        if (*(_BYTE*)(*(_DWORD*)(a1 + 428) + 300))
        {
            *(float*)&v51 = 0.0;
            v52 = -1.0;
        }
        else
        {
            *(float*)&v51 = 0.0;
            v52 = 1.0;
        }
    LABEL_6:
        v53 = 0.0;
        return sub_4196F0(v3, (float*)&v51, 3.1415927, COERCE_FLOAT(1), 1, 0);
    case 2:
        v3 = *(_DWORD*)(a1 + 468);
        if (*(_BYTE*)(*(_DWORD*)(a1 + 428) + 300))
        {
            *(float*)&v51 = 0.0;
            v52 = 1.0;
        }
        else
        {
            *(float*)&v51 = 0.0;
            v52 = -1.0;
        }
        goto LABEL_6;
    case 3:
    case 4:
        v44 = *(_DWORD*)(*(_DWORD*)(a1 + 468) + 4132);
        sub_45F160(*(float**)(dword_520970 + 280), (float*)(a1 + 400));
        v32 = 0;
        *(_DWORD*)(*(_DWORD*)(a1 + 468) + 4300) = *(_DWORD*)(*(_DWORD*)(a1 + 428) + 840);
        *(_DWORD*)(*(_DWORD*)(a1 + 468) + 4304) = *(_DWORD*)(*(_DWORD*)(a1 + 428) + 844);
        *(_DWORD*)(*(_DWORD*)(a1 + 468) + 4308) = *(_DWORD*)(*(_DWORD*)(a1 + 428) + 832);
        *(_DWORD*)(*(_DWORD*)(a1 + 468) + 4312) = *(_DWORD*)(*(_DWORD*)(a1 + 428) + 836);
        while (1)
        {
            sub_418E50(*(_DWORD*)(a1 + 468), 1, COERCE_FLOAT(1));
            v33 = (float*)sub_417140(*(_DWORD**)(a1 + 468), 0);
            if (sub_419C40(*(_DWORD*)(a1 + 468), v33))
                break;
            if (++v1 >= 100)
                goto LABEL_57;
        }
        v32 = 1;
    LABEL_57:
        *(_DWORD*)(*(_DWORD*)(a1 + 468) + 4300) = *(_DWORD*)(*(_DWORD*)(a1 + 428) + 824);
        *(_DWORD*)(*(_DWORD*)(a1 + 468) + 4304) = *(_DWORD*)(*(_DWORD*)(a1 + 428) + 828);
        *(_DWORD*)(*(_DWORD*)(a1 + 468) + 4308) = *(_DWORD*)(*(_DWORD*)(a1 + 428) + 816);
        *(_DWORD*)(*(_DWORD*)(a1 + 468) + 4312) = *(_DWORD*)(*(_DWORD*)(a1 + 428) + 820);
        if (v32)
        {
            if (*(_DWORD*)(*(_DWORD*)(a1 + 428) + 292) == 3)
                *(float*)(a1 + 1420) = 1.0
                - *(float*)(*(_DWORD*)(a1 + 468) + 16)
                + (double)(*(_DWORD*)(*(_DWORD*)(a1 + 468) + 4132) - 4);
            v34 = 0;
            while (1)
            {
                v35 = sub_417140(*(_DWORD**)(a1 + 468), 0);
                if (!(v37 | v38) || *(float*)(v35 + 8) < (double)*(float*)(a1 + 408))
                    break;
                if (!sub_4198A0(
                    *(_DWORD**)(a1 + 468),
                    (float*)(a1 + 400),
                    *(float*)(*(_DWORD*)(a1 + 428) + 852),
                    0.0,
                    1,
                    0))
                    goto LABEL_75;
                if (++v34 >= 100)
                    goto LABEL_67;
            }
            sub_4164A0(*(_DWORD*)(a1 + 468), *(_DWORD*)(*(_DWORD*)(a1 + 468) + 4132) - 1);
        LABEL_67:
            if (*(_DWORD*)(a1 + 1308) == 4)
            {
                for (i = 0; i < 100; ++i)
                {
                    if (*(float*)(sub_417140(*(_DWORD**)(a1 + 468), 0) + 8) < -2000.0)
                        break;
                    v42 = *(float*)(*(_DWORD*)(a1 + 428) + 852);
                    v40 = (float*)sub_417180(*(char**)(a1 + 468));
                    if (!sub_4196F0(*(_DWORD*)(a1 + 468), v40, v42, 0.0, 1, 0))
                        goto LABEL_75;
                }
            }
            v41 = *(_DWORD*)(a1 + 428);
            *(_DWORD*)(a1 + 1308) = *(_DWORD*)(a1 + 1308) != 3 ? 6 : 0;
            if (*(_DWORD*)(v41 + 292) == 3)
                *(float*)(a1 + 1416) = 1.0
                - *(float*)(*(_DWORD*)(a1 + 468) + 16)
                + (double)(*(_DWORD*)(*(_DWORD*)(a1 + 468) + 4132) - 6);
            return 1;
        }
        else
        {
        LABEL_75:
            sub_4164A0(*(_DWORD*)(a1 + 468), v44);
            return 0;
        }
    case 5:
        v5 = *(_DWORD*)(a1 + 1384);
        if (v5 > 0)
        {
            *(_DWORD*)(a1 + 1384) = v5 - 1;
            return 0;
        }
        v6 = *(_DWORD*)(a1 + 1380);
        if (v6 && !*(_BYTE*)(v6 + 396))
            *(_DWORD*)(a1 + 1380) = 0;
        if (!*(_DWORD*)(a1 + 1380))
        {
            v7 = *(_DWORD*)(dword_520970 + 208);
            v8 = *(_DWORD*)(v7 + 24);
            if (v8)
                v9 = (*(_DWORD*)(v7 + 28) - v8) >> 2;
            else
                v9 = 0;
            for (j = 0; j < v9; ++j)
            {
                v11 = *(_DWORD*)(*(_DWORD*)(v7 + 24) + 4 * j);
                if (*(_BYTE*)(v11 + 396)
                    && *(_BYTE*)(*(_DWORD*)(a1 + 428) + 300) != *(_BYTE*)(*(_DWORD*)(v11 + 428) + 300))
                {
                    sub_4231C0(j);
                }
            }
            v12 = sub_423230();
            if (v12 != -1)
                *(_DWORD*)(a1 + 1380) = *(_DWORD*)(*(_DWORD*)(v7 + 24) + 4 * v12);
        }
        v13 = *(_DWORD*)(a1 + 1380);
        if (!v13)
            return 0;
        v14 = *(_DWORD*)(v13 + 468);
        v15 = *(_DWORD*)(v14 + 4132) - 1;
        v43 = (double)(*(_DWORD*)(*(_DWORD*)(a1 + 468) + 4132) - 1) * *(float*)(*(_DWORD*)(a1 + 468) + 4288);
        v16 = (double)v15 * *(float*)(v14 + 4288);
        if (v43 <= v16)
        {
            if (v43 >= v16)
            {
                v27 = sub_417140((_DWORD*)v14, 0);
            }
            else
            {
                v24 = *(float*)(v14 + 4288);
                if (v24 == 0.0)
                    v25 = 0.0;
                else
                    v25 = v43 / v24;
                v26 = (__int64)v25 + 1;
                if (v26 >= v15)
                    v26 = *(_DWORD*)(v14 + 4132) - 1;
                v27 = sub_417120((void*)v14, v26);
            }
            v45 = *(int*)v27;
            v46 = *(float*)(v27 + 4);
            v47 = *(float*)(v27 + 8);
        }
        else
        {
            v17 = *(float*)(v14 + 4288);
            if (v17 == 0.0)
                v18 = 0.0;
            else
                v18 = (v43 - v16) / v17;
            v19 = *(float*)(v14 + 4288);
            *(float*)&v51 = v19 * *(float*)(v14 + 120);
            v52 = v19 * *(float*)(v14 + 124);
            v20 = v19 * *(float*)(v14 + 128);
            v21 = *(float*)(v14 + 4284);
            *(float*)&v45 = *(float*)&v51 * v21;
            v46 = v52 * v21;
            v48 = *(float*)&v45 * v18;
            v49 = v46 * v18;
            v50 = v20 * v21 * v18;
            v22 = (float*)sub_417140((_DWORD*)v14, 0);
            *(float*)&v51 = v48 + *v22;
            v52 = v49 + v22[1];
            v23 = v50 + v22[2];
            v45 = v51;
            v46 = v52;
            v53 = v23;
            v47 = v53;
        }
        sub_417140(*(_DWORD**)(a1 + 468), 0);
        if (!(v29 | v30))
        {
            *(_DWORD*)(a1 + 1380) = 0;
            *(_DWORD*)(a1 + 1384) = rand() % 11 + 5;
        }
        return sub_4198A0(*(_DWORD**)(a1 + 468), (float*)&v45, 3.1415927, COERCE_FLOAT(1), 1, 0);
    case 6:
        v31 = (_DWORD*)sub_417140(*(_DWORD**)(a1 + 468), 0);
        return sub_416350(*(_DWORD*)(a1 + 468), v31, 0);
    default:
        return 0;
    }
}
// 433E60: conditional instruction was optimized away because bl.1==1
// 433B8B: variable 'v29' is possibly undefined
// 433B8B: variable 'v30' is possibly undefined
// 433DA9: variable 'v37' is possibly undefined
// 433DA9: variable 'v38' is possibly undefined
// 520970: using guessed type int dword_520970;

//----- (00433EF0) --------------------------------------------------------
void __thiscall sub_433EF0(int this)
{
    int i; // ebp
    void* v3; // edi
    void* v4; // eax

    if (*(_BYTE*)(this + 12))
    {
        for (i = 0; i < *(_DWORD*)(this + 4); ++i)
        {
            v3 = *(void**)(*(_DWORD*)this + 4 * i);
            if (v3)
            {
                sub_40A800(*(_DWORD*)(*(_DWORD*)this + 4 * i));
                sub_4885A6(v3);
            }
        }
    }
    memset(*(void**)this, 0, 4 * *(_DWORD*)(this + 4));
    v4 = *(void**)this;
    *(_DWORD*)(this + 4) = 0;
    sub_488CEE(v4);
    *(_DWORD*)(this + 8) = 0;
    *(_DWORD*)this = 0;
}

//----- (00433F70) --------------------------------------------------------
char* __thiscall sub_433F70(_DWORD* this, char* a2, unsigned int a3, const void* a4)
{
    unsigned int v4; // esi
    _DWORD* v5; // edi
    char* result; // eax
    int v7; // edx
    unsigned int v8; // ecx
    int v9; // eax
    int v10; // eax
    char* v11; // edx
    char* i; // eax
    char* v13; // eax
    unsigned int v14; // ebx
    char* v15; // ebp
    char* v16; // ebx
    char* v17; // eax
    int v18; // ecx
    int v19; // eax
    char* v21; // edx
    char* v22; // ebx
    char* v23; // eax
    unsigned int v24; // esi
    unsigned int v25; // edx
    char* v26; // edx
    char* v27; // eax
    char* v28; // edi
    int v29; // esi
    char* v30; // ebx
    char* v31; // edx
    char* v32; // edx
    char* v33; // eax
    char* v34; // eax
    char* v35; // edi
    int v37; // [esp+14h] [ebp-8h]
    char* v38; // [esp+18h] [ebp-4h]
    int v39; // [esp+20h] [ebp+4h]

    v4 = a3;
    v5 = this;
    result = (char*)this[2];
    if ((this[3] - (int)result) >> 5 >= a3)
    {
        if ((result - a2) >> 5 >= a3)
        {
            if (!a3)
                return result;
            v29 = 32 * a3;
            v30 = (char*)this[2];
            v31 = &result[-32 * a3];
            v39 = 32 * a3;
            if (v31 != result)
            {
                do
                {
                    if (v30)
                    {
                        qmemcpy(v30, v31, 0x20u);
                        v5 = this;
                    }
                    v31 += 32;
                    v30 += 32;
                } while (v31 != result);
                v29 = 32 * a3;
            }
            v32 = (char*)v5[2];
            v33 = &v32[-v29];
            if (a2 != &v32[-v29])
            {
                do
                {
                    v33 -= 32;
                    v32 -= 32;
                    qmemcpy(v32, v33, 0x20u);
                } while (v33 != a2);
                v5 = this;
            }
            v34 = a2;
            if (a2 == &a2[v39])
                goto LABEL_54;
            do
            {
                v35 = v34;
                v34 += 32;
                qmemcpy(v35, a4, 0x20u);
            } while (v34 != &a2[v39]);
        }
        else
        {
            v39 = 32 * a3;
            v21 = &a2[32 * a3];
            if (a2 != result)
            {
                v22 = a2;
                do
                {
                    if (v21)
                    {
                        qmemcpy(v21, v22, 0x20u);
                        v5 = this;
                        v4 = a3;
                    }
                    v22 += 32;
                    v21 += 32;
                } while (v22 != result);
            }
            v23 = (char*)v5[2];
            v24 = v4 - ((v23 - a2) >> 5);
            if (v24)
            {
                v25 = v24;
                do
                {
                    if (v23)
                    {
                        qmemcpy(v23, a4, 0x20u);
                        v5 = this;
                    }
                    v23 += 32;
                    --v25;
                } while (v25);
            }
            v26 = (char*)v5[2];
            v27 = a2;
            if (a2 == v26)
                goto LABEL_54;
            do
            {
                v28 = v27;
                v27 += 32;
                qmemcpy(v28, a4, 0x20u);
            } while (v27 != v26);
        }
        v5 = this;
    LABEL_54:
        result = (char*)(v39 + v5[2]);
        v5[2] = result;
        return result;
    }
    v7 = this[1];
    if (!v7 || (v8 = (int)&result[-v7] >> 5, a3 >= v8))
        v8 = a3;
    if (v7)
        v9 = (int)&result[-v7] >> 5;
    else
        v9 = 0;
    v10 = v8 + v9;
    v37 = v10;
    if (v10 < 0)
        v10 = 0;
    v38 = (char*)operator new(32 * v10);
    v11 = v38;
    for (i = (char*)v5[1]; i != a2; v11 += 32)
    {
        if (v11)
        {
            qmemcpy(v11, i, 0x20u);
            v5 = this;
            v4 = a3;
        }
        i += 32;
    }
    v13 = v11;
    if (v4)
    {
        v14 = v4;
        do
        {
            if (v13)
            {
                qmemcpy(v13, a4, 0x20u);
                v5 = this;
                v4 = a3;
            }
            v13 += 32;
            --v14;
        } while (v14);
    }
    v15 = (char*)v5[2];
    v16 = &v11[32 * v4];
    if (a2 != v15)
    {
        v17 = a2;
        do
        {
            if (v16)
            {
                qmemcpy(v16, v17, 0x20u);
                v5 = this;
                v4 = a3;
            }
            v17 += 32;
            v16 += 32;
        } while (v17 != v15);
    }
    sub_4885A6((LPVOID)v5[1]);
    v18 = v5[1];
    v5[3] = &v38[32 * v37];
    if (v18)
    {
        v19 = v5[2];
        v5[1] = v38;
        result = &v38[32 * v4 + 32 * ((v19 - v18) >> 5)];
    }
    else
    {
        v5[1] = v38;
        result = &v38[32 * v4];
    }
    v5[2] = result;
    return result;
}

//----- (00434200) --------------------------------------------------------
char* __thiscall sub_434200(_DWORD* this, char* a2, char* a3)
{
    char* v3; // edx
    char* v4; // ebx
    char* v5; // ebp
    const void* v6; // esi
    void* v7; // edi

    v3 = a3;
    v4 = a2;
    v5 = (char*)this[2];
    if (a3 != v5)
    {
        do
        {
            v6 = v3;
            v7 = v4;
            v3 += 32;
            v4 += 32;
            qmemcpy(v7, v6, 0x20u);
        } while (v3 != v5);
    }
    this[2] = v4;
    return a2;
}

//----- (00434250) --------------------------------------------------------
void sub_434250()
{
    flt_520C38 = 48.0 * 0.00390625;
}
// 520C38: using guessed type float flt_520C38;

//----- (00434270) --------------------------------------------------------
int __thiscall sub_434270(int this)
{
    int v2; // ebp
    _BYTE* v3; // eax
    int v4; // eax
    int v5; // ecx
    _DWORD* v6; // eax
    _DWORD* v7; // eax
    _DWORD* v8; // eax
    _DWORD* v9; // eax
    _BYTE* v10; // eax
    _BYTE* v11; // eax
    int v12; // eax
    int v13; // edi
    int v14; // edx
    double v15; // st7
    int v16; // eax
    int* v17; // eax
    int v18; // ecx
    int v19; // ebp
    int* v20; // edi
    int v21; // eax
    _DWORD* v22; // eax
    _DWORD* v23; // eax
    _DWORD* v24; // eax
    _DWORD* v25; // eax
    _DWORD* v26; // eax
    _DWORD* v27; // eax
    _DWORD* v28; // eax
    _DWORD* v29; // eax
    _DWORD* v30; // eax
    _DWORD* v31; // eax
    _BYTE* v32; // eax
    int v33; // ecx
    _BYTE* v34; // eax
    int v35; // ecx
    _BYTE* v36; // eax
    int v37; // ecx
    bool v38; // zf
    int v39; // edi
    _DWORD* v40; // ebp
    _DWORD* v41; // eax
    _DWORD* v42; // eax
    _DWORD* v43; // eax
    _DWORD* v44; // ecx
    _DWORD* v45; // eax
    _DWORD* v46; // eax
    _DWORD* v47; // ecx
    _DWORD* v48; // eax
    _DWORD* v49; // eax
    _DWORD* v50; // ecx
    _DWORD* v51; // eax
    _DWORD* v52; // eax
    _DWORD* v53; // ecx
    _DWORD* v54; // eax
    _DWORD* v55; // eax
    _DWORD* v56; // ecx
    _BYTE* v57; // eax
    int v58; // ecx
    double v59; // st7
    int v60; // eax
    double v61; // st6
    _BYTE* v62; // eax
    int v63; // ecx
    double v64; // st7
    int v65; // eax
    _DWORD* v66; // eax
    _DWORD* v67; // eax
    _DWORD* v68; // ecx
    _DWORD* v69; // eax
    _DWORD* v70; // eax
    _DWORD* v71; // ecx
    _DWORD* v72; // eax
    _DWORD* v73; // eax
    _DWORD* v74; // eax
    _DWORD* v75; // eax
    _DWORD* v76; // eax
    double v77; // st7
    int v78; // ebp
    int* v79; // edi
    double v80; // st7
    _DWORD* v81; // eax
    _DWORD* v82; // eax
    int v83; // eax
    int* v84; // ebp
    _DWORD* v85; // eax
    _DWORD* v86; // eax
    _DWORD* v87; // eax
    _DWORD* v88; // eax
    _DWORD* v89; // eax
    _DWORD* v90; // eax
    int* v91; // edi
    _DWORD* v92; // eax
    _DWORD* v93; // eax
    _BYTE* v94; // eax
    _BYTE* v95; // eax
    int v96; // edi
    float v98; // [esp+4h] [ebp-17Ch]
    float v99; // [esp+4h] [ebp-17Ch]
    float v100; // [esp+4h] [ebp-17Ch]
    float v101; // [esp+4h] [ebp-17Ch]
    float v102; // [esp+4h] [ebp-17Ch]
    float v103; // [esp+4h] [ebp-17Ch]
    float v104; // [esp+4h] [ebp-17Ch]
    float v105; // [esp+8h] [ebp-178h]
    float v106; // [esp+8h] [ebp-178h]
    float v107; // [esp+8h] [ebp-178h]
    float v108; // [esp+8h] [ebp-178h]
    float v109; // [esp+8h] [ebp-178h]
    float v110; // [esp+8h] [ebp-178h]
    int v111; // [esp+8h] [ebp-178h]
    int v112; // [esp+8h] [ebp-178h]
    float v113; // [esp+Ch] [ebp-174h]
    float v114; // [esp+Ch] [ebp-174h]
    float v115; // [esp+Ch] [ebp-174h]
    float v116; // [esp+Ch] [ebp-174h]
    float v117; // [esp+Ch] [ebp-174h]
    float v118; // [esp+Ch] [ebp-174h]
    float v119; // [esp+Ch] [ebp-174h]
    float v120; // [esp+Ch] [ebp-174h]
    float v121; // [esp+Ch] [ebp-174h]
    float v122; // [esp+Ch] [ebp-174h]
    float v123; // [esp+Ch] [ebp-174h]
    int v124; // [esp+Ch] [ebp-174h]
    float v125; // [esp+10h] [ebp-170h]
    float v126; // [esp+10h] [ebp-170h]
    float v127; // [esp+10h] [ebp-170h]
    _DWORD* v128; // [esp+10h] [ebp-170h]
    _DWORD* v129; // [esp+10h] [ebp-170h]
    _DWORD* v130; // [esp+10h] [ebp-170h]
    float v131; // [esp+10h] [ebp-170h]
    float v132; // [esp+10h] [ebp-170h]
    float v133; // [esp+10h] [ebp-170h]
    float v134; // [esp+10h] [ebp-170h]
    float v135; // [esp+10h] [ebp-170h]
    float v136; // [esp+10h] [ebp-170h]
    int v137; // [esp+10h] [ebp-170h]
    _DWORD* v138; // [esp+10h] [ebp-170h]
    _DWORD* v139; // [esp+10h] [ebp-170h]
    int v140; // [esp+10h] [ebp-170h]
    _DWORD* v141; // [esp+10h] [ebp-170h]
    _DWORD* v142; // [esp+10h] [ebp-170h]
    int v143; // [esp+2Ch] [ebp-154h]
    int v144; // [esp+2Ch] [ebp-154h]
    float v145; // [esp+2Ch] [ebp-154h]
    int v146; // [esp+2Ch] [ebp-154h]
    __int64 v147; // [esp+30h] [ebp-150h]
    __int64 v148; // [esp+30h] [ebp-150h]
    float v149; // [esp+30h] [ebp-150h]
    signed int v150; // [esp+30h] [ebp-150h]
    float v151; // [esp+30h] [ebp-150h]
    float v152; // [esp+30h] [ebp-150h]
    float v153; // [esp+30h] [ebp-150h]
    float v154; // [esp+38h] [ebp-148h]
    int v155; // [esp+38h] [ebp-148h]
    int v156; // [esp+38h] [ebp-148h]
    int v157; // [esp+3Ch] [ebp-144h]
    int v158; // [esp+3Ch] [ebp-144h]
    float v159; // [esp+3Ch] [ebp-144h]
    float v160; // [esp+40h] [ebp-140h]
    float v161; // [esp+40h] [ebp-140h]
    float v162; // [esp+44h] [ebp-13Ch]
    signed int v163; // [esp+44h] [ebp-13Ch]
    float v164; // [esp+44h] [ebp-13Ch]
    float v165; // [esp+44h] [ebp-13Ch]
    float v166; // [esp+48h] [ebp-138h]
    int v167; // [esp+4Ch] [ebp-134h]
    float v168; // [esp+4Ch] [ebp-134h]
    int v169; // [esp+50h] [ebp-130h]
    float v170; // [esp+50h] [ebp-130h]
    char Buffer[260]; // [esp+70h] [ebp-110h] BYREF
    int v172; // [esp+17Ch] [ebp-4h]

    *(_DWORD*)(this + 4) = 0;
    *(_DWORD*)(this + 8) = 0;
    *(_DWORD*)(this + 12) = 0;
    *(_BYTE*)(this + 16) = 1;
    v172 = 0;
    *(_DWORD*)(this + 24) = 0;
    *(_DWORD*)(this + 28) = 0;
    *(_DWORD*)(this + 32) = 0;
    *(_BYTE*)(this + 36) = 0;
    *(_DWORD*)(this + 700) = 0;
    *(_DWORD*)(this + 704) = 0;
    *(_DWORD*)(this + 708) = 0;
    *(_BYTE*)(this + 712) = 1;
    LOBYTE(v172) = 2;
    *(_DWORD*)this = &off_4994B8;
    sub_4229D0(aLoadingLoading);
    *(_BYTE*)(this + 40) = 1;
    *(_DWORD*)(this + 44) = 0;
    v2 = sub_421B20(*(_DWORD**)(dword_520970 + 132), 1);
    byte_4A9F14 = sub_422BA0(AppName, aShowcrosshair, 1) != 0;
    v3 = sub_409AD0((int*)dword_520970, 1, 0x20u);
    *(_DWORD*)(this + 436) = v3;
    v3[35] = 1;
    v4 = *(_DWORD*)(this + 436);
    *(_DWORD*)(v4 + 12) = 1092616192;
    *(_DWORD*)(v4 + 16) = 1092616192;
    *(_BYTE*)(v4 + 32) = 0;
    *(_DWORD*)(*(_DWORD*)(this + 436) + 20) = 1064514355;
    v5 = *(_DWORD*)(this + 436);
    *(_BYTE*)(v5 + 33) = 0;
    sub_421540((void**)v5);
    v6 = operator new(0x80u);
    LOBYTE(v172) = 3;
    if (v6)
        v7 = sub_412AB0(v6);
    else
        v7 = 0;
    *(_DWORD*)(this + 452) = v7;
    LOBYTE(v172) = 2;
    v125 = (double)(unsigned int)dword_5209D8 + 5.0;
    v113 = (double)(unsigned int)dword_5209F4 + 5.0;
    sub_413090((int)v7, -5.0, -5.0, v113, v125);
    sub_413160(*(_DWORD*)(this + 452), 0, 0, 0);
    sub_413180(*(_DWORD*)(this + 452), 0, 1);
    sub_413120(*(_DWORD*)(this + 452), 1084227584);
    sub_428680((_DWORD*)this, *(_DWORD*)(this + 452));
    *(_BYTE*)(this + 724) = 0;
    v8 = operator new(0x80u);
    LOBYTE(v172) = 4;
    if (v8)
        v9 = sub_412AB0(v8);
    else
        v9 = 0;
    *(_DWORD*)(this + 728) = v9;
    v126 = (float)(unsigned int)dword_5209D8;
    v114 = (float)(unsigned int)dword_5209F4;
    LOBYTE(v172) = 2;
    v105 = (float)(unsigned int)(dword_5209D8 - v2);
    sub_413090((int)v9, 0.0, v105, v114, v126);
    sub_413160(*(_DWORD*)(this + 728), 0, 0, 0);
    sub_413180(*(_DWORD*)(this + 728), 200, 1);
    sub_413120(*(_DWORD*)(this + 728), 0x40000000);
    sub_428680((_DWORD*)this, *(_DWORD*)(this + 728));
    v10 = sub_409AD0((int*)dword_520970, 1, 0x41u);
    *(_DWORD*)(this + 736) = v10;
    v147 = (unsigned int)(dword_5209D8 - v2);
    *((_DWORD*)v10 + 3) = 0;
    v10[32] = 0;
    *((float*)v10 + 4) = (float)v147;
    *(_DWORD*)(*(_DWORD*)(this + 736) + 20) = 1074161254;
    v11 = sub_409AD0((int*)dword_520970, 1, 0x41u);
    *(_DWORD*)(this + 732) = v11;
    sub_421300((int)v11, 0xFFu, 0xBAu, 0, 255);
    v12 = *(_DWORD*)(this + 732);
    v148 = (unsigned int)(dword_5209D8 - v2);
    *(_DWORD*)(v12 + 12) = 0;
    *(_BYTE*)(v12 + 32) = 0;
    *(float*)(v12 + 16) = (float)v148;
    *(_DWORD*)(*(_DWORD*)(this + 732) + 20) = 1074161254;
    *(_DWORD*)(this + 560) = sub_409AF0((_DWORD**)dword_520970, aIconsHealth1Tg, 1);
    *(_DWORD*)(this + 564) = sub_409AF0((_DWORD**)dword_520970, aIconsHealth2Tg, 1);
    *(_DWORD*)(this + 568) = sub_409AF0((_DWORD**)dword_520970, aIconsHealth3Tg, 1);
    *(_DWORD*)(this + 572) = sub_409AF0((_DWORD**)dword_520970, aIconsHealth4Tg, 1);
    *(_DWORD*)(this + 576) = sub_409AF0((_DWORD**)dword_520970, aIconsHealth5Tg, 1);
    *(_DWORD*)(this + 628) = sub_409AF0((_DWORD**)dword_520970, aIconsHealthsha, 1);
    *(_DWORD*)(this + 632) = sub_409AF0((_DWORD**)dword_520970, aIconsHealthgod, 1);
    *(_DWORD*)(this + 20) = sub_409AF0((_DWORD**)dword_520970, aIconsInsignias, 0);
    *(_DWORD*)(this + 716) = operator new(0xA0u);
    v13 = 0;
    v157 = 10;
    do
    {
        *(_DWORD*)(v13 + *(_DWORD*)(this + 716)) = 10;
        *(_DWORD*)(v13 + *(_DWORD*)(this + 716) + 4) = v157;
        *(_DWORD*)(v13 + *(_DWORD*)(this + 716) + 8) = sub_409AD0((int*)dword_520970, 1, 0x100u);
        v14 = *(_DWORD*)(this + 716);
        v15 = (double)*(int*)(v13 + v14 + 4);
        v16 = *(_DWORD*)(v13 + v14 + 8);
        v143 = *(_DWORD*)(v13 + v14) + v2;
        *(_BYTE*)(v16 + 32) = 0;
        *(float*)(v16 + 12) = (float)v143;
        *(float*)(v16 + 16) = v15;
        *(_DWORD*)(*(_DWORD*)(v13 + *(_DWORD*)(this + 716) + 8) + 20) = 1065017672;
        *(_BYTE*)(*(_DWORD*)(v13 + *(_DWORD*)(this + 716) + 8) + 35) = 1;
        *(_DWORD*)(v13 + *(_DWORD*)(this + 716) + 12) = sub_437450(this, 0);
        v17 = (int*)(v13 + *(_DWORD*)(this + 716));
        v167 = v17[1];
        v127 = (float)(v2 + v167);
        v115 = (float)(v2 + *v17);
        v106 = (float)v167;
        v98 = (float)*v17;
        sub_413090(v17[3], v98, v106, v115, v127);
        v18 = *(_DWORD*)(v13 + *(_DWORD*)(this + 716) + 12);
        (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)v18 + 24))(v18, 0);
        sub_413120(*(_DWORD*)(v13 + *(_DWORD*)(this + 716) + 12), 1065017672);
        v13 += 16;
        v157 += v2;
    } while (v13 < 160);
    v19 = 6;
    v158 = 6;
    v20 = (int*)(this + 68);
    v21 = dword_5209F4 - 78;
    v169 = dword_5209F4 - 78;
    v162 = (float)(dword_5209F4 - 78 + 76);
    v149 = (float)(dword_5209F4 - 78 + 12);
    v166 = (float)(dword_5209F4 - 78 + 74);
    v144 = 4;
    v168 = (float)(dword_5209F4 - 78 + 10);
    while (1)
    {
        *((_BYTE*)v20 - 12) = 0;
        *(v20 - 5) = v21;
        *(v20 - 4) = v19;
        *(v20 - 2) = 1065353216;
        *(v20 - 1) = 0;
        v22 = operator new(0x80u);
        LOBYTE(v172) = 5;
        v23 = v22 ? sub_412AB0(v22) : 0;
        *v20 = (int)v23;
        v128 = *(_DWORD**)(this + 628);
        LOBYTE(v172) = 2;
        sub_4131B0(v23, v128);
        v160 = (float)(v19 + 64);
        v154 = (float)v158;
        sub_413090(*v20, v149, v154, v162, v160);
        sub_413120(*v20, 1063675494);
        sub_428680((_DWORD*)this, *v20);
        v24 = operator new(0x80u);
        LOBYTE(v172) = 6;
        v25 = v24 ? sub_412AB0(v24) : 0;
        v20[1] = (int)v25;
        v129 = *(_DWORD**)(this + 560);
        LOBYTE(v172) = 2;
        sub_4131B0(v25, v129);
        sub_413090(v20[1], v168, v154, v166, v160);
        sub_413120(v20[1], 1063843266);
        sub_428680((_DWORD*)this, v20[1]);
        v26 = operator new(0x80u);
        LOBYTE(v172) = 7;
        v27 = v26 ? sub_412AB0(v26) : 0;
        v20[2] = (int)v27;
        v130 = *(_DWORD**)(this + 564);
        LOBYTE(v172) = 2;
        sub_4131B0(v27, v130);
        sub_413090(v20[2], v168, v154, v166, v160);
        sub_413120(v20[2], 1064011038);
        sub_428680((_DWORD*)this, v20[2]);
        v28 = operator new(0x80u);
        LOBYTE(v172) = 8;
        v29 = v28 ? sub_412AB0(v28) : 0;
        v20[4] = (int)v29;
        v116 = (float)(unsigned int)dword_5209F4;
        LOBYTE(v172) = 2;
        v99 = (float)(unsigned int)(dword_5209F4 - 10);
        sub_413090((int)v29, v99, v154, v116, v160);
        sub_413120(v20[4], 1063675494);
        sub_413160(v20[4], 64, 64, 64);
        sub_428680((_DWORD*)this, v20[4]);
        v30 = operator new(0x80u);
        LOBYTE(v172) = 9;
        v31 = v30 ? sub_412AB0(v30) : 0;
        v20[5] = (int)v31;
        LOBYTE(v172) = 2;
        v117 = (float)(unsigned int)(dword_5209F4 - 2);
        v100 = (float)(unsigned int)(dword_5209F4 - 8);
        sub_413090((int)v31, v100, v154, v117, v160);
        sub_413120(v20[5], 1063843266);
        sub_413160(v20[5], 0, 178, 0);
        sub_428680((_DWORD*)this, v20[5]);
        v32 = sub_409AD0((int*)dword_520970, 1, 0x40u);
        v20[3] = (int)v32;
        v32[35] = 1;
        v33 = v20[3];
        *(_BYTE*)(v33 + 33) = 1;
        sub_421540((void**)v33);
        v34 = sub_409AD0((int*)dword_520970, 1, 0x40u);
        v20[6] = (int)v34;
        v34[35] = 1;
        v35 = v20[6];
        *(_BYTE*)(v35 + 33) = 1;
        sub_421540((void**)v35);
        v36 = sub_409AD0((int*)dword_520970, 1, 0x40u);
        v20[7] = (int)v36;
        v36[35] = 1;
        v37 = v20[7];
        *(_BYTE*)(v37 + 33) = 1;
        sub_421540((void**)v37);
        v20 += 13;
        v38 = v144 == 1;
        v158 += 106;
        --v144;
        if (v38)
            break;
        v21 = v169;
        v19 = v158;
    }
    v39 = 1;
    v40 = (_DWORD*)(this + 580);
    do
    {
        sprintf(Buffer, "Crosshair%d.tga", v39);
        v41 = sub_409AF0((_DWORD**)dword_520970, Buffer, 1);
        *v40 = v41;
        sub_4282E0(v41 != 0, "failed to load crosshair %d", v39);
        ++v40;
        ++v39;
    } while (v39 - 1 < 12);
    v42 = operator new(0x80u);
    LOBYTE(v172) = 10;
    if (v42)
        v43 = sub_412AB0(v42);
    else
        v43 = 0;
    LOBYTE(v172) = 2;
    *(_DWORD*)(this + 472) = v43;
    sub_413120((int)v43, 1063675494);
    sub_428680((_DWORD*)this, *(_DWORD*)(this + 472));
    v44 = *(_DWORD**)(this + 472);
    *(_DWORD*)(this + 492) = 0;
    sub_4131B0(v44, *(_DWORD**)(this + 580));
    *(_DWORD*)(this + 676) = sub_409AF0((_DWORD**)dword_520970, aBinocularsTga, 0);
    v163 = (unsigned int)dword_5209F4 >> 1;
    v150 = (unsigned int)dword_5209D8 >> 1;
    v45 = operator new(0x80u);
    LOBYTE(v172) = 11;
    if (v45)
        v46 = sub_412AB0(v45);
    else
        v46 = 0;
    v47 = *(_DWORD**)(this + 676);
    LOBYTE(v172) = 2;
    *(_DWORD*)(this + 476) = v46;
    sub_4131B0(v46, v47);
    v151 = (float)v150;
    v164 = (float)v163;
    sub_413090(*(_DWORD*)(this + 476), 0.0, 0.0, v164, v151);
    sub_413120(*(_DWORD*)(this + 476), 1061997773);
    sub_413130(*(_DWORD*)(this + 476), 0, 0, 1065353216, 1065353216);
    *(_BYTE*)(*(_DWORD*)(this + 476) + 104) = 1;
    sub_428680((_DWORD*)this, *(_DWORD*)(this + 476));
    v48 = operator new(0x80u);
    LOBYTE(v172) = 12;
    if (v48)
        v49 = sub_412AB0(v48);
    else
        v49 = 0;
    v50 = *(_DWORD**)(this + 676);
    LOBYTE(v172) = 2;
    *(_DWORD*)(this + 480) = v49;
    sub_4131B0(v49, v50);
    v118 = (float)(unsigned int)dword_5209F4;
    sub_413090(*(_DWORD*)(this + 480), v164, 0.0, v118, v151);
    sub_413120(*(_DWORD*)(this + 480), 1061997773);
    sub_413130(*(_DWORD*)(this + 480), 1065353216, 0, 0, 1065353216);
    *(_BYTE*)(*(_DWORD*)(this + 480) + 104) = 1;
    sub_428680((_DWORD*)this, *(_DWORD*)(this + 480));
    v51 = operator new(0x80u);
    LOBYTE(v172) = 13;
    if (v51)
        v52 = sub_412AB0(v51);
    else
        v52 = 0;
    v53 = *(_DWORD**)(this + 676);
    LOBYTE(v172) = 2;
    *(_DWORD*)(this + 484) = v52;
    sub_4131B0(v52, v53);
    v131 = (float)(unsigned int)dword_5209D8;
    sub_413090(*(_DWORD*)(this + 484), 0.0, v151, v164, v131);
    sub_413120(*(_DWORD*)(this + 484), 1061997773);
    sub_413130(*(_DWORD*)(this + 484), 0, 1065353216, 1065353216, 0);
    *(_BYTE*)(*(_DWORD*)(this + 484) + 104) = 1;
    sub_428680((_DWORD*)this, *(_DWORD*)(this + 484));
    v54 = operator new(0x80u);
    LOBYTE(v172) = 14;
    if (v54)
        v55 = sub_412AB0(v54);
    else
        v55 = 0;
    v56 = *(_DWORD**)(this + 676);
    LOBYTE(v172) = 2;
    *(_DWORD*)(this + 488) = v55;
    sub_4131B0(v55, v56);
    v132 = (float)(unsigned int)dword_5209D8;
    v119 = (float)(unsigned int)dword_5209F4;
    sub_413090(*(_DWORD*)(this + 488), v164, v151, v119, v132);
    sub_413120(*(_DWORD*)(this + 488), 1061997773);
    sub_413130(*(_DWORD*)(this + 488), 1065353216, 1065353216, 0, 0);
    *(_BYTE*)(*(_DWORD*)(this + 488) + 104) = 1;
    sub_428680((_DWORD*)this, *(_DWORD*)(this + 488));
    v57 = sub_409AD0((int*)dword_520970, 1, 0x20u);
    *(_DWORD*)(this + 444) = v57;
    v57[35] = 1;
    v58 = *(_DWORD*)(this + 444);
    *(_BYTE*)(v58 + 33) = 1;
    sub_421540((void**)v58);
    v59 = (double)(unsigned int)(dword_5209D8 - 12);
    v60 = *(_DWORD*)(this + 444);
    v61 = (double)(unsigned int)(dword_5209F4 - 30);
    *(_BYTE*)(v60 + 32) = 1;
    *(float*)(v60 + 12) = v61;
    *(float*)(v60 + 16) = v59;
    *(_DWORD*)(*(_DWORD*)(this + 444) + 20) = 1063675494;
    v62 = sub_409AD0((int*)dword_520970, 1, 0x20u);
    *(_DWORD*)(this + 448) = v62;
    v62[35] = 1;
    v63 = *(_DWORD*)(this + 448);
    *(_BYTE*)(v63 + 33) = 1;
    sub_421540((void**)v63);
    v64 = (double)(unsigned int)(dword_5209D8 - 12);
    v65 = *(_DWORD*)(this + 448);
    *(float*)(v65 + 12) = (float)(unsigned int)(dword_5209F4 - 95);
    *(_BYTE*)(v65 + 32) = 1;
    *(float*)(v65 + 16) = v64;
    *(_DWORD*)(*(_DWORD*)(this + 448) + 20) = 1063675494;
    *(_DWORD*)(this + 636) = sub_409AF0((_DWORD**)dword_520970, aIcons30calTga, 1);
    *(_DWORD*)(this + 640) = sub_409AF0((_DWORD**)dword_520970, aIcons45calTga, 1);
    *(_DWORD*)(this + 644) = sub_409AF0((_DWORD**)dword_520970, aIcons50calTga, 1);
    *(_DWORD*)(this + 648) = sub_409AF0((_DWORD**)dword_520970, aIcons40mmTga, 1);
    *(_DWORD*)(this + 652) = sub_409AF0((_DWORD**)dword_520970, aIcons105mmTga, 1);
    *(_DWORD*)(this + 656) = sub_409AF0((_DWORD**)dword_520970, aIcons155mmTga, 1);
    *(_DWORD*)(this + 660) = sub_409AF0((_DWORD**)dword_520970, aIcons203mmTga, 1);
    *(_DWORD*)(this + 664) = sub_409AF0((_DWORD**)dword_520970, aIconsBazookaTg, 1);
    *(_DWORD*)(this + 668) = sub_409AF0((_DWORD**)dword_520970, aIconsSuperbazo, 1);
    *(_DWORD*)(this + 672) = sub_409AF0((_DWORD**)dword_520970, aIconsGrenadesp, 1);
    v66 = operator new(0x80u);
    LOBYTE(v172) = 15;
    if (v66)
        v67 = sub_412AB0(v66);
    else
        v67 = 0;
    v68 = *(_DWORD**)(this + 636);
    LOBYTE(v172) = 2;
    *(_DWORD*)(this + 464) = v67;
    sub_4131B0(v67, v68);
    v133 = (float)(unsigned int)(dword_5209D8 - 22);
    v120 = (float)(unsigned int)(dword_5209F4 + 4);
    v107 = (float)(unsigned int)(dword_5209D8 - 86);
    v101 = (float)(unsigned int)(dword_5209F4 - 60);
    sub_413090(*(_DWORD*)(this + 464), v101, v107, v120, v133);
    sub_413120(*(_DWORD*)(this + 464), 1063675494);
    sub_428680((_DWORD*)this, *(_DWORD*)(this + 464));
    v69 = operator new(0x80u);
    LOBYTE(v172) = 16;
    if (v69)
        v70 = sub_412AB0(v69);
    else
        v70 = 0;
    v71 = *(_DWORD**)(this + 672);
    LOBYTE(v172) = 2;
    *(_DWORD*)(this + 468) = v70;
    sub_4131B0(v70, v71);
    v134 = (float)(unsigned int)(dword_5209D8 - 22);
    v121 = (float)(unsigned int)(dword_5209F4 - 64);
    v108 = (float)(unsigned int)(dword_5209D8 - 86);
    v102 = (float)(unsigned int)(dword_5209F4 - 128);
    sub_413090(*(_DWORD*)(this + 468), v102, v108, v121, v134);
    sub_413130(*(_DWORD*)(this + 468), 0, 0, 1056964608, 1056964608);
    sub_413120(*(_DWORD*)(this + 468), 1063675494);
    sub_428680((_DWORD*)this, *(_DWORD*)(this + 468));
    v72 = operator new(0x80u);
    LOBYTE(v172) = 17;
    if (v72)
        v73 = sub_412AB0(v72);
    else
        v73 = 0;
    *(_DWORD*)(this + 456) = v73;
    LOBYTE(v172) = 2;
    v135 = (float)(unsigned int)(dword_5209D8 - 10);
    v122 = (float)((unsigned int)(dword_5209F4 + 200) >> 1);
    v109 = (float)(unsigned int)(dword_5209D8 - 20);
    v103 = (float)((unsigned int)(dword_5209F4 - 200) >> 1);
    sub_413090((int)v73, v103, v109, v122, v135);
    sub_413120(*(_DWORD*)(this + 456), 1063675494);
    sub_413160(*(_DWORD*)(this + 456), 64, 64, 64);
    sub_428680((_DWORD*)this, *(_DWORD*)(this + 456));
    v74 = operator new(0x80u);
    LOBYTE(v172) = 18;
    if (v74)
        v75 = sub_412AB0(v74);
    else
        v75 = 0;
    *(_DWORD*)(this + 460) = v75;
    LOBYTE(v172) = 2;
    v136 = (float)(unsigned int)(dword_5209D8 - 12);
    v123 = (float)(((unsigned int)(dword_5209F4 + 200) >> 1) - 2);
    v110 = (float)(unsigned int)(dword_5209D8 - 18);
    v104 = (float)(((unsigned int)(dword_5209F4 - 200) >> 1) + 2);
    sub_413090((int)v75, v104, v110, v123, v136);
    sub_413120(*(_DWORD*)(this + 460), 1063843266);
    sub_413160(*(_DWORD*)(this + 460), 0, 178, 0);
    sub_428680((_DWORD*)this, *(_DWORD*)(this + 460));
    *(_DWORD*)(this + 680) = sub_409AF0((_DWORD**)dword_520970, aIconsSpecialat, 1);
    *(_DWORD*)(this + 684) = sub_409AF0((_DWORD**)dword_520970, aIconsSpecialat_0, 1);
    *(_DWORD*)(this + 688) = sub_409AF0((_DWORD**)dword_520970, aIconsGrenadesp, 1);
    *(_DWORD*)(this + 692) = sub_409AF0((_DWORD**)dword_520970, aIconsInsignias_0, 1);
    v76 = sub_409AF0((_DWORD**)dword_520970, aHitarrowsmallT, 0);
    *(_DWORD*)(this + 696) = v76;
    v77 = (double)(unsigned int)dword_5209F4;
    v145 = v77 * 0.25;
    v159 = (float)(int)v76[7];
    v78 = 0;
    v155 = 0;
    v79 = (int*)(this + 496);
    v170 = (v77 - v159) * 0.5;
    v161 = (v77 + v159) * 0.5;
    v80 = (double)(unsigned int)dword_5209D8;
    v152 = (v80 - v159) * 0.5;
    v153 = v152 - v145;
    do
    {
        v79[8] = 0;
        v81 = operator new(0x80u);
        LOBYTE(v172) = 19;
        if (v81)
            v82 = sub_412AB0(v81);
        else
            v82 = 0;
        LOBYTE(v172) = 2;
        *v79 = (int)v82;
        v165 = (v80 + v159) * 0.5 - v145;
        sub_413090((int)v82, v170, v153, v161, v165);
        *(float*)&v137 = (double)v155 * 0.78539819;
        *(float*)&v124 = (float)((unsigned int)dword_5209D8 >> 1);
        *(float*)&v111 = (float)((unsigned int)dword_5209F4 >> 1);
        sub_413100(*v79, v111, v124, v137);
        sub_413120(*v79, 1063675494);
        sub_413180(*v79, 0, 1);
        sub_413130(*v79, 0, 0, 1065353216, 1065353216);
        sub_4131B0((_DWORD*)*v79, *(_DWORD**)(this + 696));
        *(_BYTE*)(*v79 + 105) = 1;
        sub_428680((_DWORD*)this, *v79);
        ++v78;
        ++v79;
        v155 = v78;
    } while (v78 < 8);
    v83 = 0;
    v156 = 0;
    while (1)
    {
        v84 = (int*)(this + 60 * v83 + 256);
        memset(v84, 0, 0x3Cu);
        v85 = operator new(0x80u);
        LOBYTE(v172) = 20;
        if (v85)
            v86 = sub_412AB0(v85);
        else
            v86 = 0;
        v84[2] = (int)v86;
        v138 = *(_DWORD**)(this + 680);
        LOBYTE(v172) = 2;
        sub_4131B0(v86, v138);
        sub_413120(v84[2], 1063675494);
        (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)v84[2] + 24))(v84[2], 0);
        sub_428680((_DWORD*)this, v84[2]);
        v87 = operator new(0x80u);
        LOBYTE(v172) = 21;
        if (v87)
            v88 = sub_412AB0(v87);
        else
            v88 = 0;
        v84[4] = (int)v88;
        v139 = *(_DWORD**)(this + 688);
        LOBYTE(v172) = 2;
        sub_4131B0(v88, v139);
        switch (v156)
        {
        case 0:
            v140 = 1056964608;
            v112 = 0;
        LABEL_75:
            sub_413130(v84[4], 1056964608, v112, 1065353216, v140);
            break;
        case 1:
            sub_413130(v84[4], 0, 1056964608, 1056964608, 1065353216);
            break;
        case 2:
            v140 = 1065353216;
            v112 = 1056964608;
            goto LABEL_75;
        }
        sub_413120(v84[4], 1065353216);
        (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)v84[4] + 24))(v84[4], 0);
        sub_428680((_DWORD*)this, v84[4]);
        v89 = operator new(0x80u);
        LOBYTE(v172) = 22;
        v90 = v89 ? sub_412AB0(v89) : 0;
        v84[3] = (int)v90;
        v141 = *(_DWORD**)(this + 684);
        LOBYTE(v172) = 2;
        sub_4131B0(v90, v141);
        sub_413120(v84[3], 1066192077);
        (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)v84[3] + 24))(v84[3], 0);
        sub_428680((_DWORD*)this, v84[3]);
        v91 = v84 + 5;
        v146 = 6;
        do
        {
            v92 = operator new(0x80u);
            LOBYTE(v172) = 23;
            if (v92)
                v93 = sub_412AB0(v92);
            else
                v93 = 0;
            *v91 = (int)v93;
            v142 = *(_DWORD**)(this + 692);
            LOBYTE(v172) = 2;
            sub_4131B0(v93, v142);
            sub_413130(*v91, 0, 1056964608, 1056964608, 1065353216);
            sub_413120(*v91, 1067030938);
            (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)*v91 + 24))(*v91, 0);
            sub_428680((_DWORD*)this, *v91++);
            --v146;
        } while (v146);
        v94 = sub_409AD0((int*)dword_520970, 1, 0x20u);
        v84[13] = (int)v94;
        v94[35] = 1;
        *(_DWORD*)(v84[13] + 20) = 1067869798;
        v95 = sub_409AD0((int*)dword_520970, 1, 0x20u);
        v84[11] = (int)v95;
        v95[35] = 1;
        *(_DWORD*)(v84[11] + 20) = 1067869798;
        v96 = v156;
        if (v156)
        {
            if (v156 == 1)
            {
                sub_421110(v84[11], aW_0);
            }
            else if (v156 == 2)
            {
                sub_421110(v84[11], aE);
            }
        }
        else
        {
            sub_421110(v84[11], aQ);
        }
        ++v156;
        if (v96 + 1 >= 3)
            break;
        v83 = v96 + 1;
    }
    sub_436D70((_DWORD*)this);
    sub_4229D0(aFinishedLoadin_0);
    return this;
}
// 4994B8: using guessed type _UNKNOWN *off_4994B8;
// 4A9F14: using guessed type char byte_4A9F14;
// 520970: using guessed type int dword_520970;
// 5209D8: using guessed type int dword_5209D8;
// 5209F4: using guessed type int dword_5209F4;

//----- (00435880) --------------------------------------------------------
void __thiscall sub_435880(LPVOID* this)
{
    int i; // edi
    void* v3; // eax
    int j; // edi
    void(__thiscall * **v5)(_DWORD, int); // ecx
    void* v6; // eax

    *this = &off_4994B8;
    sub_4885A6(this[179]);
    if (*((_BYTE*)this + 712))
    {
        for (i = 0; i < (int)this[176]; ++i)
            sub_4885A6(*((LPVOID*)this[175] + i));
    }
    memset(this[175], 0, 4 * (_DWORD)this[176]);
    v3 = this[175];
    this[176] = 0;
    sub_488CEE(v3);
    this[177] = 0;
    this[175] = 0;
    if (*((_BYTE*)this + 36))
    {
        for (j = 0; j < (int)this[7]; ++j)
        {
            v5 = (void(__thiscall***)(_DWORD, int)) * ((_DWORD*)this[6] + j);
            if (v5)
                (**v5)(v5, 1);
        }
    }
    memset(this[6], 0, 4 * (_DWORD)this[7]);
    v6 = this[6];
    this[7] = 0;
    sub_488CEE(v6);
    this[8] = 0;
    this[6] = 0;
    *this = &off_499040;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 4994B8: using guessed type _UNKNOWN *off_4994B8;

//----- (004359A0) --------------------------------------------------------
char __thiscall sub_4359A0(int this, int a2)
{
    double v3; // st7
    int v4; // esi
    BOOL v5; // eax
    char v6; // al
    int v7; // edi
    int v8; // ecx
    int v9; // eax
    double v10; // st7
    bool v11; // al
    int v12; // ecx
    int v13; // ebx
    int v14; // eax
    double v15; // st7
    int v16; // esi
    int v17; // ecx
    _DWORD* v18; // eax
    void* v19; // esi
    int v20; // ecx
    float* v21; // ecx
    int v22; // edx
    double v23; // st7
    int v24; // ecx
    int* v25; // esi
    bool v26; // al
    int v27; // ecx
    BOOL v28; // eax
    BOOL v29; // eax
    BOOL v30; // eax
    BOOL v31; // eax
    BOOL v32; // eax
    bool v33; // al
    int v34; // ecx
    bool v35; // al
    int v36; // ecx
    int v37; // edi
    int v38; // ebx
    double v39; // st7
    int v40; // ebx
    int v41; // ebx
    int* v42; // esi
    _DWORD* v43; // edi
    int v44; // eax
    double v45; // st7
    int* v46; // edi
    int v47; // ecx
    int v48; // ecx
    _DWORD* v49; // edi
    int v50; // ecx
    int v51; // ecx
    int* v52; // edi
    int v53; // ecx
    int v54; // ecx
    int v55; // eax
    double v56; // st7
    _DWORD* v57; // edi
    int v58; // ecx
    int v59; // ecx
    int v60; // edi
    float v61; // edi
    double v62; // st7
    char v64; // c0
    int v65; // ecx
    int v66; // ecx
    bool v67; // cc
    _DWORD* v68; // esi
    int v69; // edi
    char v70; // bl
    BOOL v71; // eax
    bool v72; // bl
    int v73; // ecx
    int v74; // eax
    int v75; // edx
    int v76; // esi
    double v77; // st7
    int v78; // edi
    int i; // esi
    bool v80; // al
    int v81; // ecx
    BOOL v82; // eax
    int v83; // ecx
    double v84; // st7
    int* v85; // ecx
    int v86; // edx
    _DWORD* v87; // ecx
    int v88; // edx
    int v89; // esi
    unsigned int v90; // eax
    int v91; // esi
    _DWORD* v92; // eax
    int v93; // eax
    int v94; // ecx
    int v95; // esi
    BOOL v96; // eax
    bool v97; // al
    int v98; // ecx
    float v100; // [esp+48h] [ebp-80h]
    float v101; // [esp+48h] [ebp-80h]
    float v102; // [esp+48h] [ebp-80h]
    float v103; // [esp+48h] [ebp-80h]
    float v104; // [esp+48h] [ebp-80h]
    float v105; // [esp+4Ch] [ebp-7Ch]
    float v106; // [esp+4Ch] [ebp-7Ch]
    float v107; // [esp+4Ch] [ebp-7Ch]
    float v108; // [esp+4Ch] [ebp-7Ch]
    float v109; // [esp+4Ch] [ebp-7Ch]
    float v110; // [esp+4Ch] [ebp-7Ch]
    float v111; // [esp+4Ch] [ebp-7Ch]
    int v112; // [esp+4Ch] [ebp-7Ch]
    float v113; // [esp+4Ch] [ebp-7Ch]
    float v114; // [esp+4Ch] [ebp-7Ch]
    float v115; // [esp+50h] [ebp-78h]
    float v116; // [esp+50h] [ebp-78h]
    float v117; // [esp+50h] [ebp-78h]
    int v118; // [esp+50h] [ebp-78h]
    float v119; // [esp+50h] [ebp-78h]
    float v120; // [esp+50h] [ebp-78h]
    float v121; // [esp+54h] [ebp-74h]
    float v122; // [esp+54h] [ebp-74h]
    float v123; // [esp+54h] [ebp-74h]
    float v124; // [esp+54h] [ebp-74h]
    float v125; // [esp+54h] [ebp-74h]
    float v126; // [esp+54h] [ebp-74h]
    float v127; // [esp+54h] [ebp-74h]
    int v128; // [esp+54h] [ebp-74h]
    float v129; // [esp+54h] [ebp-74h]
    float v130; // [esp+54h] [ebp-74h]
    char v131; // [esp+6Ah] [ebp-5Eh] BYREF
    bool v132; // [esp+6Bh] [ebp-5Dh] BYREF
    int v133; // [esp+6Ch] [ebp-5Ch]
    int v134; // [esp+70h] [ebp-58h]
    float v135; // [esp+74h] [ebp-54h]
    float v136[2]; // [esp+78h] [ebp-50h]
    int v137; // [esp+80h] [ebp-48h]
    int v138; // [esp+84h] [ebp-44h]
    int v139; // [esp+88h] [ebp-40h]
    int v140; // [esp+8Ch] [ebp-3Ch]
    int v141; // [esp+90h] [ebp-38h]
    int v142; // [esp+94h] [ebp-34h]
    float v143; // [esp+98h] [ebp-30h]
    float v144[2]; // [esp+9Ch] [ebp-2Ch]
    float v145[2]; // [esp+A4h] [ebp-24h]
    float v146; // [esp+ACh] [ebp-1Ch] BYREF
    float v147; // [esp+B0h] [ebp-18h]
    int v148; // [esp+B4h] [ebp-14h]
    __int64 v149; // [esp+B8h] [ebp-10h]
    __int64 v150; // [esp+C0h] [ebp-8h]

    if (*(float*)(this + 44) > 0.0)
    {
        v3 = *(float*)(this + 44) - *(float*)(dword_520970 + 68);
        *(float*)(this + 44) = v3;
        if (v3 < 0.0)
            v3 = 0.0;
        *(float*)(this + 44) = v3;
    }
    v4 = sub_421B20(*(_DWORD**)(dword_520970 + 132), 1) + 2;
    v5 = *(_BYTE*)(this + 40) && *(_BYTE*)(this + 724);
    (*(void(__thiscall**)(_DWORD, BOOL))(**(_DWORD**)(this + 728) + 24))(*(_DWORD*)(this + 728), v5);
    if (*(_BYTE*)(this + 40) && *(_BYTE*)(this + 724))
    {
        v6 = 1;
        v7 = 0;
    }
    else
    {
        v7 = 0;
        v6 = 0;
    }
    v8 = *(_DWORD*)(this + 732);
    *(_BYTE*)(v8 + 33) = v6;
    sub_421540((void**)v8);
    v150 = (unsigned int)(dword_5209D8 - v4);
    v9 = *(_DWORD*)(this + 732);
    v10 = (double)v150;
    *(_DWORD*)(v9 + 12) = 0;
    *(_BYTE*)(v9 + 32) = 0;
    *(float*)(v9 + 16) = v10;
    LOBYTE(v9) = *(_BYTE*)(this + 40);
    v147 = *(float*)(*(_DWORD*)(this + 732) + 24);
    v11 = (_BYTE)v9 && *(_BYTE*)(this + 724);
    v12 = *(_DWORD*)(this + 736);
    *(_BYTE*)(v12 + 33) = v11;
    sub_421540((void**)v12);
    v13 = 0;
    v150 = (unsigned int)(dword_5209D8 - v4);
    v14 = *(_DWORD*)(this + 736);
    v15 = (double)v150;
    *(float*)(v14 + 12) = v147;
    *(_BYTE*)(v14 + 32) = 0;
    *(float*)(v14 + 16) = v15;
    while (v13 < *(_DWORD*)(this + 704))
    {
        v16 = *(_DWORD*)(*(_DWORD*)(this + 700) + 4 * v13);
        v17 = *(_DWORD*)(v16 + 8);
        *(float*)(v16 + 12) = *(float*)(v16 + 12) - *(float*)(dword_520970 + 68);
        *(_BYTE*)(v17 + 33) = *(_BYTE*)(this + 40);
        v18 = sub_421540((void**)v17);
        LOBYTE(v18) = *(_BYTE*)(this + 40);
        (*(void(__thiscall**)(_DWORD, _DWORD*))(**(_DWORD**)(v16 + 16) + 24))(*(_DWORD*)(v16 + 16), v18);
        if (*(float*)(v16 + 12) >= 0.0)
        {
            ++v13;
            v7 += 0x3FFFFFFF;
        }
        else
        {
            sub_437540((_DWORD*)this, *(_DWORD*)(v16 + 16));
            v19 = *(void**)(v16 + 8);
            if (v19)
            {
                sub_4213B0((int)v19);
                sub_4885A6(v19);
            }
            if (v13 >= *(_DWORD*)(this + 704))
                break;
            if (*(_BYTE*)(this + 712))
                sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 700) + 4 * v13));
            v20 = *(_DWORD*)(this + 704) - 1;
            *(_DWORD*)(this + 704) = v20;
            if (v13 != v20)
            {
                memcpy(
                    (void*)(*(_DWORD*)(this + 700) + 4 * v13),
                    (const void*)(*(_DWORD*)(this + 700) + 4 * v13 + 4),
                    4 * (v7 + v20));
                *(_DWORD*)(*(_DWORD*)(this + 700) + 4 * *(_DWORD*)(this + 704)) = 0;
            }
        }
    }
    v21 = (float*)(this + 528);
    v22 = 8;
    do
    {
        v144[1] = *v21 - *(float*)(dword_520970 + 68);
        *v21 = v144[1];
        if (v144[1] >= 0.0)
            v23 = v144[1];
        else
            v23 = 0.0;
        *v21++ = v23;
        --v22;
    } while (v22);
    v24 = *(_DWORD*)(this + 436);
    *(_BYTE*)(v24 + 33) = 0;
    sub_421540((void**)v24);
    v25 = (int*)(this + 76);
    LODWORD(v144[0]) = 4;
    do
    {
        v26 = *(_BYTE*)(this + 40) && *((_BYTE*)v25 - 20);
        v27 = v25[1];
        *(_BYTE*)(v27 + 33) = v26;
        sub_421540((void**)v27);
        v28 = *(_BYTE*)(this + 40) && *((_BYTE*)v25 - 20);
        (*(void(__thiscall**)(int, BOOL))(*(_DWORD*)*v25 + 24))(*v25, v28);
        v29 = *(_BYTE*)(this + 40) && *((_BYTE*)v25 - 20);
        (*(void(__thiscall**)(_DWORD, BOOL))(*(_DWORD*)*(v25 - 1) + 24))(*(v25 - 1), v29);
        v30 = *(_BYTE*)(this + 40) && *((_BYTE*)v25 - 20);
        (*(void(__thiscall**)(_DWORD, BOOL))(*(_DWORD*)*(v25 - 2) + 24))(*(v25 - 2), v30);
        v31 = *(_BYTE*)(this + 40) && *((_BYTE*)v25 - 20);
        (*(void(__thiscall**)(int, BOOL))(*(_DWORD*)v25[3] + 24))(v25[3], v31);
        v32 = *(_BYTE*)(this + 40) && *((_BYTE*)v25 - 20);
        (*(void(__thiscall**)(int, BOOL))(*(_DWORD*)v25[2] + 24))(v25[2], v32);
        v33 = *(_BYTE*)(this + 40) && *((_BYTE*)v25 - 20);
        v34 = v25[4];
        *(_BYTE*)(v34 + 33) = v33;
        sub_421540((void**)v34);
        v35 = *(_BYTE*)(this + 40) && *((_BYTE*)v25 - 20);
        v36 = v25[5];
        *(_BYTE*)(v36 + 33) = v35;
        sub_421540((void**)v36);
        if (*((_BYTE*)v25 - 20))
        {
            v37 = 0;
            LODWORD(v144[1]) = *(v25 - 4);
            v38 = 1;
            v39 = (1.0 - v144[1]) * 4.0;
            if (v39 > 1.0)
            {
                do
                {
                    v39 = v39 - 1.0;
                    ++v37;
                    ++v38;
                } while (v39 > 1.0);
                if (v38 >= 5)
                {
                    v39 = 1.0;
                    --v38;
                    --v37;
                }
            }
            if (*(_BYTE*)(*(_DWORD*)(dword_520970 + 280) + 2552))
            {
                sub_413180(*v25, 0, 1);
                sub_4131B0((_DWORD*)*v25, *(_DWORD**)(this + 632));
                sub_4131B0((_DWORD*)*(v25 - 1), *(_DWORD**)(this + 632));
            }
            else
            {
                sub_413180(*v25, (__int64)(v39 * 255.0), 1);
                sub_4131B0((_DWORD*)*v25, *(_DWORD**)(this + 4 * v38 + 560));
                sub_4131B0((_DWORD*)*(v25 - 1), *(_DWORD**)(this + 4 * v37 + 560));
            }
            v40 = *(v25 - 6);
            v150 = (unsigned int)(dword_5209F4 - 2);
            v121 = (float)(v40 + 62);
            v115 = (float)v150;
            LODWORD(v147) = v40 - (__int64)(v144[1] * 60.0) + 62;
            v149 = (unsigned int)(dword_5209F4 - 8);
            v105 = (float)SLODWORD(v147);
            v100 = (float)v149;
            sub_413090(v25[3], v100, v105, v115, v121);
        }
        v25 += 13;
        --LODWORD(v144[0]);
    } while (LODWORD(v144[0]));
    v134 = 4;
    v144[1] = 0.0;
    LODWORD(v136[1]) = 36;
    v41 = dword_5209D8 - 68;
    v142 = 68;
    v148 = dword_5209D8 - 68;
    v141 = -5;
    v140 = 20;
    v139 = 44;
    v138 = 45;
    v137 = 49;
    v42 = (int*)(this + 256);
    do
    {
        if (!*(_BYTE*)(this + 40) || *(_BYTE*)(dword_4F5CC4 + 936) || *(_BYTE*)(dword_4F5CC4 + 937))
        {
            LOBYTE(v133) = 0;
            v43 = v42 + 5;
            LODWORD(v144[0]) = 6;
            do
            {
                (*(void(__thiscall**)(_DWORD, _DWORD))(*(_DWORD*)*v43 + 24))(*v43, 0);
                ++v43;
                --LODWORD(v144[0]);
            } while (LODWORD(v144[0]));
        }
        else
        {
            LOBYTE(v133) = 1;
        }
        sub_45F3A0(*(char**)(dword_520970 + 280), SLODWORD(v144[1]), (bool*)&v131, &v132, &v146);
        v44 = v42[11];
        LODWORD(v147) = v41 + 50;
        *(float*)(v44 + 12) = (float)v137;
        v45 = (double)SLODWORD(v147);
        *(_BYTE*)(v44 + 32) = 0;
        *(float*)(v44 + 16) = v45;
        if (v131)
        {
            v42[14] = 2;
            v46 = v42 + 5;
            LODWORD(v144[0]) = 6;
            do
            {
                (*(void(__thiscall**)(int, int))(*(_DWORD*)*v46 + 24))(*v46, v133);
                sub_413180(*v46++, 255, 1);
                --LODWORD(v144[0]);
            } while (LODWORD(v144[0]));
            v47 = v42[13];
            *(_BYTE*)(v47 + 33) = 0;
            sub_421540((void**)v47);
            v48 = v42[11];
            *(_BYTE*)(v48 + 33) = v133;
            sub_421540((void**)v48);
            sub_413120(v42[2], 1063675494);
            sub_413120(v42[4], 1065353216);
        LABEL_87:
            (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)v42[3] + 24))(v42[3], 0);
            goto LABEL_101;
        }
        if (v132)
        {
            if (v42[14] == 3)
                goto LABEL_101;
            v42[14] = 3;
            v49 = v42 + 5;
            LODWORD(v144[0]) = 6;
            do
            {
                (*(void(__thiscall**)(_DWORD, _DWORD))(*(_DWORD*)*v49 + 24))(*v49, 0);
                ++v49;
                --LODWORD(v144[0]);
            } while (LODWORD(v144[0]));
            v50 = v42[13];
            *(_BYTE*)(v50 + 33) = 0;
            sub_421540((void**)v50);
            v51 = v42[11];
            *(_BYTE*)(v51 + 33) = 0;
            sub_421540((void**)v51);
            sub_413120(v42[2], 1065353216);
            sub_413120(v42[4], 1063675494);
            goto LABEL_87;
        }
        if (v146 <= 0.0)
        {
            v42[14] = 1;
            v57 = v42 + 5;
            LODWORD(v144[0]) = 6;
            do
            {
                (*(void(__thiscall**)(_DWORD, _DWORD))(*(_DWORD*)*v57 + 24))(*v57, 0);
                ++v57;
                --LODWORD(v144[0]);
            } while (LODWORD(v144[0]));
            v58 = v42[11];
            *(_BYTE*)(v58 + 33) = 0;
            sub_421540((void**)v58);
            v59 = v42[13];
            *(_BYTE*)(v59 + 33) = 0;
            sub_421540((void**)v59);
            (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)v42[3] + 24))(v42[3], 0);
        }
        else if (v42[14] != 4)
        {
            v42[14] = 4;
            v42[12] = 0;
            v52 = v42 + 5;
            LODWORD(v144[0]) = 6;
            do
            {
                (*(void(__thiscall**)(int, int))(*(_DWORD*)*v52 + 24))(*v52, v133);
                sub_413180(*v52++, 0, 1);
                --LODWORD(v144[0]);
            } while (LODWORD(v144[0]));
            v53 = v42[11];
            *(_BYTE*)(v53 + 33) = 0;
            sub_421540((void**)v53);
            v54 = v42[13];
            *(_BYTE*)(v54 + 33) = v133;
            sub_421540((void**)v54);
            v55 = v42[13];
            LODWORD(v147) = v41 + 32;
            *(float*)(v55 + 12) = (float)SLODWORD(v136[1]);
            v56 = (double)SLODWORD(v147);
            *(_BYTE*)(v55 + 32) = 1;
            *(float*)(v55 + 16) = v56;
            sub_413120(v42[2], 1065353216);
            sub_413120(v42[4], 1063675494);
            (*(void(__thiscall**)(int, int))(*(_DWORD*)v42[3] + 24))(v42[3], v133);
        }
    LABEL_101:
        if (v42[14] == 1 || !(_BYTE)v133)
        {
            (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)v42[2] + 24))(v42[2], 0);
            (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)v42[4] + 24))(v42[4], 0);
            v65 = v42[11];
            *(_BYTE*)(v65 + 33) = 0;
            sub_421540((void**)v65);
            v66 = v42[13];
            *(_BYTE*)(v66 + 33) = 0;
            sub_421540((void**)v66);
            (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)v42[3] + 24))(v42[3], 0);
        }
        else
        {
            v60 = v133;
            (*(void(__thiscall**)(int, int))(*(_DWORD*)v42[2] + 24))(v42[2], v133);
            (*(void(__thiscall**)(int, int))(*(_DWORD*)v42[4] + 24))(v42[4], v60);
            v147 = (float)(v41 + 64);
            v61 = v147;
            v136[0] = (float)v142;
            v143 = (float)v148;
            v144[0] = (float)v134;
            sub_413090(v42[2], v144[0], v143, v136[0], v147);
            sub_413090(v42[4], v144[0], v143, v136[0], v61);
            LODWORD(v150) = v41 + 32;
            v145[0] = (float)(v134 + 48);
            v145[1] = (float)v140;
            LODWORD(v149) = v41 - 13;
            v122 = (float)(v41 + 19);
            v106 = (float)(v41 - 13);
            sub_413090(v42[5], v145[1], v106, v145[0], v122);
            v123 = (float)(v41 + 33);
            LODWORD(v149) = v41 + 1;
            v116 = (float)(v134 + 73);
            v107 = (float)(v41 + 1);
            v101 = (float)v138;
            sub_413090(v42[6], v101, v107, v116, v123);
            v124 = (float)(v41 + 63);
            LODWORD(v149) = v41 + 31;
            v117 = (float)(v134 + 72);
            v108 = (float)(v41 + 31);
            v102 = (float)v139;
            sub_413090(v42[7], v102, v108, v117, v124);
            LODWORD(v149) = v41 + 45;
            v125 = (float)(v41 + 77);
            v109 = (float)(v41 + 45);
            sub_413090(v42[8], v145[1], v109, v145[0], v125);
            v145[1] = (float)(v134 + 23);
            v145[0] = (float)v141;
            LODWORD(v149) = v41 + 30;
            v126 = (float)(v41 + 62);
            v110 = (float)(v41 + 30);
            sub_413090(v42[9], v145[0], v110, v145[1], v126);
            LODWORD(v149) = v41 + 2;
            v127 = (float)(v41 + 34);
            v111 = (float)(v41 + 2);
            sub_413090(v42[10], v145[0], v111, v145[1], v127);
            if (v42[14] == 4)
            {
                sub_421190(v42[13], "%d:%02d", (int)(__int64)v146 / 60, (int)(__int64)v146 % 60);
                sub_413090(v42[3], v144[0], v143, v136[0], v147);
                (*(void(__thiscall**)(int, int))(*(_DWORD*)v42[3] + 24))(v42[3], v133);
                v135 = *((float*)v42 + 12);
                v62 = *(float*)&a2 * 60.0 + v135;
                v136[0] = v62;
                if (!v64)
                {
                    do
                        v62 = v62 - 360.0;
                    while (v62 >= 360.0);
                    v136[0] = v62;
                }
                *((float*)v42 + 12) = v62;
                *(float*)&v128 = v62 * 0.017453292;
                *(float*)&v118 = (float)(int)v150;
                *(float*)&v112 = (float)SLODWORD(v136[1]);
                sub_413100(v42[3], v112, v118, v128);
                if (v136[0] >= (double)v135)
                {
                    if (v135 >= 60.0 || v136[0] < 60.0)
                    {
                        if (v135 >= 120.0 || v136[0] < 120.0)
                        {
                            if (v135 >= 180.0 || v136[0] < 180.0)
                            {
                                if (v135 >= 240.0 || v136[0] < 240.0)
                                {
                                    if (v135 < 300.0 && v136[0] >= 300.0)
                                    {
                                        sub_413180(v42[10], 255, 1);
                                        sub_413240((_DWORD*)v42[10], 1065353216, 1077936128, 255, 0);
                                    }
                                }
                                else
                                {
                                    sub_413180(v42[9], 255, 1);
                                    sub_413240((_DWORD*)v42[9], 1065353216, 1077936128, 255, 0);
                                }
                            }
                            else
                            {
                                sub_413180(v42[8], 255, 1);
                                sub_413240((_DWORD*)v42[8], 1065353216, 1077936128, 255, 0);
                            }
                        }
                        else
                        {
                            sub_413180(v42[7], 255, 1);
                            sub_413240((_DWORD*)v42[7], 1065353216, 1077936128, 255, 0);
                        }
                    }
                    else
                    {
                        sub_413180(v42[6], 255, 1);
                        sub_413240((_DWORD*)v42[6], 1065353216, 1077936128, 255, 0);
                    }
                }
                else
                {
                    sub_413180(v42[5], 255, 1);
                    sub_413240((_DWORD*)v42[5], 1065353216, 1077936128, 255, 0);
                }
            }
        }
        v134 += 68;
        v137 += 68;
        v138 += 68;
        v139 += 68;
        v140 += 68;
        v42 += 15;
        v141 += 68;
        v67 = LODWORD(v144[1]) + 1 < 3;
        v142 += 68;
        LODWORD(v136[1]) += 68;
        ++LODWORD(v144[1]);
    } while (v67);
    v68 = (_DWORD*)(this + 476);
    v69 = 4;
    v70 = *(_BYTE*)(*(_DWORD*)(dword_520970 + 280) + 2584);
    v131 = v70;
    do
    {
        v71 = *(_BYTE*)(this + 40) && v70;
        (*(void(__thiscall**)(_DWORD, BOOL))(*(_DWORD*)*v68 + 24))(*v68, v71);
        ++v68;
        --v69;
    } while (v69);
    v72 = *(_BYTE*)(this + 40) && byte_4A9F14 && *(int*)(this + 492) > -1 && !v70;
    v73 = *(_DWORD*)(this + 472);
    LOBYTE(v147) = v72;
    (*(void(__thiscall**)(int, float))(*(_DWORD*)v73 + 24))(v73, COERCE_FLOAT(LODWORD(v147)));
    if (v72)
    {
        v74 = *(_DWORD*)(this + 4 * *(_DWORD*)(this + 492) + 580);
        v75 = *(_DWORD*)(v74 + 32);
        v76 = *(_DWORD*)(v74 + 28);
        LODWORD(v150) = (unsigned int)(v75 + dword_5209D8) >> 1;
        v129 = (float)(int)v150;
        LODWORD(v150) = (unsigned int)(v76 + dword_5209F4) >> 1;
        v77 = (double)(int)v150;
        LODWORD(v150) = (unsigned int)(dword_5209D8 - v75) >> 1;
        v119 = v77;
        v113 = (float)(int)v150;
        LODWORD(v150) = (unsigned int)(dword_5209F4 - v76) >> 1;
        v103 = (float)(int)v150;
        sub_413090(*(_DWORD*)(this + 472), v103, v113, v119, v129);
    }
    v78 = 0;
    for (i = 0; i < 160; i += 16)
    {
        v80 = v78 < *(_DWORD*)(this + 720) && *(_BYTE*)(this + 40) && !v131;
        v81 = *(_DWORD*)(*(_DWORD*)(this + 716) + i + 8);
        *(_BYTE*)(v81 + 33) = v80;
        sub_421540((void**)v81);
        v82 = v78 < *(_DWORD*)(this + 720) && *(_BYTE*)(this + 40) && !v131;
        v83 = *(_DWORD*)(*(_DWORD*)(this + 716) + i + 12);
        (*(void(__thiscall**)(int, BOOL))(*(_DWORD*)v83 + 24))(v83, v82);
        ++v78;
    }
    if (*(_BYTE*)(this + 40) && sub_45F4A0((_DWORD*)*(_DWORD*)(dword_520970 + 280)) >= 2.0)
    {
        v84 = sub_45F520(*(_DWORD*)(dword_520970 + 280));
        v85 = *(int**)(this + 460);
        v86 = *v85;
        v147 = 1.0 - v84;
        (*(void(__thiscall**)(int*, int))(v86 + 24))(v85, 1);
        (*(void(__thiscall**)(_DWORD, int))(**(_DWORD**)(this + 456) + 24))(*(_DWORD*)(this + 456), 1);
        v150 = (unsigned int)(dword_5209D8 - 12);
        v130 = (float)v150;
        LODWORD(v149) = ((unsigned int)(dword_5209F4 - 200) >> 1) + 2;
        v150 = (unsigned int)(dword_5209D8 - 18);
        v120 = (float)(int)(v149 - (__int64)(v147 * -196.0));
        v114 = (float)v150;
        v104 = (float)(int)v149;
        sub_413090(*(_DWORD*)(this + 460), v104, v114, v120, v130);
        if (v147 - 1.0 <= -0.0000099999997)
            sub_413160(*(_DWORD*)(this + 460), 255, 0, 0);
        else
            sub_413160(*(_DWORD*)(this + 460), 0, 178, 0);
    }
    else
    {
        (*(void(__thiscall**)(_DWORD, _DWORD))(**(_DWORD**)(this + 460) + 24))(*(_DWORD*)(this + 460), 0);
        (*(void(__thiscall**)(_DWORD, _DWORD))(**(_DWORD**)(this + 456) + 24))(*(_DWORD*)(this + 456), 0);
    }
    v87 = *(_DWORD**)(dword_520970 + 280);
    v88 = v87[645];
    if (v88 < 0
        || ((v89 = v87[642]) != 0 ? (v90 = (v87[643] - v89) >> 3) : (v90 = 0),
            v88 >= v90 || (v91 = *(_DWORD*)(*(_DWORD*)(v87[642] + 8 * v88) + 296), v91 <= -1)))
    {
        (*(void(__thiscall**)(_DWORD, _DWORD))(**(_DWORD**)(this + 464) + 24))(*(_DWORD*)(this + 464), 0);
        v94 = *(_DWORD*)(this + 444);
        *(_BYTE*)(v94 + 33) = 0;
    }
    else
    {
        v92 = sub_4131B0(*(_DWORD**)(this + 464), *(_DWORD**)(this + 4 * v91 + 636));
        LOBYTE(v92) = *(_BYTE*)(this + 40);
        (*(void(__thiscall**)(_DWORD, _DWORD*))(**(_DWORD**)(this + 464) + 24))(*(_DWORD*)(this + 464), v92);
        v93 = sub_4629B0(*(_DWORD*)(dword_520970 + 280), v91);
        sub_421190(*(_DWORD*)(this + 444), "%d", v93);
        v94 = *(_DWORD*)(this + 444);
        *(_BYTE*)(v94 + 33) = *(_BYTE*)(this + 40);
    }
    sub_421540((void**)v94);
    v95 = sub_4629B0(*(_DWORD*)(dword_520970 + 280), 9);
    v96 = *(_BYTE*)(this + 40) && v95 > 0;
    (*(void(__thiscall**)(_DWORD, BOOL))(**(_DWORD**)(this + 468) + 24))(*(_DWORD*)(this + 468), v96);
    sub_421190(*(_DWORD*)(this + 448), "%d", v95);
    v97 = *(_BYTE*)(this + 40) && v95 > 0;
    v98 = *(_DWORD*)(this + 448);
    *(_BYTE*)(v98 + 33) = v97;
    sub_421540((void**)v98);
    return sub_428620((_DWORD*)this, a2);
}
// 4363D7: variable 'v64' is possibly undefined
// 4A9F14: using guessed type char byte_4A9F14;
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;
// 5209D8: using guessed type int dword_5209D8;
// 5209F4: using guessed type int dword_5209F4;

//----- (00436A40) --------------------------------------------------------
int __thiscall sub_436A40(int this, int a2)
{
    _DWORD* v3; // eax
    int v4; // ecx

    *(_DWORD*)(this + 492) = a2;
    if (a2 <= -1)
        v3 = 0;
    else
        v3 = *(_DWORD**)(this + 4 * a2 + 580);
    sub_4131B0(*(_DWORD**)(this + 472), v3);
    v4 = *(_DWORD*)(this + 472);
    if (a2 >= 0)
        return (*(int(__thiscall**)(int, int))(*(_DWORD*)v4 + 24))(v4, 1);
    else
        return (*(int(__thiscall**)(int, _DWORD))(*(_DWORD*)v4 + 24))(v4, 0);
}

//----- (00436A90) --------------------------------------------------------
int __thiscall sub_436A90(int this)
{
    int v2; // ebx
    int v3; // edi
    int* v4; // esi
    int v5; // edx
    int v6; // ecx
    int v7; // ecx
    int v8; // eax
    double v9; // st7
    int v10; // edx
    int* v11; // esi
    _BYTE* v12; // eax
    int v13; // eax
    double v14; // st7
    int v15; // ecx
    _DWORD* v16; // eax
    int v17; // eax
    int v18; // ecx
    void* v19; // ecx
    int v20; // eax
    char* v21; // eax
    int v22; // edi
    int v23; // ecx
    float v25; // [esp+0h] [ebp-30h]
    float v26; // [esp+0h] [ebp-30h]
    float v27; // [esp+4h] [ebp-2Ch]
    float v28; // [esp+4h] [ebp-2Ch]
    float v29; // [esp+8h] [ebp-28h]
    float v30; // [esp+8h] [ebp-28h]
    float v31; // [esp+Ch] [ebp-24h]
    float v32; // [esp+Ch] [ebp-24h]
    int v33; // [esp+20h] [ebp-10h]
    void* v34; // [esp+24h] [ebp-Ch]
    int v35; // [esp+24h] [ebp-Ch]
    int v36; // [esp+28h] [ebp-8h]
    int v37; // [esp+2Ch] [ebp-4h]

    v2 = 0;
    v3 = sub_421B20(*(_DWORD**)(dword_520970 + 132), 1) + 2;
    if (*(int*)(this + 704) > 0)
    {
        v33 = 0;
        do
        {
            v4 = *(int**)(*(_DWORD*)(this + 700) + 4 * v2);
            v5 = v4[1] - v3;
            v4[1] = v5;
            if (v5 > 100)
            {
                v31 = (float)(v3 + v5);
                v29 = (float)(v3 + *v4);
                v27 = (float)v5;
                v25 = (float)*v4;
                sub_413090(v4[4], v25, v27, v29, v31);
                v8 = v4[2];
                v9 = (double)v4[1];
                v10 = v3 + *v4;
                *(_BYTE*)(v8 + 32) = 0;
                ++v2;
                *(float*)(v8 + 12) = (float)v10;
                *(float*)(v8 + 16) = v9;
                *(_DWORD*)(v4[2] + 20) = 1065017672;
                v33 += 0x3FFFFFFF;
            }
            else
            {
                v6 = v4[2];
                v34 = (void*)v6;
                if (v6)
                {
                    sub_4213B0(v6);
                    sub_4885A6(v34);
                }
                sub_437540((_DWORD*)this, v4[4]);
                if (v2 >= *(_DWORD*)(this + 704))
                    break;
                if (*(_BYTE*)(this + 712))
                    sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 700) + 4 * v2));
                v7 = *(_DWORD*)(this + 704) - 1;
                *(_DWORD*)(this + 704) = v7;
                if (v2 != v7)
                {
                    memcpy(
                        (void*)(*(_DWORD*)(this + 700) + 4 * v2),
                        (const void*)(*(_DWORD*)(this + 700) + 4 * v2 + 4),
                        4 * (v7 + v33));
                    *(_DWORD*)(*(_DWORD*)(this + 700) + 4 * *(_DWORD*)(this + 704)) = 0;
                }
            }
        } while (v2 < *(_DWORD*)(this + 704));
    }
    v11 = (int*)operator new(0x14u);
    *v11 = 10;
    v11[1] = dword_5209D8 - 100;
    v12 = sub_421980(*(_DWORD*)(dword_520970 + 132), 1, 0x100u);
    v11[2] = (int)v12;
    v12[35] = 1;
    sub_421430((_DWORD*)v11[2], 1092616192, 1092930765, 255, 0);
    v13 = v11[2];
    v14 = (double)v11[1];
    v15 = v3 + *v11;
    *(_BYTE*)(v13 + 32) = 0;
    *(float*)(v13 + 12) = (float)v15;
    *(float*)(v13 + 16) = v14;
    *(_DWORD*)(v11[2] + 20) = 1065017672;
    v11[3] = 1092930765;
    v16 = sub_437450(this, 1);
    v36 = v11[1];
    v35 = *v11;
    v37 = v3 + *v11;
    v11[4] = (int)v16;
    v32 = (float)(v3 + v36);
    v30 = (float)v37;
    v28 = (float)v36;
    v26 = (float)v35;
    sub_413090((int)v16, v26, v28, v30, v32);
    sub_413240((_DWORD*)v11[4], 1092616192, 1092930765, 255, 0);
    v17 = *(_DWORD*)(this + 708);
    v18 = *(_DWORD*)(this + 704) + 1;
    *(_DWORD*)(this + 704) = v18;
    if (v18 > v17)
    {
        v19 = *(void**)(this + 700);
        v20 = v17 + 8;
        *(_DWORD*)(this + 708) = v20;
        v21 = (char*)sub_488DD7(v19, 4 * v20);
        if (v21)
        {
            v22 = *(_DWORD*)(this + 704);
            v23 = *(_DWORD*)(this + 708) - v22;
            *(_DWORD*)(this + 700) = v21;
            memset(&v21[4 * v22], 0, 4 * v23);
        }
    }
    *(_DWORD*)(*(_DWORD*)(this + 700) + 4 * *(_DWORD*)(this + 704) - 4) = v11;
    return v11[2];
}
// 520970: using guessed type int dword_520970;
// 5209D8: using guessed type int dword_5209D8;

//----- (00436D70) --------------------------------------------------------
int __thiscall sub_436D70(_DWORD* this)
{
    int i; // esi
    int v3; // ecx
    int result; // eax

    for (i = 0; i < 160; i += 16)
    {
        sub_421110(*(_DWORD*)(this[179] + i + 8), AppName);
        *(_DWORD*)(*(_DWORD*)(this[179] + i + 8) + 20) = 1065017672;
        v3 = *(_DWORD*)(this[179] + i + 12);
        result = (*(int(__thiscall**)(int, _DWORD))(*(_DWORD*)v3 + 24))(v3, 0);
    }
    this[180] = 0;
    return result;
}

//----- (00436DD0) --------------------------------------------------------
int __thiscall sub_436DD0(_DWORD* this)
{
    int v2; // eax
    int v4; // ecx

    v2 = this[180];
    if (v2 >= 10)
        return 0;
    v4 = *(_DWORD*)(16 * v2 + this[179] + 12);
    (*(void(__thiscall**)(int, int))(*(_DWORD*)v4 + 24))(v4, 1);
    return *(_DWORD*)(16 * this[180]++ + this[179] + 8);
}

//----- (00436E20) --------------------------------------------------------
_BYTE* __thiscall sub_436E20(char* this)
{
    _BYTE* result; // eax
    int v2; // ecx

    result = this + 56;
    v2 = 4;
    do
    {
        *result = 0;
        result += 52;
        --v2;
    } while (v2);
    return result;
}

//----- (00436E40) --------------------------------------------------------
int __thiscall sub_436E40(char* this, const char* a2)
{
    int v2; // edi
    char* i; // esi
    int result; // eax
    int v5; // ecx
    int v6; // eax
    double v7; // st7
    double v8; // st6

    v2 = 0;
    for (i = this + 48; i[8]; i += 52)
    {
        if (++v2 >= 4)
            return -1;
    }
    v5 = *((_DWORD*)i + 8);
    i[8] = 1;
    sub_421110(v5, a2);
    v6 = *((_DWORD*)i + 8);
    v7 = (double)*((int*)i + 1);
    v8 = (double)(unsigned int)dword_5209F4 - *(float*)(v6 + 24);
    *(_BYTE*)(v6 + 32) = 0;
    *(float*)(v6 + 12) = v8 - 16.0;
    *(float*)(v6 + 16) = v7;
    result = v2;
    *(_DWORD*)(*((_DWORD*)i + 8) + 20) = 1064514355;
    return result;
}
// 5209F4: using guessed type int dword_5209F4;

//----- (00436EC0) --------------------------------------------------------
unsigned int __thiscall sub_436EC0(_DWORD* this, unsigned int a2, int a3, int ArgList)
{
    unsigned int result; // eax
    _DWORD* v5; // esi
    int v6; // eax
    double v7; // st6
    double v8; // st7
    double v9; // st6
    int v10; // [esp-10h] [ebp-1Ch]
    int v11; // [esp+10h] [ebp+4h]
    int v12; // [esp+14h] [ebp+8h]

    result = a2;
    if (a2 < 4)
    {
        v5 = &this[13 * a2 + 12];
        this[13 * a2 + 15] = a3;
        sub_421110(this[13 * a2 + 23], aScore);
        v6 = v5[11];
        v11 = v5[1] + 60;
        v12 = *(int*)(v6 + 28);
        v7 = (double)(unsigned int)dword_5209F4 - *(float*)(v6 + 24);
        *(_BYTE*)(v6 + 32) = 0;
        *(float*)(v6 + 12) = v7;
        *(float*)(v6 + 16) = (float)v11;
        *(_DWORD*)(v5[11] + 20) = 1064514355;
        v10 = v5[12];
        v5[4] = ArgList;
        sub_421190(v10, "%d", ArgList);
        result = v5[12];
        v8 = (double)(v5[1] + 60) + *(float*)&v12;
        v9 = (double)(unsigned int)dword_5209F4 - *(float*)(result + 24);
        *(_BYTE*)(result + 32) = 0;
        *(float*)(result + 12) = v9;
        *(float*)(result + 16) = v8;
        *(_DWORD*)(v5[12] + 20) = 1064514355;
    }
    return result;
}
// 5209F4: using guessed type int dword_5209F4;

//----- (00436FA0) --------------------------------------------------------
int __thiscall sub_436FA0(int this, int a2, float a3)
{
    int v4; // [esp+8h] [ebp+8h]

    *(float*)&v4 = *(float*)&a2 + a3;
    *(float*)(this + 44) = *(float*)&v4;
    return sub_413240(*(_DWORD**)(this + 452), a2, v4, 0, 255);
}

//----- (00436FD0) --------------------------------------------------------
int __thiscall sub_436FD0(int this, int a2, float a3)
{
    int v4; // [esp+8h] [ebp+8h]

    *(float*)&v4 = *(float*)&a2 + a3;
    *(float*)(this + 44) = *(float*)&v4;
    return sub_413240(*(_DWORD**)(this + 452), a2, v4, 255, 0);
}

//----- (00437000) --------------------------------------------------------
BOOL __thiscall sub_437000(float* this)
{
    return this[11] <= 0.0;
}

//----- (00437020) --------------------------------------------------------
void __thiscall sub_437020(float* this, float a2, float a3)
{
    int v3; // edx
    int v4; // esi
    double v5; // st7
    int v6; // esi
    double v7; // st7
    double v8; // st7
    double v9; // st7
    int v10; // [esp+0h] [ebp-10h]
    int v11; // [esp+Ch] [ebp-4h]
    int v12; // [esp+Ch] [ebp-4h]
    int v13; // [esp+14h] [ebp+4h]

    v3 = -1;
    v4 = 0;
    v11 = 0;
    while (1)
    {
        v5 = (double)v11 * 45.0;
        if (v5 - 22.5 < a2 && v5 + 22.5 >= a2)
            break;
        v11 = ++v4;
        if (v4 >= 4)
            goto LABEL_7;
    }
    v3 = v4;
LABEL_7:
    v6 = 5;
    v12 = 5;
    while (v3 == -1)
    {
        v7 = (double)v12 * 45.0 - 360.0;
        if (v7 - 22.5 < a2 && v7 + 22.5 >= a2)
        {
            v3 = v6;
            break;
        }
        v12 = ++v6;
        if (v6 >= 8)
            break;
    }
    if (a2 > -157.5 && a2 < 157.5)
    {
        if (v3 <= -1)
            return;
    }
    else
    {
        v3 = 4;
    }
    v8 = a3;
    if (a3 < 0.25)
    {
        if (v8 <= 0.0099999998)
            v8 = 0.0099999998;
    }
    else
    {
        v8 = 0.25;
    }
    *(float*)&v13 = v8 * 4.0;
    if (this[v3 + 132] <= (double)*(float*)&v13)
        v9 = *(float*)&v13;
    else
        v9 = this[v3 + 132];
    this[v3 + 132] = v9;
    *(float*)&v10 = *(float*)&v13 + 0.2;
    sub_413240((_DWORD*)LODWORD(this[v3 + 124]), v13, v10, 255, 0);
}

//----- (00437180) --------------------------------------------------------
char __thiscall sub_437180(_DWORD* this, int a2, int a3)
{
    return sub_428590(this, a2, a3);
}

//----- (004371A0) --------------------------------------------------------
char __thiscall sub_4371A0(int this, char a2)
{
    char v2; // bl
    char v4; // al
    int v5; // eax
    int v6; // ecx
    const char* v7; // eax
    int v8; // eax
    int v9; // ecx
    char* v10; // edi
    int v11; // ecx
    CHAR* v12; // eax
    int v13; // eax
    int v14; // eax
    int v16; // [esp+Ch] [ebp-104h]
    char Buffer[256]; // [esp+10h] [ebp-100h] BYREF

    v2 = a2;
    LOBYTE(v16) = a2;
    if (isupper(a2))
    {
        v2 = tolower(a2);
        LOBYTE(v16) = v2;
    }
    v4 = *(_BYTE*)(this + 724);
    if (v4)
    {
        if (v2 == 13)
        {
            *(_BYTE*)(dword_520970 + 296) = 0;
            v9 = *(_DWORD*)(this + 736);
            *(_BYTE*)(this + 724) = 0;
            sub_421280(v9);
            v10 = *(char**)(*(_DWORD*)(this + 736) + 8);
            if (*(_BYTE*)(dword_4F5CC4 + 936) || *(_BYTE*)(dword_4F5CC4 + 937))
            {
                sub_463710(*(const char**)(*(_DWORD*)(this + 736) + 8));
            }
            else
            {
                v11 = *(_DWORD*)(dword_520970 + 280);
                v12 = (CHAR*)(v11 + 472);
                if (!*(_BYTE*)(v11 + 472))
                {
                    v13 = *(_DWORD*)(v11 + 512);
                    if (v13 <= -1)
                        v12 = AppName;
                    else
                        v12 = (CHAR*)(352 * v13 + v11 + 899);
                }
                sprintf(Buffer, (const char* const)&dword_4A0090 + 32, v12, *(_DWORD*)(*(_DWORD*)(this + 736) + 8));
                v14 = sub_436A90(this);
                sub_421110(v14, Buffer);
                if (!*(_BYTE*)(dword_4F5CC4 + 936) && !*(_BYTE*)(dword_4F5CC4 + 937))
                    sub_4375C0((void*)this, v10);
            }
            return sub_4285C0((_DWORD*)this, v16);
        }
    }
    else if (v2 == 13)
    {
        if (!*(_BYTE*)(dword_520970 + 296) && !sub_450BB0((_DWORD*)dword_520970))
        {
            *(_BYTE*)(this + 724) = 1;
            v5 = dword_520970;
            if (!*(_BYTE*)(dword_520970 + 296))
            {
                *(_BYTE*)(dword_520970 + 296) = 1;
                v5 = dword_520970;
            }
            v6 = *(_DWORD*)(v5 + 280);
            v7 = (const char*)(v6 + 472);
            if (!*(_BYTE*)(v6 + 472))
            {
                v8 = *(_DWORD*)(v6 + 512);
                if (v8 <= -1)
                    v7 = AppName;
                else
                    v7 = (const char*)(352 * v8 + v6 + 899);
            }
            sub_421190(*(_DWORD*)(this + 732), "%s: ", v7);
            sub_421110(*(_DWORD*)(this + 736), asc_4AA198);
        }
        return sub_4285C0((_DWORD*)this, v16);
    }
    if (v2 == 27)
    {
        *(_BYTE*)(this + 724) = 0;
    }
    else if (v4)
    {
        if (isprint(a2) && strlen(*(const char**)(*(_DWORD*)(this + 736) + 8)) < 0x3C)
        {
            sub_421280(*(_DWORD*)(this + 736));
            sub_4211E0(*(_DWORD*)(this + 736), a2);
            sub_4211E0(*(_DWORD*)(this + 736), 95);
            if (*(float*)(*(_DWORD*)(this + 732) + 24) + *(float*)(*(_DWORD*)(this + 732) + 24) < 512.0)
                return sub_4285C0((_DWORD*)this, v16);
        }
        else if (v2 != 8)
        {
            return sub_4285C0((_DWORD*)this, v16);
        }
        sub_421280(*(_DWORD*)(this + 736));
        sub_421280(*(_DWORD*)(this + 736));
        sub_4211E0(*(_DWORD*)(this + 736), 95);
    }
    return sub_4285C0((_DWORD*)this, v16);
}
// 437293: conditional instruction was optimized away because al.1==0
// 43743B: variable 'v16' is possibly undefined
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (00437450) --------------------------------------------------------
_DWORD* __thiscall sub_437450(int this, char a2)
{
    int v3; // eax
    int v4; // eax
    _DWORD* v5; // esi
    _DWORD* v6; // eax

    v3 = *(_DWORD*)(this + 28);
    if (v3 <= 0)
    {
        v6 = operator new(0x80u);
        if (v6)
            v5 = sub_412AB0(v6);
        else
            v5 = 0;
        *((_BYTE*)v5 + 104) = 1;
        sub_413120((int)v5, 1065017672);
        sub_4131B0(v5, *(_DWORD**)(this + 20));
        if (a2)
            sub_413130((int)v5, 1056964608, 0, 1065353216, 1056964608);
        else
            sub_413130((int)v5, 0, 0, 1056964608, 1056964608);
        sub_428680((_DWORD*)this, (int)v5);
    }
    else
    {
        v4 = v3 - 1;
        v5 = *(_DWORD**)(*(_DWORD*)(this + 24) + 4 * v4);
        *(_DWORD*)(this + 28) = v4;
        (*(void(__thiscall**)(_DWORD*, int))(*v5 + 24))(v5, 1);
    }
    return v5;
}

//----- (00437540) --------------------------------------------------------
int __thiscall sub_437540(_DWORD* this, int a2)
{
    int v3; // eax
    int v4; // ecx
    void* v5; // edx
    int v6; // eax
    char* v7; // eax
    int v8; // edi
    int v9; // ecx
    int result; // eax

    (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)a2 + 24))(a2, 0);
    v3 = this[8];
    v4 = this[7] + 1;
    this[7] = v4;
    if (v4 > v3)
    {
        v5 = (void*)this[6];
        v6 = v3 + 8;
        this[8] = v6;
        v7 = (char*)sub_488DD7(v5, 4 * v6);
        if (v7)
        {
            v8 = this[7];
            v9 = this[8] - v8;
            this[6] = v7;
            memset(&v7[4 * v8], 0, 4 * v9);
        }
    }
    result = this[7];
    *(_DWORD*)(this[6] + 4 * result - 4) = a2;
    return result;
}

//----- (004375C0) --------------------------------------------------------
char __thiscall sub_4375C0(void* this, char* String1)
{
    int v3; // eax
    int v4; // eax

    if (!_strcmpi(String1, aEatYourSpinach))
    {
        *(_BYTE*)(*(_DWORD*)(dword_520970 + 280) + 2552) = *(_BYTE*)(*(_DWORD*)(dword_520970 + 280) + 2552) == 0;
    LABEL_5:
        v4 = sub_436A90((int)this);
        LOBYTE(v3) = sub_421110(v4, aCheatCodeEnabl);
        return v3;
    }
    v3 = _strcmpi(String1, aSayUncle);
    if (!v3)
    {
        LOBYTE(v3) = sub_45B4E0(*(int**)(dword_520970 + 236), (int)this);
        if ((_BYTE)v3)
            goto LABEL_5;
    }
    return v3;
}
// 520970: using guessed type int dword_520970;

//----- (004376B0) --------------------------------------------------------
_DWORD* __thiscall sub_4376B0(_DWORD* this, int a2)
{
    int v3; // ebx
    int v4; // ecx
    _DWORD* v5; // eax
    _DWORD* v6; // eax
    _DWORD* v7; // eax
    const char** v8; // edi
    float* v9; // esi
    int v10; // eax
    int v12; // [esp-8h] [ebp-B8h]
    float v13; // [esp+0h] [ebp-B0h]
    int v14; // [esp+14h] [ebp-9Ch]
    int v15; // [esp+18h] [ebp-98h]
    float v16[17]; // [esp+1Ch] [ebp-94h] BYREF
    float v17; // [esp+60h] [ebp-50h] BYREF
    char Buffer[64]; // [esp+64h] [ebp-4Ch] BYREF
    int v19; // [esp+ACh] [ebp-4h]

    LODWORD(v16[16]) = this;
    sub_403B10(this);
    v3 = 0;
    v19 = 0;
    v4 = 13;
    v5 = this + 176;
    do
    {
        *(v5 - 2) = 0;
        *(v5 - 1) = 0;
        *v5 = 0;
        v5 += 35;
        --v4;
    } while (v4);
    *this = &off_499508;
    this[148] = a2;
    sub_403D90((char*)this, aMapMapworksPf3);
    sub_403E30((int)this, (int)this);
    v6 = operator new(0x15Cu);
    LOBYTE(v19) = 1;
    if (v6)
        v7 = sub_41C6A0(v6);
    else
        v7 = 0;
    LOBYTE(v19) = 0;
    this[609] = v7;
    sub_41C760((int)v7, aSoundsWarmapEx);
    sub_41CA40(this[609]);
    v13 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
    sub_41CFD0(this[609], v13);
    memset(this + 149, 0, 0x71Cu);
    v15 = 0;
    v14 = 0;
    v8 = (const char**)off_4AA5F0;
    v9 = (float*)(this + 169);
    do
    {
        for (*v9 = 0.0; ; ++*(_DWORD*)v9)
        {
            sprintf(Buffer, "%s %03d", *v8, *(_DWORD*)v9);
            v10 = sub_405A30(this, Buffer, -1, 1);
            if (v10 < 0)
                break;
            this[v3 + 149 + *(_DWORD*)v9] = v10;
        }
        if ((int)v8 < (int)&off_4AA620)
        {
            sprintf(Buffer, "Allied Flag%02d", v15 + 1);
            *((_DWORD*)v9 + 1) = sub_405A30(this, Buffer, -1, 1);
            sprintf(Buffer, "Enemy Flag%02d", v15 + 1);
            *((_DWORD*)v9 + 2) = sub_405A30(this, Buffer, -1, 1);
            v12 = *((_DWORD*)v9 + 1);
            memset(&v16[11], 0, 16);
            memset(&v16[6], 0, 16);
            memset(&v16[1], 0, 16);
            v16[15] = 1.0;
            v16[10] = 1.0;
            v16[5] = 1.0;
            v16[0] = 1.0;
            sub_404F60(this, v12, v16, &v17);
            sub_46C5C5(v9 + 5, v9 + 5, v16);
            v3 = v14;
        }
        v9[10] = 1.0;
        v9[9] = 1.0;
        v9[8] = 1.0;
        ++v8;
        v3 += 35;
        v9 += 35;
        ++v15;
        v14 = v3;
    } while ((int)v8 < (int)&dword_4AA624);
    this[604] = sub_413830(*(_DWORD**)(dword_520970 + 116), aMapblasthalo);
    this[605] = sub_413830(*(_DWORD**)(dword_520970 + 116), aMapexplode);
    this[606] = sub_413830(*(_DWORD**)(dword_520970 + 116), aMapexplodespar);
    this[607] = sub_413830(*(_DWORD**)(dword_520970 + 116), aMapshellexplod);
    this[608] = sub_413830(*(_DWORD**)(dword_520970 + 116), aMapshellexplod_0);
    return this;
}
// 499508: using guessed type int (__stdcall *off_499508)(int, int, int);
// 4AA5F0: using guessed type char *off_4AA5F0[13];
// 4AA620: using guessed type char *off_4AA620;
// 4AA624: using guessed type const char *dword_4AA624;
// 520970: using guessed type int dword_520970;

//----- (004379D0) --------------------------------------------------------
int __thiscall sub_4379D0(int* this, int a2, int a3, int a4)
{
    int v5; // eax
    int v6; // ebp
    int v7; // ecx
    int* v8; // esi
    int i; // ebx
    int v10; // edx
    int v11; // ecx
    int result; // eax
    _DWORD v13[17]; // [esp+10h] [ebp-44h] BYREF
    int v14; // [esp+60h] [ebp+Ch]

    sub_405C40(a2, a3, a4);
    v5 = this[2];
    v6 = 0;
    if (v5 > 0)
    {
        v7 = this[1];
        do
        {
            if (a2 == v7)
                break;
            ++v6;
            v7 += 172;
        } while (v6 < v5);
    }
    v8 = this + 169;
    v14 = 13;
    do
    {
        for (i = 1; i < *v8; ++i)
        {
            if (v8[i - 20] == v6)
            {
                v10 = v8[8];
                memset(v13, 0, sizeof(v13));
                v11 = v8[10];
                v13[5] = v8[9];
                v13[1] = v13[5];
                v13[6] = v11;
                v13[2] = v11;
                v13[4] = v10;
                v13[7] = 1065353216;
                v13[0] = v10;
                v13[3] = 1065353216;
                (*(void(__stdcall**)(_DWORD, _DWORD*))(**(_DWORD**)ArgList + 168))(*(_DWORD*)ArgList, v13);
            }
        }
        v8 += 35;
        result = --v14;
    } while (v14);
    return result;
}

//----- (00437AA0) --------------------------------------------------------
char* __thiscall sub_437AA0(char* this, int a2, int a3)
{
    char* result; // eax

    result = &this[140 * a2 + 596];
    *((_DWORD*)result + 31) = 6;
    *((_DWORD*)result + 32) = a3;
    *((_DWORD*)result + 33) = 0;
    *((_DWORD*)result + 34) = 1058642330;
    return result;
}

//----- (00437AE0) --------------------------------------------------------
_DWORD* __thiscall sub_437AE0(_DWORD* this)
{
    _DWORD* result; // eax
    int v2; // ecx

    result = this + 182;
    v2 = 12;
    do
    {
        *(result - 2) = 8;
        *result = 0;
        *(result - 1) = 1050253722;
        result[1] = 1058642330;
        result += 35;
        --v2;
    } while (v2);
    return result;
}

//----- (00437B10) --------------------------------------------------------
_DWORD* __thiscall sub_437B10(_DWORD* this)
{
    _DWORD* result; // eax
    int v2; // ecx

    result = this + 182;
    v2 = 12;
    do
    {
        *(result - 2) = 5;
        *result = 0;
        *(result - 1) = 0;
        result[1] = 1065353216;
        result += 35;
        --v2;
    } while (v2);
    return result;
}

//----- (00437B40) --------------------------------------------------------
int __thiscall sub_437B40(_DWORD* this)
{
    int result; // eax

    result = 0;
    this[600] = 9;
    this[602] = 0;
    this[601] = 0;
    this[603] = 1065353216;
    return result;
}

//----- (00437B70) --------------------------------------------------------
void __userpurge sub_437B70(int a1@<ecx>, int a2@<ebp>, float a3)
{
    int v4; // ecx
    int v5; // esi
    float* v6; // ebp
    double v7; // st7
    int v8; // eax
    double v10; // st7
    char v11; // c0
    double v12; // st7
    _DWORD* v13; // eax
    _BYTE* v14; // eax
    bool v15; // zf
    _DWORD* v16; // eax
    _BYTE* v17; // eax
    int* v18; // ecx
    int v19; // edx
    _DWORD* v20; // eax
    float v21; // [esp+0h] [ebp-B0h]
    float v22; // [esp+0h] [ebp-B0h]
    float v23; // [esp+8h] [ebp-A8h]
    int v24; // [esp+8h] [ebp-A8h]
    int v25; // [esp+8h] [ebp-A8h]
    float v26; // [esp+1Ch] [ebp-94h]
    float v27; // [esp+1Ch] [ebp-94h]
    int v28; // [esp+1Ch] [ebp-94h]
    int* v29; // [esp+1Ch] [ebp-94h]
    int v30; // [esp+1Ch] [ebp-94h]
    int* v31; // [esp+1Ch] [ebp-94h]
    int v32; // [esp+20h] [ebp-90h]
    int v33; // [esp+20h] [ebp-90h]
    int v34; // [esp+20h] [ebp-90h]
    int v35; // [esp+20h] [ebp-90h]
    int v36; // [esp+20h] [ebp-90h]
    int v37; // [esp+20h] [ebp-90h]
    int v38; // [esp+24h] [ebp-8Ch]
    float v39; // [esp+28h] [ebp-88h]
    float v40; // [esp+2Ch] [ebp-84h]
    _DWORD v41[16]; // [esp+30h] [ebp-80h] BYREF
    _DWORD v42[16]; // [esp+70h] [ebp-40h] BYREF

    v4 = *(_DWORD*)(a1 + 2436);
    if (v4)
    {
        sub_41D0C0(v4, a2, a3);
        v23 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
        sub_41CFD0(*(_DWORD*)(a1 + 2436), v23);
    }
    v5 = 0;
    v38 = 0;
    v6 = (float*)(a1 + 728);
    v40 = (sin(*(float*)(dword_520970 + 72)) + 1.0) * 0.5;
    do
    {
        v39 = *v6;
        if (*(v6 - 1) <= 0.0)
        {
            if (v6[1] != 0.0)
            {
                v27 = a3 / v6[1] + *v6;
                *v6 = v27;
                if (v27 >= 1.0)
                    v7 = 1.0;
                else
                    v7 = v27;
                *v6 = v7;
            }
        }
        else
        {
            v26 = *(v6 - 1) - a3;
            *(v6 - 1) = v26;
            *v6 = 0.0;
            if (v26 >= 0.0)
                *(v6 - 1) = v26;
            else
                *(v6 - 1) = 0.0;
        }
        v8 = *((_DWORD*)v6 - 2);
        switch (v8)
        {
        case 5:
            v10 = *v6;
            if (v11)
            {
                v12 = v10 * 10.0;
            }
            else
            {
                if (v10 < 0.69999999)
                {
                LABEL_21:
                    v12 = 1.0;
                    goto LABEL_24;
                }
                if (*v6 < 0.69999999 || *v6 > 1.0)
                    goto LABEL_23;
                v12 = 1.0 - (*v6 - 0.69999999) * 3.3333333;
            }
            if (v12 >= 1.0)
                goto LABEL_21;
            if (v12 > 0.0)
            {
            LABEL_24:
                *(float*)&v32 = 1.0 - v12;
                sub_438430((char*)a1, v5, 1065353216, v32, v32);
                if (*(_DWORD*)v6 == 1065353216)
                {
                    *((_DWORD*)v6 - 2) = 1;
                    *v6 = 0.0;
                    *(v6 - 1) = 0.0;
                    v6[1] = 1.0;
                }
                break;
            }
        LABEL_23:
            v12 = 0.0;
            goto LABEL_24;
        case 6:
            sub_438460((_DWORD**)a1, v5, *v6, 0.0, 0.0);
            *(float*)&v28 = 1.0 - *v6;
            sub_438430((char*)a1, v5, 1065353216, v28, v28);
            if (*(_DWORD*)v6 == 1065353216)
            {
                *((_DWORD*)v6 - 2) = 7;
                *v6 = 0.0;
                *(v6 - 1) = 0.0;
                v6[1] = 0.60000002;
                v29 = (int*)(a1 + 2416);
                v33 = 5;
                do
                {
                    v13 = sub_413870(*(_DWORD**)(dword_520970 + 116), *v29);
                    if (v13)
                    {
                        v14 = v13 + 29;
                        memset(&v41[11], 0, 16);
                        memset(&v41[6], 0, 16);
                        memset(&v41[1], 0, 16);
                        v41[15] = 1065353216;
                        v41[10] = 1065353216;
                        v41[5] = 1065353216;
                        v41[0] = 1065353216;
                        qmemcpy(v14, v41, 0x40u);
                        *(float*)&v24 = *(v6 - 6) + 19.0;
                        sub_40E880(v14, *((_DWORD*)v6 - 8), *((_DWORD*)v6 - 7), v24);
                        v5 = v38;
                    }
                    v15 = v33 == 1;
                    ++v29;
                    --v33;
                } while (!v15);
                sub_41CF50(*(_DWORD*)(a1 + 2436));
                sub_41CF00(*(_DWORD*)(a1 + 2436));
                sub_41CD90(*(_DWORD*)(a1 + 2436));
            }
            break;
        case 7:
            sub_438460((_DWORD**)a1, v5, 1.0, 0.0, *v6);
        LABEL_35:
            sub_438430((char*)a1, v5, 1065353216, 0, 0);
            break;
        case 8:
            v21 = 1.0 - *v6;
            sub_438460((_DWORD**)a1, v5, v21, 0.0, 1.0);
            sub_438430((char*)a1, v5, 1065353216, 0, 0);
            if (*(_DWORD*)v6 == 1065353216)
            {
                *((_DWORD*)v6 - 2) = 3;
                *v6 = 0.0;
                *(v6 - 1) = 0.0;
                v6[1] = 1.0;
            }
            break;
        case 9:
            *(float*)&v30 = 1.0 - *v6;
            sub_438430((char*)a1, v5, 1065353216, v30, v30);
            if (*(_DWORD*)v6 == 1065353216)
            {
                *(v6 - 2) = 0.0;
                *v6 = 0.0;
                *(v6 - 1) = 0.0;
                v6[1] = 1.0;
            }
            break;
        case 2:
            sub_438460((_DWORD**)a1, v5, 0.0, 1.0, 0.0);
            sub_438430((char*)a1, v5, 1065353216, 1065353216, 1065353216);
            break;
        case 3:
            sub_438460((_DWORD**)a1, v5, 0.0, 0.0, 1.0);
            goto LABEL_35;
        case 4:
            sub_438460((_DWORD**)a1, v5, 1.0, 0.0, 1.0);
            *(float*)&v34 = (sin(v40 * 3.1415927) + 1.0) * 0.5;
            sub_438430((char*)a1, v5, 1065353216, v34, v34);
            if (*(_DWORD*)v6 == 1065353216)
            {
                *((_DWORD*)v6 - 2) = 10;
                *v6 = 0.0;
                *(v6 - 1) = 0.0;
                v6[1] = 1.0;
            }
            break;
        case 10:
            *(float*)&v35 = (1.0 - *v6) * ((sin(v40 * 3.1415927) + 1.0) * 0.5) + *v6;
            v22 = 1.0 - *v6;
            sub_438460((_DWORD**)a1, v5, v22, 0.0, 1.0);
            sub_438430((char*)a1, v5, 1065353216, v35, v35);
            if (*(_DWORD*)v6 == 1065353216)
            {
                *((_DWORD*)v6 - 2) = 11;
                *v6 = 0.0;
                *(v6 - 1) = 0.2;
                v6[1] = 1.0;
            }
            break;
        case 11:
            if (*v6 == 0.0)
                sub_438460((_DWORD**)a1, v5, 0.0, 0.0, 1.0);
            else
                sub_438460((_DWORD**)a1, v5, 0.0, *v6, 0.0);
            if (v39 == 0.0 && *v6 > 0.0)
            {
                v36 = 5;
                v31 = (int*)(a1 + 2416);
                do
                {
                    v16 = sub_413870(*(_DWORD**)(dword_520970 + 116), *v31);
                    if (v16)
                    {
                        v17 = v16 + 29;
                        memset(&v42[11], 0, 16);
                        memset(&v42[6], 0, 16);
                        memset(&v42[1], 0, 16);
                        v42[15] = 1065353216;
                        v42[10] = 1065353216;
                        v42[5] = 1065353216;
                        v42[0] = 1065353216;
                        qmemcpy(v17, v42, 0x40u);
                        *(float*)&v25 = *(v6 - 6) + 19.0;
                        sub_40E880(v17, *((_DWORD*)v6 - 8), *((_DWORD*)v6 - 7), v25);
                        v5 = v38;
                    }
                    v15 = v36 == 1;
                    ++v31;
                    --v36;
                } while (!v15);
                sub_41CF50(*(_DWORD*)(a1 + 2436));
                sub_41CF00(*(_DWORD*)(a1 + 2436));
                sub_41CD90(*(_DWORD*)(a1 + 2436));
            }
            if (*(_DWORD*)v6 == 1065353216 && v39 < 1.0)
            {
                v18 = *(int**)(a1 + 592);
                v19 = v18[99];
                if (v19 + 1 < 12)
                {
                    v20 = (_DWORD*)(a1 + 140 * v19 + 736);
                    v20[31] = 13;
                    v20[33] = 0;
                    v20[32] = 0x40000000;
                    v20[34] = 1065353216;
                    sub_43A120(*(_DWORD*)(a1 + 592), *(_DWORD*)(*(_DWORD*)(a1 + 592) + 396) + 1);
                    sub_4030B0(*(_DWORD**)(*(_DWORD*)(a1 + 592) + 468), 0, aCommandertakeb_0, -1);
                    sub_4030B0(
                        *(_DWORD**)(*(_DWORD*)(a1 + 592) + 468),
                        0,
                        aCommanderprovi_0,
                        *(_DWORD*)(*(_DWORD*)(a1 + 592) + 396) + 1);
                }
                else
                {
                    sub_438D00(v18);
                }
            }
            break;
        case 13:
            *(float*)&v37 = *v6 * ((sin(v40 * 3.1415927) + 1.0) * 0.5);
            sub_438460((_DWORD**)a1, v5, *v6, 0.0, 1.0);
            sub_438430((char*)a1, v5, 1065353216, v37, v37);
            if (*(_DWORD*)v6 == 1065353216 && v39 < 1.0)
                *(_BYTE*)(*(_DWORD*)(a1 + 592) + 432) = 1;
            break;
        }
        ++v5;
        v6 += 35;
        v38 = v5;
    } while (v5 < 13);
}
// 437C97: variable 'v11' is possibly undefined
// 520970: using guessed type int dword_520970;

//----- (004383D0) --------------------------------------------------------
_DWORD* __thiscall sub_4383D0(_DWORD** this, int a2)
{
    _DWORD* result; // eax

    result = &this[35 * a2 + 149];
    result[24] = 0;
    result[23] = 0;
    result[30] = 1065353216;
    result[29] = 1065353216;
    result[28] = 1065353216;
    result[31] = 0;
    result[33] = 0;
    result[32] = 0;
    result[34] = 1065353216;
    if (a2 < 12)
        return (_DWORD*)sub_438460(this, a2, 0.0, 0.0, 0.0);
    return result;
}

//----- (00438430) --------------------------------------------------------
char* __thiscall sub_438430(char* this, int a2, int a3, int a4, int a5)
{
    char* result; // eax

    result = &this[140 * a2 + 596];
    *((_DWORD*)result + 28) = a3;
    *((_DWORD*)result + 29) = a4;
    *((_DWORD*)result + 30) = a5;
    return result;
}

//----- (00438460) --------------------------------------------------------
int __thiscall sub_438460(_DWORD** this, int a2, float a3, float a4, float a5)
{
    int v6; // ebp
    int* v7; // ebx
    int v9; // [esp+0h] [ebp-10h]
    int v10; // [esp+0h] [ebp-10h]
    int v11; // [esp+18h] [ebp+8h]

    v6 = 0;
    *(float*)&v11 = a3 * 19.0;
    if ((int)this[35 * a2 + 169] > 0)
    {
        v7 = (int*)&this[35 * a2 + 149];
        do
        {
            sub_4074B0(this[147], *v7);
            sub_407600(this[147], *v7, 0, 0, v11);
            ++v6;
            ++v7;
        } while (v6 < (int)this[35 * a2 + 169]);
    }
    sub_4074B0(this[147], (int)this[35 * a2 + 170]);
    if (a4 == 0.0)
    {
        sub_408640(this[147], (int)this[35 * a2 + 170], 0);
    }
    else
    {
        sub_408640(this[147], (int)this[35 * a2 + 170], 1);
        *(float*)&v9 = *(float*)&v11 - 110.0 + 110.0 * a4;
        sub_407600(this[147], (int)this[35 * a2 + 170], 0, 0, v9);
    }
    sub_4074B0(this[147], (int)this[35 * a2 + 171]);
    if (a5 == 0.0)
        return sub_408640(this[147], (int)this[35 * a2 + 171], 0);
    sub_408640(this[147], (int)this[35 * a2 + 171], 1);
    *(float*)&v10 = *(float*)&v11 - 110.0 + 110.0 * a5;
    return sub_407600(this[147], (int)this[35 * a2 + 171], 0, 0, v10);
}

//----- (004385C0) --------------------------------------------------------
_DWORD* __thiscall sub_4385C0(_DWORD* this)
{
    _DWORD* v2; // eax
    _DWORD* v3; // eax
    float v5; // [esp+0h] [ebp-20h]

    sub_401270((int)this);
    this[101] = 0;
    this[102] = 0;
    this[122] = 0;
    this[123] = 0;
    this[124] = 0;
    *((_BYTE*)this + 500) = 1;
    *this = &off_49951C;
    this[98] = 0;
    this[99] = 0;
    this[100] = 0;
    this[103] = 0;
    v2 = operator new(0x15Cu);
    if (v2)
        v3 = sub_41C6A0(v2);
    else
        v3 = 0;
    this[104] = v3;
    sub_41C7A0((int)v3, 1);
    sub_41C760(this[104], aSoundsDialogue_0);
    sub_41CA40(this[104]);
    v5 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
    sub_41CFD0(this[104], v5);
    this[107] = -1;
    this[118] = -1;
    this[109] = 0;
    this[110] = 0;
    this[111] = 0;
    this[112] = 0;
    this[113] = 0;
    this[114] = 0;
    this[115] = 0;
    this[117] = 0;
    this[116] = 0;
    this[7] = 1061459977;
    return this;
}
// 49951C: using guessed type _UNKNOWN *off_49951C;

//----- (00438730) --------------------------------------------------------
int __thiscall sub_438730(int this)
{
    _DWORD* v2; // ecx
    void* v3; // edi
    void* v4; // edi
    int i; // edi
    void* v6; // eax

    *(_DWORD*)this = &off_49951C;
    v2 = *(_DWORD**)(this + 404);
    if (v2)
    {
        sub_403B70(v2);
        *(_DWORD*)(this + 404) = 0;
    }
    v3 = *(void**)(this + 412);
    if (v3)
    {
        sub_41C700(*(_DWORD*)(this + 412));
        sub_4885A6(v3);
    }
    v4 = *(void**)(this + 416);
    if (v4)
    {
        sub_41C700(*(_DWORD*)(this + 416));
        sub_4885A6(v4);
    }
    if (*(_BYTE*)(this + 500))
    {
        for (i = 0; i < *(_DWORD*)(this + 492); ++i)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 488) + 4 * i));
    }
    memset(*(void**)(this + 488), 0, 4 * *(_DWORD*)(this + 492));
    v6 = *(void**)(this + 488);
    *(_DWORD*)(this + 492) = 0;
    sub_488CEE(v6);
    *(_DWORD*)(this + 496) = 0;
    *(_DWORD*)(this + 488) = 0;
    return sub_4013F0((_DWORD*)this);
}
// 49951C: using guessed type _UNKNOWN *off_49951C;

//----- (00438840) --------------------------------------------------------
BOOL __thiscall sub_438840(_DWORD* this)
{
    _DWORD* v2; // eax
    _DWORD* v3; // eax
    int v4; // eax
    _DWORD* v5; // ecx
    int v6; // eax
    _DWORD* v7; // ecx
    int v8; // eax
    _DWORD* v9; // ecx
    _DWORD* v10; // eax
    int v11; // edx

    if (!this[101])
    {
        v2 = operator new(0x988u);
        if (v2)
            v3 = sub_4376B0(v2, (int)this);
        else
            v3 = 0;
        this[101] = v3;
        sub_4282E0(v3 != 0, aCanTLoadWorldM);
        v4 = sub_405A30((_DWORD*)this[101], aIntrocamera, -1, 1);
        v5 = (_DWORD*)this[101];
        this[107] = v4;
        v6 = sub_405A30(v5, aCameratrack, -1, 1);
        v7 = (_DWORD*)this[101];
        this[118] = v6;
        v8 = sub_405A30(v7, aPlayeremblem, -1, 1);
        v9 = (_DWORD*)this[101];
        this[119] = v8;
        this[120] = sub_405A30(v9, aEnemyInsignia, -1, 1);
    }
    if (!this[102])
    {
        v10 = sub_406A90(this[101], 0);
        v11 = this[101];
        this[102] = v10;
        *(_DWORD*)(v11 + 588) = v10;
        (*(void(__thiscall**)(_DWORD, _DWORD))(*(_DWORD*)this[102] + 24))(this[102], 0);
        sub_428680(this, this[102]);
    }
    return this[101] && this[102];
}

//----- (004389A0) --------------------------------------------------------
void __thiscall sub_4389A0(_DWORD* this)
{
    void(__thiscall * **v2)(_DWORD, int); // ecx
    _DWORD* v3; // ecx

    if (this[102])
    {
        sub_4286C0(this, this[102]);
        v2 = (void(__thiscall***)(_DWORD, int))this[102];
        if (v2)
            (**v2)(v2, 1);
        this[102] = 0;
    }
    v3 = (_DWORD*)this[101];
    if (v3)
    {
        sub_403B70(v3);
        this[101] = 0;
    }
}

//----- (004389F0) --------------------------------------------------------
void __thiscall sub_4389F0(int this, char a2)
{
    int v3; // ecx
    void* v4; // edi
    int v5; // ecx

    *(_BYTE*)(this + 16) = a2;
    if (a2)
    {
        dword_4A4DD0 = dword_4AA1E0;
        dword_4A4DD4 = dword_4AA1E4;
    }
    else
    {
        v3 = *(_DWORD*)(this + 412);
        if (v3)
        {
            sub_41CF50(v3);
            v4 = *(void**)(this + 412);
            if (v4)
            {
                sub_41C700(*(_DWORD*)(this + 412));
                sub_4885A6(v4);
            }
            *(_DWORD*)(this + 412) = 0;
        }
        v5 = *(_DWORD*)(this + 416);
        if (v5)
            sub_41CF50(v5);
        sub_4389A0((_DWORD*)this);
    }
}
// 4A4DD0: using guessed type int dword_4A4DD0;
// 4A4DD4: using guessed type int dword_4A4DD4;
// 4AA1E0: using guessed type int dword_4AA1E0;
// 4AA1E4: using guessed type int dword_4AA1E4;

//----- (00438A70) --------------------------------------------------------
char __thiscall sub_438A70(int this)
{
    _DWORD* v2; // eax
    char* v3; // ecx
    int i; // edi
    int v5; // eax

    v2 = *(_DWORD**)(this + 408);
    *(_DWORD*)(this + 396) = -1;
    *(_DWORD*)(this + 424) = 0;
    v2[8] = *(_DWORD*)(*(_DWORD*)(v2[7] + 44) + 4 * v2[11]);
    *(_DWORD*)(*(_DWORD*)(this + 408) + 36) = 1065353216;
    *(_BYTE*)(*(_DWORD*)(this + 408) + 48) = 0;
    if (*(int*)(this + 428) > -1)
        sub_408EF0(dword_520970, this);
    sub_41CF50(*(_DWORD*)(this + 416));
    sub_41CF00(*(_DWORD*)(this + 416));
    v3 = *(char**)(this + 404);
    *(_BYTE*)(this + 421) = 0;
    *(_BYTE*)(this + 420) = 0;
    sub_438430(v3, 12, 1065353216, 1065353216, 1065353216);
    for (i = 0; i < 13; ++i)
        sub_4383D0(*(_DWORD***)(this + 404), i);
    v5 = sub_450BF0((_DWORD*)dword_520970, 1, 1082130432);
    return sub_421110(v5, aDecember1941Op);
}
// 520970: using guessed type int dword_520970;

//----- (00438B40) --------------------------------------------------------
char* __thiscall sub_438B40(int this)
{
    _DWORD* v2; // eax
    _DWORD* v3; // eax
    int v4; // edi
    int v5; // ecx
    _DWORD* v6; // eax
    int v7; // edx
    char* v8; // eax
    float v10; // [esp+0h] [ebp-20h]

    v2 = operator new(0x15Cu);
    if (v2)
        v3 = sub_41C6A0(v2);
    else
        v3 = 0;
    *(_DWORD*)(this + 412) = v3;
    sub_41C7A0((int)v3, 1);
    if (*(_DWORD*)(this + 396) == 11)
    {
        sub_41C760(*(_DWORD*)(this + 412), aSoundsCelebrat);
        **(_BYTE**)(this + 412) = 0;
    }
    else
    {
        sub_41C760(*(_DWORD*)(this + 412), aSoundsWarmapLo);
        **(_BYTE**)(this + 412) = 1;
    }
    sub_41CA40(*(_DWORD*)(this + 412));
    v10 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
    sub_41CFD0(*(_DWORD*)(this + 412), v10);
    sub_41CD90(*(_DWORD*)(this + 412));
    if (*(int*)(this + 472) > -1)
        sub_408EF0(dword_520970, this);
    v4 = 0;
    v5 = 0;
    do
    {
        v6 = (_DWORD*)(v5 + *(_DWORD*)(this + 404) + 596);
        v7 = *(_DWORD*)(this + 396);
        if (v4 >= v7)
        {
            if (v4 == v7)
                *(_DWORD*)(v5 + *(_DWORD*)(this + 404) + 720) = 4;
            else
                *(_DWORD*)(v5 + *(_DWORD*)(this + 404) + 720) = 3;
        }
        else
        {
            *(_DWORD*)(v5 + *(_DWORD*)(this + 404) + 720) = 2;
        }
        v5 += 140;
        ++v4;
        v6[33] = 0;
        v6[32] = 0;
        v6[34] = 1084227584;
    } while (v5 < 1680);
    sub_43A120(this, *(_DWORD*)(this + 396));
    v8 = sub_403620((_DWORD*)dword_4B5AB0, aCommander);
    *(_DWORD*)(this + 468) = v8;
    sub_402FC0((int)v8);
    sub_4030B0(*(_DWORD**)(this + 468), 0, aCommandertakeb, -1);
    sub_4030B0(*(_DWORD**)(this + 468), 0, aCommanderprovi, *(_DWORD*)(this + 396));
    return sub_438430(*(char**)(this + 404), 12, 1065353216, 0, 0);
}
// 4B5AB0: using guessed type int dword_4B5AB0;
// 520970: using guessed type int dword_520970;

//----- (00438D00) --------------------------------------------------------
int __thiscall sub_438D00(int* this)
{
    _DWORD* v2; // eax
    _DWORD* v3; // eax
    float v5; // [esp+0h] [ebp-18h]

    this[121] = 7;
    v2 = operator new(0x15Cu);
    if (v2)
        v3 = sub_41C6A0(v2);
    else
        v3 = 0;
    this[104] = (int)v3;
    sub_41C7A0((int)v3, 1);
    sub_41C760(this[104], aSoundsDialogue);
    sub_41C7E0((_BYTE*)this[104], 1);
    v5 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
    return sub_41CFD0(this[104], v5);
}

//----- (00438DC0) --------------------------------------------------------
char __thiscall sub_438DC0(int* this)
{
    char** v2; // ebx
    int* v3; // ebp
    _BYTE* v4; // eax
    double v5; // st7
    int v6; // eax
    int v7; // edx
    int v8; // eax
    int v9; // ecx
    int v10; // eax
    void* v11; // ecx
    int v12; // eax
    char* v13; // eax
    int v14; // edi
    int v15; // ecx
    char* v16; // eax
    _DWORD* v17; // eax
    _DWORD* v18; // eax
    char result; // al
    float v20; // [esp+0h] [ebp-30h]
    int v21; // [esp+10h] [ebp-20h]
    int v22; // [esp+18h] [ebp-18h]

    v2 = &off_4AA1E8;
    v22 = sub_421B20(*(_DWORD**)(dword_520970 + 132), 1);
    v21 = (__int64)((double)(unsigned int)dword_5209D8 + 20.0);
    if (off_4AA1E8)
    {
        do
        {
            if (**v2)
            {
                v3 = (int*)operator new(8u);
                v4 = sub_409AD0((int*)dword_520970, 1, 1u);
                *v3 = (int)v4;
                sub_421110((int)v4, *v2);
                *(_DWORD*)(*v3 + 20) = 1092616192;
                sub_421300(*v3, 0xFFu, 0xFFu, 0xFFu, 255);
                v5 = (double)v21;
                v6 = *v3;
                *((float*)v3 + 1) = v5;
                v7 = dword_5209F4;
                *(_BYTE*)(v6 + 32) = 1;
                *(float*)(v6 + 12) = (double)(unsigned int)v7 * 0.5;
                *(float*)(v6 + 16) = v5;
                v8 = this[123] + 1;
                this[123] = v8;
                v9 = v8;
                v10 = this[124];
                if (v9 > v10)
                {
                    v11 = (void*)this[122];
                    v12 = v10 + 8;
                    this[124] = v12;
                    v13 = (char*)sub_488DD7(v11, 4 * v12);
                    if (v13)
                    {
                        v14 = this[123];
                        v15 = this[124] - v14;
                        this[122] = (int)v13;
                        memset(&v13[4 * v14], 0, 4 * v15);
                    }
                }
                *(_DWORD*)(this[122] + 4 * this[123] - 4) = v3;
            }
            v16 = v2[1];
            ++v2;
            v21 += v22;
        } while (v16);
    }
    v17 = operator new(0x15Cu);
    if (v17)
        v18 = sub_41C6A0(v17);
    else
        v18 = 0;
    this[103] = (int)v18;
    sub_41C7A0((int)v18, 1);
    sub_41C760(this[103], aSoundsUiMusicW);
    *(_BYTE*)this[103] = 0;
    sub_41CA40(this[103]);
    v20 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
    sub_41CFD0(this[103], v20);
    result = sub_41CD90(this[103]);
    this[121] = 8;
    return result;
}
// 4AA1E8: using guessed type char *off_4AA1E8;
// 520970: using guessed type int dword_520970;
// 5209D8: using guessed type int dword_5209D8;
// 5209F4: using guessed type int dword_5209F4;

//----- (00438FF0) --------------------------------------------------------
int __thiscall sub_438FF0(_DWORD* this)
{
    int result; // eax

    this[99] = -1;
    result = sub_436FA0(*(_DWORD*)(dword_520970 + 224), 0, 0.0);
    this[121] = 0;
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (00439020) --------------------------------------------------------
int __thiscall sub_439020(int this, int a2)
{
    int result; // eax

    *(_DWORD*)(this + 396) = a2;
    result = sub_436FA0(*(_DWORD*)(dword_520970 + 224), 0, 0.0);
    *(_DWORD*)(this + 484) = 0;
    *(_BYTE*)(this + 432) = 0;
    *(_DWORD*)(this + 436) = 0;
    *(_DWORD*)(this + 440) = 0;
    *(_DWORD*)(this + 444) = 0;
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (00439070) --------------------------------------------------------
char __thiscall sub_439070(int this, int a2)
{
    int v3; // ebx
    float* v4; // edi
    double v5; // st7
    double v6; // st7
    char v8; // c0
    float v9; // eax
    double v10; // st6
    int v11; // ecx
    int v12; // ecx
    int v13; // ecx
    int v14; // eax
    int v15; // eax
    int v16; // eax
    int v17; // eax
    double v18; // st7
    int v19; // ecx
    _DWORD* v20; // eax
    _DWORD* v21; // eax
    int v22; // eax
    double v23; // st7
    float v24; // eax
    double v25; // st6
    long double v26; // st5
    double v27; // st5
    double v28; // rt0
    double v29; // st5
    int v30; // edx
    int v31; // ecx
    int v32; // ecx
    int v33; // ecx
    int v34; // ecx
    int v35; // ecx
    double v36; // st7
    int v37; // edx
    int v38; // eax
    double v39; // st7
    double v40; // st7
    char v42; // c0
    char v44; // c0
    float* v45; // edi
    int v46; // ecx
    double v47; // st7
    float v48; // ecx
    double v49; // st6
    long double v50; // st5
    double v51; // st5
    double v52; // rt1
    double v53; // st5
    double v54; // st7
    double v55; // st6
    int v56; // edx
    int v57; // ecx
    int v58; // ecx
    void* v59; // edi
    int v60; // ecx
    int v61; // eax
    _BYTE* v62; // edi
    int v63; // ecx
    _DWORD* v64; // eax
    _DWORD* v65; // eax
    int* v66; // edi
    double v67; // st7
    double v68; // st6
    _BYTE* v69; // edi
    void(__thiscall * **v70)(_DWORD, int); // ecx
    int v71; // ebx
    int* v72; // edx
    void* v73; // edi
    int j; // edi
    void* v75; // eax
    int v76; // ecx
    void* v77; // edi
    _DWORD* v78; // ecx
    float v79; // edi
    float v81; // [esp+4h] [ebp-F4h]
    float v82; // [esp+8h] [ebp-F0h]
    int X; // [esp+Ch] [ebp-ECh]
    float Xa; // [esp+Ch] [ebp-ECh]
    float X_4; // [esp+10h] [ebp-E8h]
    float X_4a; // [esp+10h] [ebp-E8h]
    float X_4b; // [esp+10h] [ebp-E8h]
    float X_4c; // [esp+10h] [ebp-E8h]
    char i; // [esp+27h] [ebp-D1h]
    float v90; // [esp+28h] [ebp-D0h]
    float v91; // [esp+28h] [ebp-D0h]
    float v92; // [esp+2Ch] [ebp-CCh]
    float v93; // [esp+2Ch] [ebp-CCh]
    double v94; // [esp+30h] [ebp-C8h] BYREF
    float v95; // [esp+38h] [ebp-C0h]
    float v96; // [esp+44h] [ebp-B4h] BYREF
    float v97; // [esp+48h] [ebp-B0h]
    float v98; // [esp+4Ch] [ebp-ACh]
    float v99; // [esp+50h] [ebp-A8h] BYREF
    int v100; // [esp+54h] [ebp-A4h]
    int v101; // [esp+58h] [ebp-A0h]
    float v102; // [esp+5Ch] [ebp-9Ch]
    int v103; // [esp+60h] [ebp-98h] BYREF
    float v104; // [esp+64h] [ebp-94h]
    int v105; // [esp+68h] [ebp-90h]
    int v106[16]; // [esp+6Ch] [ebp-8Ch] BYREF
    int v107[16]; // [esp+ACh] [ebp-4Ch] BYREF
    int v108; // [esp+F4h] [ebp-4h]
    int savedregs; // [esp+F8h] [ebp+0h] BYREF

    v92 = 0.0;
    v90 = 0.0;
    v102 = *(float*)(dword_520970 + 68);
    if (!*(_BYTE*)(dword_520970 + 296))
    {
        v92 = sub_408F80((float*)dword_520970, 0);
        v90 = sub_408F80((float*)dword_520970, 1);
    }
    v3 = 0;
    for (i = 0; v3 < *(_DWORD*)(this + 492); ++v3)
    {
        v4 = *(float**)(*(_DWORD*)(this + 488) + 4 * v3);
        if (*(_DWORD*)v4)
        {
            v5 = v4[1];
            v97 = 0.0;
            v94 = v5;
            v96 = *(float*)&dword_5209D8;
            v6 = v5 - ceil(v102 * 0.083333336 * (double)dword_5209D8);
            v4[1] = v6;
            if (v8 && v3 == *(_DWORD*)(this + 492) - 1)
                i = 1;
            v100 = 0;
            LODWORD(v99) = dword_5209F4;
            v9 = *v4;
            v10 = (double)(unsigned int)dword_5209F4;
            *(_BYTE*)(LODWORD(v9) + 32) = 1;
            *(float*)(LODWORD(v9) + 12) = v10 * 0.5;
            *(float*)(LODWORD(v9) + 16) = v6;
        }
    }
    v11 = *(_DWORD*)(this + 412);
    if (v11)
    {
        sub_41D0C0(v11, (int)&savedregs, v102);
        X_4 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
        sub_41CFD0(*(_DWORD*)(this + 412), X_4);
    }
    v12 = *(_DWORD*)(this + 416);
    if (v12)
    {
        sub_41D0C0(v12, (int)&savedregs, v102);
        X_4a = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
        sub_41CFD0(*(_DWORD*)(this + 416), X_4a);
    }
    v13 = *(_DWORD*)(this + 404);
    if (v13)
        (*(void(__thiscall**)(int, int))(*(_DWORD*)v13 + 8))(v13, a2);
    v14 = *(_DWORD*)(this + 484);
    if (!v14)
    {
        v15 = sub_450BF0((_DWORD*)dword_520970, 1, 0);
        sub_421110(v15, aLoadingMap);
        *(_DWORD*)(this + 484) = 1;
        goto LABEL_140;
    }
    if (v14 == 1)
    {
        sub_438840((_DWORD*)this);
        v16 = sub_450BF0((_DWORD*)dword_520970, 1, 1082130432);
        sub_421110(v16, AppName);
        (*(void(__thiscall**)(_DWORD, int))(**(_DWORD**)(this + 408) + 24))(*(_DWORD*)(this + 408), 1);
        sub_436FD0(*(_DWORD*)(dword_520970 + 224), 0, 1.0);
        v17 = *(_DWORD*)(this + 396);
        *(_DWORD*)(this + 484) = 2;
        if (v17 == -1)
        {
            sub_438A70(this);
            sub_422DC0((HKEY)AppName, aShowintro, 0);
            *(_DWORD*)(this + 484) = 3;
        }
        else
        {
            sub_438B40(this);
            *(_DWORD*)(this + 484) = 4;
        }
    LABEL_140:
        v78 = *(_DWORD**)(this + 408);
        if (v78)
        {
            v79 = v102;
            sub_4075B0(v78, *(_DWORD*)(this + 476), v102);
            sub_4075B0(*(_DWORD**)(this + 408), *(_DWORD*)(this + 480), v79);
        }
        return sub_428620((_DWORD*)this, a2);
    }
    if (v14 != 3)
    {
        if (v14 != 4)
        {
            if (v14 == 6)
            {
                if (sub_437000(*(float**)(dword_520970 + 224)))
                {
                    sub_450AC0(dword_520970, 0, -1);
                    *(_BYTE*)(dword_520970 + 296) = 0;
                    sub_45A9D0(*(_DWORD**)(dword_520970 + 236));
                }
            }
            else if (v14 == 7)
            {
                v62 = *(_BYTE**)(this + 412);
                if (v62)
                {
                    if (!v62[1])
                    {
                        sub_41C700(*(_DWORD*)(this + 412));
                        sub_4885A6(v62);
                        v63 = *(_DWORD*)(this + 416);
                        *(_DWORD*)(this + 412) = 0;
                        sub_41CD90(v63);
                        v64 = operator new(0x80u);
                        v108 = 1;
                        if (v64)
                            v65 = sub_412AB0(v64);
                        else
                            v65 = 0;
                        *(_DWORD*)(this + 464) = v65;
                        v108 = -1;
                        v66 = sub_409AF0((_DWORD**)dword_520970, aWwiivictoryTga, 1);
                        v100 = 0;
                        v67 = (double)v66[7];
                        v68 = (double)(unsigned int)dword_5209D8;
                        LODWORD(v99) = dword_5209F4;
                        v100 = 0;
                        v93 = (float)(unsigned int)dword_5209F4;
                        X_4c = (v67 + v68) * 0.5;
                        Xa = (v67 + v93) * 0.5;
                        v82 = (v68 - v67) * 0.5;
                        v81 = (v93 - v67) * 0.5;
                        sub_413090(*(_DWORD*)(this + 464), v81, v82, Xa, X_4c);
                        sub_4131B0(*(_DWORD**)(this + 464), v66);
                        sub_422230(v66);
                        sub_413240(*(_DWORD**)(this + 464), 1103101952, 1103626240, 0, 255);
                        sub_428680((_DWORD*)this, *(_DWORD*)(this + 464));
                    }
                }
                else
                {
                    v69 = *(_BYTE**)(this + 416);
                    if (v69)
                    {
                        if (!v69[1])
                        {
                            sub_41C700(*(_DWORD*)(this + 416));
                            sub_4885A6(v69);
                            *(_DWORD*)(this + 416) = 0;
                            sub_436FA0(*(_DWORD*)(dword_520970 + 224), 0, 2.0);
                        }
                    }
                    else if (sub_437000(*(float**)(dword_520970 + 224)))
                    {
                        sub_438DC0((int*)this);
                    }
                }
            }
            else if (v14 == 8 && (i || sub_408F40(57) || sub_408F40(28) || sub_408F40(1)))
            {
                sub_4286C0((_DWORD*)this, *(_DWORD*)(this + 464));
                v70 = *(void(__thiscall****)(_DWORD, int))(this + 464);
                if (v70)
                    (**v70)(v70, 1);
                v71 = 0;
                for (*(_DWORD*)(this + 464) = 0; v71 < *(_DWORD*)(this + 492); ++v71)
                {
                    v72 = *(int**)(*(_DWORD*)(this + 488) + 4 * v71);
                    v73 = (void*)*v72;
                    if (*v72)
                    {
                        sub_4213B0(*v72);
                        sub_4885A6(v73);
                    }
                }
                if (*(_BYTE*)(this + 500))
                {
                    for (j = 0; j < *(_DWORD*)(this + 492); ++j)
                        sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 488) + 4 * j));
                }
                memset(*(void**)(this + 488), 0, 4 * *(_DWORD*)(this + 492));
                v75 = *(void**)(this + 488);
                *(_DWORD*)(this + 492) = 0;
                sub_488CEE(v75);
                *(_DWORD*)(this + 496) = 0;
                *(_DWORD*)(this + 488) = 0;
                v76 = *(_DWORD*)(this + 412);
                if (v76)
                {
                    sub_41CF50(v76);
                    v77 = *(void**)(this + 412);
                    if (v77)
                    {
                        sub_41C700(*(_DWORD*)(this + 412));
                        sub_4885A6(v77);
                    }
                    *(_DWORD*)(this + 412) = 0;
                }
                sub_450AC0(dword_520970, 0, -1);
                *(_BYTE*)(*(_DWORD*)(dword_520970 + 224) + 40) = 0;
                sub_4261C0(*(_DWORD**)(dword_520970 + 232), aMainmenu, 1);
                sub_436FD0(*(_DWORD*)(dword_520970 + 224), 0, 2.0);
            }
            goto LABEL_140;
        }
        v35 = *(_DWORD*)(this + 472);
        if (v35 <= -1)
            goto LABEL_90;
        if (*(float*)(this + 444) <= 0.0)
        {
            if (!*(_BYTE*)(this + 432))
                goto LABEL_83;
            v40 = *(float*)(this + 436) - v90 * 0.0099999998;
            *(float*)(this + 436) = v40;
            if (!v42)
                v40 = 3.3333333;
            *(float*)(this + 436) = v40;
            if (v40 <= 0.0)
                v40 = 0.0;
            *(float*)(this + 436) = v40;
            v39 = v92 * 0.0099999998 + *(float*)(this + 440);
            *(float*)(this + 440) = v39;
            if (!v44)
                v39 = 1.0;
            *(float*)(this + 440) = v39;
            if (v39 <= -1.0)
                v39 = -1.0;
        }
        else
        {
            v36 = *(float*)(this + 444) - *(float*)&a2;
            *(float*)(this + 444) = v36;
            if (v36 <= 0.0)
            {
                v37 = *(_DWORD*)(this + 456);
                v38 = *(_DWORD*)(this + 460);
                *(_DWORD*)(this + 444) = 0;
                *(_DWORD*)(this + 436) = v37;
                *(_DWORD*)(this + 440) = v38;
                goto LABEL_83;
            }
            *(float*)(this + 436) = *(float*)&a2 * *(float*)(this + 448) + *(float*)(this + 436);
            v39 = *(float*)&a2 * *(float*)(this + 452) + *(float*)(this + 440);
        }
        *(float*)(this + 440) = v39;
    LABEL_83:
        sub_4072A0(*(_DWORD**)(this + 408), v35, *(_DWORD*)(this + 436), 0);
        v45 = (float*)(this + 32);
        sub_4085B0(*(_DWORD*)(this + 408), *(_DWORD*)(this + 472), this + 32);
        v46 = *(_DWORD*)(this + 408);
        X = *(_DWORD*)(this + 472);
        memset(&v106[11], 0, 16);
        memset(&v106[6], 0, 16);
        memset(&v106[1], 0, 16);
        v106[15] = 1065353216;
        v106[10] = 1065353216;
        v106[5] = 1065353216;
        v106[0] = 1065353216;
        sub_407690(v46, X, v106);
        v96 = 0.0;
        v97 = 1.0;
        v98 = 0.0;
        sub_46C5C5(&v96, &v96, (float*)v106);
        v47 = v96 - *(float*)(this + 32);
        v48 = *(float*)(this + 40);
        HIDWORD(v94) = *(_DWORD*)(this + 36);
        v95 = v48;
        v97 = v97 - *((float*)&v94 + 1);
        v49 = v98 - v48;
        v50 = sqrt(v49 * v49 + v97 * v97 + v47 * v47);
        if (v50 >= 0.0000099999997 || v50 <= -0.0000099999997)
        {
            if (v50 == 0.0)
                v51 = 0.0;
            else
                v51 = 1.0 / v50;
        }
        else
        {
            v51 = 1.0 / 1.0;
        }
        v52 = v51;
        v103 = 0;
        v104 = 0.0;
        v105 = -1082130432;
        v96 = v47 * v51;
        v53 = v97 * v51;
        *(float*)(this + 56) = v96;
        v97 = v53;
        *(float*)(this + 60) = v97;
        v98 = v49 * v52;
        *(float*)(this + 64) = v98;
        sub_46C5C5((float*)&v103, (float*)&v103, (float*)v106);
        v54 = *(float*)(this + 440) * 200.0;
        v55 = v54 + *v45;
        *(_DWORD*)(this + 44) = v103;
        *(float*)(this + 48) = v104;
        v56 = v105;
        *v45 = v55;
        *(_DWORD*)(this + 52) = v56;
        *(float*)(this + 44) = v54 + *(float*)(this + 44);
    LABEL_90:
        if ((sub_408F40(57) || sub_408F40(28) || sub_408F40(1)) && *(_DWORD*)(this + 396) != 11)
        {
            v57 = *(_DWORD*)(this + 468);
            if (v57)
                sub_402FC0(v57);
            v58 = *(_DWORD*)(this + 412);
            if (v58)
            {
                sub_41CF50(v58);
                v59 = *(void**)(this + 412);
                if (v59)
                {
                    sub_41C700(*(_DWORD*)(this + 412));
                    sub_4885A6(v59);
                }
                *(_DWORD*)(this + 412) = 0;
            }
            v60 = *(_DWORD*)(this + 416);
            if (v60)
                sub_41CF50(v60);
            v61 = dword_520970;
            if (!*(_BYTE*)(dword_520970 + 296))
            {
                *(_BYTE*)(dword_520970 + 296) = 1;
                v61 = dword_520970;
            }
            sub_436FA0(*(_DWORD*)(v61 + 224), 0, 2.0);
            *(_DWORD*)(this + 484) = 6;
        }
        goto LABEL_140;
    }
    v18 = *(float*)&a2 + *(float*)(this + 424);
    v91 = *(float*)(this + 424);
    *(float*)(this + 424) = v18;
    if (v18 > 98.0 && v91 <= 98.0)
        sub_436FA0(*(_DWORD*)(dword_520970 + 224), 0, 2.0);
    if (*(float*)(this + 424) > 10.0 && !*(_BYTE*)(*(_DWORD*)(this + 416) + 1))
    {
        sub_450AC0(dword_520970, 0, -1);
        *(_BYTE*)(*(_DWORD*)(dword_520970 + 224) + 40) = 0;
        sub_4261C0(*(_DWORD**)(dword_520970 + 232), aLevelselect, 1);
        sub_436FD0(*(_DWORD*)(dword_520970 + 224), 0, 2.0);
        return sub_428620((_DWORD*)this, a2);
    }
    if (!sub_408F40(57) && !sub_408F40(28) && !sub_408F40(1))
    {
        if (!*(_BYTE*)(this + 421))
        {
            v19 = *(_DWORD*)(this + 416);
            *(_BYTE*)(this + 421) = 1;
            sub_41CD90(v19);
        }
        if (!*(_BYTE*)(this + 420) && *(float*)(this + 424) > 6.0)
        {
            *(_BYTE*)(this + 420) = 1;
            v20 = operator new(0x15Cu);
            v108 = 0;
            if (v20)
                v21 = sub_41C6A0(v20);
            else
                v21 = 0;
            v108 = -1;
            *(_DWORD*)(this + 412) = v21;
            sub_41C7A0((int)v21, 1);
            sub_41C760(*(_DWORD*)(this + 412), aSoundsWarmapWa);
            sub_41CA40(*(_DWORD*)(this + 412));
            X_4b = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
            sub_41CFD0(*(_DWORD*)(this + 412), X_4b);
            sub_41CD90(*(_DWORD*)(this + 412));
        }
        if (*(float*)(this + 424) > 10.0 && v91 <= 10.0)
            sub_437B40(*(_DWORD**)(this + 404));
        if (*(float*)(this + 424) > 14.333333 && v91 <= 14.333333)
            sub_437B10(*(_DWORD**)(this + 404));
        if (*(float*)(this + 424) > 17.0 && v91 <= 17.0)
        {
            sub_437AA0(*(char**)(this + 404), 11, 0);
            sub_437AA0(*(char**)(this + 404), 10, 1069547520);
            sub_437AA0(*(char**)(this + 404), 9, 0x40000000);
            sub_437AA0(*(char**)(this + 404), 8, 1077237077);
            sub_437AA0(*(char**)(this + 404), 7, 1078635179);
            sub_437AA0(*(char**)(this + 404), 6, 1080732331);
            sub_437AA0(*(char**)(this + 404), 5, 1083528533);
            sub_437AA0(*(char**)(this + 404), 4, 1087373312);
            sub_437AA0(*(char**)(this + 404), 3, 1089120939);
            sub_437AA0(*(char**)(this + 404), 2, 1089819989);
            sub_437AA0(*(char**)(this + 404), 1, 1091043328);
            sub_437AA0(*(char**)(this + 404), 0, 1091882189);
        }
        if (*(float*)(this + 424) > 28.333334 && v91 <= 28.333334)
            sub_437AE0(*(_DWORD**)(this + 404));
        v22 = *(_DWORD*)(this + 428);
        if (v22 > -1)
        {
            sub_4085B0(*(_DWORD*)(this + 408), v22, this + 32);
            sub_406BE0(v107);
            sub_407690(*(_DWORD*)(this + 408), *(_DWORD*)(this + 428), v107);
            v94 = 0.0078125;
            v95 = 0.0;
            sub_46C5C5((float*)&v94, (float*)&v94, (float*)v107);
            v23 = *(float*)&v94 - *(float*)(this + 32);
            v24 = *(float*)(this + 40);
            v104 = *(float*)(this + 36);
            v105 = LODWORD(v24);
            *((float*)&v94 + 1) = *((float*)&v94 + 1) - v104;
            v25 = v95 - v24;
            v26 = sqrt(v25 * v25 + *((float*)&v94 + 1) * *((float*)&v94 + 1) + v23 * v23);
            if (v26 >= 0.0000099999997 || v26 <= -0.0000099999997)
            {
                if (v26 == 0.0)
                    v27 = 0.0;
                else
                    v27 = 1.0 / v26;
            }
            else
            {
                v27 = 1.0 / 1.0;
            }
            v28 = v27;
            v99 = 0.0;
            v100 = 0;
            v101 = -1082130432;
            *(float*)&v94 = v23 * v27;
            v29 = *((float*)&v94 + 1) * v27;
            *(_DWORD*)(this + 56) = LODWORD(v94);
            *((float*)&v94 + 1) = v29;
            *(_DWORD*)(this + 60) = HIDWORD(v94);
            v95 = v25 * v28;
            *(float*)(this + 64) = v95;
            sub_46C5C5(&v99, &v99, (float*)v107);
            v30 = v100;
            *(float*)(this + 44) = v99;
            v31 = v101;
            *(_DWORD*)(this + 48) = v30;
            *(_DWORD*)(this + 52) = v31;
        }
        goto LABEL_140;
    }
    v32 = *(_DWORD*)(this + 468);
    if (v32)
        sub_402FC0(v32);
    v33 = *(_DWORD*)(this + 412);
    if (v33)
        sub_41CF50(v33);
    v34 = *(_DWORD*)(this + 416);
    if (v34)
        sub_41CF50(v34);
    sub_450AC0(dword_520970, 0, -1);
    *(_BYTE*)(*(_DWORD*)(dword_520970 + 224) + 40) = 0;
    sub_4261C0(*(_DWORD**)(dword_520970 + 232), aLevelselect, 1);
    sub_436FA0(*(_DWORD*)(dword_520970 + 224), 0, 0.0);
    sub_436FD0(*(_DWORD*)(dword_520970 + 224), 0, 2.0);
    return sub_428620((_DWORD*)this, a2);
}
// 439CFB: conditional instruction was optimized away because edi.4!=0
// 439E33: conditional instruction was optimized away because edi.4!=0
// 439E68: conditional instruction was optimized away because edi.4!=0
// 439147: variable 'v8' is possibly undefined
// 439926: variable 'v42' is possibly undefined
// 439976: variable 'v44' is possibly undefined
// 520970: using guessed type int dword_520970;
// 5209D8: using guessed type int dword_5209D8;
// 5209F4: using guessed type int dword_5209F4;

//----- (0043A080) --------------------------------------------------------
char __thiscall sub_43A080(_DWORD* this, int a2, int a3)
{
    int v4; // eax
    int v5; // eax
    int v6; // eax
    const char* v8; // [esp-4h] [ebp-10h]

    if ((_BYTE)a3)
    {
        if (a2 == 12)
        {
            v4 = this[100] - 1;
            this[100] = v4;
            if (v4 < 0)
                this[100] = 12;
        LABEL_8:
            v8 = off_4AA5F0[this[100]];
            v6 = sub_450BF0((_DWORD*)dword_520970, 1, 0x40000000);
            sub_421110(v6, v8);
            sub_43A120((int)this, this[100]);
            return sub_428590(this, a2, a3);
        }
        if (a2 == 13)
        {
            v5 = this[100] + 1;
            this[100] = v5;
            if (v5 >= 12)
                this[100] = 0;
            goto LABEL_8;
        }
    }
    return sub_428590(this, a2, a3);
}
// 4AA5F0: using guessed type char *off_4AA5F0[13];
// 520970: using guessed type int dword_520970;

//----- (0043A120) --------------------------------------------------------
int __thiscall sub_43A120(int this, int a2)
{
    int result; // eax
    double v3; // st7
    double v4; // st7

    *(_DWORD*)(this + 456) = dword_4AA62C[2 * a2];
    result = dword_4AA628[2 * a2];
    v3 = *(float*)(this + 456) - *(float*)(this + 436);
    *(_DWORD*)(this + 460) = result;
    *(_DWORD*)(this + 444) = 1056964608;
    *(float*)(this + 448) = v3 + v3;
    v4 = *(float*)(this + 460) - *(float*)(this + 440);
    *(float*)(this + 452) = v4 + v4;
    return result;
}
// 4AA628: using guessed type int dword_4AA628[];
// 4AA62C: using guessed type int dword_4AA62C[23];

//----- (0043A180) --------------------------------------------------------
_DWORD* __thiscall sub_43A180(_DWORD* this)
{
    _DWORD* result; // eax

    result = this;
    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
    *((_BYTE*)this + 16) = 1;
    *this = &off_49955C;
    this[6] = 0;
    this[7] = 0;
    this[8] = 0;
    this[9] = 0;
    this[10] = 0;
    this[12] = 0;
    return result;
}
// 49955C: using guessed type _UNKNOWN *off_49955C;

//----- (0043A1D0) --------------------------------------------------------
void __thiscall sub_43A1D0(_DWORD* this)
{
    *this = &off_499040;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);

//----- (0043A1E0) --------------------------------------------------------
int __thiscall sub_43A1E0(int* this)
{
    int v2; // ebx
    int* v3; // esi
    int result; // eax

    v2 = 4;
    this[5] = -1;
    this[10] = 0;
    v3 = this + 6;
    do
    {
        result = *v3;
        if (*v3)
        {
            result = sub_4286C0(this, *v3);
            if (*v3)
                result = (**(int(__thiscall***)(int, int)) * v3)(*v3, 1);
            *v3 = 0;
        }
        ++v3;
        --v2;
    } while (v2);
    return result;
}

//----- (0043A230) --------------------------------------------------------
void __thiscall sub_43A230(int* this, int ArgList)
{
    _DWORD* v3; // eax
    _DWORD* v4; // eax
    int v5; // eax
    _DWORD* v6; // ebp
    int v7; // edi
    int i; // edi
    _DWORD* v9; // eax
    _DWORD* v10; // eax
    int v11; // ecx
    int** v12; // edi
    int v13; // ebx
    float v14; // [esp+0h] [ebp-130h]
    _DWORD v15[3]; // [esp+14h] [ebp-11Ch] BYREF
    char Buffer[260]; // [esp+20h] [ebp-110h] BYREF
    int v17; // [esp+12Ch] [ebp-4h]

    v3 = operator new(0x15Cu);
    v17 = 0;
    if (v3)
        v4 = sub_41C6A0(v3);
    else
        v4 = 0;
    v17 = -1;
    this[12] = (int)v4;
    sub_41C760((int)v4, aSoundsNewspape);
    sub_41CA40(this[12]);
    v14 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
    sub_41CFD0(this[12], v14);
    sub_41CD90(this[12]);
    sub_4229D0("Showing Newspaper #%d", ArgList);
    if (!*(_BYTE*)(dword_520970 + 296))
        *(_BYTE*)(dword_520970 + 296) = 1;
    sub_43A1E0(this);
    (*(void(__thiscall**)(int*, int))(*this + 24))(this, 1);
    this[5] = ArgList;
    v5 = 0;
    v6 = v15;
    do
    {
        v7 = v5 + 1;
        sprintf(Buffer, ".\\Newspapers\\%s %03d.tga", off_4AAEC8[ArgList], v5 + 1);
        *v6 = sub_409AF0((_DWORD**)dword_520970, Buffer, 1);
        v5 = v7;
        ++v6;
    } while (v7 < 3);
    for (i = 0; i < 4; ++i)
    {
        v9 = operator new(0x80u);
        v17 = 1;
        if (v9)
            v10 = sub_412AB0(v9);
        else
            v10 = 0;
        v17 = -1;
        this[i + 6] = (int)v10;
        v11 = i;
        if (i >= 2)
            v11 = 2;
        sub_4131B0(v10, (_DWORD*)v15[v11]);
        sub_413120(this[i + 6], 1148862464);
        sub_428680(this, this[i + 6]);
        (*(void(__thiscall**)(int, int))(*(_DWORD*)this[i + 6] + 24))(this[i + 6], 1);
        if ((unsigned int)i < 2)
        {
            sub_413130(this[i + 6], 0, 0, 1065353216, 1065353216);
        }
        else if (i == 2)
        {
            sub_413130(this[8], 0, 0, 1065353216, 1056964608);
        }
        else if (i == 3)
        {
            sub_413130(this[9], 0, 1056964608, 1065353216, 1065353216);
        }
    }
    v12 = (int**)v15;
    v13 = 3;
    do
    {
        sub_422230(*v12++);
        --v13;
    } while (v13);
    this[11] = 0;
}
// 4AAEC8: using guessed type char *off_4AAEC8[12];
// 520970: using guessed type int dword_520970;

//----- (0043A460) --------------------------------------------------------
char __thiscall sub_43A460(_DWORD* this, int a2, char a3)
{
    char result; // al

    result = a3;
    if (a3)
    {
        if (this[11] == 1)
            return sub_43A4A0(this);
    }
    return result;
}

//----- (0043A480) --------------------------------------------------------
char __thiscall sub_43A480(int this, int a2, char a3)
{
    char result; // al

    result = a3;
    if (a3)
    {
        result = *(_BYTE*)(this + 16);
        if (result)
        {
            if (*(_DWORD*)(this + 44) == 1)
                return sub_43A4A0((_DWORD*)this);
        }
    }
    return result;
}

//----- (0043A4A0) --------------------------------------------------------
int __thiscall sub_43A4A0(_DWORD* this)
{
    void* v2; // esi
    _DWORD** v3; // esi
    int v4; // edi
    int result; // eax

    sub_41CF50(this[12]);
    v2 = (void*)this[12];
    if (v2)
    {
        sub_41C700(this[12]);
        sub_4885A6(v2);
    }
    this[12] = 0;
    v3 = (_DWORD**)(this + 6);
    v4 = 4;
    do
    {
        sub_413240(*v3++, 1048576000, 1067450368, 255, 0);
        --v4;
    } while (v4);
    result = sub_436FA0(*(_DWORD*)(dword_520970 + 224), 1048576000, 1.5);
    this[11] = 2;
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (0043A520) --------------------------------------------------------
int __thiscall sub_43A520(int* this)
{
    int result; // eax

    sub_43A1E0(this);
    result = (*(int(__thiscall**)(int*, _DWORD))(*this + 24))(this, 0);
    *(_BYTE*)(dword_520970 + 296) = 0;
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (0043A540) --------------------------------------------------------
char __userpurge sub_43A540@<al>(int a1@<ecx>, int a2@<ebp>, int a3)
{
    int v4; // ecx
    int v5; // eax
    double v6; // st7
    double v7; // st7
    int v8; // ecx
    double v9; // st6
    double v10; // st6
    int* v11; // ebx
    int v12; // ebp
    float v14; // [esp+0h] [ebp-30h]
    float v15; // [esp+Ch] [ebp-24h]
    int v16; // [esp+10h] [ebp-20h]
    int v17; // [esp+14h] [ebp-1Ch]
    float v18; // [esp+18h] [ebp-18h]
    float v19; // [esp+18h] [ebp-18h]
    float v20; // [esp+1Ch] [ebp-14h]
    float v21; // [esp+20h] [ebp-10h]
    float v22; // [esp+24h] [ebp-Ch]
    float v23; // [esp+28h] [ebp-8h]
    int v24; // [esp+28h] [ebp-8h]

    v4 = *(_DWORD*)(a1 + 48);
    if (v4)
    {
        sub_41D0C0(v4, a2, *(float*)&a3);
        v14 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
        sub_41CFD0(*(_DWORD*)(a1 + 48), v14);
    }
    v5 = *(_DWORD*)(a1 + 44);
    if (v5 != 2)
        *(float*)(a1 + 40) = *(float*)(dword_520970 + 68) + *(float*)(a1 + 40);
    v15 = 1.0;
    if (!v5)
    {
        v6 = *(float*)(a1 + 40) * 0.5;
        v15 = v6;
        if (v6 >= 1.0)
        {
            v15 = 1.0;
            *(_DWORD*)(a1 + 44) = 1;
        }
    }
    v7 = v15 * v15;
    v8 = *(_DWORD*)(a1 + 24);
    *(float*)&v16 = (double)(unsigned int)dword_5209F4 * 0.5;
    *(float*)&v17 = (double)(unsigned int)dword_5209D8 * 0.5;
    v18 = v7 * 384.0;
    v9 = v7 * 512.0 * 0.5;
    v20 = *(float*)&v16 - v9;
    v21 = v9 + *(float*)&v16;
    v10 = v18 * 0.5;
    v19 = *(float*)&v17 - v10;
    v23 = v10 + *(float*)&v17;
    v22 = v7 * 256.0 + v19;
    if (v8)
    {
        sub_413090(v8, v20, v19, *(float*)&v16, v22);
        sub_413090(*(_DWORD*)(a1 + 28), *(float*)&v16, v19, v21, v22);
        sub_413090(*(_DWORD*)(a1 + 32), v20, v22, *(float*)&v16, v23);
        sub_413090(*(_DWORD*)(a1 + 36), *(float*)&v16, v22, v21, v23);
        v11 = (int*)(a1 + 24);
        v12 = 4;
        do
        {
            *(float*)&v24 = (1.0 - (1.0 - v15) * (1.0 - v15)) * 3600.0 * 0.017453292;
            sub_413100(*v11++, v16, v17, v24);
            --v12;
        } while (v12);
    }
    if (*(_DWORD*)(a1 + 44) == 2 && *(float*)(*(_DWORD*)(a1 + 24) + 72) <= -1.0)
        sub_43A520((int*)a1);
    return sub_428620((_DWORD*)a1, a3);
}
// 520970: using guessed type int dword_520970;
// 5209D8: using guessed type int dword_5209D8;
// 5209F4: using guessed type int dword_5209F4;

//----- (0043A740) --------------------------------------------------------
_DWORD* __thiscall sub_43A740(_DWORD* this, int a2)
{
    sub_4233C0((int)this, a2, aMainmenu);
    *this = &off_499588;
    return this;
}
// 499588: using guessed type _UNKNOWN *off_499588;

//----- (0043A760) --------------------------------------------------------
char __thiscall sub_43A760(_DWORD** this, char* String1, int a3)
{
    if (String1)
    {
        if (!_strcmpi(String1, aSingleplayerbu))
        {
            sub_4261C0(this[10], aNameentry, 0);
            return 1;
        }
        if (!_strcmpi(String1, aMultiplayerbut))
        {
            sub_4261C0(this[10], aConnectiontype, 0);
            return 1;
        }
        if (!_strcmpi(String1, aOptionsbutton))
        {
            strcpy(byte_521688, aMainmenu);
            sub_4261C0(this[10], aOptions, 0);
            return 1;
        }
        if (!_strcmpi(String1, aExitbutton))
        {
            byte_520885 = 1;
            SendMessageA(dword_5209E4, 0x10u, 0, 0);
        }
    }
    return 1;
}
// 520885: using guessed type char byte_520885;

//----- (0043A840) --------------------------------------------------------
char __thiscall sub_43A840(int** this)
{
    return sub_424630(this[10]);
}

//----- (0043A850) --------------------------------------------------------
_DWORD* __thiscall sub_43A850(_DWORD* this, int a2)
{
    sub_4233C0((int)this, a2, aOptions);
    *this = &off_4995C0;
    this[12] = sub_424350(this, aParticles);
    this[13] = sub_424350(this, aMousespeed);
    this[14] = sub_424350(this, aVolume);
    this[15] = sub_424350(this, aAnimatedocean);
    this[16] = sub_424350(this, aDoppler);
    this[17] = sub_424350(this, aBlood);
    this[18] = sub_424350(this, aCrosshair);
    this[19] = sub_424350(this, aInvertmouse);
    this[20] = 0;
    this[21] = 0;
    return this;
}
// 4995C0: using guessed type _UNKNOWN *off_4995C0;

//----- (0043A950) --------------------------------------------------------
char __thiscall sub_43A950(int this)
{
    char* v2; // eax
    int v3; // eax
    int v4; // ecx
    INT v5; // eax
    int v6; // eax

    sub_424630(*(int**)(this + 40));
    if (!*(_DWORD*)(this + 84))
    {
        v2 = sub_41DE10(*(_DWORD**)(dword_520970 + 120), aSoundsInterfac, 1, 0, 1, 0, 0);
        *(_DWORD*)(this + 84) = v2;
        sub_4282E0(v2 != 0, aCouldnTLoadBan);
    }
    v3 = sub_41E2D0(*(_DWORD**)(dword_520970 + 120), *(_DWORD**)(this + 84), 0, 1);
    v4 = *(_DWORD*)(this + 60);
    *(_DWORD*)(this + 80) = v3;
    *(_BYTE*)(v4 + 172) = byte_520974;
    *(_BYTE*)(*(_DWORD*)(this + 64) + 172) = byte_4A34BC;
    *(_BYTE*)(*(_DWORD*)(this + 72) + 172) = byte_4A9F14;
    *(_BYTE*)(*(_DWORD*)(this + 76) + 172) = byte_520884;
    *(_BYTE*)(*(_DWORD*)(this + 68) + 172) = byte_4AC684;
    sub_421190(*(_DWORD*)(*(_DWORD*)(this + 56) + 112), "%d%%", *(_DWORD*)&dword_4A34C0);
    sub_421190(*(_DWORD*)(*(_DWORD*)(this + 52) + 112), "%d%%", *(_DWORD*)&dword_4A1EC4);
    v5 = sub_422BA0(AppName, aMaxparticles, 256);
    if (v5 > 64)
    {
        if (v5 > 128)
        {
            if (v5 >= 256)
                *(_DWORD*)(this + 44) = 2;
        }
        else
        {
            *(_DWORD*)(this + 44) = 1;
        }
    }
    else
    {
        *(_DWORD*)(this + 44) = 0;
    }
    v6 = *(_DWORD*)(this + 44);
    if (v6)
    {
        if (v6 == 1)
        {
            LOBYTE(v6) = sub_421110(*(_DWORD*)(*(_DWORD*)(this + 48) + 112), aMedium);
        }
        else if (v6 == 2)
        {
            LOBYTE(v6) = sub_421110(*(_DWORD*)(*(_DWORD*)(this + 48) + 112), aHigh);
        }
    }
    else
    {
        LOBYTE(v6) = sub_421110(*(_DWORD*)(*(_DWORD*)(this + 48) + 112), aLow);
    }
    return v6;
}
// 4A34BC: using guessed type char byte_4A34BC;
// 4A9F14: using guessed type char byte_4A9F14;
// 4AC684: using guessed type char byte_4AC684;
// 520884: using guessed type char byte_520884;
// 520970: using guessed type int dword_520970;
// 520974: using guessed type char byte_520974;

//----- (0043AAC0) --------------------------------------------------------
void __thiscall sub_43AAC0(int* this)
{
    int v2; // ecx
    _DWORD* v3; // ecx

    v2 = this[20];
    if (v2)
    {
        sub_41D860(v2);
        sub_41D9A0(this[20]);
        this[20] = 0;
    }
    v3 = (_DWORD*)this[21];
    if (v3)
    {
        sub_41D700(v3);
        this[21] = 0;
    }
}

//----- (0043AB00) --------------------------------------------------------
int __thiscall sub_43AB00(_DWORD* this)
{
    int v2; // esi
    int v3; // edi
    int result; // eax

    byte_520974 = *(_BYTE*)(this[15] + 172);
    sub_422DC0((HKEY)AppName, aAnimatedocean, byte_520974 != 0);
    byte_4A34BC = *(_BYTE*)(this[16] + 172);
    sub_422BA0(AppName, aDoppler, byte_4A34BC != 0);
    byte_4A9F14 = *(_BYTE*)(this[18] + 172);
    sub_422DC0((HKEY)AppName, aShowcrosshair, byte_4A9F14 != 0);
    byte_520884 = *(_BYTE*)(this[19] + 172);
    sub_422DC0((HKEY)AppName, aInvertmouse, byte_520884 != 0);
    byte_4AC684 = *(_BYTE*)(this[17] + 172);
    sub_422DC0((HKEY)AppName, aGore, byte_4AC684 != 0);
    v2 = this[11];
    v3 = 64;
    if (v2)
    {
        if (v2 == 1)
        {
            v3 = 128;
        }
        else if (v2 == 2)
        {
            v3 = 256;
        }
    }
    result = sub_422DC0((HKEY)AppName, aMaxparticles, v3);
    *(_DWORD*)&dword_520A44 = v3;
    return result;
}
// 4A34BC: using guessed type char byte_4A34BC;
// 4A9F14: using guessed type char byte_4A9F14;
// 4AC684: using guessed type char byte_4AC684;
// 520884: using guessed type char byte_520884;
// 520974: using guessed type char byte_520974;

//----- (0043AC00) --------------------------------------------------------
char __thiscall sub_43AC00(int this, char* String1, int a3)
{
    int v5; // ecx
    _DWORD* v6; // eax
    int v7; // ecx
    int v8; // ecx
    int v9; // eax
    int v10; // eax
    int v11; // esi
    int v12; // [esp+8h] [ebp-18h] BYREF
    int v13; // [esp+Ch] [ebp-14h]
    int v14; // [esp+10h] [ebp-10h]
    _DWORD v15[3]; // [esp+14h] [ebp-Ch] BYREF

    if (String1 && !_strcmpi(String1, aOkbutton))
    {
        sub_43AB00((_DWORD*)this);
        sub_4261C0(*(_DWORD**)(this + 40), byte_521688, 0);
        return 1;
    }
    if (String1 == *(char**)(this + 56))
    {
        if (a3)
        {
            if (a3 == 1)
            {
                *(_DWORD*)&dword_4A34C0 -= 10;
                if (*(int*)&dword_4A34C0 < 0)
                    *(_DWORD*)&dword_4A34C0 = 100;
            }
        }
        else
        {
            *(_DWORD*)&dword_4A34C0 += 10;
            if (*(int*)&dword_4A34C0 > 100)
                *(_DWORD*)&dword_4A34C0 = 0;
        }
        sub_421190(*(_DWORD*)(*(_DWORD*)(this + 56) + 112), "%d%%", *(_DWORD*)&dword_4A34C0);
        sub_422DC0((HKEY)AppName, aVolume, *(int*)&dword_4A34C0);
        v5 = *(_DWORD*)(this + 80);
        if (v5)
        {
            sub_41D860(v5);
            v12 = 0;
            v13 = 0;
            v14 = 0;
            memset(v15, 0, sizeof(v15));
            if (sub_408F30((_DWORD*)dword_520970))
            {
                v6 = (_DWORD*)sub_408F30((_DWORD*)dword_520970);
                v7 = v6[8];
                v6 += 8;
                v12 = v7;
                v13 = v6[1];
                v14 = v6[2];
            }
            sub_41D960(*(_DWORD**)(this + 80), &v12, v15);
            sub_41D840(*(_DWORD*)(this + 80));
            return 1;
        }
        return 1;
    }
    if (String1 != *(char**)(this + 52))
    {
        v8 = *(_DWORD*)(this + 48);
        if (String1 == (char*)v8)
        {
            if (a3)
            {
                if (a3 == 1)
                {
                    v10 = *(_DWORD*)(this + 44) - 1;
                    *(_DWORD*)(this + 44) = v10;
                    if (v10 < 0)
                        *(_DWORD*)(this + 44) = 2;
                }
            }
            else
            {
                v9 = *(_DWORD*)(this + 44) + 1;
                *(_DWORD*)(this + 44) = v9;
                if (v9 >= 3)
                    *(_DWORD*)(this + 44) = 0;
            }
            v11 = *(_DWORD*)(this + 44);
            switch (v11)
            {
            case 0:
                sub_421110(*(_DWORD*)(v8 + 112), aLow);
                return 1;
            case 1:
                sub_421110(*(_DWORD*)(v8 + 112), aMedium);
                return 1;
            case 2:
                sub_421110(*(_DWORD*)(v8 + 112), aHigh);
                break;
            }
        }
        return 1;
    }
    if (a3)
    {
        if (a3 == 1)
        {
            *(_DWORD*)&dword_4A1EC4 -= 10;
            if (*(int*)&dword_4A1EC4 < 10)
                *(_DWORD*)&dword_4A1EC4 = 100;
        }
    }
    else
    {
        *(_DWORD*)&dword_4A1EC4 += 10;
        if (*(int*)&dword_4A1EC4 > 100)
            *(_DWORD*)&dword_4A1EC4 = 10;
    }
    sub_421190(*(_DWORD*)(*(_DWORD*)(this + 52) + 112), "%d%%", *(_DWORD*)&dword_4A1EC4);
    sub_422DC0((HKEY)AppName, aMousespeed, *(int*)&dword_4A1EC4);
    return 1;
}
// 520970: using guessed type int dword_520970;

//----- (0043AE80) --------------------------------------------------------
_DWORD* __thiscall sub_43AE80(_DWORD* this, int a2)
{
    sub_4233C0((int)this, a2, aNameentry);
    *this = &off_4995F8;
    this[11] = 0;
    this[12] = 0;
    this[13] = sub_424350(this, aSavedgames);
    return this;
}
// 4995F8: using guessed type _UNKNOWN *off_4995F8;

//----- (0043AEF0) --------------------------------------------------------
bool __thiscall sub_43AEF0(int this)
{
    sub_424630(*(int**)(this + 40));
    sub_43B180((_DWORD*)this);
    *(_DWORD*)(*(_DWORD*)(this + 52) + 132) = *(_DWORD*)(this + 48);
    *(_BYTE*)(*(_DWORD*)(this + 52) + 136) = 1;
    *(_DWORD*)(*(_DWORD*)(this + 52) + 124) = 0;
    return sub_43B330((_DWORD*)this);
}

//----- (0043AF30) --------------------------------------------------------
char __thiscall sub_43AF30(int this, char* String1, int a3)
{
    int v5; // eax
    int v6; // eax
    const char* v7; // eax
    int v8; // ecx
    int v9; // ecx
    int v10; // edx
    int v11; // ecx
    int v12; // esi

    if (!String1)
        return 1;
    if (!_strcmpi(String1, aAddbutton))
    {
        sub_4261C0(*(_DWORD**)(this + 40), aAddplayer, 0);
        return 1;
    }
    if (!_strcmpi(String1, aDeletebutton))
    {
        v5 = *(_DWORD*)(*(_DWORD*)(this + 52) + 124);
        if (v5 > -1 && v5 < *(_DWORD*)(this + 48))
        {
            strcpy(byte_521580, *(const char**)(*(_DWORD*)(this + 44) + 4 * v5));
            sub_4261C0(*(_DWORD**)(this + 40), aDeletechar, 0);
            return 1;
        }
        return 1;
    }
    if (!_strcmpi(String1, aCancelbutton))
    {
        sub_4261C0(*(_DWORD**)(this + 40), aMainmenu, 0);
        return 1;
    }
    if (_strcmpi(String1, aOkbutton))
    {
        if (_strcmpi(String1, aArrowup))
        {
            if (_strcmpi(String1, aArrowdown))
                return 1;
            v7 = sub_424350((_DWORD*)this, aSavedgames_0);
            v10 = *((_DWORD*)v7 + 30);
            v11 = v10 + *((_DWORD*)v7 + 32);
            v12 = *((_DWORD*)v7 + 33) - 1;
            *((_DWORD*)v7 + 32) = v11;
            if (v11 <= v12)
            {
            LABEL_20:
                *((_BYTE*)v7 + 136) = 1;
                sub_43B330((_DWORD*)this);
                return 1;
            }
            v9 = v11 - v10;
        }
        else
        {
            v7 = sub_424350((_DWORD*)this, aSavedgames_0);
            v8 = *((_DWORD*)v7 + 32) - *((_DWORD*)v7 + 30);
            *((_DWORD*)v7 + 32) = v8;
            v9 = v8 < 0 ? 0 : v8;
        }
        *((_DWORD*)v7 + 32) = v9;
        goto LABEL_20;
    }
    v6 = *(_DWORD*)(*(_DWORD*)(this + 52) + 124);
    if (v6 > -1 && v6 < *(_DWORD*)(this + 48))
    {
        strcpy(String, *(const char**)(*(_DWORD*)(this + 44) + 4 * v6));
        sub_422E60(AppName, aUsername, String);
        sub_4229D0("UI NameEntry: current name=%s", String);
        sub_45E720(*(_DWORD*)(dword_520970 + 280), String, 1);
        sub_45E760(*(_DWORD*)(dword_520970 + 280));
        sub_4261C0(*(_DWORD**)(this + 40), aLevelselect, 0);
        return 1;
    }
    return 1;
}
// 520970: using guessed type int dword_520970;

//----- (0043B150) --------------------------------------------------------
char __stdcall sub_43B150(int a1, int a2, int a3)
{
    return 1;
}

//----- (0043B160) --------------------------------------------------------
void __thiscall sub_43B160(int this)
{
    sub_4885A6(*(LPVOID*)(this + 44));
    *(_DWORD*)(this + 48) = 0;
}

//----- (0043B180) --------------------------------------------------------
int __thiscall sub_43B180(_DWORD* this)
{
    void* v2; // esi
    int i; // esi
    void* v4; // edi
    void* v5; // esi
    int v6; // ebp
    char* v7; // eax
    char* v8; // edx
    void* v10; // [esp+Ch] [ebp-220h]
    int v11[5]; // [esp+10h] [ebp-21Ch] BYREF
    char String1[260]; // [esp+24h] [ebp-208h] BYREF
    char Str[260]; // [esp+128h] [ebp-104h] BYREF

    sub_43B160((int)this);
    v2 = (void*)_findfirst(FileName, (int)v11);
    if (v2 != (void*)-1)
    {
        do
        {
            if (_strcmpi(String1, aSps))
                ++this[12];
        } while (!_findnext(v2, (int)v11));
    }
    _findclose((intptr_t)v2);
    this[11] = operator new(4 * this[12]);
    for (i = 0; i < this[12]; ++i)
    {
        *(_DWORD*)(this[11] + 4 * i) = operator new(0x18u);
        v4 = *(void**)(this[11] + 4 * i);
        memset(v4, 0, 0x18u);
    }
    v5 = (void*)_findfirst(FileName, (int)v11);
    v10 = v5;
    if (v5 != (void*)-1)
    {
        v6 = 0;
        do
        {
            if (_strcmpi(String1, aSps))
            {
                strcpy(Str, String1);
                v7 = strrchr(Str, 46);
                if (v7)
                    *v7 = 0;
                v8 = *(char**)(this[11] + v6);
                v6 += 4;
                strcpy(v8, Str);
                v5 = v10;
            }
        } while (!_findnext(v5, (int)v11));
    }
    return _findclose((intptr_t)v5);
}

//----- (0043B2F0) --------------------------------------------------------
char __thiscall sub_43B2F0(_DWORD* this, int a2, int a3, int a4, int a5)
{
    char result; // al

    result = a2;
    if (a2 == this[13])
    {
        if (a3 >= this[12])
            return sub_421110(a4, AppName);
        else
            return sub_421110(a4, *(const char**)(this[11] + 4 * a3));
    }
    return result;
}

//----- (0043B330) --------------------------------------------------------
bool __thiscall sub_43B330(_DWORD* this)
{
    const char* v2; // edi
    const char* v3; // ebx
    const char* v4; // eax
    bool result; // al

    v2 = sub_424350(this, aArrowup);
    v3 = sub_424350(this, aArrowdown);
    v4 = sub_424350(this, aSavedgames_0);
    *((_BYTE*)v2 + 44) = *((_DWORD*)v4 + 32) > 0;
    result = *((_DWORD*)v4 + 32) + *((_DWORD*)v4 + 30) < *((_DWORD*)v4 + 33);
    *((_BYTE*)v3 + 44) = result;
    return result;
}

//----- (0043B390) --------------------------------------------------------
_DWORD* __thiscall sub_43B390(_DWORD* this, int a2)
{
    const char* v3; // eax
    const char* v4; // eax

    sub_4233C0((int)this, a2, aAddplayer);
    *this = &off_499630;
    this[12] = sub_424350(this, aEasybutton);
    v3 = sub_424350(this, aMediumbutton);
    this[13] = v3;
    *((_BYTE*)v3 + 172) = 1;
    this[14] = sub_424350(this, aHardbutton);
    v4 = sub_424350(this, aNameedit);
    this[11] = v4;
    sub_421110(*((_DWORD*)v4 + 28), AppName);
    this[15] = 1;
    return this;
}
// 499630: using guessed type _UNKNOWN *off_499630;

//----- (0043B440) --------------------------------------------------------
char __thiscall sub_43B440(int this, char* String1, int a3)
{
    char result; // al
    char v5[260]; // [esp+10h] [ebp-208h] BYREF
    char Buffer[260]; // [esp+114h] [ebp-104h] BYREF

    if (!String1)
        goto LABEL_10;
    if (!_strcmpi(String1, aCancelbutton))
    {
        sub_4261C0(*(_DWORD**)(this + 40), aNameentry, 0);
        return 1;
    }
    if (_strcmpi(String1, aOkbutton))
    {
    LABEL_10:
        if (String1 == *(char**)(this + 48))
        {
            *(_DWORD*)(this + 60) = 0;
            *(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 20) = 0;
            result = 1;
            *(_BYTE*)(*(_DWORD*)(this + 52) + 172) = 0;
            *(_BYTE*)(*(_DWORD*)(this + 56) + 172) = 0;
            return result;
        }
        if (String1 == *(char**)(this + 52))
        {
            *(_DWORD*)(this + 60) = 1;
            *(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 20) = 1;
            *(_BYTE*)(*(_DWORD*)(this + 48) + 172) = 0;
            result = 1;
            *(_BYTE*)(*(_DWORD*)(this + 56) + 172) = 0;
            return result;
        }
        if (String1 == *(char**)(this + 56))
        {
            *(_DWORD*)(this + 60) = 2;
            *(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 20) = 2;
            *(_BYTE*)(*(_DWORD*)(this + 48) + 172) = 0;
            *(_BYTE*)(*(_DWORD*)(this + 52) + 172) = 0;
        }
        return 1;
    }
    strcpy(v5, *(const char**)(*(_DWORD*)(*(_DWORD*)(this + 44) + 112) + 8));
    if (!v5[0])
        return 1;
    sprintf(Buffer, "Saved\\%s.sps", v5);
    if (sub_422AE0(Buffer))
        return 1;
    strcpy(String, v5);
    sub_422E60(AppName, aUsername, String);
    sub_4229D0("UI NameEntry: current name=%s", String);
    sub_45E720(*(_DWORD*)(dword_520970 + 280), String, *(_DWORD*)(this + 60));
    if (!sub_45E760(*(_DWORD*)(dword_520970 + 280)))
    {
        sub_45E720(*(_DWORD*)(dword_520970 + 280), String, *(_DWORD*)(this + 60));
        sub_45E880(*(_DWORD*)(dword_520970 + 280));
    }
    sub_422D00(AppName, aUsername, (CHAR*)0x18, String, Default);
    sub_421110(*(_DWORD*)(*(_DWORD*)(this + 44) + 112), String);
    sub_4262D0(*(int**)(dword_520970 + 232));
    sub_450AC0(dword_520970, 1, -1);
    return 1;
}
// 520970: using guessed type int dword_520970;

//----- (0043B6C0) --------------------------------------------------------
_DWORD* __thiscall sub_43B6C0(_DWORD* this, int a2)
{
    sub_4233C0((int)this, a2, aLevelselect);
    *this = &off_499668;
    return this;
}
// 499668: using guessed type _UNKNOWN *off_499668;

//----- (0043B6E0) --------------------------------------------------------
char __thiscall sub_43B6E0(_DWORD* this, int a2, int a3, int a4)
{
    const char* v4; // eax
    int v5; // ecx
    int v6; // edx

    v4 = sub_424350(this, aLevelhighscore);
    v5 = *(_DWORD*)(dword_520970 + 280);
    if (a4 > *(_DWORD*)(v5 + 496))
        v6 = 0;
    else
        v6 = *(_DWORD*)(*(_DWORD*)(v5 + 508) + 4 * a4);
    sub_421190(*((_DWORD*)v4 + 28), "%d", v6);
    return 1;
}
// 520970: using guessed type int dword_520970;

//----- (0043B730) --------------------------------------------------------
bool __thiscall sub_43B730(int this)
{
    int v2; // edi
    int v3; // ebp
    const char* v4; // esi
    int v5; // eax
    int v6; // ecx
    int v7; // eax
    int v8; // ebp
    const char* v9; // eax
    int v10; // esi
    int v11; // ecx
    int v12; // esi
    const char* v13; // esi
    int v14; // eax
    int v16; // [esp+10h] [ebp-4h]

    sub_424630(*(int**)(this + 40));
    v2 = *(_DWORD*)(16 * *(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 20) + *(_DWORD*)(dword_520970 + 236) + 28);
    v3 = *(_DWORD*)(*(_DWORD*)(dword_520970 + 280) + 496);
    v16 = v3;
    if (sub_422BA0(AppName, aShowalllevels, 0))
        v3 = v2 - 1;
    v4 = sub_424350((_DWORD*)this, aLevellist);
    v5 = v3 + 2;
    *((_DWORD*)v4 + 32) = 0;
    if (v3 + 2 >= v2)
        v5 = v2;
    *((_DWORD*)v4 + 33) = v5;
    v6 = v2 - 1;
    if (v16 + 1 < v2 - 1)
        v6 = v16 + 1;
    v7 = *((_DWORD*)v4 + 30);
    *((_DWORD*)v4 + 31) = v6;
    if (v6 > v7 - 1)
    {
        do
        {
            v8 = v7 + *((_DWORD*)v4 + 32);
            *((_DWORD*)v4 + 32) = v8;
        } while (v6 > v8 + v7 - 1);
    }
    *((_BYTE*)v4 + 136) = 1;
    v9 = sub_424350((_DWORD*)this, aLevelhighscore);
    v10 = *((_DWORD*)v4 + 31);
    v11 = *(_DWORD*)(dword_520970 + 280);
    if (v10 > *(_DWORD*)(v11 + 496))
        v12 = 0;
    else
        v12 = *(_DWORD*)(*(_DWORD*)(v11 + 508) + 4 * v10);
    sub_421190(*((_DWORD*)v9 + 28), "%d", v12);
    v13 = sub_424350((_DWORD*)this, aGamescore);
    v14 = sub_45EA60(*(_DWORD**)(dword_520970 + 280));
    sub_421190(*((_DWORD*)v13 + 28), "%d", v14);
    return sub_43B9E0((_DWORD*)this);
}
// 520970: using guessed type int dword_520970;

//----- (0043B870) --------------------------------------------------------
char __thiscall sub_43B870(int this, char* String1, int a3)
{
    int v5; // eax
    const char* v6; // eax
    int v7; // ecx
    int v8; // ecx
    int v9; // edx
    int v10; // ecx
    int v11; // edi

    if (!String1)
        return 1;
    if (!_strcmpi(String1, aCancelbutton))
    {
        sub_4261C0(*(_DWORD**)(this + 40), aNameentry, 0);
        return 1;
    }
    if (!_strcmpi(String1, aOkbutton))
    {
        v5 = *((_DWORD*)sub_424350((_DWORD*)this, aLevellist) + 31);
        byte_5216E4 = 0;
        *(_DWORD*)dword_5216E0 = v5;
        sub_4261C0(*(_DWORD**)(this + 40), aObjectives, 0);
        sub_4229D0("UI LevelSelect: launching mission %d", *(_DWORD*)dword_5216E0);
        return 1;
    }
    if (!_strcmpi(String1, aLevelup))
    {
        v6 = sub_424350((_DWORD*)this, aLevellist);
        v7 = *((_DWORD*)v6 + 32) - *((_DWORD*)v6 + 30);
        *((_DWORD*)v6 + 32) = v7;
        v8 = v7 < 0 ? 0 : v7;
        goto LABEL_11;
    }
    if (!_strcmpi(String1, aLeveldown))
    {
        v6 = sub_424350((_DWORD*)this, aLevellist);
        v9 = *((_DWORD*)v6 + 30);
        v10 = v9 + *((_DWORD*)v6 + 32);
        v11 = *((_DWORD*)v6 + 33) - 1;
        *((_DWORD*)v6 + 32) = v10;
        if (v10 <= v11)
        {
        LABEL_12:
            *((_BYTE*)v6 + 136) = 1;
            sub_43B9E0((_DWORD*)this);
            return 1;
        }
        v8 = v10 - v9;
    LABEL_11:
        *((_DWORD*)v6 + 32) = v8;
        goto LABEL_12;
    }
    return 1;
}
// 5216E4: using guessed type char byte_5216E4;

//----- (0043B9A0) --------------------------------------------------------
FILE* __stdcall sub_43B9A0(int a1, int ArgList, int a3, int a4)
{
    const char* v4; // esi

    v4 = (const char*)sub_45A870(*(_DWORD**)(dword_520970 + 236), ArgList);
    sub_421110(a3, v4);
    return sub_4229D0("%d: %s", ArgList, v4);
}
// 520970: using guessed type int dword_520970;

//----- (0043B9E0) --------------------------------------------------------
bool __thiscall sub_43B9E0(_DWORD* this)
{
    const char* v2; // edi
    const char* v3; // ebx
    const char* v4; // eax
    bool result; // al

    v2 = sub_424350(this, aLevelup);
    v3 = sub_424350(this, aLeveldown);
    v4 = sub_424350(this, aLevellist);
    *((_BYTE*)v2 + 44) = *((_DWORD*)v4 + 32) > 0;
    result = *((_DWORD*)v4 + 32) + *((_DWORD*)v4 + 30) < *((_DWORD*)v4 + 33);
    *((_BYTE*)v3 + 44) = result;
    return result;
}

//----- (0043BA40) --------------------------------------------------------
_DWORD* __thiscall sub_43BA40(_DWORD* this, int a2)
{
    sub_4233C0((int)this, a2, aConnectiontype);
    *this = &off_4996A0;
    return this;
}
// 4996A0: using guessed type _UNKNOWN *off_4996A0;

//----- (0043BA60) --------------------------------------------------------
char __thiscall sub_43BA60(_DWORD** this, char* String1, int a3)
{
    char result; // al

    if (!String1)
        return 1;
    if (!_strcmpi(String1, aCancelbutton))
    {
        sub_4261C0(this[10], aMainmenu, 0);
        return 1;
    }
    if (_strcmpi(String1, aTcpipbutton))
    {
        if (_strcmpi(String1, aIpxbutton))
            return 1;
        sub_4261C0(this[10], aNetnameentry, 0);
        result = 1;
        byte_521684 = 1;
    }
    else
    {
        sub_4261C0(this[10], aNetnameentry, 0);
        byte_521684 = 0;
        return 1;
    }
    return result;
}
// 521684: using guessed type char byte_521684;

//----- (0043BAF0) --------------------------------------------------------
char __thiscall sub_43BAF0(_DWORD* this, char* String1)
{
    const char* v2; // eax
    const char* v3; // esi

    v2 = sub_424350(this, aHelptext);
    v3 = v2;
    if (v2)
    {
        v2 = (const char*)*((_DWORD*)v2 + 28);
        if (v2)
        {
            if (String1)
            {
                if (!_strcmpi(String1, aTcpipbutton))
                {
                    LOBYTE(v2) = sub_421110(*((_DWORD*)v3 + 28), aInternetTcpIpC);
                    return (char)v2;
                }
                if (!_strcmpi(String1, aIpxbutton))
                {
                    LOBYTE(v2) = sub_421110(*((_DWORD*)v3 + 28), aLanIpxClickThi);
                    return (char)v2;
                }
            }
            LOBYTE(v2) = sub_421110(*((_DWORD*)v3 + 28), aMoveTheCursorO);
        }
    }
    return (char)v2;
}

//----- (0043BB70) --------------------------------------------------------
_DWORD* __thiscall sub_43BB70(_DWORD* this, int a2)
{
    sub_4233C0((int)this, a2, aNetnameentry);
    *this = &off_4996D8;
    return this;
}
// 4996D8: using guessed type _UNKNOWN *off_4996D8;

//----- (0043BB90) --------------------------------------------------------
char __thiscall sub_43BB90(int this)
{
    const char* v2; // eax
    const char* v3; // esi

    sub_424630(*(int**)(this + 40));
    v2 = sub_424350((_DWORD*)this, aNameedit);
    v3 = v2;
    if (v2)
    {
        sub_422D00(AppName, aNetusername, (CHAR*)0x18, String, Default);
        LOBYTE(v2) = sub_421110(*((_DWORD*)v3 + 28), String);
    }
    return (char)v2;
}

//----- (0043BBE0) --------------------------------------------------------
char __thiscall sub_43BBE0(_DWORD* this)
{
    char v2[260]; // [esp+Ch] [ebp-104h] BYREF

    strcpy(v2, *(const char**)(*((_DWORD*)sub_424350(this, aNameedit) + 28) + 8));
    if (!strcmp(v2, AppName))
        return 0;
    strcpy(String, v2);
    sub_422E60(AppName, aNetusername, String);
    strcpy((char*)(dword_4F5CC4 + 140), String);
    strcpy((char*)(dword_4F5CC4 + 400), String);
    sub_4229D0(aUiNetnameentry, String);
    return 1;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (0043BD20) --------------------------------------------------------
char __thiscall sub_43BD20(int this, char* String1, int a3)
{
    if (String1)
    {
        if (!_strcmpi(String1, aCancelbutton))
        {
            sub_4261C0(*(_DWORD**)(this + 40), aConnectiontype, 0);
            return 1;
        }
        if (!_strcmpi(String1, aOkbutton) && sub_43BBE0((_DWORD*)this))
        {
            if (byte_521684)
            {
                sub_4261C0(*(_DWORD**)(this + 40), aIpx, 0);
                return 1;
            }
            sub_4261C0(*(_DWORD**)(this + 40), aTcpip, 0);
        }
    }
    return 1;
}
// 521684: using guessed type char byte_521684;

//----- (0043BDB0) --------------------------------------------------------
_DWORD* __thiscall sub_43BDB0(_DWORD* this, int a2)
{
    _DWORD* v3; // esi
    int v4; // edi
    _BYTE* v5; // eax

    sub_4233C0((int)this, a2, aIpx);
    v3 = this + 12;
    *this = &off_499710;
    memset(this + 12, 0, 0x40u);
    v4 = 16;
    do
    {
        v5 = operator new(0x104u);
        *v3++ = v5;
        --v4;
        *v5 = 0;
    } while (v4);
    return this;
}
// 499710: using guessed type _UNKNOWN *off_499710;

//----- (0043BE50) --------------------------------------------------------
void __thiscall sub_43BE50(LPVOID* this)
{
    LPVOID* v2; // esi
    int v3; // edi

    *this = &off_499710;
    v2 = this + 12;
    v3 = 16;
    do
    {
        sub_4885A6(*v2++);
        --v3;
    } while (v3);
    sub_4234A0(this);
}
// 499710: using guessed type _UNKNOWN *off_499710;

//----- (0043BE80) --------------------------------------------------------
void __thiscall sub_43BE80(int this)
{
    const char* v2; // eax
    int v3; // [esp+4h] [ebp-14h] BYREF
    LPVOID lpMem; // [esp+8h] [ebp-10h]
    int v5; // [esp+14h] [ebp-4h]

    sub_424630(*(int**)(this + 40));
    v2 = sub_424350((_DWORD*)this, aHostlist);
    *(_DWORD*)(this + 44) = v2;
    *((_DWORD*)v2 + 33) = 0;
    *(_DWORD*)(this + 112) = 0;
    sub_4229D0(aUiIpxSearchFor);
    sub_40F7B0(dword_4F5CC4, &v3);
    v5 = 0;
    if (v3)
    {
        sub_4229D0(aUiIpxUnableToS);
        strcpy(byte_520D40, aNameentry);
        strcpy(byte_520D80, aUnableToSearch);
        strcpy(byte_521180, (const char*)lpMem);
        sub_4261C0(*(_DWORD**)(this + 40), aErrormsg, 0);
    }
    sub_488CEE(lpMem);
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (0043BFA0) --------------------------------------------------------
FILE* sub_43BFA0()
{
    sub_4229D0(aUiIpxDeactivat);
    return sub_40FC90((struct _RTL_CRITICAL_SECTION*)dword_4F5CC4);
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (0043BFC0) --------------------------------------------------------
char __thiscall sub_43BFC0(int this, char* String1, int a3)
{
    int v4; // eax
    char* v5; // ecx
    char* v7; // [esp-8h] [ebp-134h]
    int v8; // [esp+Ch] [ebp-120h] BYREF
    char* v9; // [esp+10h] [ebp-11Ch]
    int v10; // [esp+14h] [ebp-118h] BYREF
    LPVOID lpMem; // [esp+18h] [ebp-114h]
    char ArgList[260]; // [esp+1Ch] [ebp-110h] BYREF
    int v13; // [esp+128h] [ebp-4h]

    if (String1)
    {
        if (_strcmpi(String1, aCancelbutton))
        {
            if (_strcmpi(String1, aJoinbutton))
            {
                if (_strcmpi(String1, aCreatebutton))
                    return 1;
                sub_4229D0("UI IPX: hosting game %s", String);
                sub_4246F0(*(int**)(this + 40));
                sub_40FEE0(dword_4F5CC4, &v8);
                v13 = 1;
                if (v8)
                {
                    sub_4229D0("UI IPX: unable to host game %s - %s", String, v9);
                    strcpy(byte_520D40, aIpx);
                    strcpy(byte_520D80, aUnableToHost);
                    v7 = aErrormsg;
                    strcpy(byte_521180, v9);
                }
                else
                {
                    sub_4229D0(aUiIpxSuccessHo);
                    *(_BYTE*)(dword_4F5CC4 + 108) = 1;
                    v7 = aStaging;
                }
                sub_4261C0(*(_DWORD**)(this + 40), v7, 0);
                v5 = v9;
            }
            else
            {
                sub_4246F0(*(int**)(this + 40));
                v4 = *(_DWORD*)(*(_DWORD*)(this + 44) + 124);
                if (v4 >= *(_DWORD*)(this + 112))
                    return 1;
                strcpy(ArgList, *(const char**)(this + 4 * v4 + 48));
                sub_4229D0("UI IPX: attempt to join host %s", ArgList);
                sub_40FDD0(dword_4F5CC4, &v10, ArgList);
                v13 = 0;
                if (v10)
                {
                    sub_4229D0("UI IPX: failed to join host %s - %s", ArgList, (const char*)lpMem);
                    strcpy(byte_520D40, aIpx);
                    strcpy(byte_520D80, aUnableToConnec);
                    strcpy(byte_521180, (const char*)lpMem);
                    sub_4261C0(*(_DWORD**)(this + 40), aErrormsg, 0);
                }
                else
                {
                    sub_4261C0(*(_DWORD**)(this + 40), aConnecting, 0);
                }
                v5 = (char*)lpMem;
            }
            sub_488CEE(v5);
            return 1;
        }
        sub_4261C0(*(_DWORD**)(this + 40), aNetnameentry, 0);
    }
    return 1;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (0043C290) --------------------------------------------------------
char __thiscall sub_43C290(int this, int a2)
{
    double v3; // st7
    int v4; // ecx
    int v5; // eax
    int v6; // ecx
    int v7; // edi
    int v8; // edx
    const char** v10; // [esp+4h] [ebp-10Ch]
    int v11; // [esp+8h] [ebp-108h]
    char v12[260]; // [esp+Ch] [ebp-104h] BYREF

    v3 = *(float*)(this + 116) - *(float*)(dword_520970 + 68);
    *(float*)(this + 116) = v3;
    if (v3 < 0.0)
    {
        v4 = *(_DWORD*)(this + 44);
        *(_DWORD*)(this + 116) = 0x40000000;
        strcpy(v12, *(const char**)(this + 4 * *(_DWORD*)(v4 + 124) + 48));
        v5 = sub_40FD50((struct _RTL_CRITICAL_SECTION*)dword_4F5CC4, (char**)(this + 48), 16);
        v6 = *(_DWORD*)(this + 44);
        *(_DWORD*)(this + 112) = v5;
        v7 = 0;
        *(_DWORD*)(v6 + 132) = v5;
        v11 = 0;
        *(_BYTE*)(*(_DWORD*)(this + 44) + 136) = 1;
        v8 = *(_DWORD*)(this + 112);
        if (v8 > 0)
        {
            v10 = (const char**)(this + 48);
            do
            {
                if (!strcmp(*v10, v12))
                    v11 = v7;
                ++v7;
                ++v10;
            } while (v7 < v8);
        }
        *(_DWORD*)(*(_DWORD*)(this + 44) + 124) = v11;
    }
    return sub_428620((_DWORD*)this, a2);
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (0043C3A0) --------------------------------------------------------
char __thiscall sub_43C3A0(_DWORD* this, int a2, int a3, int a4, int a5)
{
    char result; // al

    result = a2;
    if (a2 == this[11])
    {
        result = a3;
        if (a3 < this[28])
            return sub_421110(a4, (const char*)this[a3 + 12]);
    }
    return result;
}

//----- (0043C3D0) --------------------------------------------------------
_DWORD* __thiscall sub_43C3D0(_DWORD* this, int a2)
{
    const char* v3; // eax
    int v4; // eax
    const char* v5; // eax
    int v6; // eax

    sub_4233C0((int)this, a2, aTcpip);
    *this = &off_499748;
    v3 = sub_424350(this, aHelptext);
    if (v3)
    {
        v4 = *((_DWORD*)v3 + 28);
        if (v4)
            sub_421110(v4, aToHostANewGame);
    }
    v5 = sub_424350(this, aUserip);
    if (v5)
    {
        v6 = *((_DWORD*)v5 + 28);
        if (v6)
            sub_421110(v6, byte_520A60);
    }
    return this;
}
// 499748: using guessed type _UNKNOWN *off_499748;

//----- (0043C470) --------------------------------------------------------
char __thiscall sub_43C470(int this)
{
    const char* v2; // eax
    const char* v3; // esi
    CHAR ReturnedString[16]; // [esp+4h] [ebp-10h] BYREF

    sub_424630(*(int**)(this + 40));
    v2 = sub_424350((_DWORD*)this, aHostip);
    v3 = v2;
    if (v2)
    {
        v2 = (const char*)*((_DWORD*)v2 + 28);
        if (v2)
        {
            sub_422D00(AppName, aHostip, (CHAR*)0x10, ReturnedString, a127001);
            LOBYTE(v2) = sub_421110(*((_DWORD*)v3 + 28), ReturnedString);
        }
    }
    return (char)v2;
}

//----- (0043C4D0) --------------------------------------------------------
char __thiscall sub_43C4D0(int this, char* String1, int a3)
{
    const char* v4; // esi
    char* v6; // [esp-8h] [ebp-30h]
    int v7; // [esp+Ch] [ebp-1Ch] BYREF
    char* v8; // [esp+10h] [ebp-18h]
    int v9; // [esp+14h] [ebp-14h] BYREF
    LPVOID lpMem; // [esp+18h] [ebp-10h]
    int v11; // [esp+24h] [ebp-4h]

    if (String1)
    {
        if (_strcmpi(String1, aCancelbutton))
        {
            if (_strcmpi(String1, aJoinbutton))
            {
                if (!_strcmpi(String1, aCreatebutton))
                {
                    sub_4246F0(*(int**)(this + 40));
                    sub_43EF90((void*)dword_4F5CC4, &v9, 52973);
                    v11 = 1;
                    if (v9)
                    {
                        v6 = aErrormsg;
                        strcpy(byte_520D40, aTcpip_0);
                        strcpy(byte_520D80, aUnableToHost);
                        strcpy(byte_521180, (const char*)lpMem);
                    }
                    else
                    {
                        v6 = aStaging;
                        *(_BYTE*)(dword_4F5CC4 + 108) = 1;
                    }
                    sub_4261C0(*(_DWORD**)(this + 40), v6, 0);
                    sub_488CEE(lpMem);
                }
            }
            else
            {
                sub_4246F0(*(int**)(this + 40));
                v4 = sub_424350((_DWORD*)this, aHostip);
                if (v4)
                {
                    sub_422E60(AppName, aHostip, *(LPCSTR*)(*((_DWORD*)v4 + 28) + 8));
                    sub_43EFC0((void*)dword_4F5CC4, &v7, *(const CHAR**)(*((_DWORD*)v4 + 28) + 8), 52973);
                    v11 = 0;
                    if (v7)
                    {
                        strcpy(byte_520D40, aTcpip_0);
                        strcpy(byte_520D80, aUnableToConnec);
                        strcpy(byte_521180, v8);
                        sub_4261C0(*(_DWORD**)(this + 40), aErrormsg, 0);
                    }
                    else
                    {
                        sub_4261C0(*(_DWORD**)(this + 40), aConnecting, 0);
                    }
                    sub_488CEE(v8);
                }
            }
        }
        else
        {
            sub_4261C0(*(_DWORD**)(this + 40), aNetnameentry, 0);
        }
    }
    return 1;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (0043C730) --------------------------------------------------------
_DWORD* __thiscall sub_43C730(_DWORD* this, int a2)
{
    sub_4233C0((int)this, a2, aTelegram);
    *this = &off_499780;
    this[11] = 0;
    return this;
}
// 499780: using guessed type _UNKNOWN *off_499780;

//----- (0043C760) --------------------------------------------------------
char __thiscall sub_43C760(int* this)
{
    _DWORD* v2; // eax
    _DWORD* v3; // eax
    char result; // al
    float v5; // [esp+0h] [ebp-18h]

    v2 = operator new(0x15Cu);
    if (v2)
        v3 = sub_41C6A0(v2);
    else
        v3 = 0;
    this[11] = (int)v3;
    sub_41C7A0((int)v3, 1);
    sub_41C760(this[11], aSoundsMissionf);
    *(_BYTE*)this[11] = 0;
    sub_41CA40(this[11]);
    v5 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
    sub_41CFD0(this[11], v5);
    result = sub_41CD90(this[11]);
    this[12] = 1084227584;
    return result;
}

//----- (0043C820) --------------------------------------------------------
void __thiscall sub_43C820(int* this)
{
    int v2; // ecx
    void* v3; // edi

    v2 = this[11];
    if (v2)
    {
        sub_41CF50(v2);
        v3 = (void*)this[11];
        if (v3)
        {
            sub_41C700(this[11]);
            sub_4885A6(v3);
        }
        this[11] = 0;
    }
}

//----- (0043C860) --------------------------------------------------------
char __thiscall sub_43C860(int this, int a2, int a3)
{
    if ((_BYTE)a3 && *(float*)(this + 48) == 0.0)
        sub_43C930((int**)this);
    return sub_4285F0((_DWORD*)this, a2, a3);
}

//----- (0043C8A0) --------------------------------------------------------
char __thiscall sub_43C8A0(int this, int a2, int a3)
{
    if ((_BYTE)a3 && *(float*)(this + 48) == 0.0)
        sub_43C930((int**)this);
    return sub_428590((_DWORD*)this, a2, a3);
}

//----- (0043C8E0) --------------------------------------------------------
char __userpurge sub_43C8E0@<al>(int a1@<ecx>, int a2@<ebp>, int a3)
{
    int v4; // ecx
    double v5; // st7

    v4 = *(_DWORD*)(a1 + 44);
    if (v4)
        sub_41D0C0(v4, a2, *(float*)(dword_520970 + 68));
    v5 = *(float*)(a1 + 48) - *(float*)(dword_520970 + 68);
    *(float*)(a1 + 48) = v5;
    if (v5 < 0.0)
        *(_DWORD*)(a1 + 48) = 0;
    return sub_428620((_DWORD*)a1, a3);
}
// 520970: using guessed type int dword_520970;

//----- (0043C930) --------------------------------------------------------
char __thiscall sub_43C930(int** this)
{
    if (*(_BYTE*)(dword_4F5CC4 + 936) || *(_BYTE*)(dword_4F5CC4 + 937))
    {
        sub_4262D0(this[10]);
        return sub_45AB70(*(_DWORD**)(dword_520970 + 236));
    }
    else
    {
        sub_45ABF0(*(_DWORD*)(dword_520970 + 236));
        return sub_4261C0(this[10], aLevelselect, 0);
    }
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (0043C990) --------------------------------------------------------
int __thiscall sub_43C990(int this, int a2)
{
    const char* v3; // eax
    const char* v4; // eax

    sub_4233C0(this, a2, aObjectives);
    *(_DWORD*)(this + 44) = 0;
    *(_DWORD*)(this + 48) = 0;
    *(_DWORD*)(this + 52) = 0;
    *(_BYTE*)(this + 56) = 1;
    *(_DWORD*)this = &off_4997B8;
    v3 = sub_424350((_DWORD*)this, aTitle);
    *(_DWORD*)(this + 68) = v3;
    sub_421110(*((_DWORD*)v3 + 28), AppName);
    v4 = sub_424350((_DWORD*)this, aObjectivetext);
    *(_DWORD*)(this + 72) = v4;
    *((_BYTE*)v4 + 45) = 0;
    *(_DWORD*)(this + 60) = 0;
    *(_DWORD*)(this + 64) = 0;
    *(_DWORD*)(this + 76) = 0;
    return this;
}
// 4997B8: using guessed type _UNKNOWN *off_4997B8;

//----- (0043CA50) --------------------------------------------------------
void __thiscall sub_43CA50(int this)
{
    int i; // edi
    void* v3; // eax

    if (*(_BYTE*)(this + 56))
    {
        for (i = 0; i < *(_DWORD*)(this + 48); ++i)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 44) + 4 * i));
    }
    memset(*(void**)(this + 44), 0, 4 * *(_DWORD*)(this + 48));
    v3 = *(void**)(this + 44);
    *(_DWORD*)(this + 48) = 0;
    sub_488CEE(v3);
    *(_DWORD*)(this + 52) = 0;
    *(_DWORD*)(this + 44) = 0;
    sub_4234A0((void*)this);
}

//----- (0043CAC0) --------------------------------------------------------
char __thiscall sub_43CAC0(_DWORD* this, int a2, int a3, int a4, int a5)
{
    int v5; // eax

    LOBYTE(v5) = a2;
    if (a2 == this[18])
    {
        v5 = this[15];
        if (v5)
        {
            if (a3 < *(_DWORD*)(v5 + 8))
                LOBYTE(v5) = sub_421110(a4, *(const char**)(*(_DWORD*)(v5 + 12) + 4 * a3 + 4));
        }
    }
    return v5;
}

//----- (0043CB00) --------------------------------------------------------
int __thiscall sub_43CB00(_DWORD* this)
{
    _DWORD* v1; // esi
    int result; // eax
    int v3; // ebp
    int v4; // edi
    int v5; // ebx
    void* v6; // ebx
    int v7; // eax
    int v8; // ecx
    int v9; // eax
    char* v10; // eax
    int v11; // edi
    int v12; // ecx
    int v13; // [esp+8h] [ebp-238h] BYREF
    int v14; // [esp+Ch] [ebp-234h]
    _DWORD* v15; // [esp+10h] [ebp-230h]
    _DWORD v16[72]; // [esp+14h] [ebp-22Ch] BYREF
    char Buffer[256]; // [esp+134h] [ebp-10Ch] BYREF
    int v18; // [esp+23Ch] [ebp-4h]

    v1 = this;
    v15 = this;
    this[16] = sub_403620((_DWORD*)dword_4B5AB0, aCommander);
    result = v1[12];
    v3 = 0;
    if (!result)
    {
        sub_40A1D0((int)v16, aObjectivedialo);
        v13 = 0;
        v4 = 0;
        v18 = 0;
        if (*(int*)(16 * *(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 20) + *(_DWORD*)(dword_520970 + 236) + 28) > 0)
        {
            do
            {
                v5 = v4 + 1;
                v14 = v4 + 1;
                sprintf(Buffer, "mission %d", v4 + 1);
                if (sub_40AAF0(v16, Buffer, 0))
                {
                    v6 = operator new(0x10u);
                    *(_DWORD*)v6 = v4;
                    *((_DWORD*)v6 + 3) = 0;
                    *((_DWORD*)v6 + 2) = 0;
                    sub_40AA40((int)v16, Buffer);
                    for (; sub_40ABC0(v16, aLine, 0); ++*((_DWORD*)v6 + 2))
                        sub_40AFC0(v16, aLine, &v13);
                    *((_DWORD*)v6 + 3) = operator new(4 * *((_DWORD*)v6 + 2));
                    sub_40ADB0(v16);
                    if (sub_40ABC0(v16, aLine, 0))
                    {
                        do
                        {
                            sub_40AFC0(v16, aLine, &v13);
                            *(_DWORD*)(*((_DWORD*)v6 + 3) + v3) = operator new(strlen((const char*)v13) + 1);
                            strcpy(*(char**)(*((_DWORD*)v6 + 3) + v3), (const char*)v13);
                            v3 += 4;
                        } while (sub_40ABC0(v16, aLine, 0));
                        v1 = v15;
                        v3 = 0;
                    }
                    sub_40AF00((const char*)v16, aDialogue, (char**)v6 + 1);
                    v7 = v1[13];
                    v8 = v1[12] + 1;
                    v1[12] = v8;
                    if (v8 > v7)
                    {
                        v9 = v7 + 8;
                        v1[13] = v9;
                        v10 = (char*)sub_488DD7((LPVOID)v1[11], 4 * v9);
                        if (v10)
                        {
                            v11 = v1[12];
                            v12 = v1[13] - v11;
                            v1[11] = v10;
                            memset(&v10[4 * v11], 0, 4 * v12);
                        }
                    }
                    *(_DWORD*)(v1[11] + 4 * v1[12] - 4) = v6;
                    v5 = v14;
                }
                v4 = v5;
            } while (v5 < *(_DWORD*)(16 * *(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 20)
                + *(_DWORD*)(dword_520970 + 236)
                + 28));
        }
        while (sub_40AAF0(v16, aControl, 0))
            sub_40AA40((int)v16, aControl);
        v18 = -1;
        return sub_40A830((int)v16);
    }
    return result;
}
// 4B5AB0: using guessed type int dword_4B5AB0;
// 520970: using guessed type int dword_520970;

//----- (0043CDB0) --------------------------------------------------------
char __userpurge sub_43CDB0@<al>(_DWORD* a1@<ecx>, int a2@<ebp>, int a3)
{
    int v4; // ecx

    v4 = a1[19];
    if (v4)
        sub_41D0C0(v4, a2, *(float*)(dword_520970 + 68));
    return sub_428620(a1, a3);
}
// 520970: using guessed type int dword_520970;

//----- (0043CDE0) --------------------------------------------------------
int __thiscall sub_43CDE0(int this)
{
    _DWORD* v2; // eax
    _DWORD* v3; // eax
    int v4; // eax
    _DWORD** v5; // edx
    _DWORD* v6; // ecx
    int v7; // eax
    float v9; // [esp+0h] [ebp-20h]

    sub_4246F0(*(int**)(this + 40));
    if (*(_BYTE*)(dword_4F5CC4 + 936) || *(_BYTE*)(dword_4F5CC4 + 937))
        return sub_4262D0(*(int**)(this + 40));
    v2 = operator new(0x15Cu);
    if (v2)
        v3 = sub_41C6A0(v2);
    else
        v3 = 0;
    *(_DWORD*)(this + 76) = v3;
    sub_41C7A0((int)v3, 1);
    sub_41C760(*(_DWORD*)(this + 76), aSoundsWarmapLo);
    **(_BYTE**)(this + 76) = 1;
    sub_41CA40(*(_DWORD*)(this + 76));
    v9 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
    sub_41CFD0(*(_DWORD*)(this + 76), v9);
    sub_41CD90(*(_DWORD*)(this + 76));
    sub_43CB00((_DWORD*)this);
    *(_DWORD*)(this + 60) = 0;
    v4 = 0;
    if (*(int*)(this + 48) > 0)
    {
        v5 = *(_DWORD***)(this + 44);
        do
        {
            v6 = *v5;
            *(_DWORD*)(this + 60) = *v5;
            if (*v6 == *(_DWORD*)dword_5216E0)
                break;
            *(_DWORD*)(this + 60) = 0;
            ++v4;
            ++v5;
        } while (v4 < *(_DWORD*)(this + 48));
    }
    v7 = *(_DWORD*)(this + 60);
    if (!v7)
        return sub_4262D0(*(int**)(this + 40));
    *(_DWORD*)(*(_DWORD*)(this + 72) + 132) = *(_DWORD*)(v7 + 8) - 1;
    *(_DWORD*)(*(_DWORD*)(this + 72) + 128) = 0;
    *(_BYTE*)(*(_DWORD*)(this + 72) + 136) = 1;
    *(_DWORD*)(*(_DWORD*)(this + 72) + 124) = 0;
    sub_421110(*(_DWORD*)(*(_DWORD*)(this + 68) + 112), **(const char***)(*(_DWORD*)(this + 60) + 12));
    return sub_4030B0(*(_DWORD**)(this + 64), 1065353216, aCommanderspeci, *(_DWORD*)(*(_DWORD*)(this + 60) + 4) - 1);
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (0043CF70) --------------------------------------------------------
void __thiscall sub_43CF70(_DWORD* this)
{
    int v2; // ecx
    void* v3; // edi
    int v4; // ecx
    int v5; // esi
    int v6; // eax

    v2 = this[19];
    if (v2)
    {
        sub_41CF50(v2);
        v3 = (void*)this[19];
        if (v3)
        {
            sub_41C700(this[19]);
            sub_4885A6(v3);
        }
        this[19] = 0;
    }
    v4 = this[16];
    if (v4)
        sub_402FC0(v4);
    if (byte_5216E4)
    {
        sub_45A9D0(*(_DWORD**)(dword_520970 + 236));
    }
    else
    {
        sub_45ABF0(*(_DWORD*)(dword_520970 + 236));
        v5 = rand() % 10;
        v6 = rand();
        sub_45A890(*(_DWORD**)(dword_520970 + 236), *(int*)dword_5216E0, v6 % 10, v5);
    }
}
// 520970: using guessed type int dword_520970;
// 5216E4: using guessed type char byte_5216E4;

//----- (0043D010) --------------------------------------------------------
char __thiscall sub_43D010(int** this, char* String1, int a3)
{
    if (String1 && !_strcmpi(String1, aOkbutton))
        sub_4262D0(this[10]);
    return 1;
}

//----- (0043D040) --------------------------------------------------------
_DWORD* __thiscall sub_43D040(_DWORD* this, int a2)
{
    sub_4233C0((int)this, a2, aHelpscreen);
    *this = &off_4997F0;
    return this;
}
// 4997F0: using guessed type _UNKNOWN *off_4997F0;

//----- (0043D060) --------------------------------------------------------
char __thiscall sub_43D060(_DWORD* this)
{
    const char* v2; // eax
    const char* v3; // eax

    v2 = sub_424350(this, aHelptext1);
    sub_421110(*((_DWORD*)v2 + 28), aAirStrikeTorpe);
    v3 = sub_424350(this, aHelptext2);
    return sub_421110(*((_DWORD*)v3 + 28), aQAWTEBSpaceMou);
}

//----- (0043D0A0) --------------------------------------------------------
char __thiscall sub_43D0A0(int** this, char* String1, int a3)
{
    if (!_strcmpi(String1, aOkbutton_0))
        sub_4262D0(this[10]);
    return 1;
}

//----- (0043D0D0) --------------------------------------------------------
_DWORD* __thiscall sub_43D0D0(_DWORD* this, int a2)
{
    sub_4233C0((int)this, a2, aDeletechar);
    *this = &off_499828;
    return this;
}
// 499828: using guessed type _UNKNOWN *off_499828;

//----- (0043D0F0) --------------------------------------------------------
char __thiscall sub_43D0F0(int this)
{
    const char* v2; // eax
    const char* v3; // eax

    sub_424630(*(int**)(this + 40));
    v2 = sub_424350((_DWORD*)this, aLine1);
    if (v2)
        sub_421110(*((_DWORD*)v2 + 28), aAreYouSureYouW);
    v3 = sub_424350((_DWORD*)this, aLine2);
    if (v3)
        LOBYTE(v3) = sub_421190(*((_DWORD*)v3 + 28), "saved game '%s'?", byte_521580);
    return (char)v3;
}

//----- (0043D140) --------------------------------------------------------
char __thiscall sub_43D140(_DWORD** this, char* String1, int a3)
{
    char Buffer[260]; // [esp+8h] [ebp-104h] BYREF

    if (String1)
    {
        if (!_strcmpi(String1, aOkbutton))
        {
            sprintf(Buffer, ".\\Saved\\%s.sps", byte_521580);
            if (sub_422AE0(Buffer))
                DeleteFileA(Buffer);
            goto LABEL_6;
        }
        if (!_strcmpi(String1, aCancelbutton))
            LABEL_6:
        sub_4261C0(this[10], aNameentry, 0);
    }
    return 1;
}

//----- (0043D1D0) --------------------------------------------------------
_DWORD* __thiscall sub_43D1D0(_DWORD* this, int a2)
{
    sub_4233C0((int)this, a2, aErrormsg);
    *this = &off_499860;
    return this;
}
// 499860: using guessed type _UNKNOWN *off_499860;

//----- (0043D1F0) --------------------------------------------------------
char __thiscall sub_43D1F0(int this)
{
    const char* v2; // eax
    const char* v3; // eax

    sub_424630(*(int**)(this + 40));
    v2 = sub_424350((_DWORD*)this, aErrormsg1);
    if (v2)
        sub_421110(*((_DWORD*)v2 + 28), byte_520D80);
    v3 = sub_424350((_DWORD*)this, aErrormsg2);
    if (v3)
        LOBYTE(v3) = sub_421110(*((_DWORD*)v3 + 28), byte_521180);
    return (char)v3;
}

//----- (0043D240) --------------------------------------------------------
char __thiscall sub_43D240(_DWORD** this, char* String1, int a3)
{
    if (String1 && !_strcmpi(String1, aOkbutton))
        sub_4261C0(this[10], byte_520D40, 0);
    return 1;
}

//----- (0043D280) --------------------------------------------------------
_DWORD* __thiscall sub_43D280(_DWORD* this, int a2)
{
    sub_4233C0((int)this, a2, aConnecting);
    *this = &off_499898;
    this[12] = sub_424350(this, aErrormsg1);
    this[13] = sub_424350(this, aErrormsg2);
    return this;
}
// 499898: using guessed type _UNKNOWN *off_499898;

//----- (0043D2F0) --------------------------------------------------------
char __thiscall sub_43D2F0(_DWORD** this, char* String1, int a3)
{
    if (String1 && !_strcmpi(String1, aCancelbutton))
    {
        sub_411C50(dword_4F5CC4);
        sub_4261C0(this[10], aConnectiontype, 0);
        byte_520C3C = 0;
    }
    return 1;
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520C3C: using guessed type char byte_520C3C;

//----- (0043D340) --------------------------------------------------------
char __thiscall sub_43D340(int this, int a2)
{
    double v3; // st7
    int v5; // [esp+4h] [ebp-1Ch] BYREF
    LPVOID v6; // [esp+8h] [ebp-18h]
    LPVOID v7[2]; // [esp+Ch] [ebp-14h] BYREF
    int v8; // [esp+1Ch] [ebp-4h]

    v3 = *(float*)(this + 44) - *(float*)(dword_520970 + 68);
    *(float*)(this + 44) = v3;
    if (v3 < 0.0)
    {
        sub_43EFF0((_DWORD*)dword_4F5CC4, &v5);
        v8 = 0;
        if (v5)
        {
            if (v5 == 1)
            {
                sub_4261C0(*(_DWORD**)(this + 40), aStaging, 0);
            }
            else if (v5 == 888)
            {
                if (byte_520C3C[0])
                {
                    sub_43EFC0((void*)dword_4F5CC4, v7, byte_520C3C, 52973);
                    sub_488CEE(v7[1]);
                }
            }
            else if (v5 > 1)
            {
                sub_421110(*(_DWORD*)(*(_DWORD*)(this + 48) + 112), (const char*)v6);
                *(_DWORD*)(this + 44) = 2139095039;
            }
        }
        else
        {
            *(_DWORD*)(this + 44) = 1056964608;
        }
        v8 = -1;
        sub_488CEE(v6);
    }
    return sub_428620((_DWORD*)this, a2);
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (0043D450) --------------------------------------------------------
_DWORD* __thiscall sub_43D450(_DWORD* this, int a2)
{
    sub_4233C0((int)this, a2, aMissionfailed);
    *this = &off_4998D0;
    return this;
}
// 4998D0: using guessed type _UNKNOWN *off_4998D0;

//----- (0043D480) --------------------------------------------------------
const char* __thiscall sub_43D480(int this)
{
    const char* v2; // edi
    const char* result; // eax
    bool v4; // cl

    sub_424630(*(int**)(this + 40));
    v2 = sub_424350((_DWORD*)this, aRetrybutton);
    result = sub_424350((_DWORD*)this, aAbortbutton);
    v4 = *(_BYTE*)(dword_4F5CC4 + 937) == 0;
    *((_BYTE*)result + 44) = v4;
    *((_BYTE*)v2 + 44) = v4;
    return result;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (0043D4D0) --------------------------------------------------------
char __thiscall sub_43D4D0(int** this, char* String1, int a3)
{
    if (String1)
    {
        if (!_strcmpi(String1, aRetrybutton_0))
        {
            sub_4262D0(this[10]);
            sub_45AA80(*(_DWORD**)(dword_520970 + 236));
            return 1;
        }
        if (!_strcmpi(String1, aAbortbutton_0))
        {
            sub_4262D0(this[10]);
            if (*(_BYTE*)(dword_4F5CC4 + 936) || *(_BYTE*)(dword_4F5CC4 + 937))
            {
                sub_45B2B0(*(_DWORD*)(dword_520970 + 236), aStaging);
                return 1;
            }
            sub_45B2B0(*(_DWORD*)(dword_520970 + 236), aLevelselect);
        }
    }
    return 1;
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (0043D580) --------------------------------------------------------
_DWORD* __thiscall sub_43D580(_DWORD* this, int a2)
{
    sub_4233C0((int)this, a2, aIngamemenu);
    *this = &off_499908;
    return this;
}
// 499908: using guessed type _UNKNOWN *off_499908;

//----- (0043D5A0) --------------------------------------------------------
void __thiscall sub_43D5A0(_BYTE* this)
{
    this[44] = 1;
}

//----- (0043D5B0) --------------------------------------------------------
char __thiscall sub_43D5B0(int this, int a2)
{
    *(_BYTE*)(this + 44) = 0;
    return sub_428620((_DWORD*)this, a2);
}

//----- (0043D5D0) --------------------------------------------------------
char __thiscall sub_43D5D0(int this, char* String1, int a3)
{
    int v5; // esi
    int v6; // edi
    int v7; // eax

    if (*(_BYTE*)(this + 44))
        return 0;
    if (!String1)
        return 1;
    if (!_strcmpi(String1, aResumebutton))
    {
        sub_4262D0(*(int**)(this + 40));
        return 1;
    }
    if (!_strcmpi(String1, aOptionsbutton))
    {
        strcpy(byte_521688, aIngamemenu);
        sub_4261C0(*(_DWORD**)(this + 40), aOptions, 0);
        return 1;
    }
    if (_strcmpi(String1, aAbortmissionbu))
    {
        if (!_strcmpi(String1, aRestartmission))
        {
            if (*(_BYTE*)(dword_4F5CC4 + 936))
            {
                v5 = *(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 72);
                v6 = *(_DWORD*)(*(_DWORD*)(dword_520970 + 252) + 20);
                v7 = rand();
                sub_45B150(*(_DWORD**)(dword_520970 + 236), v5, v6, v7 % 10);
            }
            else if (!*(_BYTE*)(dword_4F5CC4 + 937))
            {
                sub_45AA80(*(_DWORD**)(dword_520970 + 236));
                sub_4262D0(*(int**)(this + 40));
                return 1;
            }
        }
        return 1;
    }
    sub_4262D0(*(int**)(this + 40));
    if (*(_BYTE*)(dword_4F5CC4 + 937))
    {
        sub_411C50(dword_4F5CC4);
        sub_45ABF0(*(_DWORD*)(dword_520970 + 236));
        sub_45ECB0(*(_DWORD**)(dword_520970 + 280));
        if (byte_521684)
        {
            sub_45B2B0(*(_DWORD*)(dword_520970 + 236), aIpx);
            return 1;
        }
        sub_45B2B0(*(_DWORD*)(dword_520970 + 236), aTcpip_0);
        return 1;
    }
    else
    {
        if (!*(_BYTE*)(dword_4F5CC4 + 936))
        {
            sub_45B2B0(*(_DWORD*)(dword_520970 + 236), aLevelselect);
            return 1;
        }
        sub_45B2B0(*(_DWORD*)(dword_520970 + 236), aStaging);
        return 1;
    }
}
// 43D773: conditional instruction was optimized away because al.1==0
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;
// 521684: using guessed type char byte_521684;

//----- (0043D7C0) --------------------------------------------------------
const char** __thiscall sub_43D7C0(const char** this, int a2)
{
    int v3; // esi
    const char** v4; // ebx
    char Buffer[64]; // [esp+10h] [ebp-4Ch] BYREF
    int v7; // [esp+58h] [ebp-4h]

    sub_4233C0((int)this, a2, aScoring);
    v7 = 0;
    *this = (const char*)&off_499940;
    v3 = 1;
    v4 = this + 21;
    do
    {
        sprintf(Buffer, "ScoreIcon%d", v3);
        *(v4 - 4) = sub_424350(this, Buffer);
        sprintf(Buffer, "ScoreIcon%dName", v3);
        *v4 = sub_424350(this, Buffer);
        sprintf(Buffer, "ScoreIcon%dText", v3);
        v4[4] = sub_424350(this, Buffer);
        ++v4;
        ++v3;
    } while (v3 - 1 < 4);
    this[11] = 0;
    return this;
}
// 499940: using guessed type _UNKNOWN *off_499940;

//----- (0043D8A0) --------------------------------------------------------
char __userpurge sub_43D8A0@<al>(_DWORD* a1@<ecx>, int a2@<ebp>, int a3)
{
    int v4; // ecx

    v4 = a1[11];
    if (v4)
        sub_41D0C0(v4, a2, *(float*)(dword_520970 + 68));
    return sub_428620(a1, a3);
}
// 520970: using guessed type int dword_520970;

//----- (0043D8D0) --------------------------------------------------------
char __thiscall sub_43D8D0(_DWORD* this)
{
    int v2; // edi
    int v3; // ebp
    int v4; // edx
    int v5; // eax
    int v6; // edi
    int v7; // eax
    int v8; // ecx
    int v9; // eax
    int v10; // ebp
    int v11; // eax
    double v12; // st7
    int v13; // eax
    const char* v14; // eax
    const char* v15; // eax
    int v17; // [esp+8h] [ebp-8h]
    int v18; // [esp+Ch] [ebp-4h]

    v2 = *(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 72);
    v18 = v2;
    if (!*(_BYTE*)(dword_4F5CC4 + 936) && !*(_BYTE*)(dword_4F5CC4 + 937))
        sub_45EA00(*(_DWORD**)(dword_520970 + 280), v2);
    this[14] = 0;
    this[13] = 0;
    v3 = dword_520970;
    v4 = 0;
    v17 = *(_DWORD*)(*(_DWORD*)(dword_520970 + 280) + 11784);
    if (v17 > 0)
    {
        do
        {
            v5 = *(_DWORD*)(v3 + 280);
            v6 = *(_DWORD*)(*(_DWORD*)(v5 + 11780) + 4 * v4);
            v7 = *(_DWORD*)(v5 + 4 * (v4 + 88 * *(_DWORD*)(v5 + 512)) + 972);
            if (v7 > 0)
            {
                v8 = v7 * *(_DWORD*)(v6 + 296);
                v9 = this[13] + 1;
                this[14] += v8;
                this[13] = v9;
                v3 = dword_520970;
            }
            ++v4;
        } while (v4 < v17);
        v2 = v18;
    }
    v10 = *(_DWORD*)(v3 + 280);
    v11 = *(_DWORD*)(v10 + 512);
    if (v11 >= 0)
        v12 = *(float*)(352 * v11 + v10 + 924);
    else
        v12 = 0.0;
    this[14] += (__int64)v12;
    sub_4624D0(*(_DWORD**)(dword_520970 + 280), (__int64)v12);
    v13 = this[14];
    this[16] = v13;
    if (!*(_BYTE*)(dword_4F5CC4 + 936) && !*(_BYTE*)(dword_4F5CC4 + 937))
    {
        this[15] = sub_45E9B0(*(_DWORD**)(dword_520970 + 280), v2, v13);
        this[16] = sub_45EA60(*(_DWORD**)(dword_520970 + 280));
    }
    v14 = sub_424350(this, aLevelscore);
    sub_421190(*((_DWORD*)v14 + 28), "%d", this[14]);
    v15 = sub_424350(this, aGamescore);
    return sub_421190(*((_DWORD*)v15 + 28), "%d", this[16]);
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (0043DA70) --------------------------------------------------------
char __thiscall sub_43DA70(int this)
{
    _DWORD* v2; // esi
    int v3; // ebp
    int v4; // eax
    int v5; // ecx
    int v6; // edx
    int v7; // edi
    char result; // al
    int v9; // ecx
    int v10; // eax
    int v11; // [esp+10h] [ebp-10h]
    float v12; // [esp+10h] [ebp-10h]
    int v13; // [esp+14h] [ebp-Ch]
    char ArgList[4]; // [esp+18h] [ebp-8h]
    int v15; // [esp+1Ch] [ebp-4h]

    v2 = (_DWORD*)(this + 84);
    v3 = 0;
    v4 = this + 84;
    v5 = 4;
    do
    {
        v6 = *(_DWORD*)(v4 - 16);
        v4 += 4;
        --v5;
        *(_BYTE*)(v6 + 44) = 0;
        *(_BYTE*)(*(_DWORD*)(v4 - 4) + 44) = 0;
        *(_BYTE*)(*(_DWORD*)(v4 + 12) + 44) = 0;
    } while (v5);
    v13 = *(_DWORD*)(this + 48);
    v11 = 0;
    v15 = *(_DWORD*)(*(_DWORD*)(dword_520970 + 280) + 11784);
    if (v15 > 0)
    {
        do
        {
            v7 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(dword_520970 + 280) + 11780) + 4 * v11);
            if (_strcmpi((const char*)v7, aNone))
            {
                *(_DWORD*)ArgList = *(_DWORD*)(*(_DWORD*)(dword_520970 + 280)
                    + 4 * (v11 + 88 * *(_DWORD*)(*(_DWORD*)(dword_520970 + 280) + 512))
                    + 972);
                if (*(int*)ArgList > 0)
                {
                    if (v13)
                    {
                        --v13;
                    }
                    else
                    {
                        *(_BYTE*)(*(v2 - 4) + 44) = 1;
                        *(_BYTE*)(*v2 + 44) = 1;
                        *(_BYTE*)(v2[4] + 44) = 1;
                        sub_424300((_DWORD**)this, *(v2 - 4), 0, (char*)(v7 + 33), 1);
                        sub_421110(*(_DWORD*)(*v2 + 112), (const char*)v7);
                        result = sub_421190(*(_DWORD*)(v2[4] + 112), "%d x %d", *(_DWORD*)ArgList, *(_DWORD*)(v7 + 296));
                        ++v3;
                        ++v2;
                        if (v3 >= 4)
                            return result;
                    }
                }
            }
            ++v11;
        } while (v11 < v15);
    }
    v9 = *(_DWORD*)(dword_520970 + 280);
    v10 = *(_DWORD*)(v9 + 512);
    if (v10 >= 0)
        v12 = *(float*)(352 * v10 + v9 + 924);
    else
        v12 = 0.0;
    result = v13;
    if (!v13)
    {
        *(_BYTE*)(*(_DWORD*)(this + 4 * v3 + 68) + 44) = 1;
        *(_BYTE*)(*(_DWORD*)(this + 4 * v3 + 84) + 44) = 1;
        *(_BYTE*)(*(_DWORD*)(this + 4 * v3 + 100) + 44) = 1;
        sub_424300((_DWORD**)this, *(_DWORD*)(this + 4 * v3 + 68), 0, aHealth_0, 1);
        sub_421110(*(_DWORD*)(*(_DWORD*)(this + 4 * v3 + 84) + 112), aHealth_0);
        return sub_421190(*(_DWORD*)(*(_DWORD*)(this + 4 * v3 + 100) + 112), "%d", (unsigned int)(__int64)v12);
    }
    return result;
}
// 43DB30: conditional instruction was optimized away because ebp.4<4
// 520970: using guessed type int dword_520970;

//----- (0043DC50) --------------------------------------------------------
const char* __thiscall sub_43DC50(_DWORD* this)
{
    const char* v2; // edi
    const char* result; // eax

    v2 = sub_424350(this, aIconup);
    result = sub_424350(this, aIcondown);
    *((_BYTE*)v2 + 44) = this[12] > 0;
    *((_BYTE*)result + 44) = this[12] + 4 < this[13];
    return result;
}

//----- (0043DC90) --------------------------------------------------------
char __thiscall sub_43DC90(_DWORD* this)
{
    const char* v2; // eax
    _DWORD* v3; // eax
    _DWORD* v4; // eax
    float v6; // [esp+0h] [ebp-18h]

    this[12] = 0;
    sub_43D8D0(this);
    sub_43DA70((int)this);
    sub_43DC50(this);
    v2 = sub_424350(this, aOkbutton);
    if (*(_BYTE*)(dword_4F5CC4 + 937))
        *((_BYTE*)v2 + 44) = 0;
    else
        *((_BYTE*)v2 + 44) = 1;
    v3 = operator new(0x15Cu);
    if (v3)
        v4 = sub_41C6A0(v3);
    else
        v4 = 0;
    this[11] = v4;
    sub_41C7A0((int)v4, 1);
    sub_41C760(this[11], aSoundsScorescr);
    *(_BYTE*)this[11] = 0;
    sub_41CA40(this[11]);
    v6 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
    sub_41CFD0(this[11], v6);
    return sub_41CD90(this[11]);
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (0043DD80) --------------------------------------------------------
void __thiscall sub_43DD80(int* this)
{
    int v2; // ecx
    void* v3; // edi

    sub_463070(*(_DWORD**)(dword_520970 + 280));
    sub_4630D0(*(char**)(dword_520970 + 280));
    sub_463150(*(_DWORD**)(dword_520970 + 280));
    v2 = this[11];
    if (v2)
    {
        sub_41CF50(v2);
        v3 = (void*)this[11];
        if (v3)
        {
            sub_41C700(this[11]);
            sub_4885A6(v3);
        }
        this[11] = 0;
    }
}
// 520970: using guessed type int dword_520970;

//----- (0043DDF0) --------------------------------------------------------
char __thiscall sub_43DDF0(int this, char* String1, int a3)
{
    char result; // al
    int v5; // eax
    bool v6; // sf
    int v7; // eax

    if (!String1)
        return 1;
    if (!_strcmpi(String1, aOkbutton))
    {
        sub_4262D0(*(int**)(this + 40));
        result = 1;
        *(_BYTE*)(*(_DWORD*)(dword_520970 + 224) + 40) = 0;
        return result;
    }
    if (_strcmpi(String1, aIconup))
    {
        if (_strcmpi(String1, aIcondown))
            return 1;
        v7 = *(_DWORD*)(this + 48) + 4;
        if (v7 > *(_DWORD*)(this + 52))
            return 1;
    }
    else
    {
        v5 = *(_DWORD*)(this + 48);
        v6 = v5 - 4 < 0;
        v5 -= 4;
        *(_DWORD*)(this + 48) = v5;
        v7 = v6 ? 0 : v5;
    }
    *(_DWORD*)(this + 48) = v7;
    sub_43DA70(this);
    sub_43DC50((_DWORD*)this);
    return 1;
}
// 520970: using guessed type int dword_520970;

//----- (0043DE90) --------------------------------------------------------
_DWORD* __thiscall sub_43DE90(_DWORD* this, int a2)
{
    const char* v3; // eax
    int v4; // ecx
    int v5; // eax
    const char* v6; // eax

    sub_4233C0((int)this, a2, aStaging);
    *this = &off_499978;
    this[24] = 1050253722;
    this[23] = 1050253722;
    this[12] = sub_424350(this, aHostip);
    this[13] = sub_424350(this, aPlayerslist);
    this[15] = sub_424350(this, aFightbutton);
    this[16] = sub_424350(this, aKickbutton);
    this[14] = sub_424350(this, aReadybutton);
    this[17] = sub_424350(this, aReady1);
    this[18] = sub_424350(this, aReady2);
    this[19] = sub_424350(this, aReady3);
    this[20] = sub_424350(this, aReady4);
    this[21] = sub_424350(this, aChatbar);
    this[11] = 0;
    v3 = sub_424350(this, aChattext);
    this[28] = v3;
    v4 = *((_DWORD*)v3 + 30);
    this[29] = v4;
    *((_DWORD*)v3 + 33) = v4;
    v5 = this[29];
    this[30] = 0;
    this[31] = operator new(72 * v5);
    v6 = sub_424350(this, aDifficulty);
    this[22] = v6;
    sub_421110(*((_DWORD*)v6 + 28), aSoldier);
    this[27] = 1;
    *(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 20) = 1;
    *(_DWORD*)(dword_520970 + 312) = this;
    sub_4113F0((_DWORD*)dword_4F5CC4, (int)this, 65280, 1024, 1);
    return this;
}
// 499978: using guessed type _UNKNOWN *off_499978;
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (0043E040) --------------------------------------------------------
void __thiscall sub_43E040(LPVOID* this)
{
    *this = &off_499978;
    sub_4885A6(this[31]);
    *(_DWORD*)(dword_520970 + 312) = 0;
    sub_411430((_DWORD*)dword_4F5CC4, (int)this);
    sub_4234A0(this);
}
// 499978: using guessed type _UNKNOWN *off_499978;
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (0043E0C0) --------------------------------------------------------
bool __thiscall sub_43E0C0(_DWORD* this)
{
    int v1; // edx
    int v2; // eax
    _WORD v4[3]; // [esp+0h] [ebp-14h] BYREF
    int v5; // [esp+6h] [ebp-Eh]
    int v6; // [esp+Ah] [ebp-Ah]
    int v7; // [esp+Eh] [ebp-6h]

    v1 = this[26];
    v5 = this[25];
    v2 = this[27];
    v6 = v1;
    v7 = v2;
    return sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x402, v4, 18, 15, 5000);
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (0043E100) --------------------------------------------------------
char __thiscall sub_43E100(int this, char* String1, int a3)
{
    int v4; // edi
    int v5; // eax
    int v6; // ebx
    const char* v7; // edi
    char* v8; // eax
    int v10; // ebx
    int v11; // ebx
    int v12; // eax
    int v13; // eax
    int v14; // ebx
    const char* v15; // edi
    const char* v16; // eax
    int v17; // eax
    int v18; // eax
    int v19; // edx
    int v20; // eax
    _WORD v21[3]; // [esp+Ch] [ebp-110h] BYREF
    bool v22; // [esp+12h] [ebp-10Ah]
    _WORD v23[3]; // [esp+14h] [ebp-108h] BYREF
    char v24[37]; // [esp+1Ah] [ebp-102h] BYREF

    if (!String1)
        goto LABEL_38;
    if (!_strcmpi(String1, aYear))
        return 1;
    if (!_strcmpi(String1, aTimeOfDay))
    {
        if (*(_BYTE*)(dword_4F5CC4 + 936))
        {
            if (a3)
            {
                v6 = *(_DWORD*)(this + 104) - 1;
                *(_DWORD*)(this + 104) = v6;
                v5 = v6 < 0 ? 0 : v6;
            }
            else
            {
                v4 = *(_DWORD*)(this + 104) + 1;
                *(_DWORD*)(this + 104) = v4;
                if (v4 >= sub_4647F0() - 1)
                    v5 = sub_4647F0() - 1;
                else
                    v5 = v4;
            }
            *(_DWORD*)(this + 104) = v5;
            v7 = sub_424350((_DWORD*)this, aTimeOfDay);
            if (v7)
            {
                v8 = sub_464800(*(_DWORD*)(this + 104));
                sub_421110(*((_DWORD*)v7 + 28), v8);
            }
            sub_422DC0((HKEY)AppName, aMultiplayersky, *(_DWORD*)(this + 104));
            sub_43E0C0((_DWORD*)this);
            return 1;
        }
        return 1;
    }
    if (_strcmpi(String1, aMonth))
    {
        if (!_strcmpi(String1, aDifficulty_0))
        {
            if (!*(_BYTE*)(dword_4F5CC4 + 936))
                return 1;
            v17 = *(_DWORD*)(this + 108);
            if (v17)
            {
                if (v17 == 1)
                {
                    *(_DWORD*)(this + 108) = 2;
                }
                else if (v17 == 2)
                {
                    *(_DWORD*)(this + 108) = 0;
                }
            }
            else
            {
                *(_DWORD*)(this + 108) = 1;
            }
            v18 = *(_DWORD*)(this + 108);
            if (v18)
            {
                if (v18 == 1)
                {
                    sub_421110(*(_DWORD*)(*(_DWORD*)(this + 88) + 112), aSoldier);
                }
                else if (v18 == 2)
                {
                    sub_421110(*(_DWORD*)(*(_DWORD*)(this + 88) + 112), aVeteran);
                }
            }
            else
            {
                sub_421110(*(_DWORD*)(*(_DWORD*)(this + 88) + 112), aRecruit);
            }
            *(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 20) = *(_DWORD*)(this + 108);
            sub_43E0C0((_DWORD*)this);
            return 1;
        }
    LABEL_38:
        if (String1 == *(char**)(this + 56))
        {
            v22 = String1[172] == 0;
            sub_4117D0(dword_4F5CC4, (int**)0x403, v21, 7, 7, 0);
            return 0;
        }
        if (!String1 || _strcmpi(String1, aCancelbutton))
        {
            if (String1 == *(char**)(this + 64))
            {
                v19 = *(_DWORD*)(*(_DWORD*)(this + 52) + 124);
                if (v19 > 0)
                {
                    strcpy(v24, aTheHostKickedY);
                    sub_411480(
                        (_DWORD*)dword_4F5CC4,
                        (int**)0x404,
                        *(_DWORD*)(*(_DWORD*)(dword_520970 + 280) + 352 * v19 + 888),
                        v23,
                        262,
                        7,
                        0);
                    return 1;
                }
            }
            else if (String1 == *(char**)(this + 60) && *(_BYTE*)(dword_4F5CC4 + 936))
            {
                sub_4262D0(*(int**)(this + 40));
                v20 = rand();
                sub_45B150(*(_DWORD**)(dword_520970 + 236), *(_DWORD*)(this + 100), *(_DWORD*)(this + 104), v20 % 10);
            }
            return 1;
        }
        sub_411C50(dword_4F5CC4);
        sub_45ABF0(*(_DWORD*)(dword_520970 + 236));
        sub_45ECB0(*(_DWORD**)(dword_520970 + 280));
        if (byte_521684)
            sub_4261C0(*(_DWORD**)(this + 40), aIpx, 0);
        else
            sub_4261C0(*(_DWORD**)(this + 40), aTcpip_0, 0);
        return 1;
    }
    if (!*(_BYTE*)(dword_4F5CC4 + 936))
        return 1;
    v10 = *(_DWORD*)(this + 100);
    if (a3)
    {
        v14 = v10 - 1;
        *(_DWORD*)(this + 100) = v14;
        v13 = v14 < 0 ? 0 : v14;
    }
    else
    {
        v11 = v10 + 1;
        *(_DWORD*)(this + 100) = v11;
        v12 = *(_DWORD*)(dword_520970 + 236);
        if (v11 >= *(_DWORD*)(16 * *(_DWORD*)(v12 + 20) + v12 + 28) - 1)
            v13 = *(_DWORD*)(16 * *(_DWORD*)(v12 + 20) + v12 + 28) - 1;
        else
            v13 = v11;
    }
    *(_DWORD*)(this + 100) = v13;
    v15 = sub_424350((_DWORD*)this, aMonth);
    if (v15)
    {
        v16 = (const char*)sub_45A870(*(_DWORD**)(dword_520970 + 236), *(_DWORD*)(this + 100));
        sub_421110(*((_DWORD*)v15 + 28), v16);
    }
    sub_422DC0((HKEY)AppName, aMultiplayermis, *(_DWORD*)(this + 100));
    sub_43E0C0((_DWORD*)this);
    return 1;
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;
// 521684: using guessed type char byte_521684;

//----- (0043E540) --------------------------------------------------------
char __thiscall sub_43E540(int this, int a2)
{
    double v3; // st7
    int v4; // ebp
    int v5; // eax
    int v6; // edx
    int v7; // ecx
    int v8; // edi
    char v9; // bl
    int v11; // [esp+4h] [ebp-18h]
    char ArgList[16]; // [esp+Ch] [ebp-10h] BYREF

    v3 = *(float*)(this + 92) - *(float*)(dword_520970 + 68);
    *(float*)(this + 92) = v3;
    if (v3 <= 0.0)
    {
        *(_DWORD*)(this + 92) = *(_DWORD*)(this + 96);
        v4 = *(_DWORD*)(*(_DWORD*)(dword_520970 + 280) + 520);
        *(_DWORD*)(*(_DWORD*)(this + 52) + 132) = v4;
        *(_BYTE*)(*(_DWORD*)(this + 52) + 136) = 1;
        v5 = sub_45E6F0(*(_DWORD**)(dword_520970 + 280), *(_DWORD*)(dword_4F5CC4 + 84));
        v6 = 0;
        v11 = 0;
        v7 = 0;
        v8 = this + 68;
        do
        {
            *(_BYTE*)(*(_DWORD*)v8 + 44) = v7 < v4;
            if (v7 < v4)
            {
                v9 = *(_BYTE*)(*(_DWORD*)(dword_520970 + 280) + v6 + 896);
                *(_BYTE*)(*(_DWORD*)v8 + 172) = v9;
                if (v7 == v5)
                    *(_BYTE*)(*(_DWORD*)(this + 56) + 172) = v9;
                if (v9)
                    ++v11;
            }
            v6 += 352;
            ++v7;
            v8 += 4;
        } while (v6 < 1408);
        if (*(_BYTE*)(dword_4F5CC4 + 936))
            *(_BYTE*)(*(_DWORD*)(this + 60) + 45) = v11 == v4;
        sub_411DE0(dword_4F5CC4, ArgList);
        sub_421190(*(_DWORD*)(*(_DWORD*)(this + 48) + 112), "Host IP: %s", ArgList);
    }
    return sub_428620((_DWORD*)this, a2);
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (0043E670) --------------------------------------------------------
_DWORD* __thiscall sub_43E670(_DWORD* this, _DWORD* a2, int a3, int a4, int a5)
{
    _DWORD* result; // eax
    int v7; // ecx

    result = a2;
    if (a2 == (_DWORD*)this[28])
    {
        result = (_DWORD*)a3;
        if (a3 < this[30])
        {
            sub_421110(a4, (const char*)(72 * a3 + this[31] + 8));
            return sub_421350(a4, *(_DWORD*)(72 * a3 + this[31] + 4));
        }
    }
    else if (a2 == (_DWORD*)this[13])
    {
        result = (_DWORD*)a3;
        v7 = *(_DWORD*)(dword_520970 + 280);
        if (a3 < *(_DWORD*)(v7 + 520))
        {
            sub_421110(a4, (const char*)(352 * a3 + v7 + 899));
            return sub_421350(a4, *(_DWORD*)(*(_DWORD*)(dword_520970 + 280) + 352 * a3 + 892));
        }
    }
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (0043E720) --------------------------------------------------------
bool __thiscall sub_43E720(int this)
{
    const char* v2; // edi
    const char* v3; // ebp
    const char* v4; // eax
    const char* v5; // edi
    const char* v6; // eax
    const char* v7; // edi
    char* v8; // eax
    int v9; // ecx
    int v10; // eax
    int v11; // edx
    _WORD v13[3]; // [esp+10h] [ebp-14h] BYREF
    int v14; // [esp+16h] [ebp-Eh] BYREF
    int v15; // [esp+1Ah] [ebp-Ah] BYREF
    int v16; // [esp+1Eh] [ebp-6h] BYREF

    sub_424630(*(int**)(this + 40));
    *(_DWORD*)(*(_DWORD*)(this + 52) + 132) = 0;
    *(_DWORD*)(*(_DWORD*)(this + 112) + 132) = 0;
    *(_DWORD*)(this + 120) = 0;
    v2 = sub_424350((_DWORD*)this, aHostipleft);
    v3 = sub_424350((_DWORD*)this, aHostipright);
    v4 = sub_424350((_DWORD*)this, aHostip_0);
    *((_BYTE*)v2 + 44) = byte_521684 == 0;
    *((_BYTE*)v3 + 44) = byte_521684 == 0;
    *((_BYTE*)v4 + 44) = byte_521684 == 0;
    if (*(_BYTE*)(dword_4F5CC4 + 936))
    {
        *(_DWORD*)(this + 100) = sub_422BA0(AppName, aMultiplayermis, 0);
        v5 = sub_424350((_DWORD*)this, aMonth);
        if (v5)
        {
            v6 = (const char*)sub_45A870(*(_DWORD**)(dword_520970 + 236), *(_DWORD*)(this + 100));
            sub_421110(*((_DWORD*)v5 + 28), v6);
        }
        *(_DWORD*)(this + 104) = sub_422BA0(AppName, aMultiplayersky, 0);
        v7 = sub_424350((_DWORD*)this, aTimeOfDay);
        if (v7)
        {
            v8 = sub_464800(*(_DWORD*)(this + 104));
            sub_421110(*((_DWORD*)v7 + 28), v8);
        }
        *(_BYTE*)(dword_4F5CC4 + 108) = 1;
        *(_BYTE*)(*(_DWORD*)(this + 64) + 44) = 1;
        *(_BYTE*)(*(_DWORD*)(this + 60) + 44) = 1;
    }
    else
    {
        *(_BYTE*)(*(_DWORD*)(this + 64) + 44) = 0;
        *(_BYTE*)(*(_DWORD*)(this + 60) + 44) = 0;
    }
    sub_411EE0(dword_4F5CC4, &v14, &v16, &v15);
    v9 = 0;
    v10 = *(_DWORD*)(dword_520970 + 280);
    if (*(int*)(v10 + 520) > 0)
    {
        v11 = 0;
        do
        {
            *(_BYTE*)(v11 + v10 + 896) = 0;
            ++v9;
            v11 += 352;
            v10 = *(_DWORD*)(dword_520970 + 280);
        } while (v9 < *(_DWORD*)(v10 + 520));
    }
    return sub_4117D0(dword_4F5CC4, (int**)0x405, v13, 18, 15, 0);
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;
// 521684: using guessed type char byte_521684;

//----- (0043E8D0) --------------------------------------------------------
int sub_43E8D0()
{
    int result; // eax

    result = dword_4F5CC4;
    if (*(_BYTE*)(dword_4F5CC4 + 936))
        *(_BYTE*)(dword_4F5CC4 + 108) = 0;
    return result;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (0043E8F0) --------------------------------------------------------
char __thiscall sub_43E8F0(_DWORD* this, int a2, int a3)
{
    int v4; // eax
    _WORD v6[3]; // [esp+8h] [ebp-48h] BYREF
    char v7[66]; // [esp+Eh] [ebp-42h] BYREF

    if ((_BYTE)a3)
    {
        v4 = this[21];
        if (*(_DWORD*)(this[10] + 76) == v4)
        {
            if (a2 == 1)
            {
                sub_421110(*(_DWORD*)(v4 + 112), asc_4AA198);
            }
            else if (a2 == 28)
            {
                sub_421280(*(_DWORD*)(v4 + 112));
                strcpy(v7, *(const char**)(*(_DWORD*)(this[21] + 112) + 8));
                sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x401, v6, 70, 5, 5000);
                sub_421110(*(_DWORD*)(this[21] + 112), asc_4AA198);
            }
        }
    }
    return sub_428590(this, a2, a3);
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (0043E9B0) --------------------------------------------------------
int __thiscall sub_43E9B0(_DWORD* this)
{
    int v2; // ebx
    int v3; // eax
    int v4; // ecx
    const void* v5; // esi
    void* v6; // edi
    int result; // eax

    v2 = 0;
    if (this[29] - 1 <= 0)
    {
        result = this[30] - 1;
        this[30] = result;
    }
    else
    {
        v3 = 0;
        do
        {
            v4 = this[31];
            ++v2;
            v5 = (const void*)(v3 + v4 + 72);
            v6 = (void*)(v3 + v4);
            v3 += 72;
            qmemcpy(v6, v5, 0x48u);
        } while (v2 < this[29] - 1);
        result = this[30] - 1;
        this[30] = result;
    }
    return result;
}

//----- (0043EA00) --------------------------------------------------------
int __thiscall sub_43EA00(_DWORD* this, const char* a2, int a3, int a4, char a5)
{
    int v6; // eax
    int v7; // eax
    int v8; // eax
    int v9; // edx
    int v10; // edx
    int v11; // eax
    int result; // eax
    char Buffer[64]; // [esp+10h] [ebp-40h] BYREF

    if (a5)
    {
        v6 = this[30];
        if (v6 <= 0 || (v7 = *(_DWORD*)(this[31] + 72 * v6 - 72), v7 != a4) && v7)
        {
            v8 = sub_45E6F0(*(_DWORD**)(dword_520970 + 280), a4);
            if (v8 > -1)
            {
                sprintf(Buffer, "%s:", (const char*)(*(_DWORD*)(dword_520970 + 280) + 352 * v8 + 899));
                sub_43EA00(Buffer, a3, a4, 0);
            }
        }
    }
    if (this[30] == this[29])
        sub_43E9B0(this);
    v9 = this[31] + 72 * this[30];
    strcpy((char*)(v9 + 8), a2);
    *(_DWORD*)v9 = a4;
    *(_DWORD*)(v9 + 4) = a3;
    v10 = this[28];
    v11 = this[30] + 1;
    this[30] = v11;
    *(_DWORD*)(v10 + 132) = v11;
    result = this[28];
    *(_BYTE*)(result + 136) = 1;
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (0043EB00) --------------------------------------------------------
char __thiscall sub_43EB00(int this, int a2)
{
    int v3; // eax
    int v4; // ebp
    int v5; // eax
    const char* v6; // esi
    const char* v7; // eax
    const char* v8; // esi
    char* v9; // eax
    unsigned int v10; // edx
    char* v11; // edi
    char* v12; // esi
    char v13; // cl
    unsigned int v14; // eax
    const char* v15; // edi
    unsigned int v16; // edx
    char* v17; // edi
    char* v18; // esi
    char v19; // cl
    unsigned int v20; // eax
    int v22; // [esp+10h] [ebp-114h] BYREF
    char ArgList[4]; // [esp+14h] [ebp-110h] BYREF
    int v24; // [esp+18h] [ebp-10Ch] BYREF
    _WORD v25[3]; // [esp+1Ch] [ebp-108h] BYREF
    char v26[26]; // [esp+22h] [ebp-102h] BYREF

    v3 = *(unsigned __int16*)(a2 + 12);
    v4 = *(_DWORD*)(a2 + 16);
    if ((unsigned __int16)v3 > 0xFF01u)
    {
        if (v3 == 65283)
        {
            sub_411C50(dword_4F5CC4);
            sub_45ABF0(*(_DWORD*)(dword_520970 + 236));
            sub_45ECB0(*(_DWORD**)(dword_520970 + 280));
            if (byte_521684)
            {
                v16 = strlen(aIpx) + 1;
                qmemcpy(byte_520D40, aIpx, 4 * (v16 >> 2));
                v18 = &aIpx[4 * (v16 >> 2)];
                v17 = &byte_520D40[4 * (v16 >> 2)];
                v19 = v16;
            }
            else
            {
                v20 = strlen(aTcpip_0) + 1;
                qmemcpy(byte_520D40, aTcpip_0, 4 * (v20 >> 2));
                v18 = &aTcpip_0[4 * (v20 >> 2)];
                v17 = &byte_520D40[4 * (v20 >> 2)];
                v19 = v20;
            }
            qmemcpy(v17, v18, v19 & 3);
            strcpy(byte_520D80, aHostLeftTheGam);
            v15 = AppName;
        LABEL_34:
            strcpy(byte_521180, v15);
            LOBYTE(v3) = sub_4261C0(*(_DWORD**)(this + 40), aErrormsg, 0);
        }
    }
    else if ((unsigned __int16)v3 == 65281)
    {
        LOBYTE(v3) = *(_BYTE*)(dword_4F5CC4 + 936);
        if ((_BYTE)v3)
        {
            v3 = *(_DWORD*)(v4 + 6);
            if (v3)
                LOBYTE(v3) = sub_43E0C0((_DWORD*)this);
        }
    }
    else
    {
        v3 -= 1025;
        switch (v3)
        {
        case 0:
            v3 = sub_45E6F0(*(_DWORD**)(dword_520970 + 280), *(_DWORD*)(a2 + 4));
            if (v3 > -1)
                LOBYTE(v3) = sub_43EA00(
                    (_DWORD*)this,
                    (const char*)(v4 + 6),
                    *(_DWORD*)(*(_DWORD*)(dword_520970 + 280) + 352 * v3 + 892),
                    *(_DWORD*)(a2 + 4),
                    1);
            break;
        case 1:
            LOBYTE(v3) = *(_BYTE*)(dword_4F5CC4 + 936);
            if (!(_BYTE)v3)
            {
                *(_DWORD*)(this + 100) = *(_DWORD*)(v4 + 6);
                *(_DWORD*)(this + 104) = *(_DWORD*)(v4 + 10);
                *(_DWORD*)(this + 108) = *(_DWORD*)(v4 + 14);
                v6 = sub_424350((_DWORD*)this, aMonth);
                v7 = (const char*)sub_45A870(*(_DWORD**)(dword_520970 + 236), *(_DWORD*)(this + 100));
                sub_421110(*((_DWORD*)v6 + 28), v7);
                v8 = sub_424350((_DWORD*)this, aTimeOfDay);
                v9 = sub_464800(*(_DWORD*)(this + 104));
                sub_421110(*((_DWORD*)v8 + 28), v9);
                v3 = *(_DWORD*)(this + 108);
                if (v3)
                {
                    if (v3 == 1)
                    {
                        LOBYTE(v3) = sub_421110(*(_DWORD*)(*(_DWORD*)(this + 88) + 112), aSoldier);
                    }
                    else if (v3 == 2)
                    {
                        LOBYTE(v3) = sub_421110(*(_DWORD*)(*(_DWORD*)(this + 88) + 112), aVeteran);
                    }
                }
                else
                {
                    LOBYTE(v3) = sub_421110(*(_DWORD*)(*(_DWORD*)(this + 88) + 112), aRecruit);
                }
            }
            break;
        case 2:
            LOBYTE(v3) = *(_BYTE*)(dword_4F5CC4 + 936);
            if ((_BYTE)v3)
            {
                v5 = sub_45E6F0(*(_DWORD**)(dword_520970 + 280), *(_DWORD*)(a2 + 4));
                if (v5 > -1)
                    *(_BYTE*)(*(_DWORD*)(dword_520970 + 280) + 352 * v5 + 896) = *(_BYTE*)(v4 + 6);
                LOBYTE(v3) = sub_463180(*(_BYTE**)(dword_520970 + 280));
            }
            break;
        case 3:
            sub_411C50(dword_4F5CC4);
            sub_45ABF0(*(_DWORD*)(dword_520970 + 236));
            sub_45ECB0(*(_DWORD**)(dword_520970 + 280));
            if (byte_521684)
            {
                v10 = strlen(aIpx) + 1;
                qmemcpy(byte_520D40, aIpx, 4 * (v10 >> 2));
                v12 = &aIpx[4 * (v10 >> 2)];
                v11 = &byte_520D40[4 * (v10 >> 2)];
                v13 = v10;
            }
            else
            {
                v14 = strlen(aTcpip_0) + 1;
                qmemcpy(byte_520D40, aTcpip_0, 4 * (v14 >> 2));
                v12 = &aTcpip_0[4 * (v14 >> 2)];
                v11 = &byte_520D40[4 * (v14 >> 2)];
                v13 = v14;
            }
            qmemcpy(v11, v12, v13 & 3);
            strcpy(byte_520D80, aYouVeBeenKicke);
            v15 = (const char*)(v4 + 6);
            goto LABEL_34;
        case 4:
            LOBYTE(v3) = *(_BYTE*)(dword_4F5CC4 + 936);
            if ((_BYTE)v3)
            {
                sub_411EE0(dword_4F5CC4, ArgList, &v22, &v24);
                v3 = *(_DWORD*)(v4 + 10);
                if (v3 != v24 || *(_DWORD*)(v4 + 14) != v22 || *(_DWORD*)(v4 + 6) != *(_DWORD*)ArgList)
                {
                    sub_4229D0(
                        "MP Checksum mismatch: numfiles is %d, should be %d; numbytes is %d, should be %d; checksum is 0x%08x, should be 0x%08x",
                        *(_DWORD*)ArgList,
                        *(_DWORD*)(v4 + 6),
                        v24,
                        v3,
                        v22,
                        *(_DWORD*)(v4 + 14));
                    strcpy(v26, aGameDataIsOutO);
                    LOBYTE(v3) = sub_411480((_DWORD*)dword_4F5CC4, (int**)0x404, *(_DWORD*)(a2 + 4), v25, 262, 7, 0);
                }
            }
            break;
        default:
            return v3;
        }
    }
    return v3;
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;
// 521684: using guessed type char byte_521684;

//----- (0043EF90) --------------------------------------------------------
_DWORD* __thiscall sub_43EF90(void* this, _DWORD* a2, int a3)
{
    sub_4102F0((int)this, a2, 0, a3);
    return a2;
}

//----- (0043EFC0) --------------------------------------------------------
_DWORD* __thiscall sub_43EFC0(void* this, _DWORD* a2, const CHAR* a3, int a4)
{
    sub_4102F0((int)this, a2, a3, a4);
    return a2;
}

//----- (0043EFF0) --------------------------------------------------------
_DWORD* __thiscall sub_43EFF0(_DWORD* this, _DWORD* a2)
{
    const char* v2; // ecx

    *a2 = this[235];
    v2 = (const char*)this[236];
    if (v2)
        a2[1] = _strdup(v2);
    return a2;
}

//----- (0043F030) --------------------------------------------------------
float* __thiscall sub_43F030(float* this, char* a2)
{
    char* v2; // edi
    double v4; // st7
    double v5; // st7
    double v6; // st7
    double v7; // st7
    double v8; // st7
    double v9; // st7
    int v10; // eax
    const char* v12; // [esp-8h] [ebp-2Ch]
    int v13[5]; // [esp+10h] [ebp-14h] BYREF

    v2 = a2;
    v13[1] = (int)this;
    sub_468FF0(this, a2);
    v13[4] = 0;
    v12 = (const char*)*((_DWORD*)this + 1);
    *(_DWORD*)this = &off_4999B0;
    sub_4229D0("Started to load %s in %s", v12, v2 + 16);
    sub_40AFC0(v2, aType_0, &a2);
    if (!strcmp(a2, aAntiGround))
    {
        this[73] = 0.0;
    }
    else if (!strcmp(a2, aAntiAircraft))
    {
        *((_DWORD*)this + 73) = 1;
    }
    else
    {
        sub_40A120(0, "%s, see %s : %s", aInvalidGunType, *((const char**)this + 1), v2 + 16);
    }
    sub_40AFC0(v2, aBullettype, v13);
    sub_469160((int)this, (_DWORD*)this + 74, (const char*)v13[0], aBullet);
    sub_40B1B0(v2, aRof, this + 75);
    v4 = this[75];
    if (v4 == 0.0)
        v5 = 0.0;
    else
        v5 = 60.0 / v4;
    this[75] = v5;
    v6 = this[76];
    if (v6 == 0.0)
        v7 = 0.0;
    else
        v7 = 60.0 / v6;
    this[76] = v7;
    sub_40AF60(v2, aVelocity, this + 77);
    sub_40AF60(v2, aHealth, this + 78);
    this[79] = 0.0;
    if (sub_40ABC0(v2, aExplodeeffect, 0))
    {
        sub_40AFC0(v2, aExplodeeffect, &a2);
        sub_469160((int)this, (_DWORD*)this + 79, a2, aEffect);
    }
    sub_40B1B0(v2, aActivetime, this + 80);
    sub_40B1B0(v2, aInactivetime, this + 82);
    sub_40AF60(v2, aTurnrate, this + 84);
    v8 = this[84];
    if (v8 == 0.0)
        v9 = 0.0;
    else
        v9 = 6.2831855 / v8;
    v10 = *((_DWORD*)this + 73);
    this[84] = v9;
    if (v10 == 1)
        sub_40AF60(v2, aRange, this + 85);
    this[86] = 0.0;
    if (sub_40ABC0(v2, aFireeffect, 0))
    {
        sub_40AFC0(v2, aFireeffect, &a2);
        sub_469160((int)this, (_DWORD*)this + 86, a2, aEffect);
    }
    return this;
}
// 4999B0: using guessed type _UNKNOWN *off_4999B0;

//----- (0043F320) --------------------------------------------------------
int __thiscall sub_43F320(void* this)
{
    *(_DWORD*)this = &off_4999B0;
    return sub_4690A0(this);
}
// 4999B0: using guessed type _UNKNOWN *off_4999B0;

//----- (0043F330) --------------------------------------------------------
int __usercall sub_43F330@<eax>(_DWORD* a1@<ecx>, int a2@<ebp>)
{
    sub_43F350((int)a1, a2);
    return sub_4690E0(a1);
}

//----- (0043F350) --------------------------------------------------------
unsigned int __usercall sub_43F350@<eax>(int a1@<ecx>, int a2@<ebp>)
{
    unsigned int result; // eax
    char* v4; // eax
    unsigned int v5; // edi
    int i; // ebx
    signed int v7; // ecx

    result = *(_DWORD*)(a1 + 564);
    if (!result)
    {
        v4 = sub_4069C0(*(_DWORD*)(dword_520970 + 128), a2, (char*)(a1 + 304));
        *(_DWORD*)(a1 + 564) = v4;
        sub_4282E0(v4 != 0, "failed to load model %s, see file %s", (const char*)(a1 + 304), (const char*)(a1 + 16));
        v5 = 0;
        for (i = 0; ; i += 260)
        {
            result = *(_DWORD*)(a1 + 644);
            if (!result)
                break;
            v7 = *(_DWORD*)(a1 + 648) - result;
            result = (unsigned int)((unsigned __int64)(2114445439LL * v7) >> 32) >> 31;
            if (v5 >= v7 / 260)
                break;
            sub_403E80(*(_DWORD*)(a1 + 564), a2, (char*)(i + *(_DWORD*)(a1 + 644)));
            ++v5;
        }
    }
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (0043F3E0) --------------------------------------------------------
int __thiscall sub_43F3E0(int this)
{
    int i; // edi
    void* v3; // ecx
    void* v4; // eax

    *(_DWORD*)this = &off_4999BC;
    sub_42A840((_DWORD*)this);
    if (*(_BYTE*)(this + 936))
    {
        for (i = 0; i < *(_DWORD*)(this + 928); ++i)
        {
            v3 = *(void**)(*(_DWORD*)(this + 924) + 4 * i);
            if (v3)
                sub_448C00(v3, 1);
        }
    }
    memset(*(void**)(this + 924), 0, 4 * *(_DWORD*)(this + 928));
    v4 = *(void**)(this + 924);
    *(_DWORD*)(this + 928) = 0;
    sub_488CEE(v4);
    *(_DWORD*)(this + 932) = 0;
    *(_DWORD*)(this + 924) = 0;
    sub_4885A6(*(LPVOID*)(this + 908));
    *(_DWORD*)(this + 908) = 0;
    *(_DWORD*)(this + 912) = 0;
    *(_DWORD*)(this + 916) = 0;
    sub_4885A6(*(LPVOID*)(this + 864));
    *(_DWORD*)(this + 864) = 0;
    *(_DWORD*)(this + 868) = 0;
    *(_DWORD*)(this + 872) = 0;
    sub_4885A6(*(LPVOID*)(this + 644));
    *(_DWORD*)(this + 644) = 0;
    *(_DWORD*)(this + 648) = 0;
    *(_DWORD*)(this + 652) = 0;
    sub_4885A6(*(LPVOID*)(this + 596));
    *(_DWORD*)(this + 596) = 0;
    *(_DWORD*)(this + 600) = 0;
    *(_DWORD*)(this + 604) = 0;
    return sub_4690A0((void*)this);
}
// 4999BC: using guessed type _UNKNOWN *off_4999BC;

//----- (0043F560) --------------------------------------------------------
_DWORD* __thiscall sub_43F560(_DWORD* this, int a2)
{
    char v3; // cl
    char v4; // dl
    const char* v5; // eax
    const char* v6; // eax
    char* v7; // ecx
    double v8; // st7
    double v9; // st7
    _DWORD** v10; // eax
    int v11; // esi
    _DWORD** v12; // eax
    int v13; // esi
    _DWORD** v14; // eax
    int v15; // esi
    _DWORD** v16; // eax
    int v17; // esi
    _DWORD** v18; // eax
    int v19; // esi
    _DWORD** v20; // eax
    int v21; // esi
    int* v22; // eax
    int v23; // ecx
    int v24; // edi
    _BYTE* v25; // eax
    int v26; // esi
    int v27; // ecx
    int v28; // eax
    int v29; // eax
    int v30; // esi
    _DWORD* v31; // eax
    int v32; // esi
    _DWORD* v33; // eax
    int v34; // esi
    int* v35; // eax
    int v36; // esi
    int v37; // eax
    const char* v38; // edx
    int v39; // eax
    int v40; // edx
    int v41; // eax
    unsigned int v42; // esi
    unsigned int v43; // edx
    char* v44; // edi
    int v45; // eax
    int v46; // eax
    int v47; // edx
    int* v48; // eax
    int v49; // esi
    int v50; // esi
    int v51; // eax
    int v52; // edx
    int v53; // eax
    unsigned int v54; // esi
    unsigned int v55; // edx
    char* v56; // edi
    int v57; // eax
    int v58; // eax
    int v59; // edx
    int* v60; // eax
    int v61; // esi
    int v62; // esi
    int v63; // eax
    int v64; // edx
    int v65; // eax
    unsigned int v66; // esi
    unsigned int v67; // edx
    char* v68; // edi
    int v69; // eax
    int v70; // eax
    int v71; // edx
    int* v72; // eax
    int v73; // esi
    int v74; // esi
    int v75; // eax
    int v76; // edx
    int v77; // eax
    unsigned int v78; // esi
    unsigned int v79; // edx
    char* v80; // edi
    int v81; // eax
    int v82; // eax
    int v83; // edx
    int* v84; // eax
    int v85; // esi
    int v86; // esi
    int v87; // eax
    int v88; // edx
    int v89; // esi
    unsigned int v90; // edi
    unsigned int v91; // edx
    int v92; // edx
    int v93; // eax
    int v94; // edx
    int* v95; // eax
    int v96; // esi
    int v97; // esi
    int v98; // eax
    int v99; // edx
    int v100; // esi
    unsigned int v101; // edi
    unsigned int v102; // edx
    int v103; // edx
    int v104; // eax
    int v105; // edx
    int* v106; // eax
    int v107; // esi
    int v108; // eax
    int v109; // edx
    int v110; // esi
    unsigned int v111; // edi
    unsigned int v112; // edx
    int v113; // edx
    int v114; // eax
    int v115; // edx
    int* v116; // eax
    int v117; // esi
    int v118; // esi
    int v119; // eax
    int v120; // edx
    int v121; // esi
    unsigned int v122; // edi
    unsigned int v123; // edx
    int v124; // edx
    int v125; // eax
    int v126; // edx
    int* v127; // eax
    int v128; // esi
    int v129; // esi
    int v130; // eax
    int v131; // edx
    int v132; // esi
    unsigned int v133; // edi
    unsigned int v134; // edx
    int v135; // edx
    int v136; // eax
    int v137; // edx
    int* v138; // eax
    int v139; // esi
    char* v140; // esi
    int v141; // eax
    int v142; // edx
    int v143; // esi
    unsigned int v144; // edi
    unsigned int v145; // edx
    int v146; // edx
    int v147; // eax
    int v148; // edx
    int* v149; // eax
    int v150; // esi
    int v151; // esi
    float* v152; // edi
    float* v153; // edi
    double v154; // st7
    _DWORD* v155; // eax
    _DWORD* v156; // esi
    _DWORD* v157; // eax
    const char* v158; // edi
    _DWORD* v159; // ebx
    char* v160; // esi
    int v161; // eax
    float* v162; // edi
    _DWORD** v163; // eax
    int v164; // ecx
    _DWORD* v165; // eax
    _DWORD* v166; // edi
    int* v167; // eax
    const char* v168; // eax
    int v169; // ebx
    int v170; // edi
    const void* v171; // eax
    char* v172; // edi
    char j; // al
    const char* v174; // ebx
    int v175; // edi
    int v176; // eax
    unsigned int v177; // ebx
    unsigned int v178; // edx
    int v179; // eax
    unsigned int v180; // ebx
    int v181; // ebx
    _DWORD** v182; // eax
    int v183; // ecx
    _DWORD* v184; // eax
    _DWORD* v185; // edi
    int* v186; // eax
    const char* v187; // eax
    int v188; // ebx
    int v189; // edi
    const void* v190; // eax
    char* v191; // edi
    char k; // al
    int v193; // ebx
    int v194; // eax
    unsigned int v195; // edi
    unsigned int v196; // edx
    int v197; // eax
    unsigned int v198; // edi
    int v199; // edi
    int v200; // ecx
    _DWORD* v201; // esi
    int* v202; // eax
    const char* v203; // eax
    int v204; // ebx
    int v205; // esi
    int v206; // edi
    const void* v207; // eax
    char* v208; // esi
    _DWORD* v209; // eax
    _DWORD* v210; // edi
    char v211; // dl
    int v212; // eax
    int v213; // ecx
    int v214; // eax
    void* v215; // ecx
    int v216; // eax
    char* v217; // eax
    int v218; // edi
    int v219; // ecx
    int v220; // edx
    char n; // al
    int v222; // ebx
    char* v223; // edi
    char ii; // al
    char jj; // al
    char kk; // al
    char mm; // al
    int v228; // ebx
    int v229; // ecx
    int v230; // edi
    _DWORD* v231; // eax
    int v232; // esi
    _BYTE* v233; // eax
    int v234; // esi
    int* v235; // eax
    int v236; // ecx
    int v237; // ebx
    _DWORD* v238; // eax
    int v239; // esi
    _BYTE* v240; // eax
    int v241; // esi
    _BYTE* v242; // eax
    int v243; // esi
    _DWORD* v244; // edi
    _DWORD* v245; // eax
    _DWORD* v246; // esi
    int v247; // edx
    unsigned int v248; // ecx
    int v249; // eax
    int v250; // eax
    _DWORD* v251; // eax
    _DWORD* v252; // ebx
    _DWORD* v253; // ebx
    _DWORD* v254; // ebx
    _DWORD* v255; // esi
    int v256; // eax
    _DWORD* i1; // eax
    _DWORD* v258; // eax
    int v259; // esi
    _DWORD* v260; // esi
    const char* v262; // [esp+0h] [ebp-168h]
    const char* v263; // [esp+0h] [ebp-168h]
    const char* v264; // [esp+0h] [ebp-168h]
    const char* v265; // [esp+0h] [ebp-168h]
    const char* v266; // [esp+0h] [ebp-168h]
    float v267; // [esp+0h] [ebp-168h]
    unsigned int v268; // [esp+4h] [ebp-164h]
    unsigned int v269; // [esp+4h] [ebp-164h]
    unsigned int v270; // [esp+4h] [ebp-164h]
    float v271; // [esp+4h] [ebp-164h]
    int v272; // [esp+18h] [ebp-150h] BYREF
    char v273; // [esp+1Fh] [ebp-149h] BYREF
    char* String1; // [esp+20h] [ebp-148h] BYREF
    _DWORD* i2; // [esp+24h] [ebp-144h] BYREF
    char ArgList[4]; // [esp+28h] [ebp-140h]
    char v277[4]; // [esp+2Ch] [ebp-13Ch]
    int m; // [esp+30h] [ebp-138h] BYREF
    int nn; // [esp+34h] [ebp-134h] BYREF
    _DWORD* v280; // [esp+38h] [ebp-130h] BYREF
    int v281; // [esp+3Ch] [ebp-12Ch] BYREF
    int i; // [esp+40h] [ebp-128h] BYREF
    unsigned int v283; // [esp+44h] [ebp-124h] BYREF
    float v284; // [esp+48h] [ebp-120h]
    float v285; // [esp+4Ch] [ebp-11Ch]
    _DWORD* v286; // [esp+50h] [ebp-118h]
    _DWORD* v287; // [esp+54h] [ebp-114h]
    _BYTE v288[260]; // [esp+58h] [ebp-110h] BYREF
    int v289; // [esp+164h] [ebp-4h]

    v287 = this;
    sub_468FF0(this, (char*)a2);
    v289 = 0;
    *((_BYTE*)this + 592) = v273;
    this[149] = 0;
    this[150] = 0;
    this[151] = 0;
    *((_BYTE*)this + 640) = v273;
    this[161] = 0;
    this[162] = 0;
    this[163] = 0;
    v3 = v273;
    this[216] = 0;
    *((_BYTE*)this + 860) = v3;
    this[217] = 0;
    this[218] = 0;
    v4 = v273;
    this[227] = 0;
    *((_BYTE*)this + 904) = v4;
    this[228] = 0;
    this[229] = 0;
    this[231] = 0;
    this[232] = 0;
    this[233] = 0;
    *((_BYTE*)this + 936) = 1;
    *this = &off_4999BC;
    *(_DWORD*)ArgList = a2 + 16;
    v5 = (const char*)this[1];
    LOBYTE(v289) = 5;
    sub_4229D0("Started to load %s in %s", v5, (const char*)(a2 + 16));
    sub_40AFC0((void*)a2, aType_0, &String1);
    if (!strcmp(String1, aPatrolBoat))
    {
        this[73] = 0;
    }
    else if (!strcmp(String1, aUBoat))
    {
        this[73] = 1;
    }
    else if (!strcmp(String1, aHiggins))
    {
        this[73] = 2;
    }
    else if (!strcmp(String1, aLct))
    {
        this[73] = 3;
    }
    else if (!strcmp(String1, aBattleship))
    {
        this[73] = 4;
    }
    else if (!strcmp(String1, aCargoBoat))
    {
        this[73] = 5;
    }
    else if (!strcmp(String1, aCarrier))
    {
        this[73] = 6;
    }
    else
    {
        sub_40A120(0, "%s, see %s : %s", aInvalidBoatTyp, (const char*)this[1], *(const char**)ArgList);
    }
    this[74] = 1065353216;
    if (sub_40ABC0((_DWORD*)a2, aUnitvalue, 0))
        sub_40AF60((const char*)a2, aUnitvalue, (float*)this + 74);
    sub_40AFC0((void*)a2, aScoringgroup, &String1);
    v6 = sub_462480(*(_DWORD**)(dword_520970 + 280), String1);
    v7 = String1;
    this[75] = v6;
    sub_4282E0(v6 != 0, "Boat type %s: couldn't find scoring groups %s", (const char*)this[1], v7);
    sub_40AFC0((void*)a2, aModelfile, &String1);
    strcpy((char*)this + 304, String1);
    this[141] = 0;
    if (!sub_46A3A0(*(_BYTE**)(dword_520970 + 200), (LPCSTR)this + 304))
        sub_43F350((int)this, (int)this);
    if (!sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        sub_4066C0(
            (_DWORD*)this[141],
            (int)(this + 143),
            this + 145,
            (float*)this + 142,
            (float*)this + 146,
            (float*)this + 143,
            (float*)this + 147,
            (float*)this + 144);
        v8 = *((float*)this + 145);
        *((float*)this + 145) = -*((float*)this + 142);
        *((float*)this + 142) = -v8;
        v9 = *((float*)this + 146);
        *((float*)this + 146) = -*((float*)this + 143);
        *((float*)this + 143) = -v9;
    }
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v10 = (_DWORD**)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v11 = *(_DWORD*)(dword_520970 + 200);
        v272 = (__int64)*((float*)this + 145);
        v10 = (_DWORD**)sub_46A4C0(v11, &v272, 4u);
    }
    i2 = *v10;
    *((float*)this + 145) = (float)(int)i2;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v12 = (_DWORD**)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v13 = *(_DWORD*)(dword_520970 + 200);
        v272 = (__int64)*((float*)this + 146);
        v12 = (_DWORD**)sub_46A4C0(v13, &v272, 4u);
    }
    i2 = *v12;
    *((float*)this + 146) = (float)(int)i2;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v14 = (_DWORD**)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v15 = *(_DWORD*)(dword_520970 + 200);
        v272 = (__int64)*((float*)this + 147);
        v14 = (_DWORD**)sub_46A4C0(v15, &v272, 4u);
    }
    i2 = *v14;
    *((float*)this + 147) = (float)(int)i2;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v16 = (_DWORD**)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v17 = *(_DWORD*)(dword_520970 + 200);
        v272 = (__int64)*((float*)this + 142);
        v16 = (_DWORD**)sub_46A4C0(v17, &v272, 4u);
    }
    i2 = *v16;
    *((float*)this + 142) = (float)(int)i2;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v18 = (_DWORD**)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v19 = *(_DWORD*)(dword_520970 + 200);
        v272 = (__int64)*((float*)this + 143);
        v18 = (_DWORD**)sub_46A4C0(v19, &v272, 4u);
    }
    i2 = *v18;
    *((float*)this + 143) = (float)(int)i2;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v20 = (_DWORD**)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v21 = *(_DWORD*)(dword_520970 + 200);
        v272 = (__int64)*((float*)this + 144);
        v20 = (_DWORD**)sub_46A4C0(v21, &v272, 4u);
    }
    i2 = *v20;
    *((float*)this + 144) = (float)(int)i2;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v22 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v23 = *(_DWORD*)(dword_520970 + 200);
        v272 = *(_DWORD*)(this[141] + 8);
        v22 = (int*)sub_46A4C0(v23, &v272, 4u);
    }
    v24 = *v22;
    for (i = 0; i < v24; ++i)
    {
        if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
        {
            v25 = (_BYTE*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
        }
        else
        {
            v26 = *(_DWORD*)(dword_520970 + 200);
            v273 = sub_405BE0((_DWORD*)this[141], i);
            v25 = (_BYTE*)sub_46A4C0(v26, &v273, 4u);
        }
        if (*v25)
            sub_44F190((int)(this + 148), (_DWORD*)this[150], 1u, &i);
    }
    v27 = this[149];
    if (v27)
        v28 = (this[150] - v27) >> 2;
    else
        v28 = 0;
    sub_40A120(
        v28 != 0,
        "there are not enough nodes where fires can start on a boat, see %s : %s",
        (const char*)this[1],
        *(const char**)ArgList);
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v29 = *(_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v30 = *(_DWORD*)(dword_520970 + 200);
        v272 = sub_405A30((_DWORD*)this[141], aHull, -1, 1);
        v29 = *(_DWORD*)sub_46A4C0(v30, &v272, 4u);
    }
    this[152] = v29;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v31 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v32 = *(_DWORD*)(dword_520970 + 200);
        v272 = sub_405A30((_DWORD*)this[141], aHull_0, -1, 1);
        v31 = (_DWORD*)sub_46A4C0(v32, &v272, 4u);
    }
    this[153] = *v31;
    this[154] = -1;
    if (this[153] == -1)
    {
        if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
        {
            v33 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
        }
        else
        {
            v34 = *(_DWORD*)(dword_520970 + 200);
            v272 = sub_405A30((_DWORD*)this[141], aBow, -1, 1);
            v33 = (_DWORD*)sub_46A4C0(v34, &v272, 4u);
        }
        this[153] = *v33;
        if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
        {
            v35 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
        }
        else
        {
            v36 = *(_DWORD*)(dword_520970 + 200);
            v272 = sub_405A30((_DWORD*)this[141], aStern, -1, 1);
            v35 = (int*)sub_46A4C0(v36, &v272, 4u);
        }
        v37 = *v35;
        v38 = *(const char**)ArgList;
        this[154] = v37;
        sub_40A120(v37 != -1, "%s, see %s : %s", aSternCollision, (const char*)this[1], v38);
    }
    sub_40A120(this[153] != -1, "%s, see %s : %s", aSternCollision, (const char*)this[1], *(const char**)ArgList);
    if (this[154] == -1)
    {
        if (sub_40ABC0((_DWORD*)a2, aAnimsink, 0))
        {
            sub_40AFC0((void*)a2, aAnimsink, &String1);
            v39 = this[161];
            if (v39)
                v40 = (this[162] - v39) / 260;
            else
                v40 = 0;
            v41 = this[161];
            v42 = v40 + 1;
            if (v41)
                v43 = (this[162] - v41) / 260;
            else
                v43 = 0;
            if (v43 >= v42)
            {
                if (v42 < sub_4481E0(this + 160))
                    sub_4486E0(this + 160, (char*)(this[161] + 260 * v42), (char*)this[162]);
            }
            else
            {
                v44 = (char*)this[162];
                v45 = sub_4481E0(this + 160);
                sub_448390(this + 160, v44, v42 - v45, v288);
            }
            v46 = this[161];
            if (v46)
                v47 = (this[162] - v46) / 260;
            else
                v47 = 0;
            strcpy((char*)(this[161] + 260 * v47 - 260), String1);
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v48 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v49 = *(_DWORD*)(dword_520970 + 200);
                v272 = sub_403E80(this[141], (int)this, String1);
                v48 = (int*)sub_46A4C0(v49, &v272, 4u);
            }
            v50 = *v48;
            v262 = (const char*)this[1];
            v277[0] = *v48 != -1;
            sub_40A120(v277[0], "%s, see %s : %s", aFailedToLoadAn_0, v262, *(const char**)ArgList);
            this[155] = v50;
            this[156] = v50;
        }
        else
        {
            sub_40AFC0((void*)a2, aAnimsinkl, &String1);
            v51 = this[161];
            if (v51)
                v52 = (this[162] - v51) / 260;
            else
                v52 = 0;
            v53 = this[161];
            v54 = v52 + 1;
            if (v53)
                v55 = (this[162] - v53) / 260;
            else
                v55 = 0;
            if (v55 >= v54)
            {
                if (v54 < sub_4481E0(this + 160))
                    sub_4486E0(this + 160, (char*)(this[161] + 260 * v54), (char*)this[162]);
            }
            else
            {
                v56 = (char*)this[162];
                v57 = sub_4481E0(this + 160);
                sub_448390(this + 160, v56, v54 - v57, v288);
            }
            v58 = this[161];
            if (v58)
                v59 = (this[162] - v58) / 260;
            else
                v59 = 0;
            strcpy((char*)(this[161] + 260 * v59 - 260), String1);
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v60 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v61 = *(_DWORD*)(dword_520970 + 200);
                v272 = sub_403E80(this[141], (int)this, String1);
                v60 = (int*)sub_46A4C0(v61, &v272, 4u);
            }
            v62 = *v60;
            sub_40A120(*v60 != -1, "%s, see %s : %s", aFailedToLoadAn_0, (const char*)this[1], *(const char**)ArgList);
            this[155] = v62;
            sub_40AFC0((void*)a2, aAnimsinkr, &String1);
            v63 = this[161];
            if (v63)
                v64 = (this[162] - v63) / 260;
            else
                v64 = 0;
            v65 = this[161];
            v66 = v64 + 1;
            if (v65)
                v67 = (this[162] - v65) / 260;
            else
                v67 = 0;
            if (v67 >= v66)
            {
                if (v66 < sub_4481E0(this + 160))
                    sub_4486E0(this + 160, (char*)(this[161] + 260 * v66), (char*)this[162]);
            }
            else
            {
                v68 = (char*)this[162];
                v69 = sub_4481E0(this + 160);
                sub_448390(this + 160, v68, v66 - v69, v288);
            }
            v70 = this[161];
            if (v70)
                v71 = (this[162] - v70) / 260;
            else
                v71 = 0;
            strcpy((char*)(this[161] + 260 * v71 - 260), String1);
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v72 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v73 = *(_DWORD*)(dword_520970 + 200);
                v272 = sub_403E80(this[141], (int)this, String1);
                v72 = (int*)sub_46A4C0(v73, &v272, 4u);
            }
            v74 = *v72;
            v263 = (const char*)this[1];
            v277[0] = *v72 != -1;
            sub_40A120(v277[0], "%s, see %s : %s", aFailedToLoadAn_0, v263, *(const char**)ArgList);
            this[156] = v74;
        }
    }
    else
    {
        if (sub_40ABC0((_DWORD*)a2, aAnimsinkbow, 0))
        {
            sub_40AFC0((void*)a2, aAnimsinkbow, &String1);
            v75 = this[161];
            if (v75)
                v76 = (this[162] - v75) / 260;
            else
                v76 = 0;
            v77 = this[161];
            v78 = v76 + 1;
            if (v77)
                v79 = (this[162] - v77) / 260;
            else
                v79 = 0;
            if (v79 >= v78)
            {
                if (v78 < sub_4481E0(this + 160))
                    sub_4486E0(this + 160, (char*)(this[161] + 260 * v78), (char*)this[162]);
            }
            else
            {
                v80 = (char*)this[162];
                v81 = sub_4481E0(this + 160);
                sub_448390(this + 160, v80, v78 - v81, v288);
            }
            v82 = this[161];
            if (v82)
                v83 = (this[162] - v82) / 260;
            else
                v83 = 0;
            strcpy((char*)(this[161] + 260 * v83 - 260), String1);
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v84 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v85 = *(_DWORD*)(dword_520970 + 200);
                v272 = sub_403E80(this[141], (int)this, String1);
                v84 = (int*)sub_46A4C0(v85, &v272, 4u);
            }
            v86 = *v84;
            sub_40A120(*v84 != -1, "%s, see %s : %s", aFailedToLoadAn_0, (const char*)this[1], *(const char**)ArgList);
            this[155] = v86;
        }
        else
        {
            sub_40AFC0((void*)a2, aAnimsinkbowl, &String1);
            v87 = this[161];
            if (v87)
                v88 = (this[162] - v87) / 260;
            else
                v88 = 0;
            v89 = this[161];
            v90 = v88 + 1;
            if (v89)
                v91 = (this[162] - v89) / 260;
            else
                v91 = 0;
            if (v91 >= v90)
            {
                if (v90 < sub_4481E0(this + 160))
                    sub_4486E0(this + 160, (char*)(this[161] + 260 * v90), (char*)this[162]);
            }
            else
            {
                if (v89)
                    v92 = (this[162] - v89) / 260;
                else
                    v92 = 0;
                sub_448390(this + 160, (char*)this[162], v90 - v92, v288);
            }
            v93 = this[161];
            if (v93)
                v94 = (this[162] - v93) / 260;
            else
                v94 = 0;
            strcpy((char*)(this[161] + 260 * v94 - 260), String1);
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v95 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v96 = *(_DWORD*)(dword_520970 + 200);
                v272 = sub_403E80(this[141], (int)this, String1);
                v95 = (int*)sub_46A4C0(v96, &v272, 4u);
            }
            v97 = *v95;
            sub_40A120(*v95 != -1, "%s, see %s : %s", aFailedToLoadAn_0, (const char*)this[1], *(const char**)ArgList);
            this[155] = v97;
            sub_40AFC0((void*)a2, aAnimsinkbowr, &String1);
            v98 = this[161];
            if (v98)
                v99 = (this[162] - v98) / 260;
            else
                v99 = 0;
            v100 = this[161];
            v101 = v99 + 1;
            if (v100)
                v102 = (this[162] - v100) / 260;
            else
                v102 = 0;
            if (v102 >= v101)
            {
                if (v101 < sub_4481E0(this + 160))
                    sub_4486E0(this + 160, (char*)(this[161] + 260 * v101), (char*)this[162]);
            }
            else
            {
                if (v100)
                    v103 = (this[162] - v100) / 260;
                else
                    v103 = 0;
                sub_448390(this + 160, (char*)this[162], v101 - v103, v288);
            }
            v104 = this[161];
            if (v104)
                v105 = (this[162] - v104) / 260;
            else
                v105 = 0;
            strcpy((char*)(this[161] + 260 * v105 - 260), String1);
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v106 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v107 = *(_DWORD*)(dword_520970 + 200);
                v272 = sub_403E80(this[141], (int)this, String1);
                v106 = (int*)sub_46A4C0(v107, &v272, 4u);
            }
            v86 = *v106;
            sub_40A120(*v106 != -1, "%s, see %s : %s", aFailedToLoadAn_0, (const char*)this[1], *(const char**)ArgList);
        }
        this[156] = v86;
        if (sub_40ABC0((_DWORD*)a2, aAnimsinkstern, 0))
        {
            sub_40AFC0((void*)a2, aAnimsinkstern, &String1);
            v108 = this[161];
            if (v108)
                v109 = (this[162] - v108) / 260;
            else
                v109 = 0;
            v110 = this[161];
            v111 = v109 + 1;
            if (v110)
                v112 = (this[162] - v110) / 260;
            else
                v112 = 0;
            if (v112 >= v111)
            {
                if (v111 < sub_4481E0(this + 160))
                    sub_4486E0(this + 160, (char*)(this[161] + 260 * v111), (char*)this[162]);
            }
            else
            {
                if (v110)
                    v113 = (this[162] - v110) / 260;
                else
                    v113 = 0;
                sub_448390(this + 160, (char*)this[162], v111 - v113, v288);
            }
            v114 = this[161];
            if (v114)
                v115 = (this[162] - v114) / 260;
            else
                v115 = 0;
            strcpy((char*)(this[161] + 260 * v115 - 260), String1);
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v116 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v117 = *(_DWORD*)(dword_520970 + 200);
                v272 = sub_403E80(this[141], (int)this, String1);
                v116 = (int*)sub_46A4C0(v117, &v272, 4u);
            }
            v118 = *v116;
            v264 = (const char*)this[1];
            v277[0] = *v116 != -1;
            sub_40A120(v277[0], "%s, see %s : %s", aFailedToLoadAn_0, v264, *(const char**)ArgList);
            this[157] = v118;
        }
        else
        {
            sub_40AFC0((void*)a2, aAnimsinksternl, &String1);
            v119 = this[161];
            if (v119)
                v120 = (this[162] - v119) / 260;
            else
                v120 = 0;
            v121 = this[161];
            v122 = v120 + 1;
            if (v121)
                v123 = (this[162] - v121) / 260;
            else
                v123 = 0;
            if (v123 >= v122)
            {
                if (v122 < sub_4481E0(this + 160))
                    sub_4486E0(this + 160, (char*)(this[161] + 260 * v122), (char*)this[162]);
            }
            else
            {
                if (v121)
                    v124 = (this[162] - v121) / 260;
                else
                    v124 = 0;
                sub_448390(this + 160, (char*)this[162], v122 - v124, v288);
            }
            v125 = this[161];
            if (v125)
                v126 = (this[162] - v125) / 260;
            else
                v126 = 0;
            strcpy((char*)(this[161] + 260 * v126 - 260), String1);
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v127 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v128 = *(_DWORD*)(dword_520970 + 200);
                v272 = sub_403E80(this[141], (int)this, String1);
                v127 = (int*)sub_46A4C0(v128, &v272, 4u);
            }
            v129 = *v127;
            sub_40A120(*v127 != -1, "%s, see %s : %s", aFailedToLoadAn_0, (const char*)this[1], *(const char**)ArgList);
            this[157] = v129;
            sub_40AFC0((void*)a2, aAnimsinksternr, &String1);
            v130 = this[161];
            if (v130)
                v131 = (this[162] - v130) / 260;
            else
                v131 = 0;
            v132 = this[161];
            v133 = v131 + 1;
            if (v132)
                v134 = (this[162] - v132) / 260;
            else
                v134 = 0;
            if (v134 >= v133)
            {
                if (v133 < sub_4481E0(this + 160))
                    sub_4486E0(this + 160, (char*)(this[161] + 260 * v133), (char*)this[162]);
            }
            else
            {
                if (v132)
                    v135 = (this[162] - v132) / 260;
                else
                    v135 = 0;
                sub_448390(this + 160, (char*)this[162], v133 - v135, v288);
            }
            v136 = this[161];
            if (v136)
                v137 = (this[162] - v136) / 260;
            else
                v137 = 0;
            strcpy((char*)(this[161] + 260 * v137 - 260), String1);
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v138 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v139 = *(_DWORD*)(dword_520970 + 200);
                v272 = sub_403E80(this[141], (int)this, String1);
                v138 = (int*)sub_46A4C0(v139, &v272, 4u);
            }
            v118 = *v138;
            v265 = (const char*)this[1];
            v277[0] = *v138 != -1;
            sub_40A120(v277[0], "%s, see %s : %s", aFailedToLoadAn_0, v265, *(const char**)ArgList);
        }
        this[158] = v118;
    }
    v140 = (char*)a2;
    if (sub_40ABC0((_DWORD*)a2, aAnimsinkshore, 0))
    {
        sub_40AFC0((void*)a2, aAnimsinkshore, &String1);
        v141 = this[161];
        if (v141)
            v142 = (this[162] - v141) / 260;
        else
            v142 = 0;
        v143 = this[161];
        v144 = v142 + 1;
        if (v143)
            v145 = (this[162] - v143) / 260;
        else
            v145 = 0;
        if (v145 >= v144)
        {
            if (v144 < sub_4481E0(this + 160))
                sub_4486E0(this + 160, (char*)(this[161] + 260 * v144), (char*)this[162]);
        }
        else
        {
            if (v143)
                v146 = (this[162] - v143) / 260;
            else
                v146 = 0;
            sub_448390(this + 160, (char*)this[162], v144 - v146, v288);
        }
        v147 = this[161];
        if (v147)
            v148 = (this[162] - v147) / 260;
        else
            v148 = 0;
        strcpy((char*)(this[161] + 260 * v148 - 260), String1);
        if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
        {
            v149 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
        }
        else
        {
            v150 = *(_DWORD*)(dword_520970 + 200);
            v272 = sub_403E80(this[141], (int)this, String1);
            v149 = (int*)sub_46A4C0(v150, &v272, 4u);
        }
        v151 = *v149;
        v266 = (const char*)this[1];
        v277[0] = *v149 != -1;
        sub_40A120(v277[0], "%s, see %s : %s", aFailedToLoadAn_0, v266, *(const char**)ArgList);
        this[159] = v151;
        v140 = (char*)a2;
    }
    this[164] = 1065353216;
    this[165] = 1065353216;
    if (sub_40ABC0(v140, aAnimsinkrate, 0))
        sub_40B1B0(v140, aAnimsinkrate, (float*)this + 164);
    this[166] = 0;
    if (sub_40ABC0(v140, aTimebeforestop, 0))
        sub_40AF60(v140, aTimebeforestop, (float*)this + 166);
    sub_40AF60(v140, aHealth, (float*)this + 167);
    v152 = (float*)(this + 168);
    this[168] = 1065353216;
    if (sub_40ABC0(v140, aStarthealthper, 0))
        sub_40AF60(v140, aStarthealthper, (float*)this + 168);
    if (*v152 > 1.0)
        *v152 = *v152 * 0.0099999998;
    v153 = (float*)(this + 169);
    this[169] = 0;
    if (sub_40ABC0(v140, aSpecialdeathhe, 0))
        sub_40AF60(v140, aSpecialdeathhe, (float*)this + 169);
    if (*v153 > 1.0)
        *v153 = *v153 * 0.0099999998;
    this[170] = 0;
    this[171] = 0;
    if (sub_40ABC0(v140, aLifetime, 0))
        sub_40AF60(v140, aLifetime, (float*)this + 170);
    if (sub_40ABC0(v140, aFadetime, 0))
        sub_40AF60(v140, aFadetime, (float*)this + 171);
    sub_40AF60(v140, aSpeed, (float*)this + 172);
    this[173] = 0;
    if (sub_40ABC0(v140, aStartdist, 0))
        sub_40AF60(v140, aStartdist, (float*)this + 173);
    sub_40B1D0(v140, aRange, (float*)this + 174, (float*)this + 175);
    sub_40AF60(v140, aPathsegmenttim, (float*)this + 178);
    sub_40AF60(v140, aPathsegmentvar, (float*)this + 179);
    *((float*)this + 179) = *((float*)this + 179) * 0.017453292;
    sub_40AF60(v140, aRollfactor, (float*)this + 180);
    sub_40AF60(v140, aMaxpitch, (float*)this + 181);
    v154 = *((float*)this + 181) * 0.017453292;
    *((_BYTE*)this + 728) = 0;
    *((float*)this + 181) = v154;
    if (sub_40ABC0(v140, aSlowdownrange, 0))
    {
        *((_BYTE*)this + 728) = 1;
        sub_40AF60(v140, aSlowdownrange, (float*)this + 183);
        sub_40AF60(v140, aSlowdownspeed, (float*)this + 184);
    }
    *((_BYTE*)this + 740) = 0;
    if (sub_40ABC0(v140, aSailhome, 0))
        sub_40B130(v140, aSailhome, (_BYTE*)this + 740);
    v155 = operator new(0x148u);
    v156 = v155;
    v281 = (int)v155;
    LOBYTE(v289) = 6;
    if (v155)
    {
        sub_468FA0((int)v155);
        *v156 = &off_499224;
        v157 = v156;
    }
    else
    {
        v157 = 0;
    }
    v158 = *(const char**)ArgList;
    v159 = this + 186;
    LOBYTE(v289) = 5;
    this[186] = v157;
    v157[3] = aPath;
    strcpy((char*)(this[186] + 16), v158);
    *(_DWORD*)(*v159 + 292) = this[172];
    *(_DWORD*)(*v159 + 296) = this[178];
    *(_DWORD*)(*v159 + 300) = this[179];
    *(_DWORD*)(*v159 + 304) = 0;
    *(_DWORD*)(*v159 + 308) = this[174];
    *(_DWORD*)(*v159 + 312) = this[175];
    *(_DWORD*)(*v159 + 316) = 0;
    *(_DWORD*)(*v159 + 320) = 0;
    *(_BYTE*)(*v159 + 324) = this[73] < 4u;
    sub_469700(*(_DWORD**)(dword_520970 + 200), this[186], aCustumPath);
    sub_469160((int)this, this + 186, 0, 0);
    v160 = (char*)a2;
    this[187] = 0;
    if (sub_40ABC0((_DWORD*)a2, aBubblysoundeff, 0))
    {
        sub_40AFC0((void*)a2, aBubblysoundeff, &String1);
        sub_469160((int)this, this + 187, String1, aBubblySoundEff);
    }
    this[188] = 0;
    if (sub_40ABC0((_DWORD*)a2, aSmallburneffec, 0))
    {
        sub_40AFC0((void*)a2, aSmallburneffec, &String1);
        sub_469160((int)this, this + 188, String1, aEffect);
        sub_40AF60((const char*)a2, aBeginburnhealt, (float*)this + 190);
        sub_40B1B0((const char*)a2, aBeginburnfrequ, (float*)this + 191);
        sub_40B1B0((const char*)a2, aEndburnfrequen, (float*)this + 193);
    }
    this[189] = 0;
    if (sub_40ABC0((_DWORD*)a2, aBigburneffect, 0))
    {
        sub_40AFC0((void*)a2, aBigburneffect, &String1);
        sub_469160((int)this, this + 189, String1, aEffect);
        sub_40B1B0((const char*)a2, aBigburnfrequen, (float*)this + 195);
    }
    this[197] = 0;
    if (sub_40ABC0((_DWORD*)a2, aEnginesound, 0))
    {
        sub_40AFC0((void*)a2, aEnginesound, &String1);
        sub_469160((int)this, this + 197, String1, aSoundEffect);
    }
    this[198] = 0;
    if (sub_40ABC0((_DWORD*)a2, aEnginedying, 0))
    {
        sub_40AFC0((void*)a2, aEnginedying, &String1);
        sub_469160((int)this, this + 198, String1, aEffect);
    }
    v161 = this[73];
    switch (v161)
    {
    case 0:
        sub_40B1D0((const char*)a2, aTimetillpause, (float*)this + 199, (float*)this + 200);
        sub_40B1D0((const char*)a2, aPausetime, (float*)this + 201, (float*)this + 202);
        sub_40AF60((const char*)a2, aPausespeed, (float*)this + 203);
        sub_40B1D0((const char*)a2, aTimetilluturn, (float*)this + 204, (float*)this + 205);
        goto LABEL_380;
    case 1:
        sub_40B1D0((const char*)a2, aTimetillpause, (float*)this + 199, (float*)this + 200);
        sub_40B1D0((const char*)a2, aPausetime, (float*)this + 201, (float*)this + 202);
        sub_40AF60((const char*)a2, aPausespeed, (float*)this + 203);
        sub_40AF60((const char*)a2, aDepth, (float*)this + 206);
        sub_40B1B0((const char*)a2, aTimetillsailho, (float*)this + 207);
        goto LABEL_380;
    case 2:
        this[209] = 12;
        if (sub_40ABC0((_DWORD*)a2, aNumtroops, 0))
            sub_40AF00((const char*)a2, aNumtroops, (char**)this + 209);
        v162 = (float*)(this + 210);
        this[210] = 1053609165;
        this[211] = 1060320051;
        if (sub_40ABC0((_DWORD*)a2, aPercentgunguys, 0))
            sub_40B1B0((const char*)a2, aPercentgunguys, (float*)this + 210);
        if (*v162 > 1.0)
            *v162 = *v162 * 0.0099999998;
        if (*((float*)this + 211) > 1.0)
            *((float*)this + 211) = *((float*)this + 211) * 0.0099999998;
        sub_40AF60((const char*)a2, aDriftspeed, (float*)this + 212);
        sub_40B1D0((const char*)a2, aLandrange, (float*)this + 213, (float*)this + 214);
        goto LABEL_380;
    case 3:
        sub_40AF60((const char*)a2, aDriftspeed, (float*)this + 212);
        sub_40B1D0((const char*)a2, aLandrange, (float*)this + 213, (float*)this + 214);
        this[219] = -1;
        if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
        {
            v163 = (_DWORD**)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
        }
        else
        {
            v164 = *(_DWORD*)(dword_520970 + 200);
            v272 = *(_DWORD*)(this[141] + 8);
            v163 = (_DWORD**)sub_46A4C0(v164, &v272, 4u);
        }
        v165 = *v163;
        m = 0;
        i2 = v165;
        if ((int)v165 <= 0)
        {
        LABEL_342:
            sub_40A120(this[219] != -1, "%s, see %s : %s", aTankExitNodeNo, (const char*)this[1], *(const char**)ArgList);
            goto LABEL_380;
        }
        while (1)
        {
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v166 = *(_DWORD**)(dword_520970 + 200);
                v167 = (int*)sub_46A4A0(v166, 4);
                v168 = (const char*)sub_46A4A0(v166, *v167);
            }
            else
            {
                v169 = *(_DWORD*)(dword_520970 + 200);
                v272 = strlen((const char*)sub_405C20((_DWORD*)this[141], m));
                ++v272;
                v170 = *(_DWORD*)(dword_520970 + 200);
                v268 = *(_DWORD*)sub_46A4C0(v169, &v272, 4u);
                v171 = (const void*)sub_405C20((_DWORD*)this[141], m);
                v168 = (const char*)sub_46A4C0(v170, v171, v268);
            }
            v172 = (char*)v168;
            if (!_strnicmp(v168, aTankExit, 9u))
            {
                this[219] = m;
            }
            else if (!_strnicmp(v172, aTank_0, 4u))
            {
                for (j = *v172; j; j = *++v172)
                {
                    if (j >= 48 && j <= 57)
                        break;
                    if (j == 45)
                        break;
                    if (j == 46)
                        break;
                }
                v174 = *(const char**)ArgList;
                sub_40A120(v277[0], "%s, see %s : %s", aTankNodeNotNum, (const char*)this[1], *(const char**)ArgList);
                v175 = sub_48A1BB(v172) - 1;
                sub_40A120(v175 >= 0, "%s, see %s : %s", aInvalidTankNum, (const char*)this[1], v174);
                v176 = this[216];
                if (v176)
                    v177 = (this[217] - v176) >> 2;
                else
                    v177 = 0;
                v178 = v175 + 1;
                if (v177 < v175 + 1)
                {
                    v179 = this[216];
                    v280 = 0;
                    if (v179)
                        v180 = (this[217] - v179) >> 2;
                    else
                        v180 = 0;
                    if (v180 < v178)
                    {
                        if (v179)
                            v181 = (this[217] - v179) >> 2;
                        else
                            v181 = 0;
                        sub_44F190((int)(this + 215), (_DWORD*)this[217], v178 - v181, &v280);
                        goto LABEL_339;
                    }
                    if (v179)
                    {
                        if (v178 < (this[217] - v179) >> 2)
                            sub_448300(this + 215, (_DWORD*)(v179 + 4 * v178), (int*)this[217]);
                    LABEL_339:
                        v160 = (char*)a2;
                    }
                }
                *(_DWORD*)(this[216] + 4 * v175) = m;
            }
            if (++m >= (int)i2)
                goto LABEL_342;
        }
    }
    if (v161 != 4 && v161 != 5)
    {
        if (v161 != 6)
        {
            sub_40A120(0, "invalid boat type, see file %s", *(const char**)ArgList);
            goto LABEL_380;
        }
        sub_40B1B0((const char*)a2, aActiverange, (float*)this + 220);
        sub_40AF60((const char*)a2, aDecklength, (float*)this + 222);
        sub_40AF60((const char*)a2, aPlaneelevatord, (float*)this + 223);
        sub_40AF60((const char*)a2, aPlaneelevatort, (float*)this + 224);
        sub_40AF60((const char*)a2, aTimebetweenlau, (float*)this + 225);
        if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
        {
            v182 = (_DWORD**)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
        }
        else
        {
            v183 = *(_DWORD*)(dword_520970 + 200);
            v272 = *(_DWORD*)(this[141] + 8);
            v182 = (_DWORD**)sub_46A4C0(v183, &v272, 4u);
        }
        v184 = *v182;
        *(_DWORD*)v277 = 0;
        i2 = v184;
        if ((int)v184 > 0)
        {
            do
            {
                if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
                {
                    v185 = *(_DWORD**)(dword_520970 + 200);
                    v186 = (int*)sub_46A4A0(v185, 4);
                    v187 = (const char*)sub_46A4A0(v185, *v186);
                }
                else
                {
                    v188 = *(_DWORD*)(dword_520970 + 200);
                    v272 = strlen((const char*)sub_405C20((_DWORD*)this[141], *(int*)v277));
                    ++v272;
                    v189 = *(_DWORD*)(dword_520970 + 200);
                    v269 = *(_DWORD*)sub_46A4C0(v188, &v272, 4u);
                    v190 = (const void*)sub_405C20((_DWORD*)this[141], *(int*)v277);
                    v187 = (const char*)sub_46A4C0(v189, v190, v269);
                }
                v191 = (char*)v187;
                if (_strnicmp(v187, aLaunch, 6u))
                    goto LABEL_377;
                for (k = *v191; k; k = *++v191)
                {
                    if (k >= 48 && k <= 57)
                        break;
                    if (k == 45)
                        break;
                    if (k == 46)
                        break;
                }
                sub_40A120(*v191 != 0, "%s, see %s : %s", aLaunchNodeNotN, (const char*)this[1], *(const char**)ArgList);
                v193 = sub_48A1BB(v191) - 1;
                v194 = this[227];
                if (v194)
                    v195 = (this[228] - v194) >> 2;
                else
                    v195 = 0;
                v196 = v193 + 1;
                if (v195 < v193 + 1)
                {
                    v197 = this[227];
                    m = 0;
                    if (v197)
                        v198 = (this[228] - v197) >> 2;
                    else
                        v198 = 0;
                    if (v198 < v196)
                    {
                        if (v197)
                            v199 = (this[228] - v197) >> 2;
                        else
                            v199 = 0;
                        sub_44F190((int)(this + 226), (_DWORD*)this[228], v196 - v199, &m);
                    LABEL_375:
                        v160 = (char*)a2;
                        goto LABEL_376;
                    }
                    if (v197)
                    {
                        if (v196 < (this[228] - v197) >> 2)
                            sub_448300(this + 226, (_DWORD*)(v197 + 4 * v196), (int*)this[228]);
                        goto LABEL_375;
                    }
                }
            LABEL_376:
                *(_DWORD*)(this[227] + 4 * v193) = *(_DWORD*)v277;
            LABEL_377:
                ++*(_DWORD*)v277;
            } while (*(int*)v277 < (int)i2);
        }
    }
LABEL_380:
    *((float*)this + 230) = *((float*)this + 172) * 0.5;
    if (sub_40ABC0(v160, aSpeedthreshold, 0))
        sub_40AF60(v160, aSpeedthreshold, (float*)this + 230);
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        *(_DWORD*)v277 = *(_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v200 = *(_DWORD*)(dword_520970 + 200);
        v272 = *(_DWORD*)(this[141] + 8);
        *(_DWORD*)v277 = *(_DWORD*)sub_46A4C0(v200, &v272, 4u);
    }
    for (m = 0; m < *(int*)v277; ++m)
    {
        if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
        {
            v201 = *(_DWORD**)(dword_520970 + 200);
            v202 = (int*)sub_46A4A0(v201, 4);
            v203 = (const char*)sub_46A4A0(v201, *v202);
        }
        else
        {
            v204 = m;
            v205 = *(_DWORD*)(dword_520970 + 200);
            v283 = strlen((const char*)sub_405C20((_DWORD*)this[141], m));
            ++v283;
            v206 = *(_DWORD*)(dword_520970 + 200);
            v270 = *(_DWORD*)sub_46A4C0(v205, &v283, 4u);
            v207 = (const void*)sub_405C20((_DWORD*)this[141], v204);
            v203 = (const char*)sub_46A4C0(v206, v207, v270);
        }
        v208 = (char*)v203;
        if (!_strnicmp(v203, aGun, 3u))
        {
            v209 = operator new(0x38u);
            v210 = v209;
            v281 = (int)v209;
            LOBYTE(v289) = 7;
            if (v209)
            {
                Iostream_init::Iostream_init((Iostream_init*)(v209 + 1));
                LOBYTE(v289) = 8;
                Iostream_init::Iostream_init((Iostream_init*)(v210 + 4));
                v211 = v273;
                v210[10] = 0;
                *((_BYTE*)v210 + 36) = v211;
                v210[11] = 0;
                v210[12] = 0;
                v280 = v210;
            }
            else
            {
                v210 = 0;
                v280 = 0;
            }
            v212 = this[232];
            LOBYTE(v289) = 5;
            this[232] = ++v212;
            v213 = v212;
            v214 = this[233];
            if (v213 > v214)
            {
                v215 = (void*)this[231];
                v216 = v214 + 8;
                this[233] = v216;
                v217 = (char*)sub_488DD7(v215, 4 * v216);
                if (v217)
                {
                    v218 = this[232];
                    v219 = this[233] - v218;
                    this[231] = v217;
                    memset(&v217[4 * v218], 0, 4 * v219);
                    v210 = v280;
                }
            }
            v220 = m;
            *(_DWORD*)(this[231] + 4 * this[232] - 4) = v210;
            v210[7] = v220;
            for (n = *v208; n; n = *++v208)
            {
                if (n >= 48 && n <= 57)
                    break;
                if (n == 45)
                    break;
                if (n == 46)
                    break;
            }
            if (*v208)
            {
                v222 = sub_48A1BB(v208);
                v223 = (char*)operator new(0x40u);
                sprintf(v223, "Boat Gun %d", v222);
                sub_469160((int)this, v280, v223, aBoatGun);
                sub_4885A6(v223);
                v210 = v280;
            }
            else if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                sub_40A120(0, aExtradataDatIs);
            }
            else
            {
                sub_40A120(0, "could not find a gun id number for a gun in model file %s", (const char*)(this[141] + 60));
            }
            for (ii = *v208; ii; ii = *++v208)
            {
                if ((ii < 48 || ii > 57) && ii != 45 && ii != 46)
                    break;
            }
            for (jj = *v208; jj; jj = *++v208)
            {
                if (jj >= 48 && jj <= 57)
                    break;
                if (jj == 45)
                    break;
                if (jj == 46)
                    break;
            }
            if (*v208)
            {
                v285 = atof(v208);
            }
            else if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                sub_40A120(0, aExtradataDatIs);
            }
            else
            {
                sub_40A120(0, "could not find min angle for a gun in model file %s", (const char*)(this[141] + 60));
            }
            for (kk = *v208; kk; kk = *++v208)
            {
                if ((kk < 48 || kk > 57) && kk != 45 && kk != 46)
                    break;
            }
            for (mm = *v208; mm; mm = *++v208)
            {
                if (mm >= 48 && mm <= 57)
                    break;
                if (mm == 45)
                    break;
                if (mm == 46)
                    break;
            }
            if (*v208)
            {
                v284 = atof(v208);
            }
            else if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                sub_40A120(0, aExtradataDatIs);
            }
            else
            {
                sub_40A120(0, "could not find max angle for a gun in model file %s", (const char*)(this[141] + 60));
            }
            v271 = v284 * 0.017453292;
            v267 = v285 * 0.017453292;
            sub_41C310((int)(v210 + 1), v267, v271);
            sub_41C310((int)(v210 + 4), 0.0, 6.2831855);
            v210[8] = -1;
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v228 = *(_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
                *(_DWORD*)v277 = v228;
            }
            else
            {
                v229 = *(_DWORD*)(dword_520970 + 200);
                v272 = *(_DWORD*)(this[141] + 8);
                *(_DWORD*)v277 = *(_DWORD*)sub_46A4C0(v229, &v272, 4u);
                v228 = *(_DWORD*)v277;
            }
            v230 = m + 1;
            for (nn = m + 1; nn < v228; ++nn)
            {
                if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
                {
                    v231 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
                }
                else
                {
                    v232 = *(_DWORD*)(dword_520970 + 200);
                    v272 = sub_405BB0((_DWORD*)this[141], nn);
                    v231 = (_DWORD*)sub_46A4C0(v232, &v272, 4u);
                }
                if (*v231 < m)
                    break;
                if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
                {
                    v233 = (_BYTE*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
                }
                else
                {
                    v234 = *(_DWORD*)(dword_520970 + 200);
                    v273 = sub_405BE0((_DWORD*)this[141], nn);
                    v233 = (_BYTE*)sub_46A4C0(v234, &v273, 4u);
                }
                if (*v233)
                {
                    v280[8] = nn;
                    break;
                }
            }
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v235 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v236 = *(_DWORD*)(dword_520970 + 200);
                v272 = *(_DWORD*)(this[141] + 8);
                v235 = (int*)sub_46A4C0(v236, &v272, 4u);
            }
            v237 = *v235;
            v272 = v237;
            for (nn = v230; nn < v237; ++nn)
            {
                if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
                {
                    v238 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
                }
                else
                {
                    v239 = *(_DWORD*)(dword_520970 + 200);
                    i2 = (_DWORD*)sub_405BB0((_DWORD*)this[141], nn);
                    v238 = (_DWORD*)sub_46A4C0(v239, &i2, 4u);
                }
                if (*v238 < m)
                    break;
                if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
                {
                    v240 = (_BYTE*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
                }
                else
                {
                    v241 = *(_DWORD*)(dword_520970 + 200);
                    v273 = sub_405BE0((_DWORD*)this[141], nn);
                    v240 = (_BYTE*)sub_46A4C0(v241, &v273, 4u);
                }
                if (!*v240)
                {
                    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
                    {
                        v242 = (_BYTE*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
                    }
                    else
                    {
                        v243 = *(_DWORD*)(dword_520970 + 200);
                        v273 = sub_405C00((_DWORD*)this[141], nn);
                        v242 = (_BYTE*)sub_46A4C0(v243, &v273, 4u);
                    }
                    if (!*v242)
                    {
                        v244 = v280 + 9;
                        v245 = (_DWORD*)v280[11];
                        v246 = v245;
                        if ((v280[12] - (int)v245) >> 2)
                        {
                            sub_448B80(v245, v245, v245 + 1);
                            sub_44B480((_DWORD*)v244[2], (_DWORD*)(1 - ((v244[2] - (int)v246) >> 2)), &nn);
                            for (i1 = (_DWORD*)v244[2]; v246 != i1; ++v246)
                                *v246 = nn;
                            v244[2] += 4;
                        }
                        else
                        {
                            v247 = v280[10];
                            if (!v247 || (v248 = ((int)v245 - v247) >> 2, v248 <= 1))
                                v248 = 1;
                            if (v247)
                                v249 = ((int)v245 - v247) >> 2;
                            else
                                v249 = 0;
                            v250 = v248 + v249;
                            v281 = v250;
                            if (v250 < 0)
                                v250 = 0;
                            v251 = operator new(4 * v250);
                            v252 = (_DWORD*)v244[1];
                            v286 = v251;
                            for (i2 = v251; v252 != v246; ++i2)
                                sub_448BE0(i2, v252++);
                            v253 = i2;
                            sub_448BE0(i2, &nn);
                            i2 = (_DWORD*)v244[2];
                            if (v246 != i2)
                            {
                                v254 = v253 + 1;
                                do
                                    sub_448BE0(v254++, v246++);
                                while (v246 != i2);
                            }
                            i2 = (_DWORD*)v244[1];
                            sub_4885A6(i2);
                            v255 = v286;
                            v244[3] = &v286[v281];
                            v256 = sub_4481C0(v244);
                            v237 = v272;
                            v244[2] = &v255[v256 + 1];
                            v244[1] = v255;
                        }
                    }
                }
            }
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v258 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v259 = *(_DWORD*)(dword_520970 + 200);
                v281 = sub_405A30((_DWORD*)this[141], asc_4A6264, v280[7], 1);
                v258 = (_DWORD*)sub_46A4C0(v259, &v281, 4u);
            }
            v260 = v280;
            v280[13] = *v258;
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
                sub_40A120(v260[13] != -1, aPleaseDeleteEx);
            else
                sub_40A120(v260[13] != -1, "%s, see %s : %s", aCollisionObjec, (const char*)this[1], *(const char**)ArgList);
        }
    }
    sub_42A840(this);
    sub_4229D0("Finished loading %s in %s", (const char*)this[1], *(const char**)ArgList);
    return this;
}
// 499224: using guessed type _UNKNOWN *off_499224;
// 4999BC: using guessed type _UNKNOWN *off_4999BC;
// 520970: using guessed type int dword_520970;

//----- (00442440) --------------------------------------------------------
int __fastcall sub_442440(int a1)
{
    int result; // eax

    result = a1;
    *(_DWORD*)(a1 + 4) = 0;
    *(_DWORD*)(a1 + 8) = 0;
    *(_DWORD*)(a1 + 12) = 0;
    *(_BYTE*)(a1 + 16) = 1;
    *(_BYTE*)(a1 + 20) = HIBYTE(a1);
    *(_DWORD*)(a1 + 24) = 0;
    *(_DWORD*)(a1 + 28) = 0;
    *(_DWORD*)(a1 + 32) = 0;
    *(_BYTE*)(a1 + 36) = HIBYTE(a1);
    *(_DWORD*)(a1 + 40) = 0;
    *(_DWORD*)(a1 + 44) = 0;
    *(_DWORD*)(a1 + 48) = 0;
    *(_DWORD*)a1 = &off_4999C8;
    return result;
}
// 4999C8: using guessed type _UNKNOWN *off_4999C8;

//----- (00442520) --------------------------------------------------------
char __thiscall sub_442520(int this)
{
    int v2; // eax
    int v3; // esi
    char* v4; // ebx
    int v5; // eax
    _DWORD* v6; // ecx
    int v7; // eax
    int v8; // edx
    int v9; // eax
    int* v10; // ecx
    int v11; // edx
    int v12; // eax
    int v13; // edx
    int v14; // eax
    int* v15; // ecx
    int v16; // edx
    int v17; // edx
    int v18; // eax
    int* v19; // ecx
    int v20; // edx
    int v22; // [esp+8h] [ebp-10h] BYREF
    int v23; // [esp+Ch] [ebp-Ch]
    int v24; // [esp+10h] [ebp-8h]

    v2 = *(_DWORD*)(this + 40);
    v3 = this + 36;
    if (v2 && (unsigned int)((*(_DWORD*)(this + 44) - v2) >> 4) >= 4)
    {
        if ((unsigned int)sub_448730((_DWORD*)v3) > 4)
            sub_448750((_DWORD*)v3, (_DWORD*)(*(_DWORD*)(v3 + 4) + 64), *(_DWORD**)(v3 + 8));
    }
    else
    {
        v4 = *(char**)(this + 44);
        v5 = sub_448730((_DWORD*)v3);
        sub_419CF0((char*)v3, v4, 4 - v5, &v22);
    }
    v6 = *(_DWORD**)(this + 40);
    *v6 = 1175210701;
    v6[1] = 1164390400;
    v22 = 1176636416;
    v23 = 1170216960;
    v24 = 0;
    v6[2] = 0;
    v7 = *(_DWORD*)(this + 40);
    v8 = v22;
    v22 = -973490176;
    *(_DWORD*)(v7 + 12) = 1150681088;
    v9 = v23;
    v10 = (int*)(*(_DWORD*)(this + 40) + 16);
    v23 = -1006551040;
    *v10 = v8;
    v11 = v24;
    v24 = 0;
    v10[1] = v9;
    v10[2] = v11;
    v12 = *(_DWORD*)(this + 40);
    v13 = v22;
    v22 = 1182896128;
    *(_DWORD*)(v12 + 28) = 1156415488;
    v14 = v23;
    v15 = (int*)(*(_DWORD*)(this + 40) + 32);
    v23 = 1164181504;
    *v15 = v13;
    v16 = v24;
    v24 = 0;
    v15[1] = v14;
    v15[2] = v16;
    v17 = v22;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 44) = 1154777088;
    v18 = v23;
    v19 = (int*)(*(_DWORD*)(this + 40) + 48);
    *v19 = v17;
    v20 = v24;
    v19[1] = v18;
    v19[2] = v20;
    *(_DWORD*)(*(_DWORD*)(this + 40) + 60) = 1149861888;
    sub_4113F0((_DWORD*)dword_4F5CC4, this, 65280, 512, 0);
    *(_BYTE*)(this + 52) = sub_422BA0(AppName, aBoatturretdebu, 0) != 0;
    return 1;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (004426B0) --------------------------------------------------------
int __thiscall sub_4426B0(_DWORD* this, int ArgList, int a3)
{
    int v3; // esi
    int v5; // eax
    int v6; // ebx
    int result; // eax
    _WORD* v8; // esi
    double v9; // st7
    double v10; // st6
    double v11; // st7
    unsigned int v12; // eax
    long double v13; // st7
    long double v14; // st7
    int v15; // ecx
    int v16; // edi
    float* v17; // eax
    int v18; // edi
    char v20; // c0
    int v21; // ebx
    unsigned __int8 v23; // c0
    unsigned __int8 v24; // c3
    float* v25; // eax
    double v26; // st6
    double v27; // st6
    float* v28; // edi
    float* v29; // eax
    double v30; // st7
    int v31; // ecx
    float v32; // ebp
    bool v33; // zf
    signed int v34; // eax
    long double v35; // st7
    int v36; // ecx
    float* v37; // eax
    int v38; // edi
    float v39; // edx
    float v40; // ecx
    double v41; // st7
    int v42; // ebp
    _DWORD* v43; // eax
    float v44; // [esp+0h] [ebp-8Ch]
    float v45; // [esp+14h] [ebp-78h]
    float v46; // [esp+14h] [ebp-78h]
    float v47; // [esp+18h] [ebp-74h]
    float v48; // [esp+18h] [ebp-74h]
    float v49; // [esp+1Ch] [ebp-70h]
    float v50; // [esp+1Ch] [ebp-70h]
    float v51; // [esp+20h] [ebp-6Ch]
    float v52; // [esp+20h] [ebp-6Ch]
    int v53; // [esp+24h] [ebp-68h]
    float v54; // [esp+28h] [ebp-64h]
    float v55; // [esp+28h] [ebp-64h]
    float v56; // [esp+2Ch] [ebp-60h]
    int v57; // [esp+30h] [ebp-5Ch]
    float v58; // [esp+30h] [ebp-5Ch]
    int v59; // [esp+34h] [ebp-58h]
    float v60; // [esp+38h] [ebp-54h] BYREF
    float v61; // [esp+3Ch] [ebp-50h]
    float v62; // [esp+40h] [ebp-4Ch]
    int v63; // [esp+44h] [ebp-48h] BYREF
    float v64; // [esp+48h] [ebp-44h]
    float v65; // [esp+4Ch] [ebp-40h]
    float v66; // [esp+50h] [ebp-3Ch]
    float v67; // [esp+54h] [ebp-38h]
    float v68; // [esp+58h] [ebp-34h]
    float v69; // [esp+5Ch] [ebp-30h] BYREF
    float v70; // [esp+60h] [ebp-2Ch]
    float v71; // [esp+64h] [ebp-28h]
    float v72; // [esp+68h] [ebp-24h]
    float v73; // [esp+6Ch] [ebp-20h]
    int v74; // [esp+70h] [ebp-1Ch]
    float v75; // [esp+74h] [ebp-18h]
    float v76; // [esp+78h] [ebp-14h]
    float v77; // [esp+80h] [ebp-Ch] BYREF
    int v78; // [esp+84h] [ebp-8h]
    int v79; // [esp+88h] [ebp-4h]

    v3 = ArgList;
    sub_4229D0("Adding boats: %d %s", ArgList, *(const char**)(a3 + 4));
    v5 = this[6];
    v6 = 0;
    if (v5)
        v53 = (this[7] - v5) >> 2;
    else
        v53 = 0;
    if (ArgList <= 0)
        return -1;
    if (ArgList > 1)
    {
        do
        {
            sub_4426B0(1, a3);
            --v3;
        } while (v3 > 0);
        return v53;
    }
    v8 = sub_442F80(this, (_WORD*)a3);
    if (*(float*)(a3 + 692) == 0.0)
        v9 = 40000.0;
    else
        v9 = *(float*)(a3 + 692);
    v10 = *(float*)(*((_DWORD*)v8 + 111) + 4288) * *(float*)(*((_DWORD*)v8 + 111) + 4284);
    v49 = v10 + v10 + v9;
    v50 = fabs((double)rand() * 0.000030518509) * 10000.0 + v49;
    v11 = *(float*)(*((_DWORD*)v8 + 111) + 4288) * *(float*)(*((_DWORD*)v8 + 111) + 4284);
    v12 = *(_DWORD*)(a3 + 292);
    v56 = v11 + v11 + 40000.0;
    if (v12 < 2)
    {
        v42 = 0;
        v73 = v50;
        v74 = 0;
        do
        {
            sub_4164A0(*((_DWORD*)v8 + 111), 0);
            v59 = rand();
            v78 = LODWORD(v50);
            v79 = 0;
            v72 = fabs((double)v59 * 0.000030518509) * 10000.0 - 5000.0;
            v77 = v72;
            if (sub_416350(*((_DWORD*)v8 + 111), &v77, 1))
            {
                v43 = (_DWORD*)*((_DWORD*)v8 + 111);
                v69 = 0.0;
                v43 += 30;
                v70 = -1.0;
                *v43 = 0;
                v71 = 0.0;
                v43[1] = -1082130432;
                v43[2] = 0;
                if (sub_416F80(*((_DWORD**)v8 + 111), 0))
                    break;
            }
            ++v42;
        } while (v42 < 200);
        return v53;
    }
    if (v12 == 4 || v12 == 5 || v12 == 6)
    {
        v52 = 1.0;
        if (*((_DWORD*)v8 + 109) == 1 && *(_BYTE*)(a3 + 740))
        {
            *((_DWORD*)v8 + 109) = 2;
            v52 = -1.0;
        }
        v48 = *(float*)(a3 + 696);
        v46 = *(float*)(a3 + 700);
        v74 = 0;
        v73 = v52 * v50;
        v32 = v73;
        do
        {
            if (v6 > 0 && !(v6 % 50))
            {
                v48 = v46;
                v46 = v46 + 2000.0;
            }
            sub_4164A0(*((_DWORD*)v8 + 111), 0);
            v34 = rand() & 0x80000001;
            v33 = v34 == 0;
            if (v34 < 0)
                v33 = (((_BYTE)v34 - 1) | 0xFFFFFFFE) == -1;
            v58 = 1.0;
            if (v33)
                v58 = -1.0;
            if (v48 == v46)
                v35 = v48;
            else
                v35 = fabs((double)rand() * 0.000030518509) * (v46 - v48) + v48;
            v79 = v74;
            v36 = *((_DWORD*)v8 + 111);
            v78 = LODWORD(v32);
            v72 = v58 * v35;
            v77 = v72;
            if (sub_416350(v36, &v77, 1))
            {
                v37 = (float*)*((_DWORD*)v8 + 111);
                v69 = 0.0;
                v37 += 30;
                v71 = 0.0;
                v38 = 0;
                v70 = v52 * -1.0;
                v39 = v70;
                *v37 = 0.0;
                v40 = v71;
                v37[1] = v39;
                v37[2] = v40;
                while (sub_447D80((int)v8))
                {
                    if (-v56 > v52 * *(float*)(sub_417140(*((_DWORD**)v8 + 111), 0) + 4))
                        return v53;
                    v55 = *(float*)(sub_417140(*((_DWORD**)v8 + 111), 1) + 4);
                    v41 = *(float*)(sub_417140(*((_DWORD**)v8 + 111), 0) + 4) - v55;
                    if (v41 < 0.0000099999997 && v41 > -0.0000099999997)
                        return v53;
                    if (++v38 >= 1000)
                        break;
                }
            }
            ++v6;
        } while (v6 < 400);
        return v53;
    }
    if (v12 != 2 && v12 != 3)
        return v53;
    v57 = 0;
    while (2)
    {
        v47 = *(float*)(a3 + 852);
        v51 = *(float*)(a3 + 856);
        if (v47 == v51)
            v13 = v47;
        else
            v13 = fabs((double)rand() * 0.000030518509) * (v51 - v47) + v47;
        v64 = v13;
        *(float*)&v63 = 0.0;
        v65 = 0.0;
        v44 = fabs((double)rand() * 0.000030518509) * 6.2831855;
        sub_401000((float*)&v63, v44);
        sub_46B970(&v69, &v63);
        v45 = *(float*)(a3 + 696);
        v54 = *(float*)(a3 + 700);
        if (v45 == v54)
            v14 = v45;
        else
            v14 = fabs((double)rand() * 0.000030518509) * (v54 - v45) + v45;
        v15 = *((_DWORD*)v8 + 111);
        v77 = 0.0;
        v78 = 1065353216;
        v75 = v69 * v14;
        v79 = 0;
        v76 = v70 * v14;
        v66 = v75 + *(float*)&v63;
        v67 = v64 + v76;
        v68 = v65 + v14 * v71;
        sub_4164A0(v15, 0);
        v16 = 30;
        do
        {
            sub_416350(*((_DWORD*)v8 + 111), &v63, 0);
            --v16;
        } while (v16);
        v17 = (float*)(*((_DWORD*)v8 + 111) + 120);
        v18 = 0;
        *v17 = v69;
        v17[1] = v70;
        v17[2] = v71;
        while (1)
        {
            sub_4196F0(*((_DWORD*)v8 + 111), &v69, 0.0, 0.0, 0, 0);
            if (v18 > 0)
            {
                sub_417140(*((_DWORD**)v8 + 111), 0);
                if (v20)
                    break;
            }
            if (++v18 >= 1000)
                goto LABEL_42;
        }
        v21 = 0;
        while (1)
        {
            sub_4196F0(*((_DWORD*)v8 + 111), &v77, 0.0, 0.0, 0, 0);
            sub_417140(*((_DWORD**)v8 + 111), 0);
            sub_417140(*((_DWORD**)v8 + 111), 1);
            if (!(v23 | v24))
            {
                sub_4164A0(*((_DWORD*)v8 + 111), *(_DWORD*)(*((_DWORD*)v8 + 111) + 4132) - 1);
                v25 = (float*)sub_417140(*((_DWORD**)v8 + 111), 0);
                v26 = v25[1] * -1.0;
                v74 = 0;
                v72 = v26 - 0.0;
                v27 = *v25 * -1.0;
                v62 = 0.0;
                v60 = v72;
                v73 = 0.0 - v27;
                v61 = v73;
                sub_46B970(&v60, &v60);
                v28 = (float*)sub_417140(*((_DWORD**)v8 + 111), 0);
                v29 = (float*)sub_417140(*((_DWORD**)v8 + 111), 1);
                if (v28[1] * *v29 - v29[1] * *v28 <= 0.0)
                    v30 = -1.0;
                else
                    v30 = 1.0;
                v31 = *((_DWORD*)v8 + 111);
                v60 = v60 * v30;
                v61 = v61 * v30;
                v62 = v62 * v30;
                sub_4196F0(v31, &v60, 0.0, 0.0, 0, 0);
            }
            if (*(float*)(sub_417140(*((_DWORD**)v8 + 111), 0) + 4) > (double)v50)
                break;
            if (++v21 >= 1000)
                goto LABEL_42;
        }
        if (sub_419BC0(*((_DWORD**)v8 + 111), 1))
            break;
    LABEL_42:
        if (++v57 < 200)
            continue;
        break;
    }
    result = v53;
    *((float*)v8 + 127) = (double)(*(_DWORD*)(*((_DWORD*)v8 + 111) + 4132) - 30)
        * *(float*)(*((_DWORD*)v8 + 111) + 4288);
    return result;
}
// 44270F: conditional instruction was optimized away because esi.4>=1
// 4429F2: variable 'v20' is possibly undefined
// 442A7F: variable 'v23' is possibly undefined
// 442A7F: variable 'v24' is possibly undefined
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);

//----- (00442EE0) --------------------------------------------------------
int __thiscall sub_442EE0(_DWORD* this, int* a2, int* a3, int a4, _DWORD* a5)
{
    int result; // eax
    unsigned int i; // esi
    int v8; // ecx

    result = 0;
    for (i = 0; ; ++i)
    {
        v8 = this[6];
        if (!v8)
            break;
        if (i >= (this[7] - v8) >> 2)
            break;
        if (*(_BYTE*)(*(_DWORD*)(v8 + 4 * i) + 16))
        {
            result = sub_443950(*(_DWORD**)(v8 + 4 * i), (int)a5, a2, a3, a4, a5);
            if (result)
                break;
        }
    }
    return result;
}

//----- (00442F30) --------------------------------------------------------
int __thiscall sub_442F30(_DWORD* this, int* a2, float a3, float a4, int a5, int a6)
{
    unsigned int i; // edi
    int result; // eax
    int v9; // ecx

    for (i = 0; ; ++i)
    {
        result = this[6];
        if (!result || i >= (this[7] - result) >> 2)
            break;
        v9 = *(_DWORD*)(result + 4 * i);
        if (*(_BYTE*)(v9 + 16))
            sub_443B50(v9, a2, a3, a4, *(float*)&a5, a6);
    }
    return result;
}

//----- (00442F80) --------------------------------------------------------
_WORD* __thiscall sub_442F80(_DWORD* this, _WORD* a2)
{
    int v3; // ebx
    void* v4; // eax
    int v5; // edi
    int v6; // eax
    _DWORD* v7; // edx
    _WORD v9[4]; // [esp+Ch] [ebp-14h] BYREF
    int v10; // [esp+1Ch] [ebp-4h]

    v3 = (int)a2;
    if (*(_BYTE*)(dword_4F5CC4 + 936))
    {
        v9[3] = a2[4];
        sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x201, v9, 8, 15, 0);
    }
    v4 = operator new(0x5B4u);
    v10 = 0;
    if (v4)
    {
        v5 = this[6];
        if (v5)
            v6 = sub_443250((int)v4, v3, (this[7] - v5) >> 2);
        else
            v6 = sub_443250((int)v4, v3, 0);
    }
    else
    {
        v6 = 0;
    }
    v7 = (_DWORD*)this[7];
    a2 = (_WORD*)v6;
    v10 = -1;
    sub_44F190((int)(this + 5), v7, 1u, &a2);
    sub_4442A0((int)a2);
    sub_428680(this, (int)a2);
    if (*(_BYTE*)(dword_4F5CC4 + 937))
        (*(void(__thiscall**)(_WORD*, _DWORD))(*(_DWORD*)a2 + 24))(a2, 0);
    return a2;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (00443080) --------------------------------------------------------
int __thiscall sub_443080(_DWORD* this)
{
    int v2; // eax
    int v3; // ebx
    int i; // edi
    void(__thiscall * **v5)(_DWORD, int); // ecx
    int result; // eax

    sub_4229D0(aBoatmanagerRes);
    *(_DWORD*)(*(_DWORD*)(dword_520970 + 280) + 2588) = 0;
    v2 = this[6];
    if (v2)
        v3 = (this[7] - v2) >> 2;
    else
        v3 = 0;
    for (i = 0; i < v3; ++i)
    {
        sub_428720(*(_DWORD**)(this[6] + 4 * i));
        sub_4286C0(this, *(_DWORD*)(this[6] + 4 * i));
        v5 = *(void(__thiscall****)(_DWORD, int))(this[6] + 4 * i);
        if (v5)
            (**v5)(v5, 1);
    }
    result = this[7];
    this[7] = this[6];
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (00443130) --------------------------------------------------------
char __thiscall sub_443130(_DWORD* this)
{
    int v1; // edx
    int v2; // eax
    int v3; // esi
    int i; // edx

    v1 = this[6];
    if (v1)
        v2 = (this[7] - v1) >> 2;
    else
        v2 = 0;
    v3 = 0;
    if (v2 <= 0)
        return 1;
    for (i = this[6]; !*(_BYTE*)(*(_DWORD*)i + 392) || *(_DWORD*)(*(_DWORD*)(*(_DWORD*)i + 408) + 292) == 5; i += 4)
    {
        if (++v3 >= v2)
            return 1;
    }
    return 0;
}

//----- (00443180) --------------------------------------------------------
__int16 __thiscall sub_443180(_DWORD* this, int a2)
{
    unsigned int v2; // eax
    int v3; // edx

    if (*(_WORD*)(a2 + 12) == 513)
    {
        LOWORD(v2) = (unsigned __int16)sub_442F80(
            this,
            *(_WORD**)(*(_DWORD*)(*(_DWORD*)(dword_520970 + 200) + 20)
                + 4 * *(unsigned __int16*)(*(_DWORD*)(a2 + 16) + 6)));
    }
    else
    {
        v2 = *(unsigned __int16*)(*(_DWORD*)(a2 + 16) + 6);
        v3 = this[6];
        if (v3 && v2 < (this[7] - v3) >> 2)
            LOWORD(v2) = (*(int(__thiscall**)(_DWORD, int))(**(_DWORD**)(v3 + 4 * v2) + 28))(*(_DWORD*)(v3 + 4 * v2), a2);
    }
    return v2;
}
// 520970: using guessed type int dword_520970;

//----- (004431F0) --------------------------------------------------------
int __thiscall sub_4431F0(_DWORD* this, int a2, int a3)
{
    return sub_4436D0(*(int**)(this[6] + 4 * a2), a3);
}

//----- (00443210) --------------------------------------------------------
int __thiscall sub_443210(_DWORD* this, int a2, int a3, int a4)
{
    unsigned int i; // esi
    int result; // eax

    for (i = 0; ; ++i)
    {
        result = this[6];
        if (!result || i >= (this[7] - result) >> 2)
            break;
        sub_447750(*(_DWORD**)(result + 4 * i), a2, a3, a4);
    }
    return result;
}

//----- (00443250) --------------------------------------------------------
int __thiscall sub_443250(int this, int a2, int ArgList)
{
    _DWORD* v4; // eax
    _DWORD* v5; // eax
    int* v6; // ebp
    _DWORD* v7; // eax
    _DWORD* v8; // eax
    int v9; // eax
    int v10; // ecx
    int v11; // edx
    _BYTE* v12; // eax
    int v13; // ecx
    int* v14; // eax
    _DWORD* v16; // [esp+10h] [ebp-24h] BYREF
    int v17[2]; // [esp+14h] [ebp-20h] BYREF
    int v18[3]; // [esp+1Ch] [ebp-18h] BYREF
    int v19; // [esp+30h] [ebp-4h]

    v17[1] = this;
    sub_401270(this);
    v19 = 0;
    *(_BYTE*)(this + 520) = a2;
    *(_DWORD*)(this + 524) = 0;
    *(_DWORD*)(this + 528) = 0;
    *(_DWORD*)(this + 532) = 0;
    Iostream_init::Iostream_init((Iostream_init*)(this + 552));
    *(_DWORD*)(this + 1392) = 0;
    *(_BYTE*)(this + 1388) = a2;
    *(_DWORD*)(this + 1396) = 0;
    *(_DWORD*)(this + 1400) = 0;
    *(_DWORD*)(this + 1432) = 0;
    *(_BYTE*)(this + 1428) = a2;
    *(_DWORD*)(this + 1436) = 0;
    *(_DWORD*)(this + 1440) = 0;
    *(_DWORD*)this = &off_4999E8;
    LOBYTE(v19) = 4;
    sub_4229D0("New Boat: %d %s", ArgList, *(const char**)(a2 + 4));
    *(_DWORD*)(this + 1456) = ArgList;
    *(_DWORD*)(this + 408) = a2;
    sub_4282E0(
        *(_DWORD*)(a2 + 564) != 0,
        "model for %s not loaded, try deleting ExtraData.dat",
        *(const char**)(a2 + 4));
    v4 = operator new(0x34u);
    LOBYTE(v19) = 5;
    if (v4)
        v5 = sub_406B00(v4, *(_DWORD*)(a2 + 564), 0);
    else
        v5 = 0;
    LOBYTE(v19) = 4;
    *(_DWORD*)(this + 412) = v5;
    sub_428680((_DWORD*)this, (int)v5);
    *(_DWORD*)(this + 432) = *(_DWORD*)(*(_DWORD*)(this + 408) + 680);
    *(_DWORD*)(this + 444) = sub_415270(*(_DWORD*)(dword_520970 + 244), *(_DWORD*)(a2 + 744));
    *(_DWORD*)(this + 416) = 0;
    v6 = sub_422400(*(_DWORD**)(dword_520970 + 124), aWakestripTga, 0);
    v7 = operator new(0x7Cu);
    LOBYTE(v19) = 6;
    if (v7)
        v8 = sub_463B30(v7, v6, 255, 255, 255, 3.0, 0.30000001, 1138819072, 1153138688, 0, 1, 1045220557);
    else
        v8 = 0;
    LOBYTE(v19) = 4;
    *(_DWORD*)(this + 416) = v8;
    sub_422230(v6);
    sub_428680((_DWORD*)this, *(_DWORD*)(this + 416));
    v9 = *(_DWORD*)(this + 408);
    *(_DWORD*)(this + 1452) = 0;
    v10 = *(_DWORD*)(v9 + 788);
    if (v10)
    {
        sub_4282E0(
            *(_BYTE*)(v10 + 301),
            "engine sound did not set 'engine = true', see %s : %s",
            *(const char**)(v9 + 4),
            (const char*)(v9 + 16));
        v11 = *(_DWORD*)(this + 408);
        memset(v18, 0, sizeof(v18));
        sub_44D850(*(_DWORD*)(v11 + 788), (float*)v18, &v16, v17);
        if (v16)
        {
            v12 = (_BYTE*)sub_41E2D0(*(_DWORD**)(dword_520970 + 120), v16, 0, 1);
            *(_DWORD*)(this + 1452) = v12;
            if (v12)
            {
                sub_41D8A0(v12, *(_BYTE*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 788) + 330));
                sub_41D8B0(
                    *(_DWORD**)(this + 1452),
                    *(_DWORD*)v17[0],
                    *(_DWORD*)(v17[0] + 12),
                    *(_DWORD*)(v17[0] + 20),
                    *(_DWORD*)(v17[0] + 4),
                    *(_DWORD*)(v17[0] + 8),
                    *(_DWORD*)(v17[0] + 16));
                v13 = *(_DWORD*)(this + 408);
                v14 = *(int**)(v13 + 788);
                sub_41D900(
                    *(_DWORD**)(this + 1452),
                    *(_DWORD*)(v13 + 688),
                    v14[76],
                    v14[77],
                    v14[78],
                    v14[79],
                    v14[80],
                    v14[81]);
            }
        }
    }
    return this;
}
// 4999E8: using guessed type _UNKNOWN *off_4999E8;
// 520970: using guessed type int dword_520970;

//----- (00443590) --------------------------------------------------------
int __thiscall sub_443590(int this)
{
    void* v2; // ecx
    int v3; // edi
    int v4; // ebp
    int v6; // [esp+Ch] [ebp-14h]

    *(_DWORD*)this = &off_4999E8;
    v2 = *(void**)(this + 444);
    if (v2)
    {
        sub_415910(v2);
        *(_DWORD*)(this + 444) = 0;
    }
    sub_444030((_DWORD*)this, 0);
    sub_4229D0("Deleting Boat: %d %s", *(_DWORD*)(this + 1456), *(const char**)(*(_DWORD*)(this + 408) + 4));
    v3 = *(_DWORD*)(this + 1432);
    v6 = *(_DWORD*)(this + 1436);
    if (v3 != v6)
    {
        v4 = v3 + 20;
        do
        {
            nullsub_1(v4);
            v3 += 860;
            v4 += 860;
        } while (v3 != v6);
    }
    sub_4885A6(*(LPVOID*)(this + 1432));
    *(_DWORD*)(this + 1432) = 0;
    *(_DWORD*)(this + 1436) = 0;
    *(_DWORD*)(this + 1440) = 0;
    sub_4885A6(*(LPVOID*)(this + 1392));
    *(_DWORD*)(this + 1392) = 0;
    *(_DWORD*)(this + 1396) = 0;
    *(_DWORD*)(this + 1400) = 0;
    nullsub_1(this + 552);
    sub_4885A6(*(LPVOID*)(this + 524));
    *(_DWORD*)(this + 524) = 0;
    *(_DWORD*)(this + 528) = 0;
    *(_DWORD*)(this + 532) = 0;
    return sub_4013F0((_DWORD*)this);
}
// 415760: using guessed type int __thiscall nullsub_1(_DWORD);
// 4999E8: using guessed type _UNKNOWN *off_4999E8;

//----- (004436D0) --------------------------------------------------------
int __thiscall sub_4436D0(int* this, int a2)
{
    _DWORD* v3; // eax
    int v4; // ecx
    int* v5; // esi
    _DWORD* v6; // edi
    int v7; // edx
    unsigned int v8; // ecx
    int v9; // eax
    int v10; // eax
    _DWORD* v11; // eax
    _DWORD* v12; // ebp
    _DWORD* i; // ebx
    int v14; // eax
    int result; // eax
    int v16; // ecx
    _DWORD* v17; // eax
    _DWORD* v18; // [esp+8h] [ebp-8h]
    int v19; // [esp+Ch] [ebp-4h]

    sub_4229D0(
        "Tank has arrived for boat %d %s: %s",
        this[364],
        *(const char**)(this[102] + 4),
        *(const char**)(*(_DWORD*)(a2 + 412) + 4));
    v3 = (_DWORD*)this[132];
    v4 = this[133];
    v5 = this + 130;
    v6 = v3;
    if ((v4 - (int)v3) >> 2)
    {
        sub_448B80(v3, v3, v3 + 1);
        sub_44B480((_DWORD*)v5[2], (_DWORD*)(1 - ((v5[2] - (int)v6) >> 2)), &a2);
        v17 = (_DWORD*)v5[2];
        if (v6 == v17)
        {
            result = v5[2] + 4;
            v5[2] = result;
        }
        else
        {
            do
                *v6++ = a2;
            while (v6 != v17);
            result = v5[2] + 4;
            v5[2] = result;
        }
    }
    else
    {
        v7 = v5[1];
        if (!v7 || (v8 = ((int)v3 - v7) >> 2, v8 <= 1))
            v8 = 1;
        if (v7)
            v9 = ((int)v3 - v7) >> 2;
        else
            v9 = 0;
        v10 = v8 + v9;
        v19 = v10;
        if (v10 < 0)
            v10 = 0;
        v11 = operator new(4 * v10);
        v12 = (_DWORD*)v5[1];
        v18 = v11;
        for (i = v11; v12 != v6; ++i)
            sub_448BE0(i, v12++);
        sub_44B480(i, (_DWORD*)1, &a2);
        sub_448B80(v6, (_DWORD*)v5[2], i + 1);
        nullsub_8(v5[1], v5[2]);
        sub_4885A6((LPVOID)v5[1]);
        v14 = v5[1];
        v5[3] = (int)&v18[v19];
        if (v14)
        {
            v16 = v5[2];
            v5[1] = (int)v18;
            result = (int)&v18[((v16 - v14) >> 2) + 1];
            v5[2] = result;
        }
        else
        {
            v5[1] = (int)v18;
            result = (int)(v18 + 1);
            v5[2] = (int)(v18 + 1);
        }
    }
    return result;
}

//----- (004438C0) --------------------------------------------------------
BOOL __thiscall sub_4438C0(float* this)
{
    return sub_4438E0(this) > 0.0;
}

//----- (004438E0) --------------------------------------------------------
double __thiscall sub_4438E0(float* this)
{
    if (this[106] <= (double)this[105])
        return this[106];
    else
        return this[105];
}

//----- (00443910) --------------------------------------------------------
char __thiscall sub_443910(float** this, int* a2, int* a3)
{
    float v4[3]; // [esp+0h] [ebp-Ch] BYREF

    return sub_407710(this[103], *a2, a2[1], a2[2], *a3, a3[1], a3[2], (int*)&a3, v4);
}

//----- (00443950) --------------------------------------------------------
int __userpurge sub_443950@<eax>(_DWORD* a1@<ecx>, int a2@<ebx>, int* a3, int* a4, int a5, _DWORD* a6)
{
    int v6; // edi
    int result; // eax
    double v9; // st7
    FILE* v10; // eax
    int v11; // eax
    int v12; // ebx
    int v13; // ecx
    int v14; // eax
    bool v15; // zf
    int v16; // [esp+Ch] [ebp-68h]
    float* v17; // [esp+10h] [ebp-64h]
    _WORD v18[4]; // [esp+14h] [ebp-60h] BYREF
    _DWORD* v19; // [esp+1Ch] [ebp-58h]
    float v20; // [esp+20h] [ebp-54h]
    int v21; // [esp+24h] [ebp-50h]
    int v22; // [esp+28h] [ebp-4Ch]
    int v23; // [esp+2Ch] [ebp-48h]
    char v24; // [esp+30h] [ebp-44h]
    int v25[16]; // [esp+34h] [ebp-40h] BYREF

    v6 = (int)a6;
    if (!sub_407A90(a1[103], a2, (int)a1, *a3, a3[1], a3[2], *a4, a4[1], a4[2], (int*)&a6, a6, v16, v17))
        return 0;
    v9 = *(float*)(*(_DWORD*)(a5 + 4) + 300);
    if (v9 > 0.0)
    {
        v10 = sub_4229D0("boat %d %s damaged: node %d took %0.1f", a1[364], *(const char**)(a1[102] + 4), a6, v9);
        if (*(_BYTE*)(dword_4F5CC4 + 936) || *(_BYTE*)(dword_4F5CC4 + 937))
        {
            if (!*(_BYTE*)(a5 + 124))
            {
                v18[3] = *((_WORD*)a1 + 728);
                v19 = a6;
                v20 = *(float*)v6;
                v21 = *(_DWORD*)(v6 + 4);
                v22 = *(_DWORD*)(v6 + 8);
                v11 = *(_DWORD*)(a5 + 4);
                v23 = *(_DWORD*)(v11 + 300);
                v24 = *(_BYTE*)(v11 + 312);
                sub_4117D0(dword_4F5CC4, (int**)0x203, v18, 29, 2, 2000);
            }
        }
        else
        {
            v12 = *(_DWORD*)(a5 + 4);
            LOBYTE(v10) = *(_BYTE*)(v12 + 312);
            sub_443CD0((int)a1, (int)a6, v6, *(float*)(v12 + 300), *(float*)&v10);
        }
    }
    v13 = a1[103];
    memset(&v25[11], 0, 16);
    memset(&v25[6], 0, 16);
    memset(&v25[1], 0, 16);
    v25[15] = 1065353216;
    v25[10] = 1065353216;
    v25[5] = 1065353216;
    v25[0] = 1065353216;
    sub_407690(v13, (int)a6, v25);
    sub_46C5C5((float*)v6, (float*)v6, (float*)v25);
    v14 = *(_DWORD*)(a1[102] + 292);
    if (!v14)
        return 6;
    v15 = v14 == 2;
    result = 7;
    if (v15)
        return 6;
    return result;
}
// 443988: variable 'v16' is possibly undefined
// 443988: variable 'v17' is possibly undefined
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (00443B50) --------------------------------------------------------
unsigned int __thiscall sub_443B50(int this, int* a2, float a3, float a4, float a5, int a6)
{
    float v6; // ebx
    int v8; // ebp
    unsigned int result; // eax
    int v10; // edx
    signed int v11; // ecx
    int v12; // esi
    char v13; // al
    float v14; // [esp+0h] [ebp-48h]
    char v15; // [esp+1Bh] [ebp-2Dh]
    int v16; // [esp+1Ch] [ebp-2Ch] BYREF
    int v17; // [esp+20h] [ebp-28h]
    int v18; // [esp+24h] [ebp-24h]
    _WORD v19[4]; // [esp+28h] [ebp-20h] BYREF
    int v20; // [esp+30h] [ebp-18h]
    int v21; // [esp+34h] [ebp-14h]
    int v22; // [esp+38h] [ebp-10h]
    int v23; // [esp+3Ch] [ebp-Ch]
    float v24; // [esp+40h] [ebp-8h]
    char v25; // [esp+44h] [ebp-4h]

    v6 = a5;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v15 = 0;
    v8 = -2;
    while (1)
    {
        result = *(_DWORD*)(this + 1432);
        if (result)
        {
            v11 = *(_DWORD*)(this + 1436) - result;
            result = (unsigned int)((unsigned __int64)(1278501893LL * v11) >> 32) >> 31;
            v10 = v11 / 860;
        }
        else
        {
            v10 = 0;
        }
        if (v8 >= v10)
            return result;
        if (v8 == -2)
        {
            v12 = *(_DWORD*)(*(_DWORD*)(this + 408) + 612);
        }
        else if (v8 == -1)
        {
            v12 = *(_DWORD*)(*(_DWORD*)(this + 408) + 616);
        }
        else
        {
            v12 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + 4 * v8) + 52);
        }
        if (v12 > -1 && sub_407F00(*(_DWORD*)(this + 412), v12, a2, a3, &v16, &a5))
        {
            if (!*(_BYTE*)(dword_4F5CC4 + 936) && !*(_BYTE*)(dword_4F5CC4 + 937))
            {
                v14 = a5 * a4;
                if (sub_443CD0(this, v12, (int)&v16, v14, v6) || (v13 = v15, v15 = 0, v13))
                    v15 = 1;
                goto LABEL_19;
            }
            v19[3] = *(_WORD*)(this + 1456);
            v22 = v17;
            v24 = a5 * a4;
            v21 = v16;
            v20 = v12;
            v23 = v18;
            v25 = LOBYTE(v6);
            sub_4117D0(dword_4F5CC4, (int**)0x203, v19, 29, 2, 2000);
            ++v8;
        }
        else
        {
        LABEL_19:
            ++v8;
        }
    }
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (00443CD0) --------------------------------------------------------
bool __thiscall sub_443CD0(int this, int a2, int a3, float a4, float a5)
{
    int v6; // ebp
    unsigned int i; // edi
    int* v8; // eax
    int v9; // ebx
    int v10; // edx
    double v11; // st7
    float* v12; // edx
    int v13; // eax
    int v14; // edx
    int v15; // eax
    int v16; // eax
    int v17; // eax
    double v18; // st7
    double v19; // st7
    char v21; // [esp+1Ah] [ebp-Eh]
    char v22; // [esp+1Bh] [ebp-Dh]
    int v23[3]; // [esp+1Ch] [ebp-Ch] BYREF
    float v24; // [esp+38h] [ebp+10h]

    sub_4229D0(
        "boat %d %s node %d took %0.1f damage",
        *(_DWORD*)(this + 1456),
        *(const char**)(*(_DWORD*)(this + 408) + 4),
        a2,
        a4);
    v6 = *(_DWORD*)(this + 1432);
    v22 = *(_BYTE*)(this + 392);
    v21 = 0;
    for (i = 0; v6 && i < (*(_DWORD*)(this + 1436) - v6) / 860; ++i)
    {
        v8 = *(int**)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + 4 * i);
        v9 = *v8;
        if (a2 == v8[13])
        {
            v10 = *(_DWORD*)(this + 1432);
            v21 = 1;
            v11 = *(float*)(v10 + 860 * i + 12);
            v12 = (float*)(v10 + 860 * i + 12);
            if (v11 > 0.0)
            {
                *v12 = *v12 - a4;
                if (*(float*)(*(_DWORD*)(this + 1432) + 860 * i + 12) <= 0.0)
                {
                    v13 = *(_DWORD*)(v9 + 316);
                    if (v13)
                    {
                        v14 = *(_DWORD*)(this + 408);
                        memset(v23, 0, sizeof(v23));
                        sub_44E040(
                            *(char**)(dword_520970 + 240),
                            v13,
                            this + 480,
                            *(_DWORD*)(this + 412),
                            *(float*)(*(_DWORD*)(*(_DWORD*)(v14 + 924) + 4 * i) + 28),
                            v23);
                    }
                    sub_408640(
                        *(_DWORD**)(this + 412),
                        *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + 4 * i) + 28),
                        0);
                    v15 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + 4 * i) + 32);
                    if (v15 != -1)
                        sub_408640(*(_DWORD**)(this + 412), v15, 0);
                    sub_407670(
                        *(_DWORD**)(this + 412),
                        *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + 4 * i) + 52),
                        0);
                }
            }
            break;
        }
    }
    if (!LOBYTE(a5))
    {
        v16 = *(_DWORD*)(*(_DWORD*)(this + 408) + 292);
        if (v16)
        {
            if (v16 != 2)
                a4 = 0.0;
        }
    }
    if (sub_4438C0((float*)this))
    {
        v17 = *(_DWORD*)(this + 408);
        if (a2 == *(_DWORD*)(v17 + 616))
        {
            v21 = 1;
            *(float*)(this + 424) = *(float*)(this + 424) - a4;
        }
        if (a2 == *(_DWORD*)(v17 + 612) || !v21)
            *(float*)(this + 420) = *(float*)(this + 420) - a4;
        if (*(_BYTE*)(dword_4F5CC4 + 937))
        {
            if (!sub_4438C0((float*)this))
            {
                sub_4477F0(this, 1);
                *(_DWORD*)(this + 428) = 2139095039;
            }
        }
        else if (*(float*)(v17 + 676) != 0.0 || sub_4438C0((float*)this))
        {
            if (*(_BYTE*)(this + 392))
            {
                v24 = *(float*)(*(_DWORD*)(this + 408) + 668);
                v18 = v24 == 0.0 ? 0.0 : sub_4438E0((float*)this) / v24;
                if (v18 <= *(float*)(*(_DWORD*)(this + 408) + 676))
                    sub_4477F0(this, 1);
            }
            if (*(float*)(this + 424) <= 0.1)
                v19 = 0.1;
            else
                v19 = *(float*)(this + 424);
            *(float*)(this + 424) = v19;
            if (*(float*)(this + 420) <= 0.1)
                *(float*)(this + 420) = 0.1;
            else
                *(float*)(this + 420) = *(float*)(this + 420);
        }
        else
        {
            sub_4440B0(this, 0);
        }
    }
    return v22 && !*(_BYTE*)(this + 392);
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (00444030) --------------------------------------------------------
char __thiscall sub_444030(_DWORD* this, char a2)
{
    int v3; // ecx
    char result; // al
    int v5; // eax
    int v6; // [esp-Ch] [ebp-1Ch]
    int v7[3]; // [esp+4h] [ebp-Ch] BYREF

    v3 = this[363];
    if (v3)
    {
        sub_41D9A0(v3);
        result = a2;
        this[363] = 0;
        if (a2)
        {
            v5 = this[102];
            v6 = this[103];
            memset(v7, 0, sizeof(v7));
            return sub_44E040(*(char**)(dword_520970 + 240), *(_DWORD*)(v5 + 792), (int)(this + 120), v6, 0.0, v7);
        }
    }
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (004440B0) --------------------------------------------------------
char __thiscall sub_4440B0(int this, char a2)
{
    int v3; // eax
    int v4; // ecx
    char v5; // al
    int v6; // eax
    float* v7; // eax
    float* v8; // eax
    int v9; // edi
    int v10; // ecx
    int v12; // [esp+8h] [ebp+4h]

    sub_4229D0("Boat %d %s destroyed", *(_DWORD*)(this + 1456), *(const char**)(*(_DWORD*)(this + 408) + 4));
    v3 = *(_DWORD*)(this + 444);
    if (!v3)
        return v3;
    if (*(_BYTE*)(this + 392))
        sub_444030((_DWORD*)this, 1);
    sub_4477F0(this, 1);
    v4 = *(_DWORD*)(this + 444);
    *(float*)(this + 428) = (1.0 - *(float*)(v4 + 16)) * *(float*)(v4 + 4288) + *(float*)(v4 + 4288) * 4.0;
    if (*(_BYTE*)(dword_4F5CC4 + 937))
    {
        if (!a2)
        {
        LABEL_9:
            v5 = 0;
            goto LABEL_11;
        }
    }
    else if (*(_DWORD*)(this + 436) != 6 || *(float*)(v4 + 4288) * 6.0 <= *(float*)(this + 508))
    {
        goto LABEL_9;
    }
    v5 = 1;
LABEL_11:
    *(_DWORD*)(this + 436) = 7;
    if (v5)
    {
        sub_4164A0(v4, 6);
        v6 = *(_DWORD*)(this + 444);
        v12 = *(_DWORD*)(v6 + 4284);
        *(_DWORD*)(v6 + 4284) = *(_DWORD*)(*(_DWORD*)(this + 408) + 848);
        v7 = (float*)(*(_DWORD*)(this + 444) + 120);
        *v7 = *v7 * -1.0;
        v7[1] = v7[1] * -1.0;
        v7[2] = v7[2] * -1.0;
        v8 = (float*)(*(_DWORD*)(this + 444) + 36);
        *v8 = *v8 * -1.0;
        v8[1] = v8[1] * -1.0;
        v8[2] = v8[2] * -1.0;
        *(_BYTE*)(this + 448) = 1;
        if (!*(_BYTE*)(dword_4F5CC4 + 937))
        {
            v9 = 3;
            do
            {
                sub_419910(*(_DWORD*)(this + 444), 0.0, 0.0, COERCE_FLOAT(1), 0, 0);
                --v9;
            } while (v9);
        }
        *(_DWORD*)(*(_DWORD*)(this + 444) + 4284) = v12;
        v10 = *(_DWORD*)(this + 444);
        *(float*)(this + 428) = *(float*)(v10 + 4288) * 3.0 + *(float*)(this + 428);
        LOBYTE(v3) = sub_416F80((_DWORD*)v10, 1);
        *(_BYTE*)(this + 440) = 2;
    }
    else
    {
        LOBYTE(v3) = *(_BYTE*)(dword_4F5CC4 + 937);
        if (!(_BYTE)v3)
        {
            sub_4164A0(v4, 6);
            LOBYTE(v3) = sub_416F80(*(_DWORD**)(this + 444), 1);
        }
        *(_BYTE*)(this + 440) = 1;
    }
    return v3;
}
// 44413D: conditional instruction was optimized away because al.1!=0
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (004442A0) --------------------------------------------------------
char __thiscall sub_4442A0(int this)
{
    int v2; // eax
    float* v3; // eax
    double v4; // st7
    int v5; // eax
    int v6; // ecx
    long double v7; // st7
    int v8; // eax
    long double v9; // st7
    int v10; // eax
    _DWORD* v11; // ebp
    int v12; // eax
    int v13; // eax
    int v14; // ecx
    _DWORD* v15; // ebp
    int v16; // eax
    long double v17; // st7
    int v18; // eax
    unsigned int v19; // edi
    unsigned int v20; // edx
    char* v21; // ebx
    int v22; // eax
    unsigned int v23; // edi
    int i; // ebp
    __int64 v25; // rax
    int v26; // ebx
    int v27; // ecx
    long double v28; // st7
    long double v29; // st7
    int v30; // eax
    int v31; // eax
    int v32; // esi
    float v34; // [esp+10h] [ebp-438h]
    float v35; // [esp+10h] [ebp-438h]
    float v36; // [esp+10h] [ebp-438h]
    float v37; // [esp+10h] [ebp-438h]
    float v38; // [esp+10h] [ebp-438h]
    float v39; // [esp+10h] [ebp-438h]
    float v40; // [esp+14h] [ebp-434h]
    float v41; // [esp+14h] [ebp-434h]
    float v42; // [esp+14h] [ebp-434h]
    float v43; // [esp+14h] [ebp-434h]
    float v44; // [esp+14h] [ebp-434h]
    float v45; // [esp+14h] [ebp-434h]
    float v46; // [esp+18h] [ebp-430h]
    float v47; // [esp+1Ch] [ebp-42Ch]
    int v48[16]; // [esp+20h] [ebp-428h] BYREF
    int v49[16]; // [esp+60h] [ebp-3E8h] BYREF
    _BYTE v50[64]; // [esp+A0h] [ebp-3A8h] BYREF
    _BYTE v51[20]; // [esp+E0h] [ebp-368h] BYREF
    _BYTE v52[840]; // [esp+F4h] [ebp-354h] BYREF
    int v53; // [esp+444h] [ebp-4h]

    *(_DWORD*)(*(_DWORD*)(dword_520970 + 280) + 2588) = 0;
    v2 = *(_DWORD*)(this + 416);
    *(_BYTE*)(this + 392) = 1;
    *(_BYTE*)(this + 440) = 0;
    if (v2)
        *(_DWORD*)(v2 + 76) = 0;
    sub_407250(*(_DWORD**)(this + 412));
    sub_4074B0(*(_DWORD**)(this + 412), 0);
    sub_408860(*(_DWORD**)(this + 412), 0);
    *(_BYTE*)(*(_DWORD*)(this + 412) + 48) = 0;
    *(_DWORD*)(*(_DWORD*)(this + 412) + 36) = 0;
    *(_DWORD*)(*(_DWORD*)(this + 412) + 32) = 0;
    v3 = *(float**)(this + 408);
    v4 = v3[168] * v3[167];
    *(_BYTE*)(this + 448) = 0;
    *(float*)(this + 420) = v4;
    *(float*)(this + 424) = v4;
    if (*(_BYTE*)(dword_4F5CC4 + 937))
        sub_415770(*(_DWORD*)(this + 444), v3 + 142, v3 + 145, this, 0);
    else
        sub_415770(*(_DWORD*)(this + 444), v3 + 142, v3 + 145, this, (int)sub_447D70);
    *(_DWORD*)(*(_DWORD*)(this + 444) + 4144) = 1;
    v5 = *(_DWORD*)(this + 408);
    v6 = *(_DWORD*)(v5 + 292);
    if (v6)
    {
        switch (v6)
        {
        case 1:
            *(_DWORD*)(this + 436) = 0;
            v36 = *(float*)(v5 + 796);
            v42 = *(float*)(v5 + 800);
            if (v36 == v42)
                v9 = v36;
            else
                v9 = fabs((double)rand() * 0.000030518509) * (v42 - v36) + v36;
            v10 = *(_DWORD*)(this + 408);
            *(float*)(this + 496) = v9;
            v37 = *(float*)(v10 + 828);
            v43 = *(float*)(v10 + 832);
            if (v37 == v43)
                *(float*)(this + 504) = v37;
            else
                *(float*)(this + 504) = fabs((double)rand() * 0.000030518509) * (v43 - v37) + v37;
            break;
        case 2:
            *(_DWORD*)(this + 436) = 6;
            break;
        case 3:
            *(_DWORD*)(this + 436) = 6;
            v11 = sub_448BB0(*(int**)(this + 528), *(int**)(this + 528), *(_DWORD**)(this + 524));
            nullsub_8((int)v11, *(_DWORD*)(this + 528));
            *(_DWORD*)(this + 528) = v11;
            if (!*(_BYTE*)(dword_4F5CC4 + 937))
            {
                v12 = sub_45A840(*(_DWORD**)(dword_520970 + 236));
                sub_4476E0((int*)this, 4, v12);
            }
            *(_DWORD*)(this + 536) = 0;
            break;
        case 4:
            *(_DWORD*)(this + 436) = 1;
            *(_BYTE*)(*(_DWORD*)(this + 444) + 4316) = 0;
            break;
        case 5:
            v13 = *(_DWORD*)(this + 444);
            *(_DWORD*)(this + 436) = 1;
            *(_BYTE*)(v13 + 4316) = 0;
            break;
        case 6:
            v14 = *(_DWORD*)(this + 444);
            *(_DWORD*)(this + 436) = 1;
            *(_BYTE*)(v14 + 4316) = 0;
            *(_DWORD*)(this + 544) = 0;
            *(_DWORD*)(this + 540) = 1077936128;
            v15 = sub_448BB0(*(int**)(this + 1396), *(int**)(this + 1396), *(_DWORD**)(this + 1392));
            nullsub_8((int)v15, *(_DWORD*)(this + 1396));
            *(_DWORD*)(this + 1396) = v15;
            v16 = *(_DWORD*)(this + 408);
            v38 = *(float*)(v16 + 880);
            v44 = *(float*)(v16 + 884);
            if (v38 == v44)
                v17 = v38;
            else
                v17 = fabs((double)rand() * 0.000030518509) * (v44 - v38) + v38;
            *(float*)(this + 1404) = v17;
            *(_DWORD*)(this + 1408) = 0;
            *(_DWORD*)(this + 1412) = 0;
            *(_DWORD*)(this + 1416) = 0;
            *(_DWORD*)(this + 1420) = 0;
            break;
        default:
            sub_40A120(0, aInvalidBoatTyp);
            break;
        }
    }
    else
    {
        *(_DWORD*)(this + 436) = 0;
        v34 = *(float*)(v5 + 796);
        v40 = *(float*)(v5 + 800);
        if (v34 == v40)
            v7 = v34;
        else
            v7 = fabs((double)rand() * 0.000030518509) * (v40 - v34) + v34;
        v8 = *(_DWORD*)(this + 408);
        *(float*)(this + 496) = v7;
        v35 = *(float*)(v8 + 816);
        v41 = *(float*)(v8 + 820);
        if (v35 == v41)
            *(float*)(this + 500) = v35;
        else
            *(float*)(this + 500) = fabs((double)rand() * 0.000030518509) * (v41 - v35) + v35;
    }
    *(_BYTE*)(this + 1424) = 1;
    *(_BYTE*)(this + 1425) = 0;
    Iostream_init::Iostream_init((Iostream_init*)v52);
    v18 = *(_DWORD*)(this + 1432);
    v19 = *(_DWORD*)(*(_DWORD*)(this + 408) + 928);
    v53 = 0;
    if (v18)
        v20 = (*(_DWORD*)(this + 1436) - v18) / 860;
    else
        v20 = 0;
    if (v20 >= v19)
    {
        if (v19 < sub_4482D0((_DWORD*)(this + 1428)))
            sub_448B20((_DWORD*)(this + 1428), (char*)(*(_DWORD*)(this + 1432) + 860 * v19), *(char**)(this + 1436));
    }
    else
    {
        v21 = *(char**)(this + 1436);
        v22 = sub_4482D0((_DWORD*)(this + 1428));
        sub_4487A0((_DWORD*)(this + 1428), v21, v19 - v22, v51);
    }
    v53 = -1;
    nullsub_1(v52);
    v23 = 0;
    for (i = 0; ; i += 860)
    {
        LODWORD(v25) = *(_DWORD*)(this + 1432);
        if (!(_DWORD)v25)
            break;
        v25 = 1278501893LL * (*(_DWORD*)(this + 1436) - (int)v25);
        if (v23 >= (HIDWORD(v25) >> 31) + (SHIDWORD(v25) >> 8))
            break;
        v26 = **(_DWORD**)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + 4 * v23);
        *(_BYTE*)(*(_DWORD*)(this + 1432) + i) = rand() % 2 != 0;
        v27 = *(_DWORD*)(this + 1432);
        if (*(_BYTE*)(v27 + i))
        {
            v45 = *(float*)(v26 + 324);
            if (0.0 == v45)
                *(float*)(v27 + i + 4) = 0.0;
            else
                *(float*)(*(_DWORD*)(this + 1432) + i + 4) = fabs((double)rand() * 0.000030518509) * v45;
        }
        else
        {
            v39 = *(float*)(v26 + 332);
            if (0.0 == v39)
                v28 = 0.0;
            else
                v28 = fabs((double)rand() * 0.000030518509) * v39;
            *(float*)(*(_DWORD*)(this + 1432) + i + 4) = v28;
        }
        v46 = *(float*)(v26 + 304);
        if (0.0 == v46)
            v29 = 0.0;
        else
            v29 = fabs((double)rand() * 0.000030518509) * v46;
        *(float*)(*(_DWORD*)(this + 1432) + i + 8) = v29;
        *(_DWORD*)(*(_DWORD*)(this + 1432) + i + 12) = *(_DWORD*)(v26 + 312);
        *(_DWORD*)(*(_DWORD*)(this + 1432) + i + 16) = 0;
        *(_DWORD*)(*(_DWORD*)(this + 1432) + i + 856) = 0;
        sub_408640(
            *(_DWORD**)(this + 412),
            *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + 4 * v23) + 28),
            1);
        v30 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + 4 * v23) + 32);
        if (v30 != -1)
            sub_408640(*(_DWORD**)(this + 412), v30, 1);
        sub_41C4E0((float*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + 4 * v23) + 4));
        v47 = v29;
        sub_46BF69((float*)v49, v47);
        sub_46BE62((float*)v48, 0.0);
        v31 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + 4 * v23);
        if (*(_DWORD*)(v31 + 32) == -1)
        {
            sub_46B97C(v50, v48, v49);
            sub_4073F0(
                *(_DWORD**)(this + 412),
                *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + 4 * v23) + 28),
                v50);
            sub_4073C0(
                *(_DWORD**)(this + 412),
                *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + 4 * v23) + 28),
                1);
        }
        else
        {
            sub_4073F0(*(_DWORD**)(this + 412), *(_DWORD*)(v31 + 28), v49);
            sub_4073C0(
                *(_DWORD**)(this + 412),
                *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + 4 * v23) + 28),
                1);
            sub_4073F0(
                *(_DWORD**)(this + 412),
                *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + 4 * v23) + 32),
                v48);
            sub_4073C0(
                *(_DWORD**)(this + 412),
                *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + 4 * v23) + 32),
                1);
        }
        ++v23;
    }
    *(_DWORD*)(this + 1444) = 0;
    *(_DWORD*)(this + 1448) = 0;
    v32 = *(_DWORD*)(this + 1452);
    if (v32)
        LOBYTE(v25) = sub_41D840(v32);
    return v25;
}
// 415760: using guessed type int __thiscall nullsub_1(_DWORD);
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (00444A90) --------------------------------------------------------
void sub_444A90()
{
    JUMPOUT(0x415760);
}
// 444A93: control flows out of bounds to 415760

//----- (00444AA0) --------------------------------------------------------
char __thiscall sub_444AA0(int this, int a2)
{
    double v3; // st7
    double v4; // st6
    float* v6; // ebp
    float* v7; // edi
    int v8; // ecx
    double v9; // st7
    double v10; // st7
    int v11; // ecx
    double v12; // st7
    double v13; // st7
    double v14; // st7
    float v15; // eax
    int v16; // ecx
    int v17; // eax
    char v19; // c0
    unsigned int i; // edi
    int v21; // eax
    int v22; // ecx
    int v23; // ecx
    unsigned int j; // edi
    int v25; // eax
    int v26; // ecx
    int v27; // ecx
    double v28; // st7
    int v29; // eax
    char v30; // fps^1
    double v31; // st7
    char v32; // ah
    bool v33; // c0
    bool v34; // c3
    int v35; // ecx
    int v36; // eax
    long double v37; // st7
    char* v38; // edi
    int v39; // eax
    double v40; // st7
    int v41; // eax
    long double v42; // st7
    double v43; // st7
    int v44; // eax
    double v45; // st7
    char v46; // al
    double v47; // st7
    int v48; // eax
    double v49; // st7
    int v50; // eax
    long double v51; // st7
    double v52; // st7
    int v53; // eax
    int v54; // eax
    double v55; // st7
    int v56; // ecx
    int v57; // eax
    int v58; // ecx
    int v59; // eax
    int v60; // edi
    int v61; // ecx
    int v62; // ecx
    int v63; // ecx
    int v64; // ecx
    int v65; // ecx
    int v66; // ecx
    float* v67; // edx
    int v68; // ecx
    int v69; // eax
    int v70; // ecx
    unsigned int v71; // ebx
    unsigned int v72; // eax
    int v73; // eax
    int v74; // ecx
    int v75; // ecx
    unsigned int v76; // ebp
    unsigned int v77; // eax
    _DWORD* v78; // ebx
    int v79; // eax
    unsigned int k; // ebp
    int v81; // eax
    int v82; // ebx
    int v83; // ecx
    int v84; // ebp
    double v85; // st7
    int v86; // eax
    int v87; // eax
    double v88; // st7
    int v89; // ecx
    int v90; // eax
    int v91; // eax
    int v92; // edi
    int v93; // edi
    int v94; // eax
    double v95; // st7
    int v96; // edx
    float* v97; // ecx
    int v98; // eax
    int v99; // ebx
    int m; // edi
    int v101; // ebp
    _DWORD* v102; // eax
    _DWORD* v103; // edx
    _DWORD* v104; // edx
    _DWORD* v105; // edx
    unsigned int n; // edi
    int v107; // eax
    _DWORD* v108; // ecx
    _DWORD* v109; // edx
    _DWORD* v110; // edx
    char v111; // cl
    bool v112; // al
    int v113; // edi
    int v114; // eax
    double v115; // st7
    int v116; // eax
    int v117; // ebx
    int v118; // eax
    int v119; // eax
    int v120; // ecx
    int* v121; // ecx
    int v122; // eax
    int v123; // ecx
    int v124; // eax
    _DWORD* v125; // ecx
    double v126; // st7
    double v127; // st6
    int v128; // eax
    int v129; // ebx
    int v130; // eax
    float v131; // ecx
    int v132; // ebp
    int v133; // eax
    double v134; // st7
    double v135; // st6
    int v136; // eax
    int v137; // ecx
    int v138; // edx
    int v139; // eax
    _DWORD* v140; // eax
    int v141; // ecx
    int v142; // edx
    int v143; // ecx
    double v144; // st7
    int v145; // eax
    double v146; // st7
    int v147; // edx
    float v148; // ebp
    int v149; // edx
    int v150; // eax
    int v151; // ecx
    double v152; // st7
    long double v153; // st7
    double v154; // st7
    double v155; // st7
    int v156; // eax
    int v157; // eax
    int v158; // ebx
    int v159; // ecx
    float v160; // edx
    int v161; // eax
    int v162; // ecx
    float v163; // ecx
    float v164; // edx
    long double v165; // st7
    float v166; // ebx
    int v167; // ecx
    int v168; // edx
    int v169; // ebx
    int v170; // ebp
    int v171; // ecx
    int v172; // eax
    float** v173; // ecx
    int v174; // eax
    double v175; // st7
    int v176; // eax
    double v177; // st7
    int v178; // ecx
    double v179; // st7
    double v180; // st7
    double v181; // st7
    double v182; // st7
    long double v183; // st7
    int v184; // eax
    int v185; // eax
    int v186; // ecx
    int v187; // edi
    int v188; // eax
    int v189; // ecx
    double v190; // st7
    float v191; // edx
    long double v192; // st7
    int v193; // eax
    int v194; // eax
    int v195; // ecx
    int v196; // edi
    int v197; // eax
    _DWORD* v198; // ecx
    float v199; // eax
    int v200; // edx
    int v201; // eax
    float v202; // edx
    float v203; // eax
    float v204; // ecx
    double v205; // st7
    float v206; // eax
    float v207; // eax
    float v208; // edx
    float v209; // edx
    float v210; // ecx
    float v211; // eax
    float v212; // ecx
    float* v213; // edx
    float v214; // ecx
    float v215; // eax
    int v216; // eax
    int v217; // eax
    double v218; // st7
    int v219; // edi
    char v220; // dl
    int v221; // [esp+4h] [ebp-3C4h]
    float v222; // [esp+8h] [ebp-3C0h]
    float v223; // [esp+8h] [ebp-3C0h]
    float v224; // [esp+8h] [ebp-3C0h]
    float v225; // [esp+Ch] [ebp-3BCh]
    int v226; // [esp+Ch] [ebp-3BCh]
    int v227; // [esp+Ch] [ebp-3BCh]
    float v228; // [esp+Ch] [ebp-3BCh]
    float v229; // [esp+Ch] [ebp-3BCh]
    float v230; // [esp+Ch] [ebp-3BCh]
    int v231; // [esp+Ch] [ebp-3BCh]
    float v232; // [esp+Ch] [ebp-3BCh]
    float v233; // [esp+Ch] [ebp-3BCh]
    int v234; // [esp+Ch] [ebp-3BCh]
    int v235; // [esp+Ch] [ebp-3BCh]
    float v236; // [esp+20h] [ebp-3A8h]
    float v237; // [esp+20h] [ebp-3A8h]
    int ii; // [esp+20h] [ebp-3A8h]
    float v239; // [esp+24h] [ebp-3A4h]
    float v240; // [esp+24h] [ebp-3A4h]
    float v241; // [esp+24h] [ebp-3A4h]
    float v242; // [esp+24h] [ebp-3A4h]
    float v243; // [esp+24h] [ebp-3A4h]
    float v244; // [esp+24h] [ebp-3A4h]
    int v245; // [esp+24h] [ebp-3A4h]
    float v246; // [esp+28h] [ebp-3A0h] BYREF
    int v247; // [esp+2Ch] [ebp-39Ch] BYREF
    int v248; // [esp+30h] [ebp-398h] BYREF
    float v249; // [esp+34h] [ebp-394h]
    float v250; // [esp+38h] [ebp-390h]
    int v251; // [esp+3Ch] [ebp-38Ch] BYREF
    float v252; // [esp+40h] [ebp-388h]
    float v253; // [esp+44h] [ebp-384h]
    float v254; // [esp+48h] [ebp-380h]
    float v255; // [esp+4Ch] [ebp-37Ch]
    float v256; // [esp+50h] [ebp-378h]
    float v257; // [esp+54h] [ebp-374h] BYREF
    float v258; // [esp+58h] [ebp-370h]
    float v259; // [esp+5Ch] [ebp-36Ch]
    int v260; // [esp+60h] [ebp-368h] BYREF
    float v261; // [esp+64h] [ebp-364h]
    float v262; // [esp+68h] [ebp-360h]
    float v263; // [esp+6Ch] [ebp-35Ch] BYREF
    float v264; // [esp+70h] [ebp-358h]
    float v265; // [esp+74h] [ebp-354h]
    int v266; // [esp+78h] [ebp-350h] BYREF
    float v267; // [esp+7Ch] [ebp-34Ch]
    float v268; // [esp+80h] [ebp-348h]
    float v269; // [esp+84h] [ebp-344h]
    float jj; // [esp+88h] [ebp-340h]
    int v271; // [esp+8Ch] [ebp-33Ch] BYREF
    float v272; // [esp+90h] [ebp-338h]
    int v273; // [esp+94h] [ebp-334h]
    float v274; // [esp+98h] [ebp-330h]
    float v275; // [esp+9Ch] [ebp-32Ch]
    float v276; // [esp+A0h] [ebp-328h]
    int v277; // [esp+A4h] [ebp-324h] BYREF
    float v278; // [esp+A8h] [ebp-320h]
    float v279; // [esp+ACh] [ebp-31Ch]
    int v280; // [esp+B0h] [ebp-318h] BYREF
    float v281; // [esp+B4h] [ebp-314h]
    float v282; // [esp+B8h] [ebp-310h]
    float v283; // [esp+BCh] [ebp-30Ch]
    float v284; // [esp+C0h] [ebp-308h]
    float v285; // [esp+C4h] [ebp-304h]
    float v286; // [esp+C8h] [ebp-300h]
    int v287; // [esp+CCh] [ebp-2FCh] BYREF
    float v288; // [esp+D0h] [ebp-2F8h]
    float v289; // [esp+D4h] [ebp-2F4h]
    float v290; // [esp+D8h] [ebp-2F0h] BYREF
    __int16 v291; // [esp+DEh] [ebp-2EAh]
    __int16 v292; // [esp+E0h] [ebp-2E8h]
    char v293; // [esp+E2h] [ebp-2E6h]
    __int16 v294; // [esp+E3h] [ebp-2E5h]
    __int16 v295; // [esp+E5h] [ebp-2E3h]
    __int16 v296; // [esp+E7h] [ebp-2E1h]
    char v297; // [esp+E9h] [ebp-2DFh]
    char v298; // [esp+EAh] [ebp-2DEh]
    float v299; // [esp+ECh] [ebp-2DCh]
    int v300[14]; // [esp+F0h] [ebp-2D8h] BYREF
    float v301; // [esp+128h] [ebp-2A0h]
    float v302[3]; // [esp+130h] [ebp-298h] BYREF
    int v303[3]; // [esp+13Ch] [ebp-28Ch] BYREF
    _DWORD v304[16]; // [esp+148h] [ebp-280h] BYREF
    int v305[16]; // [esp+188h] [ebp-240h] BYREF
    int v306[16]; // [esp+1C8h] [ebp-200h] BYREF
    int v307[16]; // [esp+208h] [ebp-1C0h] BYREF
    int v308[16]; // [esp+248h] [ebp-180h] BYREF
    int v309[16]; // [esp+288h] [ebp-140h] BYREF
    int v310[16]; // [esp+2C8h] [ebp-100h] BYREF
    _BYTE v311[64]; // [esp+308h] [ebp-C0h] BYREF
    _BYTE v312[64]; // [esp+348h] [ebp-80h] BYREF
    int v313[16]; // [esp+388h] [ebp-40h] BYREF

    if (!*(_BYTE*)(this + 392) && *(float*)(this + 432) > 0.0)
    {
        v3 = *(float*)(this + 432) - *(float*)&a2;
        *(float*)(this + 432) = v3;
        v4 = *(float*)(*(_DWORD*)(this + 408) + 684);
        if (v4 == 0.0)
        {
            v239 = 0.0;
            sub_408960(*(_DWORD**)(this + 412), 0.0);
        }
        else
        {
            v239 = v3 / v4;
            if (v239 < 1.0)
                sub_408960(*(_DWORD**)(this + 412), v239);
        }
        if (v239 <= 0.0)
        {
            (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)this + 24))(this, 0);
            return sub_428620((_DWORD*)this, a2);
        }
    }
    v6 = (float*)(this + 476);
    v7 = (float*)(this + 452);
    sub_4159B0(
        *(_DWORD*)(this + 444),
        *(float*)&a2,
        (_DWORD*)(this + 452),
        (_DWORD*)(this + 464),
        (float*)(this + 476),
        this + 480,
        (float*)(this + 492));
    if (*(_BYTE*)(this + 448))
    {
        *(float*)&v251 = -*v7;
        v252 = -*(float*)(this + 456);
        v253 = -*(float*)(this + 460);
        sub_46B970(this + 464, &v251);
    }
    v8 = *(_DWORD*)(this + 408);
    v9 = *(float*)(v8 + 688);
    if (v9 == 0.0)
        v10 = 0.0;
    else
        v10 = *(float*)(this + 492) / v9;
    *(float*)(this + 472) = tan(v10 * *(float*)(v8 + 724));
    sub_46B970(this + 464, this + 464);
    *v6 = *(float*)(*(_DWORD*)(this + 408) + 720) * *v6;
    v11 = *(_DWORD*)(this + 408);
    if (*(_DWORD*)(v11 + 292) == 1)
    {
        v12 = *(float*)(v11 + 688) - *(float*)(v11 + 812);
        if (v12 == 0.0 || (v13 = (*(float*)(this + 492) - *(float*)(v11 + 812)) / v12, v13 <= 0.0))
            v13 = 0.0;
        *(float*)(this + 460) = -(v13 * *(float*)(v11 + 824));
    }
    v225 = *v6 * -1.0;
    sub_46BEE6((float*)v310, v225);
    v14 = *(float*)(this + 464) * -1.0;
    v279 = 0.0;
    v282 = 0.0;
    *(float*)&v248 = v14;
    v249 = *(float*)(this + 468) * -1.0;
    v250 = *(float*)(this + 472) * -1.0;
    *(float*)&v277 = v249 - 0.0;
    v280 = v277;
    v278 = 0.0 - *(float*)&v248;
    v281 = v278;
    sub_46B970(&v280, &v280);
    v304[0] = v280;
    *(float*)&v304[1] = v281;
    *(float*)&v304[2] = v282;
    v304[4] = v248;
    *(float*)&v304[5] = v249;
    *(float*)&v304[6] = v250;
    v252 = *(float*)&v248 * v282 - v250 * *(float*)&v280;
    v15 = *v7;
    *(float*)&v304[9] = v252;
    v16 = *(_DWORD*)(this + 456);
    v304[3] = 0;
    v304[7] = 0;
    v304[11] = 0;
    *(float*)&v304[12] = v15;
    v253 = v249 * *(float*)&v280 - *(float*)&v248 * v281;
    v304[13] = v16;
    *(float*)&v304[8] = v250 * v281 - v249 * v282;
    *(float*)&v304[10] = v253;
    v304[14] = *(_DWORD*)(this + 460);
    v304[15] = 1065353216;
    sub_46B97C(v304, v310, v304);
    sub_4073F0(*(_DWORD**)(this + 412), 0, v304);
    if (!sub_4438C0((float*)this) && sub_408880(*(_DWORD**)(this + 412)) > 0 && sub_4088E0(*(_DWORD*)(this + 412))
        || ((v17 = *(_DWORD*)(this + 436), v17 == 1) || v17 == 2)
        && *(float*)(this + 460) * *(float*)(this + 488)
        + *(float*)(this + 456) * *(float*)(this + 484)
        + *(float*)(this + 480) * *v7 > 0.0
        && !v19)
    {
        if (*(_DWORD*)(*(_DWORD*)(this + 408) + 292) == 3)
        {
            for (i = 0; ; ++i)
            {
                v21 = *(_DWORD*)(this + 524);
                if (!v21 || i >= (*(_DWORD*)(this + 528) - v21) >> 2)
                    break;
                v22 = *(_DWORD*)(v21 + 4 * i);
                if (!*(_BYTE*)(v22 + 436))
                {
                    sub_467A50(v22, 0);
                    v23 = *(_DWORD*)(*(_DWORD*)(this + 524) + 4 * i);
                    (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)v23 + 24))(v23, 0);
                }
            }
        }
        if (*(_DWORD*)(*(_DWORD*)(this + 408) + 292) == 6)
        {
            for (j = 0; ; ++j)
            {
                v25 = *(_DWORD*)(this + 1392);
                if (!v25 || j >= (*(_DWORD*)(this + 1396) - v25) >> 2)
                    break;
                v26 = *(_DWORD*)(v25 + 4 * j);
                if (!*(_BYTE*)(v26 + 460))
                {
                    sub_4333C0(v26, 0);
                    v27 = *(_DWORD*)(*(_DWORD*)(this + 1392) + 4 * j);
                    (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)v27 + 24))(v27, 0);
                }
            }
        }
        *(_DWORD*)(*(_DWORD*)(this + 416) + 76) = 0;
        (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)this + 24))(this, 0);
        sub_4477F0(this, 0);
    }
    if (!sub_4438C0((float*)this) && !sub_408880(*(_DWORD**)(this + 412)))
    {
        v28 = *(float*)(this + 428) - *(float*)&a2;
        v29 = *(_DWORD*)(this + 408);
        *(float*)(this + 428) = v28;
        if (v28 <= *(float*)(v29 + 664) && (sub_4088A0(*(_DWORD*)(this + 412)) || sub_4088E0(*(_DWORD*)(this + 412))))
        {
            if (sub_4088E0(*(_DWORD*)(this + 412)))
            {
                sub_408860(*(_DWORD**)(this + 412), *(_DWORD*)(*(_DWORD*)(this + 408) + 636));
            LABEL_56:
                *(_BYTE*)(*(_DWORD*)(this + 412) + 48) = 0;
                v36 = *(_DWORD*)(this + 408);
                v240 = *(float*)(v36 + 656);
                v254 = *(float*)(v36 + 660);
                if (v240 == v254)
                {
                    v37 = v240;
                }
                else
                {
                    v246 = COERCE_FLOAT(rand());
                    v37 = fabs((double)SLODWORD(v246) * 0.000030518509) * (v254 - v240) + v240;
                }
                *(float*)(*(_DWORD*)(this + 412) + 36) = v37;
                v38 = *(char**)(dword_520970 + 240);
                *(float*)&v226 = sub_408920(*(_DWORD*)(this + 412));
                sub_44DBF0(v38, *(_DWORD*)(*(_DWORD*)(this + 408) + 748), (float*)(this + 452), v226);
                goto LABEL_60;
            }
            v31 = *(float*)(this + 420);
            v32 = v30;
            v33 = v31 < 0.0;
            v34 = v31 == 0.0;
            if ((v32 & 1) != 0)
            {
                if (!v33 && !v34)
                {
                    sub_408860(*(_DWORD**)(this + 412), *(_DWORD*)(*(_DWORD*)(this + 408) + 628));
                    goto LABEL_56;
                }
                v35 = *(_DWORD*)(*(_DWORD*)(this + 408) + 620);
            }
            else
            {
                if (v33 || v34)
                {
                    sub_408860(*(_DWORD**)(this + 412), *(_DWORD*)(*(_DWORD*)(this + 408) + 624));
                    goto LABEL_56;
                }
                v35 = *(_DWORD*)(*(_DWORD*)(this + 408) + 632);
            }
            sub_408860(*(_DWORD**)(this + 412), v35);
            goto LABEL_56;
        }
    }
LABEL_60:
    if (sub_4438C0((float*)this))
    {
        v39 = *(_DWORD*)(*(_DWORD*)(this + 408) + 292);
        if (v39)
        {
            switch (v39)
            {
            case 1:
                if (!*(_DWORD*)(this + 436))
                {
                    v45 = *(float*)(this + 504) - *(float*)&a2;
                    v46 = *(_BYTE*)(this + 1424);
                    *(float*)(this + 504) = v45;
                    if (!v46 || v45 <= 0.0)
                    {
                        *(_DWORD*)(this + 436) = 2;
                        *(_BYTE*)(*(_DWORD*)(this + 444) + 4316) = 0;
                    }
                    if (!*(_DWORD*)(this + 436))
                    {
                        v47 = *(float*)(this + 496) - *(float*)&a2;
                        *(float*)(this + 496) = v47;
                        if (v47 <= 0.0)
                        {
                            *(_DWORD*)(this + 436) = 3;
                            v48 = *(_DWORD*)(this + 408);
                            v243 = *(float*)(v48 + 796);
                            v254 = *(float*)(v48 + 800);
                            if (v243 == v254)
                            {
                                *(float*)(this + 496) = v243;
                            }
                            else
                            {
                                v246 = COERCE_FLOAT(rand());
                                *(float*)(this + 496) = fabs((double)SLODWORD(v246) * 0.000030518509) * (v254 - v243) + v243;
                            }
                        }
                    }
                }
                break;
            case 2:
                if (*(float*)(this + 508) > 0.0)
                {
                    v49 = *(float*)(this + 508) - *(float*)&a2;
                    *(float*)(this + 508) = v49;
                    if (v49 <= 0.0 && !*(_BYTE*)(dword_4F5CC4 + 937))
                    {
                        sub_444030((_DWORD*)this, 1);
                        sub_4477F0(this, 0);
                        *(_DWORD*)(*(_DWORD*)(this + 412) + 36) = 1065353216;
                        *(_BYTE*)(*(_DWORD*)(this + 412) + 48) = 0;
                        v50 = *(_DWORD*)(this + 408);
                        v244 = *(float*)(v50 + 840);
                        v254 = *(float*)(v50 + 844);
                        if (v244 == v254)
                        {
                            v51 = v244;
                        }
                        else
                        {
                            v246 = COERCE_FLOAT(rand());
                            v51 = fabs((double)SLODWORD(v246) * 0.000030518509) * (v254 - v244) + v244;
                        }
                        v246 = *(float*)(*(_DWORD*)(this + 408) + 836);
                        *(_DWORD*)(this + 512) = sub_455AC0(
                            *(_DWORD**)(dword_520970 + 216),
                            (__int64)((double)SLODWORD(v246) * v51),
                            LODWORD(v246) - (__int64)((double)SLODWORD(v246) * v51),
                            (float*)(this + 452),
                            (float*)(this + 464),
                            300.0,
                            40.0);
                        *(_BYTE*)(this + 516) = 0;
                        if (*(_BYTE*)(dword_4F5CC4 + 936))
                        {
                            HIWORD(v258) = *(_WORD*)(this + 1456);
                            sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x205, &v257, 8, 10, 2000);
                        }
                    }
                }
                break;
            case 3:
                if (*(float*)(this + 508) > 0.0)
                {
                    v52 = *(float*)(this + 508) - *(float*)&a2;
                    *(float*)(this + 508) = v52;
                    if (v52 <= 0.0)
                    {
                        sub_444030((_DWORD*)this, 1);
                        sub_4477F0(this, 0);
                        *(_DWORD*)(*(_DWORD*)(this + 412) + 36) = 1065353216;
                        *(_BYTE*)(*(_DWORD*)(this + 412) + 48) = 0;
                        if (*(_BYTE*)(dword_4F5CC4 + 936))
                        {
                            HIWORD(v258) = *(_WORD*)(this + 1456);
                            sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x205, &v257, 8, 10, 2000);
                        }
                    }
                }
                while (1)
                {
                    v53 = *(_DWORD*)(this + 524);
                    if (!v53
                        || !((*(_DWORD*)(this + 528) - v53) >> 2)
                        || !*(_BYTE*)(*(_DWORD*)(*(_DWORD*)(this + 528) - 4) + 436))
                    {
                        break;
                    }
                    sub_448350((_DWORD*)(this + 520), *(_DWORD*)(this + 528) - 4);
                }
                if (sub_4088E0(*(_DWORD*)(this + 412)))
                {
                    v54 = *(_DWORD*)(this + 524);
                    if (v54)
                    {
                        if ((*(_DWORD*)(this + 528) - v54) >> 2)
                        {
                            v55 = *(float*)(this + 536) - *(float*)&a2;
                            *(float*)(this + 536) = v55;
                            if (v55 <= 0.0)
                            {
                                sub_406BE0(v300);
                                v56 = *(_DWORD*)(this + 524);
                                if (v56)
                                    v57 = (*(_DWORD*)(this + 528) - v56) >> 2;
                                else
                                    v57 = 0;
                                sub_407690(
                                    *(_DWORD*)(this + 412),
                                    *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 864) + 4 * v57 - 4),
                                    v300);
                                *(float*)&v266 = 0.0;
                                v267 = 0.0;
                                v268 = 0.0;
                                *(float*)&v248 = 0.0;
                                v249 = 1.0;
                                v250 = 0.0;
                                sub_46C5C5((float*)&v266, (float*)&v266, (float*)v300);
                                sub_46B976((float*)&v248, (float*)&v248, (float*)v300);
                                sub_407690(*(_DWORD*)(this + 412), *(_DWORD*)(*(_DWORD*)(this + 408) + 876), v300);
                                v257 = 0.0;
                                v258 = 0.0;
                                v259 = 0.0;
                                v263 = 0.0;
                                v264 = 1.0;
                                v265 = 0.0;
                                sub_46C5C5(&v257, &v257, (float*)v300);
                                sub_46B976(&v263, &v263, (float*)v300);
                                v58 = *(_DWORD*)(this + 524);
                                v236 = v250 * (v259 - v268) + v249 * (v258 - v267) + (v257 - *(float*)&v266) * *(float*)&v248;
                                if (v58)
                                    v59 = (*(_DWORD*)(this + 528) - v58) >> 2;
                                else
                                    v59 = 0;
                                v60 = *(_DWORD*)(*(_DWORD*)(this + 524) + 4 * v59 - 4);
                                sub_4164A0(*(_DWORD*)(v60 + 452), 0);
                                sub_416350(*(_DWORD*)(v60 + 452), &v266, 0);
                                sub_416350(*(_DWORD*)(v60 + 452), &v266, 0);
                                sub_416350(*(_DWORD*)(v60 + 452), &v266, 0);
                                sub_416350(*(_DWORD*)(v60 + 452), &v266, 0);
                                sub_416350(*(_DWORD*)(v60 + 452), &v266, 0);
                                v61 = *(_DWORD*)(v60 + 452);
                                v252 = v249 * v236;
                                v253 = v250 * v236;
                                v261 = v252 * 0.2;
                                v262 = v253 * 0.2;
                                *(float*)&v251 = *(float*)&v248 * v236 * 0.2 + *(float*)&v266;
                                v252 = v261 + v267;
                                v253 = v262 + v268;
                                sub_416350(v61, &v251, 0);
                                v252 = v249 + v249;
                                v253 = v250 + v250;
                                v62 = *(_DWORD*)(v60 + 452);
                                v261 = v252 * v236;
                                v262 = v253 * v236;
                                v252 = v261 * 0.2;
                                v253 = v262 * 0.2;
                                *(float*)&v260 = (*(float*)&v248 + *(float*)&v248) * v236 * 0.2 + *(float*)&v266;
                                v261 = v252 + v267;
                                v262 = v253 + v268;
                                sub_416350(v62, &v260, 0);
                                v63 = *(_DWORD*)(v60 + 452);
                                v252 = v264 + v264;
                                v253 = v265 + v265;
                                v261 = v252 * v236;
                                v262 = v253 * v236;
                                v252 = v261 * 0.2;
                                v253 = v262 * 0.2;
                                *(float*)&v260 = v257 - (v263 + v263) * v236 * 0.2;
                                v261 = v258 - v252;
                                v262 = v259 - v253;
                                sub_416350(v63, &v260, 0);
                                v64 = *(_DWORD*)(v60 + 452);
                                v252 = v264 * v236;
                                v253 = v265 * v236;
                                v261 = v252 * 0.2;
                                v262 = v253 * 0.2;
                                *(float*)&v251 = v257 - v263 * v236 * 0.2;
                                v252 = v258 - v261;
                                v253 = v259 - v262;
                                sub_416350(v64, &v251, 0);
                                sub_416350(*(_DWORD*)(v60 + 452), &v257, 0);
                                v65 = *(_DWORD*)(v60 + 452);
                                v252 = v264 * v236;
                                v253 = v265 * v236;
                                v261 = v252 * 0.2;
                                v262 = v253 * 0.2;
                                *(float*)&v251 = v263 * v236 * 0.2 + v257;
                                v252 = v258 + v261;
                                v253 = v259 + v262;
                                sub_416350(v65, &v251, 0);
                                v66 = *(_DWORD*)(v60 + 452);
                                v252 = v264 + v264;
                                v253 = v265 + v265;
                                v261 = v252 * v236;
                                v262 = v253 * v236;
                                v252 = v261 * 0.2;
                                v253 = v262 * 0.2;
                                *(float*)&v260 = (v263 + v263) * v236 * 0.2 + v257;
                                v261 = v258 + v252;
                                v262 = v259 + v253;
                                sub_416350(v66, &v260, 0);
                                v67 = (float*)(*(_DWORD*)(v60 + 452) + 36);
                                *v67 = *(float*)&v248;
                                v67[1] = v249;
                                v67[2] = v250;
                                *(float*)&v227 = *(float*)(*(_DWORD*)(v60 + 452) + 4288) * 7.0;
                                sub_467B60(v60, v227);
                                v68 = *(_DWORD*)(this + 524);
                                v246 = 0.0;
                                if (v68)
                                    v69 = (*(_DWORD*)(this + 528) - v68) >> 2;
                                else
                                    v69 = 0;
                                v70 = *(_DWORD*)(this + 524);
                                v71 = v69 - 1;
                                if (v70)
                                    v72 = (*(_DWORD*)(this + 528) - v70) >> 2;
                                else
                                    v72 = 0;
                                if (v72 >= v71)
                                {
                                    if (v71 < sub_4481C0((_DWORD*)(this + 520)))
                                        sub_448300(
                                            (_DWORD*)(this + 520),
                                            (_DWORD*)(*(_DWORD*)(this + 524) + 4 * v71),
                                            *(int**)(this + 528));
                                }
                                else
                                {
                                    v269 = *(float*)(this + 528);
                                    v73 = sub_4481C0((_DWORD*)(this + 520));
                                    sub_44F190(this + 520, (_DWORD*)LODWORD(v269), v71 - v73, &v246);
                                }
                                *(_DWORD*)(this + 536) = *(_DWORD*)(*(_DWORD*)(v60 + 412) + 1168);
                            }
                        }
                    }
                }
                break;
            default:
                if (v39 == 6 && !*(_BYTE*)(dword_4F5CC4 + 937))
                {
                    v74 = *(_DWORD*)(this + 544);
                    if (v74
                        || *(float*)(this + 1404) < fabs(*(float*)(this + 456))
                        || *(int*)(this + 1408) <= 0
                        || *(int*)(this + 1420) > 0)
                    {
                        if (v74 == 1)
                        {
                            v85 = sub_41C200((float*)(this + 552), *(float*)&a2);
                            if (v85 < 0.0000099999997 && v85 > -0.0000099999997)
                                *(_DWORD*)(this + 544) = 2;
                        }
                        else if (v74 == 2)
                        {
                            while (1)
                            {
                                v86 = *(_DWORD*)(this + 1392);
                                if (!v86
                                    || !((*(_DWORD*)(this + 1396) - v86) >> 2)
                                    || !*(_BYTE*)(*(_DWORD*)(*(_DWORD*)(this + 1396) - 4) + 460))
                                {
                                    break;
                                }
                                sub_448350((_DWORD*)(this + 1388), *(_DWORD*)(this + 1396) - 4);
                            }
                            v87 = *(_DWORD*)(this + 1392);
                            if (v87 && ((*(_DWORD*)(this + 1396) - v87) & 0xFFFFFFFC) != 0)
                            {
                                v88 = *(float*)(this + 548) - *(float*)&a2;
                                *(float*)(this + 548) = v88;
                                if (v88 <= 0.0)
                                {
                                    *(_DWORD*)(this + 548) = *(_DWORD*)(*(_DWORD*)(this + 408) + 900);
                                    sub_406BE0(v300);
                                    v89 = *(_DWORD*)(this + 1392);
                                    if (v89)
                                        v90 = (*(_DWORD*)(this + 1396) - v89) >> 2;
                                    else
                                        v90 = 0;
                                    sub_407690(
                                        *(_DWORD*)(this + 412),
                                        *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 908) + 4 * v90 - 4),
                                        v300);
                                    v259 = sub_41C200((float*)(this + 552), 0.0);
                                    v257 = 0.0;
                                    v258 = 0.0;
                                    *(float*)&v248 = 0.0;
                                    v249 = 1.0;
                                    v250 = 0.0;
                                    sub_46C5C5(&v257, &v257, (float*)v300);
                                    sub_46B976((float*)&v248, (float*)&v248, (float*)v300);
                                    v91 = *(_DWORD*)(this + 1392);
                                    if (v91)
                                        v92 = (*(_DWORD*)(this + 1396) - v91) >> 2;
                                    else
                                        v92 = 0;
                                    v93 = *(_DWORD*)(*(_DWORD*)(this + 1392) + 4 * v92 - 4);
                                    sub_4164A0(*(_DWORD*)(v93 + 468), 0);
                                    sub_416350(*(_DWORD*)(v93 + 468), &v257, 0);
                                    sub_416350(*(_DWORD*)(v93 + 468), &v257, 0);
                                    sub_416350(*(_DWORD*)(v93 + 468), &v257, 0);
                                    sub_416350(*(_DWORD*)(v93 + 468), &v257, 0);
                                    sub_416350(*(_DWORD*)(v93 + 468), &v257, 0);
                                    v94 = *(_DWORD*)(v93 + 468);
                                    v254 = 0.0;
                                    v237 = *(float*)(v94 + 4288) * *(float*)(v94 + 4284);
                                    if (*(float*)(*(_DWORD*)(this + 408) + 888) > 0.0)
                                    {
                                        do
                                        {
                                            v252 = v249 * v237;
                                            v253 = v250 * v237;
                                            v257 = *(float*)&v248 * v237 + v257;
                                            v258 = v258 + v252;
                                            v259 = v259 + v253;
                                            sub_416350(*(_DWORD*)(v93 + 468), &v257, 0);
                                            v95 = v254 + v237;
                                            v96 = *(_DWORD*)(this + 408);
                                            v254 = v95;
                                        } while (v95 < *(float*)(v96 + 888));
                                    }
                                    v252 = v249 * v237;
                                    v253 = v250 * v237;
                                    v257 = *(float*)&v248 * v237 + v257;
                                    v258 = v258 + v252;
                                    v259 = v259 + v253;
                                    sub_416350(*(_DWORD*)(v93 + 468), &v257, 0);
                                    v97 = (float*)(*(_DWORD*)(v93 + 468) + 36);
                                    *v97 = *(float*)&v248;
                                    v97[1] = v249;
                                    v97[2] = v250;
                                    *(_BYTE*)(v93 + 460) = 1;
                                }
                            }
                            else
                            {
                                *(_DWORD*)(this + 544) = 0;
                            }
                        }
                    }
                    else
                    {
                        v75 = *(_DWORD*)(this + 1392);
                        v76 = *(_DWORD*)(this + 1412);
                        v246 = 0.0;
                        if (v75)
                            v77 = (*(_DWORD*)(this + 1396) - v75) >> 2;
                        else
                            v77 = 0;
                        if (v77 >= v76)
                        {
                            if (v76 < sub_4481C0((_DWORD*)(this + 1388)))
                                sub_448300(
                                    (_DWORD*)(this + 1388),
                                    (_DWORD*)(*(_DWORD*)(this + 1392) + 4 * v76),
                                    *(int**)(this + 1396));
                        }
                        else
                        {
                            v78 = *(_DWORD**)(this + 1396);
                            v79 = sub_4481C0((_DWORD*)(this + 1388));
                            sub_44F190(this + 1388, v78, v76 - v79, &v246);
                        }
                        for (k = 0; ; ++k)
                        {
                            v81 = *(_DWORD*)(this + 1392);
                            if (!v81 || k >= (*(_DWORD*)(this + 1396) - v81) >> 2)
                                break;
                            v82 = *(_DWORD*)(this + 1392);
                            *(_DWORD*)(v82 + 4 * k) = sub_42FCC0(
                                *(_DWORD**)(dword_520970 + 208),
                                *(float*)(this + 1416),
                                0.0,
                                *(_DWORD*)(this + 1456));
                        }
                        v83 = *(_DWORD*)(this + 408);
                        v84 = *(_DWORD*)(this + 1408) - 1;
                        *(_DWORD*)(this + 1420) = *(_DWORD*)(this + 1412);
                        *(_DWORD*)(this + 1408) = v84;
                        *(_DWORD*)(this + 544) = 1;
                        *(_DWORD*)(this + 548) = 0;
                        *(float*)&v221 = *(float*)(v83 + 896) * 0.33333334;
                        sub_41C060((_DWORD*)(this + 552), v221, 0, 0);
                        v228 = -*(float*)(*(_DWORD*)(this + 408) + 892);
                        sub_41C0B0(this + 552, v228);
                        v229 = -*(float*)(*(_DWORD*)(this + 408) + 892);
                        sub_41C0B0(this + 552, v229);
                        v230 = -*(float*)(*(_DWORD*)(this + 408) + 892);
                        sub_41C0B0(this + 552, v230);
                        sub_41C0B0(this + 552, 0.0);
                        sub_41C0B0(this + 552, 0.0);
                        sub_41C0B0(this + 552, 0.0);
                    }
                }
                break;
            }
        }
        else if (!*(_DWORD*)(this + 436))
        {
            if (!*(_BYTE*)(this + 1424))
            {
                *(_DWORD*)(this + 436) = 2;
                *(_BYTE*)(*(_DWORD*)(this + 444) + 4316) = 0;
            }
            if (!*(_DWORD*)(this + 436))
            {
                v40 = *(float*)(this + 496) - *(float*)&a2;
                *(float*)(this + 496) = v40;
                if (v40 <= 0.0)
                {
                    *(_DWORD*)(this + 436) = 3;
                    v41 = *(_DWORD*)(this + 408);
                    v241 = *(float*)(v41 + 796);
                    v254 = *(float*)(v41 + 800);
                    if (v241 == v254)
                    {
                        v42 = v241;
                    }
                    else
                    {
                        v246 = COERCE_FLOAT(rand());
                        v42 = fabs((double)SLODWORD(v246) * 0.000030518509) * (v254 - v241) + v241;
                    }
                    *(float*)(this + 496) = v42;
                }
                if (!*(_DWORD*)(this + 436))
                {
                    v43 = *(float*)(this + 500) - *(float*)&a2;
                    *(float*)(this + 500) = v43;
                    if (v43 <= 0.0)
                    {
                        *(_DWORD*)(this + 436) = 4;
                        v44 = *(_DWORD*)(this + 408);
                        v242 = *(float*)(v44 + 816);
                        v254 = *(float*)(v44 + 820);
                        if (v242 == v254)
                        {
                            *(float*)(this + 500) = v242;
                        }
                        else
                        {
                            v246 = COERCE_FLOAT(rand());
                            *(float*)(this + 500) = fabs((double)SLODWORD(v246) * 0.000030518509) * (v254 - v242) + v242;
                        }
                    }
                }
            }
        }
    }
    if (*(_DWORD*)(*(_DWORD*)(this + 408) + 292) == 2 && sub_4088E0(*(_DWORD*)(this + 412)) && !*(_BYTE*)(this + 516))
    {
        sub_455DC0(*(_DWORD**)(dword_520970 + 216), *(_DWORD*)(this + 512));
        *(_BYTE*)(this + 516) = 1;
    }
    if (*(_DWORD*)(*(_DWORD*)(this + 408) + 292) == 3)
    {
        v98 = *(_DWORD*)(this + 524);
        v99 = v98 ? (*(_DWORD*)(this + 528) - v98) >> 2 : 0;
        for (m = 0; m < v99; ++m)
        {
            if (!*(_BYTE*)(*(_DWORD*)(*(_DWORD*)(this + 524) + 4 * m) + 436))
            {
                sub_407690(*(_DWORD*)(this + 412), *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 864) + 4 * m), v305);
                sub_4073F0(*(_DWORD**)(*(_DWORD*)(*(_DWORD*)(this + 524) + 4 * m) + 416), 0, v305);
                v101 = *(_DWORD*)(this + 524);
                v102 = (_DWORD*)sub_4010C0((int)v305);
                v103 = (_DWORD*)(*(_DWORD*)(v101 + 4 * m) + 460);
                *v103 = *v102;
                v103[1] = v102[1];
                v103[2] = v102[2];
                v104 = (_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 524) + 4 * m) + 472);
                *v104 = *(_DWORD*)(this + 464);
                v104[1] = *(_DWORD*)(this + 468);
                v104[2] = *(_DWORD*)(this + 472);
                *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 524) + 4 * m) + 484) = *(_DWORD*)(this + 476);
                v105 = (_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 524) + 4 * m) + 488);
                *v105 = *(_DWORD*)(this + 480);
                v105[1] = *(_DWORD*)(this + 484);
                v105[2] = *(_DWORD*)(this + 488);
                *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 524) + 4 * m) + 500) = *(_DWORD*)(this + 492);
            }
        }
    }
    if (*(_DWORD*)(*(_DWORD*)(this + 408) + 292) == 6 && !*(_BYTE*)(dword_4F5CC4 + 937))
    {
        for (n = 0; ; ++n)
        {
            v107 = *(_DWORD*)(this + 1392);
            if (!v107 || n >= (*(_DWORD*)(this + 1396) - v107) >> 2)
                break;
            if (!*(_BYTE*)(*(_DWORD*)(v107 + 4 * n) + 460))
            {
                *(float*)&v231 = sub_41C200((float*)(this + 552), 0.0);
                sub_46BE02((int)v306, 0, 0, v231);
                sub_407690(*(_DWORD*)(this + 412), *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 908) + 4 * n), v300);
                sub_46B97C(v300, v306, v300);
                sub_4073F0(*(_DWORD**)(*(_DWORD*)(*(_DWORD*)(this + 1392) + 4 * n) + 432), 0, v300);
                v108 = (_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 1392) + 4 * n) + 1312);
                *v108 = *(_DWORD*)(this + 452);
                v108[1] = *(_DWORD*)(this + 456);
                v108[2] = *(_DWORD*)(this + 460);
                v109 = (_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 1392) + 4 * n) + 1324);
                *v109 = *(_DWORD*)(this + 464);
                v109[1] = *(_DWORD*)(this + 468);
                v109[2] = *(_DWORD*)(this + 472);
                *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 1392) + 4 * n) + 1336) = *(_DWORD*)(this + 476);
                v110 = (_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 1392) + 4 * n) + 1340);
                *v110 = *(_DWORD*)(this + 480);
                v110[1] = *(_DWORD*)(this + 484);
                v110[2] = *(_DWORD*)(this + 488);
                *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 1392) + 4 * n) + 1352) = *(_DWORD*)(this + 492);
            }
        }
    }
    if (sub_4438C0((float*)this))
    {
        v111 = *(_BYTE*)(this + 1425);
        v112 = *(float*)(this + 492) < (double)*(float*)(*(_DWORD*)(this + 408) + 920);
        *(_BYTE*)(this + 1425) = v112;
        if (!v111 && v112)
            sub_45F160(*(float**)(dword_520970 + 280), (float*)(this + 396));
        v113 = 0;
        *(_BYTE*)(this + 1424) = 0;
        v254 = 0.0;
        for (ii = 0; ; ii += 860)
        {
            v114 = *(_DWORD*)(this + 1432);
            if (!v114 || LODWORD(v254) >= (*(_DWORD*)(this + 1436) - v114) / 860)
                break;
            v115 = *(float*)(*(_DWORD*)(this + 1432) + ii + 12);
            if (v115 > 0.0)
            {
                v116 = *(_DWORD*)(this + 408);
                *(_BYTE*)(this + 1424) = 1;
                v117 = **(_DWORD**)(v113 + *(_DWORD*)(v116 + 924));
                v245 = v117;
                if (*(_BYTE*)(*(_DWORD*)(dword_520970 + 212) + 52))
                {
                    sub_41C4E0((float*)(*(_DWORD*)(v113 + *(_DWORD*)(v116 + 924)) + 4));
                    v256 = v115;
                    sub_46BF69((float*)v309, v256);
                    sub_46BE62((float*)v308, 0.0);
                    v118 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + v113);
                    if (*(_DWORD*)(v118 + 32) == -1)
                    {
                        sub_46B97C(v312, v308, v309);
                        sub_4073F0(
                            *(_DWORD**)(this + 412),
                            *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + v113) + 28),
                            v312);
                        sub_4073C0(
                            *(_DWORD**)(this + 412),
                            *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + v113) + 28),
                            1);
                    }
                    else
                    {
                        sub_4073F0(*(_DWORD**)(this + 412), *(_DWORD*)(v118 + 28), v309);
                        sub_4073C0(
                            *(_DWORD**)(this + 412),
                            *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + v113) + 28),
                            1);
                        sub_4073F0(
                            *(_DWORD**)(this + 412),
                            *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + v113) + 32),
                            v308);
                        sub_4073C0(
                            *(_DWORD**)(this + 412),
                            *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + v113) + 32),
                            1);
                    }
                }
                v119 = *(_DWORD*)(this + 408);
                *(float*)&v248 = 0.0;
                v249 = 0.0;
                v250 = 0.0;
                *(float*)&v266 = 0.0;
                v267 = 0.0;
                v268 = 0.0;
                v120 = *(_DWORD*)(**(_DWORD**)(v113 + *(_DWORD*)(v119 + 924)) + 292);
                if (v120 == 1)
                {
                    sub_4085B0(*(_DWORD*)(this + 412), *(_DWORD*)(*(_DWORD*)(v113 + *(_DWORD*)(v119 + 924)) + 28), (int)&v251);
                    v121 = (int*)(*(_DWORD*)(this + 1432) + ii + 856);
                    v122 = *v121;
                    v256 = *(float*)(v117 + 340) * *(float*)(v117 + 340);
                    if (v122 && !*(_BYTE*)(v122 + 396))
                        *v121 = 0;
                    v123 = *(_DWORD*)(this + 1432);
                    v124 = *(_DWORD*)(v123 + ii + 856);
                    v125 = (_DWORD*)(v123 + ii + 856);
                    if (v124)
                    {
                        v126 = *(float*)(v124 + 1312) - *(float*)&v251;
                        v127 = *(float*)(v124 + 1316) - v252;
                        if (v126 * v126 + v127 * v127 > v256)
                            *v125 = 0;
                    }
                    v128 = *(_DWORD*)(this + 1432);
                    HIBYTE(v247) = 0;
                    if (!*(_DWORD*)(v128 + ii + 856))
                    {
                        v129 = *(_DWORD*)(dword_520970 + 208);
                        v130 = *(_DWORD*)(v129 + 24);
                        if (v130)
                            LODWORD(v131) = (*(_DWORD*)(v129 + 28) - v130) >> 2;
                        else
                            v131 = 0.0;
                        v132 = 0;
                        for (jj = v131; v132 < SLODWORD(v131); ++v132)
                        {
                            v133 = *(_DWORD*)(*(_DWORD*)(v129 + 24) + 4 * v132);
                            if (*(_BYTE*)(*(_DWORD*)(v133 + 428) + 300))
                            {
                                if (*(_BYTE*)(v133 + 396))
                                {
                                    v134 = *(float*)(v133 + 1312) - *(float*)&v251;
                                    v135 = *(float*)(v133 + 1316) - v252;
                                    if (v134 * v134 + v135 * v135 <= v256)
                                    {
                                        sub_4231C0(v132);
                                        v131 = jj;
                                    }
                                }
                            }
                        }
                        v136 = sub_423230();
                        if (v136 != -1)
                        {
                            v137 = *(_DWORD*)(v129 + 24);
                            v138 = *(_DWORD*)(this + 1432);
                            HIBYTE(v247) = 1;
                            *(_DWORD*)(v138 + ii + 856) = *(_DWORD*)(v137 + 4 * v136);
                        }
                    }
                    v139 = *(_DWORD*)(this + 1432) + ii;
                    if (!*(_DWORD*)(v139 + 856))
                        goto LABEL_223;
                    if (HIBYTE(v247))
                        *(_DWORD*)(v139 + 16) = 0;
                    v117 = v245;
                    v140 = (_DWORD*)(*(_DWORD*)(this + 1432) + ii + 856);
                    v141 = *v140 + 1312;
                    v248 = *(int*)v141;
                    v249 = *(float*)(v141 + 4);
                    v250 = *(float*)(v141 + 8);
                    v142 = *v140 + 1340;
                    v266 = *(int*)v142;
                    v267 = *(float*)(v142 + 4);
                    v268 = *(float*)(v142 + 8);
                }
                else if (!v120)
                {
                    if (!*(_BYTE*)(this + 1425))
                    {
                        *(_DWORD*)(*(_DWORD*)(this + 1432) + ii + 16) = 0;
                        goto LABEL_223;
                    }
                    v248 = *(int*)(this + 396);
                    v249 = *(float*)(this + 400);
                    v250 = *(float*)(this + 404);
                }
                sub_4085B0(
                    *(_DWORD*)(this + 412),
                    *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + v113) + 28),
                    (int)&v290);
                v222 = sub_44A3E0(&v290, (float*)&v248, *(float*)(v117 + 308), 1.0);
                sub_44A250(
                    *(_DWORD*)(v117 + 296),
                    &v290,
                    (float*)(this + 480),
                    (float*)&v248,
                    (float*)&v266,
                    v222,
                    (float*)&v277);
                sub_407690(*(_DWORD*)(this + 412), 0, v305);
                sub_46B982((int)v305, (int)v305);
                v263 = *(float*)&v277;
                v264 = v278;
                v265 = v279;
                sub_46B970(&v263, &v263);
                sub_46B976(&v263, &v263, (float*)v305);
                v143 = *(_DWORD*)(this + 408);
                v299 = v265;
                v232 = atan2(-v263, v264);
                v144 = sub_41C2F0((float*)(*(_DWORD*)(*(_DWORD*)(v143 + 924) + v113) + 4), v232);
                v145 = *(_DWORD*)(this + 408);
                jj = v144;
                v233 = asin(v299);
                v146 = sub_41C2F0((float*)(*(_DWORD*)(*(_DWORD*)(v145 + 924) + v113) + 16), v233);
                v147 = *(_DWORD*)(this + 408);
                v148 = jj;
                v256 = v146;
                if (sub_41C380((float*)(*(_DWORD*)(*(_DWORD*)(v147 + 924) + v113) + 4), jj))
                {
                    v149 = *(_DWORD*)(this + 1432);
                    v274 = jj;
                    v283 = v256;
                    if (*(_DWORD*)(v149 + ii + 16) <= 1u)
                    {
                        sub_407430(
                            *(_DWORD**)(this + 412),
                            *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + v113) + 28),
                            (char*)v300);
                        v286 = 1.0;
                        if (*(float*)&v300[1] <= 0.0)
                            v286 = -1.0;
                        v150 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + v113) + 32);
                        v274 = acos(*(float*)v300) * v286;
                        if (v150 != -1)
                            sub_407430(*(_DWORD**)(this + 412), v150, (char*)v300);
                        v285 = 1.0;
                        if (*(float*)&v300[6] <= 0.0)
                            v285 = -1.0;
                        v151 = *(_DWORD*)(*(_DWORD*)(this + 408) + 924);
                        v257 = *(float*)&v300[10];
                        v152 = *(float*)&a2 * *(float*)(v117 + 336);
                        *(float*)&v234 = v152;
                        sub_41C3C0(*(_DWORD*)(v151 + v113) + 4, v148, v274, v234);
                        v274 = v152;
                        *(float*)&v235 = *(float*)&a2 * *(float*)(v117 + 336);
                        v153 = acos(v257) * v285;
                        v223 = v153;
                        sub_41C3C0(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + v113) + 16, v256, v223, v235);
                        v283 = v153;
                        v154 = v274 - jj;
                        if (v154 < 0.0000099999997 && v154 > -0.0000099999997)
                        {
                            v155 = v283 - v256;
                            if (v155 < 0.0000099999997 && v155 > -0.0000099999997)
                                *(_DWORD*)(*(_DWORD*)(this + 1432) + ii + 16) = 2;
                        }
                    }
                    sub_46BF69((float*)v307, v274);
                    sub_46BE62((float*)v306, v283);
                    v156 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + v113);
                    if (*(_DWORD*)(v156 + 32) == -1)
                    {
                        sub_46B97C(v311, v306, v307);
                        sub_4073F0(
                            *(_DWORD**)(this + 412),
                            *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + v113) + 28),
                            v311);
                    }
                    else
                    {
                        sub_4073F0(*(_DWORD**)(this + 412), *(_DWORD*)(v156 + 28), v307);
                        sub_4073F0(
                            *(_DWORD**)(this + 412),
                            *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 924) + v113) + 32),
                            v306);
                    }
                    v157 = *(_DWORD*)(this + 1432) + ii;
                    if (*(_DWORD*)(v157 + 16) == 2)
                    {
                        if (*(_BYTE*)v157)
                        {
                            v158 = ii;
                        }
                        else
                        {
                            v158 = ii;
                            *(float*)(v157 + 4) = *(float*)(v157 + 4) - *(float*)&a2;
                            v159 = ii + *(_DWORD*)(this + 1432);
                            if (*(float*)(v159 + 4) <= 0.0)
                            {
                                *(_BYTE*)v159 = 1;
                                v160 = *(float*)(v245 + 324);
                                v275 = *(float*)(v245 + 320);
                                v284 = v160;
                                if (v275 == v160)
                                {
                                    *(float*)(*(_DWORD*)(this + 1432) + ii + 4) = v275;
                                }
                                else
                                {
                                    v256 = COERCE_FLOAT(rand());
                                    *(float*)(*(_DWORD*)(this + 1432) + ii + 4) = fabs((double)SLODWORD(v256) * 0.000030518509)
                                        * (v284 - v275)
                                        + v275;
                                }
                            }
                        }
                        v161 = *(_DWORD*)(this + 1432) + v158;
                        if (*(_BYTE*)v161)
                        {
                            *(float*)(v161 + 4) = *(float*)(v161 + 4) - *(float*)&a2;
                            v162 = *(_DWORD*)(this + 1432) + ii;
                            if (*(float*)(v162 + 4) > 0.0)
                            {
                                *(float*)(v162 + 8) = *(float*)(v162 + 8) - *(float*)&a2;
                                if (*(float*)(*(_DWORD*)(this + 1432) + ii + 8) <= 0.0)
                                {
                                    v164 = *(float*)(v245 + 304);
                                    v255 = *(float*)(v245 + 300);
                                    v246 = v164;
                                    if (v255 == v164)
                                    {
                                        v165 = v255;
                                    }
                                    else
                                    {
                                        v256 = COERCE_FLOAT(rand());
                                        v165 = fabs((double)SLODWORD(v256) * 0.000030518509) * (v246 - v255) + v255;
                                    }
                                    v166 = 0.0;
                                    *(float*)(*(_DWORD*)(this + 1432) + ii + 8) = v165;
                                    while (1)
                                    {
                                        v167 = *(_DWORD*)(this + 408);
                                        v256 = v166;
                                        v168 = *(_DWORD*)(*(_DWORD*)(v113 + *(_DWORD*)(v167 + 924)) + 40);
                                        if (!v168
                                            || LODWORD(v166) >= (*(_DWORD*)(*(_DWORD*)(v113 + *(_DWORD*)(v167 + 924)) + 44) - v168) >> 2)
                                        {
                                            break;
                                        }
                                        sub_407690(
                                            *(_DWORD*)(this + 412),
                                            *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v113 + *(_DWORD*)(v167 + 924)) + 40) + 4 * LODWORD(v166)),
                                            v313);
                                        sub_4010D0(&v260, (int)v313);
                                        memset(v302, 0, sizeof(v302));
                                        if (!sub_468CA0(*(int**)(dword_520970 + 260), (float*)&v260, &v248, v302, 0))
                                        {
                                            v169 = 0;
                                            v170 = *(_DWORD*)(dword_520970 + 212);
                                            while (1)
                                            {
                                                v171 = *(_DWORD*)(v170 + 24);
                                                v172 = v171 ? (*(_DWORD*)(v170 + 28) - v171) >> 2 : 0;
                                                if (v169 >= v172)
                                                    break;
                                                v173 = *(float***)(*(_DWORD*)(v170 + 24) + 4 * v169);
                                                if (v173 != (float**)this && sub_443910(v173, &v260, &v248))
                                                    goto LABEL_271;
                                                ++v169;
                                            }
                                            v224 = sub_44A3E0((float*)&v260, (float*)&v248, *(float*)(v245 + 308), 1.0);
                                            sub_44A250(
                                                *(_DWORD*)(v245 + 296),
                                                (float*)&v260,
                                                (float*)(this + 480),
                                                (float*)&v248,
                                                (float*)&v266,
                                                v224,
                                                (float*)&v277);
                                            *(float*)&v287 = *(float*)&v277 + *(float*)(this + 480);
                                            v174 = *(_DWORD*)(v245 + 296);
                                            v288 = v278 + *(float*)(this + 484);
                                            v175 = v279 + *(float*)(this + 488);
                                            v303[0] = 0;
                                            v289 = v175;
                                            v303[1] = 0;
                                            v303[2] = 1065353216;
                                            sub_449C40(*(char**)(dword_520970 + 276), v174, &v260, &v287, 0, 0, 0.0, (int)v303);
                                            v176 = *(_DWORD*)(this + 408);
                                            *(float*)&v271 = 0.0;
                                            v272 = 0.0;
                                            v273 = 0;
                                            sub_44E040(
                                                *(char**)(dword_520970 + 240),
                                                *(_DWORD*)(v245 + 344),
                                                this + 480,
                                                *(_DWORD*)(this + 412),
                                                *(float*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v176 + 924) + v113) + 40) + 4 * LODWORD(v256)),
                                                &v271);
                                        }
                                    LABEL_271:
                                        LODWORD(v166) = LODWORD(v256) + 1;
                                    }
                                }
                            }
                            else
                            {
                                *(_BYTE*)v162 = 0;
                                v163 = *(float*)(v245 + 332);
                                v276 = *(float*)(v245 + 328);
                                v269 = v163;
                                if (v276 == v163)
                                {
                                    *(float*)(*(_DWORD*)(this + 1432) + ii + 4) = v276;
                                }
                                else
                                {
                                    v256 = COERCE_FLOAT(rand());
                                    *(float*)(*(_DWORD*)(this + 1432) + ii + 4) = fabs((double)SLODWORD(v256) * 0.000030518509)
                                        * (v269 - v276)
                                        + v276;
                                }
                            }
                        }
                    }
                }
                else
                {
                    *(_DWORD*)(*(_DWORD*)(this + 1432) + ii + 16) = 0;
                }
            }
        LABEL_223:
            ++LODWORD(v254);
            v113 += 4;
        }
    }
    v177 = sub_4438E0((float*)this);
    v178 = *(_DWORD*)(this + 408);
    v269 = v177;
    v179 = *(float*)(v178 + 668);
    if (v179 == 0.0 || (v255 = v269 / v179, v255 <= 0.0))
        v255 = 0.0;
    if (*(_DWORD*)(v178 + 752))
    {
        if (v255 <= (double)*(float*)(v178 + 760))
        {
            v180 = *(float*)(this + 1444) - *(float*)&a2;
            *(float*)(this + 1444) = v180;
            if (v180 <= 0.0)
            {
                v181 = *(float*)(v178 + 760);
                if (v181 == 0.0)
                    v182 = 1.0;
                else
                    v182 = (*(float*)(v178 + 760) - v255) / v181;
                v255 = (*(float*)(v178 + 772) - *(float*)(v178 + 764)) * v182 + *(float*)(v178 + 764);
                v246 = (*(float*)(v178 + 776) - *(float*)(v178 + 768)) * v182 + *(float*)(v178 + 768);
                if (v255 == v246)
                {
                    v183 = v255;
                }
                else
                {
                    v257 = COERCE_FLOAT(rand());
                    v183 = fabs((double)SLODWORD(v257) * 0.000030518509) * (v246 - v255) + v255;
                }
                v184 = *(_DWORD*)(this + 408);
                *(float*)&v271 = 0.0;
                *(float*)(this + 1444) = v183;
                v185 = v184 + 592;
                v272 = 0.0;
                v273 = 0;
                v186 = *(_DWORD*)(v185 + 4);
                if (v186)
                    v187 = (*(_DWORD*)(v185 + 8) - v186) >> 2;
                else
                    v187 = 0;
                v188 = rand();
                sub_44E040(
                    *(char**)(dword_520970 + 240),
                    *(_DWORD*)(*(_DWORD*)(this + 408) + 752),
                    this + 480,
                    *(_DWORD*)(this + 412),
                    *(float*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 596) + 4 * (v188 % v187)),
                    &v271);
            }
        }
    }
    v189 = *(_DWORD*)(this + 408);
    if (*(_DWORD*)(v189 + 756))
    {
        if (v269 <= 0.0)
        {
            v190 = *(float*)(this + 1448) - *(float*)&a2;
            *(float*)(this + 1448) = v190;
            if (v190 <= 0.0)
            {
                v191 = *(float*)(v189 + 784);
                v255 = *(float*)(v189 + 780);
                v246 = v191;
                if (v255 == v191)
                {
                    v192 = v255;
                }
                else
                {
                    v257 = COERCE_FLOAT(rand());
                    v192 = fabs((double)SLODWORD(v257) * 0.000030518509) * (v246 - v255) + v255;
                }
                v193 = *(_DWORD*)(this + 408);
                *(float*)&v271 = 0.0;
                *(float*)(this + 1448) = v192;
                v194 = v193 + 592;
                v272 = 0.0;
                v273 = 0;
                v195 = *(_DWORD*)(v194 + 4);
                if (v195)
                    v196 = (*(_DWORD*)(v194 + 8) - v195) >> 2;
                else
                    v196 = 0;
                v197 = rand();
                sub_44E040(
                    *(char**)(dword_520970 + 240),
                    *(_DWORD*)(*(_DWORD*)(this + 408) + 756),
                    this + 480,
                    *(_DWORD*)(this + 412),
                    *(float*)(*(_DWORD*)(*(_DWORD*)(this + 408) + 596) + 4 * (v197 % v196)),
                    &v271);
            }
        }
    }
    v198 = *(_DWORD**)(this + 1452);
    if (v198)
    {
        v199 = *(float*)(this + 484);
        v271 = *(int*)(this + 480);
        v200 = *(_DWORD*)(this + 488);
        v272 = v199;
        v201 = *(int*)(this + 452);
        v273 = v200;
        v202 = *(float*)(this + 456);
        v287 = v201;
        v203 = *(float*)(this + 460);
        v288 = v202;
        v289 = v203;
        sub_41D960(v198, &v287, &v271);
    }
    if (sub_408F30((_DWORD*)dword_520970) == this)
    {
        sub_407430(*(_DWORD**)(this + 412), 0, (char*)v300);
        sub_401450((_DWORD*)this);
        *(float*)&v248 = 0.0;
        v249 = 4000.0;
        v250 = 0.0;
        v263 = 0.0;
        v264 = 0.0;
        v265 = 0.0;
        *(float*)&v260 = 0.0;
        v261 = 0.0;
        v262 = 1.0;
        sub_46C5C5((float*)&v248, (float*)&v248, (float*)v300);
        v250 = v301 + 2000.0;
        sub_46C5C5(&v263, &v263, (float*)v300);
        v204 = v249;
        v205 = v301 + 1000.0;
        *(float*)(this + 32) = *(float*)&v248;
        v206 = v250;
        *(float*)(this + 36) = v204;
        v265 = v205;
        *(float*)(this + 40) = v206;
        v207 = v264;
        *(float*)(this + 44) = v263;
        v208 = v265;
        *(float*)(this + 48) = v207;
        *(float*)(this + 52) = v208;
        v209 = v261;
        *(float*)(this + 56) = *(float*)&v260;
        v210 = v262;
        *(float*)(this + 60) = v209;
        *(float*)(this + 64) = v210;
    }
    if (*(_DWORD*)(this + 416))
    {
        rand();
        v211 = *(float*)(this + 456);
        v212 = *(float*)(this + 460);
        v260 = *(int*)(this + 452);
        v213 = *(float**)(this + 416);
        v261 = v211;
        v213 += 21;
        v262 = v212;
        v214 = v211;
        *v213 = *(float*)&v260;
        v215 = v262;
        v213[1] = v214;
        v213[2] = v215;
    }
    if (*(_BYTE*)(dword_4F5CC4 + 936))
    {
        v216 = *(_DWORD*)(this + 444);
        if (v216)
        {
            if (*(_BYTE*)(v216 + 12))
            {
                *(_BYTE*)(v216 + 12) = 0;
                v291 = *(_WORD*)(this + 1456);
                while (sub_4176E0(*(_DWORD**)(this + 444), &v246, &v271, (_BYTE*)&v247 + 3, 8))
                {
                    v217 = *(_DWORD*)(this + 444);
                    v218 = *(float*)(v217 + 16);
                    v219 = *(_DWORD*)(v217 + 4136);
                    v292 = LOWORD(v246);
                    v294 = (__int64)(*(float*)&v271 * 0.40000001);
                    v295 = (__int64)(v272 * 0.40000001);
                    v293 = HIBYTE(v247);
                    v296 = v219;
                    v220 = *(_BYTE*)(this + 440);
                    v297 = (__int64)(v218 * 255.0);
                    v298 = v220;
                    sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x202, &v290, 19, 8, 5000);
                }
            }
        }
    }
    return sub_428620((_DWORD*)this, a2);
}
// 444AA0: too many cbuild loops
// 444EEF: variable 'v19' is possibly undefined
// 44506A: variable 'v30' is possibly undefined
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (004476E0) --------------------------------------------------------
int __thiscall sub_4476E0(int* this, int a2, int a3)
{
    int v3; // esi
    int result; // eax

    v3 = a2;
    if (a2 > 0)
    {
        do
        {
            result = sub_465E00(*(_DWORD**)(dword_520970 + 220), a3, this[364]);
            --v3;
        } while (v3);
    }
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (00447720) --------------------------------------------------------
int __thiscall sub_447720(_DWORD* this, int a2, int a3, int a4)
{
    int result; // eax

    this[352] = a2;
    result = a4;
    this[353] = a3;
    this[354] = a4;
    this[355] = 0;
    return result;
}

//----- (00447750) --------------------------------------------------------
int __thiscall sub_447750(_DWORD* this, int a2, int a3, int a4)
{
    int result; // eax
    int v5; // edx

    result = this[102];
    if (*(_DWORD*)(result + 292) == 6)
    {
        result = this[354];
        if (a2 == result)
        {
            v5 = this[355] - a4;
            this[355] = v5;
            result = v5 <= 0 ? 0 : v5;
            this[355] = result;
        }
    }
    return result;
}

//----- (004477A0) --------------------------------------------------------
int __thiscall sub_4477A0(int this, int a2)
{
    int* v3; // ecx
    int result; // eax

    if (!(_BYTE)a2)
    {
        sub_444030((_DWORD*)this, 0);
        v3 = *(int**)(this + 444);
        if (v3)
        {
            if (v3[1033] > 0)
            {
                sub_415910(v3);
                *(_DWORD*)(this + 444) = 0;
            }
        }
    }
    result = (*(int(__thiscall**)(_DWORD, int))(**(_DWORD**)(this + 412) + 24))(*(_DWORD*)(this + 412), a2);
    *(_BYTE*)(this + 16) = a2;
    return result;
}

//----- (004477F0) --------------------------------------------------------
int __thiscall sub_4477F0(int this, int a2)
{
    int v3; // ebx
    int v4; // eax
    int v5; // eax
    float* v6; // edi
    int v7; // eax
    int v8; // eax
    long double v9; // st7
    __int64 v10; // rax
    int v11; // ebx
    int v12; // edi
    _DWORD* v13; // ebp
    int v14; // eax
    int v15; // ebp
    _DWORD* v16; // edi
    int v17; // eax
    int v18; // edi
    unsigned int i; // edi
    int v20; // eax
    int result; // eax
    unsigned int j; // edi
    int v23; // [esp-8h] [ebp-20h]
    int v24; // [esp-8h] [ebp-20h]
    int v25; // [esp-8h] [ebp-20h]
    float v26; // [esp+Ch] [ebp-Ch]
    float v27; // [esp+10h] [ebp-8h]

    if (*(_BYTE*)(this + 392))
    {
        v3 = a2;
        if (!*(_BYTE*)(dword_4F5CC4 + 937) && (_BYTE)a2)
            sub_462520(*(_DWORD**)(dword_520970 + 280), *(_DWORD*)(*(_DWORD*)(this + 408) + 300), dword_5216E8);
        v4 = *(_DWORD*)(this + 408);
        *(_BYTE*)(this + 392) = 0;
        sub_45A420(*(float**)(dword_520970 + 236), v4, a2, *(_DWORD*)(v4 + 292) == 5, 1);
        if ((_BYTE)a2)
        {
            v5 = *(_DWORD*)(this + 408);
            if (*(_DWORD*)(v5 + 292) == 2)
            {
                v23 = *(_DWORD*)(v5 + 836);
                v6 = *(float**)(dword_520970 + 236);
                v7 = sub_45A7E0(v6);
                sub_45A420(v6, v7, a2, 0, v23);
                if (!*(_BYTE*)(dword_4F5CC4 + 937))
                {
                    v8 = *(_DWORD*)(this + 408);
                    v26 = *(float*)(v8 + 840);
                    v27 = *(float*)(v8 + 844);
                    if (v26 == v27)
                        v9 = v26;
                    else
                        v9 = fabs((double)rand() * 0.000030518509) * (v27 - v26) + v26;
                    v10 = (__int64)((double)*(int*)(*(_DWORD*)(this + 408) + 836) * v9);
                    v11 = *(_DWORD*)(*(_DWORD*)(this + 408) + 836) - v10;
                    if ((int)v10 > 0)
                    {
                        v12 = (__int64)((double)*(int*)(*(_DWORD*)(this + 408) + 836) * v9);
                        do
                        {
                            v24 = dword_5216E8;
                            v13 = *(_DWORD**)(dword_520970 + 280);
                            v14 = sub_45A7E0(*(_DWORD**)(dword_520970 + 236));
                            sub_462520(v13, *(_DWORD*)(v14 + 304), v24);
                            --v12;
                        } while (v12);
                    }
                    if (v11 > 0)
                    {
                        v15 = v11;
                        do
                        {
                            v25 = dword_5216E8;
                            v16 = *(_DWORD**)(dword_520970 + 280);
                            v17 = sub_45A810(*(_DWORD**)(dword_520970 + 236));
                            sub_462520(v16, *(_DWORD*)(v17 + 304), v25);
                            --v15;
                        } while (v15);
                    }
                    v3 = a2;
                }
            }
        }
        if (*(_DWORD*)(*(_DWORD*)(this + 408) + 292) == 6)
        {
            v18 = *(_DWORD*)(this + 1408) * *(_DWORD*)(this + 1412);
            if (v18 > 0)
            {
                sub_45A420(
                    *(float**)(dword_520970 + 236),
                    *(_DWORD*)(this + 1416),
                    v3,
                    0,
                    *(_DWORD*)(this + 1408) * *(_DWORD*)(this + 1412));
                if ((_BYTE)v3)
                {
                    if (!*(_BYTE*)(dword_4F5CC4 + 937))
                    {
                        do
                        {
                            sub_462520(*(_DWORD**)(dword_520970 + 280), *(_DWORD*)(*(_DWORD*)(this + 1416) + 592), dword_5216E8);
                            --v18;
                        } while (v18);
                    }
                }
            }
        }
    }
    else
    {
        v3 = a2;
    }
    if (*(_DWORD*)(*(_DWORD*)(this + 408) + 292) == 3 && (_BYTE)v3)
    {
        for (i = 0; ; ++i)
        {
            v20 = *(_DWORD*)(this + 524);
            if (!v20 || i >= (*(_DWORD*)(this + 528) - v20) >> 2)
                break;
            sub_467A50(*(_DWORD*)(v20 + 4 * i), v3);
        }
    }
    result = *(_DWORD*)(this + 408);
    if (*(_DWORD*)(result + 292) == 6)
    {
        for (j = 0; ; ++j)
        {
            result = *(_DWORD*)(this + 1392);
            if (!result || j >= (*(_DWORD*)(this + 1396) - result) >> 2)
                break;
            sub_4333C0(*(_DWORD*)(result + 4 * j), v3);
        }
    }
    return result;
}
// 4479F3: conditional instruction was optimized away because edi.4>=1
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;
// 5216E8: using guessed type int dword_5216E8;

//----- (00447AA0) --------------------------------------------------------
void __thiscall sub_447AA0(_DWORD* this, float a2)
{
    int v3; // esi
    float v4; // eax
    int v5; // edi
    double v6; // st7
    int v7; // edx
    int v8; // ecx
    int v9; // eax
    int v10; // ebp
    char v11; // bl
    char v12; // al
    char v13; // cl
    bool v14; // al
    _DWORD* v15; // eax
    int v16; // eax
    int v17; // edx
    int v18; // ecx
    int v19; // edx
    int v20; // ecx
    int v21; // edx
    _DWORD* v22; // eax
    int v23; // eax
    const char* v24; // [esp-8h] [ebp-4Ch]
    const char* v25; // [esp-8h] [ebp-4Ch]
    const char* v26; // [esp-4h] [ebp-48h]
    const char* v27; // [esp-4h] [ebp-48h]
    unsigned __int8 v28; // [esp+10h] [ebp-34h]
    float v29[3]; // [esp+14h] [ebp-30h] BYREF
    _WORD v30[4]; // [esp+20h] [ebp-24h] BYREF
    int v31; // [esp+28h] [ebp-1Ch]
    int v32; // [esp+2Ch] [ebp-18h]
    int v33; // [esp+30h] [ebp-14h]
    int v34; // [esp+34h] [ebp-10h]
    int v35; // [esp+38h] [ebp-Ch]
    char v36; // [esp+3Ch] [ebp-8h]
    int v37; // [esp+3Dh] [ebp-7h]
    int v38; // [esp+48h] [ebp+4h]
    float v39; // [esp+48h] [ebp+4h]
    bool v40; // [esp+48h] [ebp+4h]

    v3 = *(_DWORD*)(LODWORD(a2) + 16);
    LODWORD(v4) = *(unsigned __int16*)(LODWORD(a2) + 12) - 514;
    v5 = (int)this;
    switch (*(_WORD*)(LODWORD(a2) + 12))
    {
    case 0x202:
        if (*(_BYTE*)(dword_4F5CC4 + 937))
        {
            v6 = (double)*(__int16*)(v3 + 11);
            v38 = *(__int16*)(v3 + 13);
            v7 = *(unsigned __int8*)(v3 + 17);
            v28 = *(_BYTE*)(v3 + 10);
            v8 = this[111];
            v29[2] = 0.0;
            v9 = *(__int16*)(v3 + 8);
            v29[0] = v6 * 2.5;
            v10 = *(__int16*)(v3 + 15);
            v29[1] = (double)v38 * 2.5;
            v39 = (double)v7 * 0.0039215689;
            if (v8)
            {
                v11 = sub_417190(v8, v9, v29, v28);
                sub_415930(*(_DWORD*)(v5 + 444), v10, v39);
                if (v11)
                    (*(void(__thiscall**)(int, int))(*(_DWORD*)v5 + 24))(v5, 1);
                v12 = *(_BYTE*)(v5 + 440);
                v13 = *(_BYTE*)(v3 + 18);
                if (v12 != v13 && !v12)
                    sub_4440B0(v5, v13 == 2);
            }
        }
        break;
    case 0x203:
        if (*(_BYTE*)(dword_4F5CC4 + 936))
        {
            dword_5216E8 = *(_DWORD*)(LODWORD(a2) + 4);
            LOBYTE(v4) = *(_BYTE*)(v3 + 28);
            v14 = sub_443CD0((int)this, *(_DWORD*)(v3 + 8), v3 + 12, *(float*)(v3 + 24), v4);
            v40 = v14;
            if (v14)
            {
                v15 = sub_411B60(dword_4F5CC4, *(_DWORD*)(LODWORD(a2) + 4));
                if (v15)
                {
                    v26 = *(const char**)(*(_DWORD*)(v5 + 408) + 4);
                    v24 = (const char*)(v15 + 3);
                    v16 = sub_436A90(*(_DWORD*)(dword_520970 + 224));
                    sub_421190(v16, "%s sunk a %s", v24, v26);
                }
                sub_411BB0(dword_4F5CC4, *(_DWORD*)(LODWORD(a2) + 4));
                v14 = v40;
            }
            v17 = *(_DWORD*)(v3 + 8);
            v30[3] = *(_WORD*)(v5 + 1456);
            v18 = *(_DWORD*)(v3 + 12);
            v31 = v17;
            v19 = *(_DWORD*)(v3 + 16);
            v32 = v18;
            v20 = *(_DWORD*)(v3 + 20);
            v33 = v19;
            v21 = *(_DWORD*)(v3 + 24);
            v34 = v20;
            LOBYTE(v20) = *(_BYTE*)(v3 + 28);
            v35 = v21;
            v36 = v20;
            if (v14)
                v37 = *(_DWORD*)(LODWORD(a2) + 4);
            else
                v37 = 0;
            sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x204, v30, 33, 11, 0);
            dword_5216E8 = 0;
        }
        break;
    case 0x204:
        LOBYTE(this) = *(_BYTE*)(v3 + 28);
        sub_443CD0(v5, *(_DWORD*)(v3 + 8), v3 + 12, *(float*)(v3 + 24), *(float*)&this);
        if (*(_DWORD*)(v3 + 29))
        {
            v22 = sub_411B60(dword_4F5CC4, *(_DWORD*)(v3 + 29));
            if (v22)
            {
                v27 = *(const char**)(*(_DWORD*)(v5 + 408) + 4);
                v25 = (const char*)(v22 + 3);
                v23 = sub_436A90(*(_DWORD*)(dword_520970 + 224));
                sub_421190(v23, "%s sunk a %s", v25, v27);
            }
            sub_411BB0(dword_4F5CC4, *(_DWORD*)(v3 + 29));
        }
        break;
    case 0x205:
        sub_444030(this, 1);
        sub_4477F0(v5, 0);
        *(_DWORD*)(*(_DWORD*)(v5 + 412) + 36) = 1065353216;
        *(_BYTE*)(*(_DWORD*)(v5 + 412) + 48) = 0;
        break;
    default:
        return;
    }
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;
// 5216E8: using guessed type int dword_5216E8;

//----- (00447D70) --------------------------------------------------------
char __cdecl sub_447D70(int a1)
{
    return sub_447D80(a1);
}

//----- (00447D80) --------------------------------------------------------
char __thiscall sub_447D80(int this)
{
    int v2; // eax
    int v3; // edi
    int v4; // eax
    int v5; // ebp
    int v6; // eax
    int v7; // ecx
    char result; // al
    int v9; // ecx
    _DWORD* v10; // ecx
    int v11; // edi
    float* v12; // eax
    int v13; // eax
    int v14; // eax
    char v15; // bl
    double v16; // st7
    double v17; // st7
    _DWORD* v18; // ecx
    float* v19; // eax
    float* v20; // edi
    float* v21; // eax
    float* v22; // edi
    float* v23; // eax
    double v24; // st7
    _DWORD* v25; // eax
    char v26; // [esp+13h] [ebp-19h]
    float v27; // [esp+14h] [ebp-18h]
    float v28; // [esp+14h] [ebp-18h]
    float v29; // [esp+14h] [ebp-18h]
    float v30; // [esp+18h] [ebp-14h]
    float v31; // [esp+18h] [ebp-14h]
    int v32; // [esp+1Ch] [ebp-10h]
    int v33; // [esp+1Ch] [ebp-10h]
    float v34; // [esp+20h] [ebp-Ch] BYREF
    int v35; // [esp+24h] [ebp-8h]
    int v36; // [esp+28h] [ebp-4h]

    v2 = *(_DWORD*)(this + 408);
    if (*(_BYTE*)(v2 + 728))
    {
        v3 = *(_DWORD*)(this + 408);
        if (*(float*)(v2 + 732) < fabs(*(float*)(sub_417140(*(_DWORD**)(this + 444), 0) + 4)))
            *(_DWORD*)(*(_DWORD*)(this + 444) + 4284) = *(_DWORD*)(v3 + 688);
        else
            *(_DWORD*)(*(_DWORD*)(this + 444) + 4284) = *(_DWORD*)(v3 + 736);
    }
    v4 = *(_DWORD*)(this + 436);
    if (v4 == 7)
        goto LABEL_41;
    v5 = 0;
    if (!v4 || sub_417160(*(_DWORD**)(this + 444)) > 0)
        return sub_418E50(*(_DWORD*)(this + 444), 1, COERCE_FLOAT(1));
    v6 = *(_DWORD*)(this + 436);
    if (v6 == 1)
    {
        v7 = *(_DWORD*)(this + 444);
        v34 = 0.0;
        v35 = -1082130432;
        v36 = 0;
        return sub_4196F0(v7, &v34, 0.0, COERCE_FLOAT(1), 1, 1);
    }
    if (v6 == 2)
    {
        v9 = *(_DWORD*)(this + 444);
        v34 = 0.0;
        v35 = 1065353216;
        v36 = 0;
        return sub_4196F0(v9, &v34, 0.0, COERCE_FLOAT(1), 1, 1);
    }
    if (v6 != 3)
    {
        if (v6 == 4)
        {
            v18 = *(_DWORD**)(this + 444);
            v33 = v18[1033];
            v19 = (float*)sub_417140(v18, 0);
            if (sub_419C40(*(_DWORD*)(this + 444), v19))
            {
                v20 = (float*)sub_417120(*(void**)(this + 444), *(_DWORD*)(*(_DWORD*)(this + 444) + 4132) - 1);
                v21 = (float*)sub_417120(*(void**)(this + 444), *(_DWORD*)(*(_DWORD*)(this + 444) + 4132) - 2);
                v29 = -1.0;
                if (v20[1] * *v21 - v21[1] * *v20 <= 0.0)
                    v29 = 1.0;
                while (sub_419910(*(_DWORD*)(this + 444), v29, 0.0, COERCE_FLOAT(1), 1, 0))
                {
                    v22 = (float*)sub_417120(*(void**)(this + 444), *(_DWORD*)(*(_DWORD*)(this + 444) + 4132) - 1);
                    v23 = (float*)sub_417120(*(void**)(this + 444), *(_DWORD*)(*(_DWORD*)(this + 444) + 4132) - 2);
                    v24 = v22[1] * *v23 - v23[1] * *v22;
                    if (v24 > 0.0 && v29 > 0.0 || v24 < 0.0 && v29 < 0.0)
                        goto LABEL_39;
                    if (++v5 >= 100)
                    {
                        if (!v26)
                            break;
                    LABEL_39:
                        *(_DWORD*)(this + 436) = 0;
                        return 1;
                    }
                }
            }
            sub_4164A0(*(_DWORD*)(this + 444), v33);
            return 0;
        }
        if (v6 != 6 && v6 != 7)
            return 0;
    LABEL_41:
        v25 = (_DWORD*)sub_417140(*(_DWORD**)(this + 444), 0);
        return sub_416350(*(_DWORD*)(this + 444), v25, 0);
    }
    v10 = *(_DWORD**)(this + 444);
    v11 = v10[1033];
    v12 = (float*)sub_417140(v10, 0);
    if (!sub_419C40(*(_DWORD*)(this + 444), v12))
        goto LABEL_24;
    v13 = *(_DWORD*)(this + 408);
    v27 = *(float*)(v13 + 804);
    v30 = *(float*)(v13 + 808);
    if (v27 == v30)
        v28 = *(float*)(v13 + 804);
    else
        v28 = fabs((double)rand() * 0.000030518509) * (v30 - v27) + v27;
    v14 = *(_DWORD*)(this + 444);
    v15 = 1;
    v32 = *(_DWORD*)(v14 + 4284);
    *(_DWORD*)(v14 + 4284) = *(_DWORD*)(*(_DWORD*)(this + 408) + 812);
    v31 = 0.0;
    if (v28 > 0.0)
    {
        while (sub_419910(*(_DWORD*)(this + 444), 0.0, 0.0, COERCE_FLOAT(1), 1, 1))
        {
            v16 = v31 + *(float*)(*(_DWORD*)(this + 408) + 712);
            v31 = v16;
            if (v16 >= v28)
                goto LABEL_22;
        }
        v15 = 0;
    }
LABEL_22:
    *(_DWORD*)(*(_DWORD*)(this + 444) + 4284) = v32;
    if (v15 && sub_419910(*(_DWORD*)(this + 444), 0.0, 0.0, COERCE_FLOAT(1), 1, 1))
    {
        v17 = v28 + *(float*)(this + 496);
        *(_DWORD*)(this + 436) = 0;
        result = 1;
        *(float*)(this + 496) = v17;
        *(float*)(this + 500) = v28 + *(float*)(this + 500);
    }
    else
    {
    LABEL_24:
        sub_4164A0(*(_DWORD*)(this + 444), v11);
        return 0;
    }
    return result;
}
// 44811C: variable 'v26' is possibly undefined

//----- (004481C0) --------------------------------------------------------
int __thiscall sub_4481C0(_DWORD* this)
{
    int v1; // edx

    v1 = this[1];
    if (v1)
        return (this[2] - v1) >> 2;
    else
        return 0;
}

//----- (004481E0) --------------------------------------------------------
int __thiscall sub_4481E0(_DWORD* this)
{
    int result; // eax

    result = this[1];
    if (result)
        return (this[2] - result) / 260;
    return result;
}

//----- (00448210) --------------------------------------------------------
void __thiscall sub_448210(int this)
{
    int i; // ebp
    void* v3; // edi
    void* v4; // eax

    if (*(_BYTE*)(this + 12))
    {
        for (i = 0; i < *(_DWORD*)(this + 4); ++i)
        {
            v3 = *(void**)(*(_DWORD*)this + 4 * i);
            if (v3)
            {
                sub_448C20(*(_DWORD*)(*(_DWORD*)this + 4 * i));
                sub_4885A6(v3);
            }
        }
    }
    memset(*(void**)this, 0, 4 * *(_DWORD*)(this + 4));
    v4 = *(void**)this;
    *(_DWORD*)(this + 4) = 0;
    sub_488CEE(v4);
    *(_DWORD*)(this + 8) = 0;
    *(_DWORD*)this = 0;
}

//----- (00448290) --------------------------------------------------------
int __thiscall sub_448290(int this)
{
    int v2; // ebx
    int i; // esi
    int result; // eax

    v2 = *(_DWORD*)(this + 8);
    for (i = *(_DWORD*)(this + 4); i != v2; i += 860)
        sub_444A90();
    sub_4885A6(*(LPVOID*)(this + 4));
    result = 0;
    *(_DWORD*)(this + 4) = 0;
    *(_DWORD*)(this + 8) = 0;
    *(_DWORD*)(this + 12) = 0;
    return result;
}

//----- (004482D0) --------------------------------------------------------
int __thiscall sub_4482D0(_DWORD* this)
{
    int result; // eax

    result = this[1];
    if (result)
        return (this[2] - result) / 860;
    return result;
}

//----- (00448300) --------------------------------------------------------
_DWORD* __thiscall sub_448300(_DWORD* this, _DWORD* a2, int* a3)
{
    int* v3; // edx
    _DWORD* result; // eax
    int* v5; // edi
    _DWORD* v6; // esi
    int v7; // ebx

    v3 = a3;
    result = a2;
    v5 = (int*)this[2];
    v6 = a2;
    if (a3 != v5)
    {
        do
        {
            v7 = *v3++;
            *v6++ = v7;
        } while (v3 != v5);
    }
    this[2] = v6;
    return result;
}

//----- (00448350) --------------------------------------------------------
int __thiscall sub_448350(_DWORD* this, int a2)
{
    int result; // eax
    _DWORD* v3; // esi
    _DWORD* i; // edx

    result = a2;
    v3 = (_DWORD*)this[2];
    for (i = (_DWORD*)(a2 + 4); i != v3; ++i)
        *(i - 1) = *i;
    this[2] -= 4;
    return result;
}

//----- (00448390) --------------------------------------------------------
int __thiscall sub_448390(_DWORD* this, char* a2, unsigned int a3, const void* a4)
{
    _DWORD* v4; // esi
    char* v6; // ebx
    int v7; // edi
    unsigned int v8; // ecx
    int v9; // edx
    unsigned int v10; // eax
    char* v11; // ebx
    char* k; // eax
    char* v13; // eax
    unsigned int v14; // edx
    char* v15; // ecx
    char* v16; // edi
    char* v17; // edx
    int v18; // eax
    int v19; // edx
    int result; // eax
    char* v21; // edi
    int v22; // eax
    char* v23; // edx
    char* v24; // ecx
    char* v25; // ebx
    unsigned int j; // eax
    char* v27; // edx
    char* v28; // eax
    char* v29; // edi
    int v30; // edx
    char* i; // eax
    char* v32; // ebx
    char* v33; // eax
    char* v34; // ebx
    void* v35; // edi
    unsigned int v37; // [esp+14h] [ebp-8h]
    char* v38; // [esp+18h] [ebp-4h]
    int v39; // [esp+18h] [ebp-4h]
    char* v40; // [esp+24h] [ebp+8h]
    char* v41; // [esp+24h] [ebp+8h]
    char* v42; // [esp+24h] [ebp+8h]
    char* v43; // [esp+28h] [ebp+Ch]

    v4 = this;
    v6 = (char*)this[2];
    if ((this[3] - (int)v6) / 260 >= a3)
    {
        v21 = a2;
        result = 2114445439 * (v6 - a2);
        if ((v6 - a2) / 260 >= a3)
        {
            if (a3)
            {
                v42 = (char*)this[2];
                v30 = 260 * a3;
                for (i = &v6[-260 * a3]; i != v6; v42 += 260)
                {
                    if (v42)
                    {
                        qmemcpy(v42, i, 0x104u);
                        v21 = a2;
                        v4 = this;
                    }
                    i += 260;
                }
                v32 = (char*)v4[2];
                v33 = &v32[-v30];
                if (v21 != &v32[-v30])
                {
                    do
                    {
                        v33 -= 260;
                        v32 -= 260;
                        qmemcpy(v32, v33, 0x104u);
                    } while (v33 != a2);
                    v4 = this;
                    v21 = a2;
                }
                v34 = &v21[v30];
                result = (int)v21;
                if (v21 != &v21[v30])
                {
                    do
                    {
                        v35 = (void*)result;
                        result += 260;
                        qmemcpy(v35, a4, 0x104u);
                    } while ((char*)result != v34);
                    v4 = this;
                }
                v4[2] += v30;
            }
        }
        else
        {
            v22 = 260 * a3;
            v39 = 260 * a3;
            v23 = &a2[260 * a3];
            if (a2 != v6)
            {
                v24 = &v23[-v22];
                v41 = &v23[-v22];
                do
                {
                    if (v23)
                    {
                        qmemcpy(v23, v41, 0x104u);
                        v21 = a2;
                        v4 = this;
                        v24 = v41;
                    }
                    v24 += 260;
                    v23 += 260;
                    v41 = v24;
                } while (v24 != v6);
            }
            v25 = (char*)v4[2];
            for (j = a3 - (v25 - v21) / 260; j; --j)
            {
                if (v25)
                {
                    qmemcpy(v25, a4, 0x104u);
                    v21 = a2;
                    v4 = this;
                }
                v25 += 260;
            }
            v27 = (char*)v4[2];
            v28 = v21;
            if (v21 != v27)
            {
                do
                {
                    v29 = v28;
                    v28 += 260;
                    qmemcpy(v29, a4, 0x104u);
                } while (v28 != v27);
                v4 = this;
            }
            result = v39 + v4[2];
            v4[2] = result;
        }
    }
    else
    {
        v7 = this[1];
        if (!v7 || (v8 = (int)&v6[-v7] / 260, a3 >= v8))
            v8 = a3;
        if (v7)
            v9 = (int)&v6[-v7] / 260;
        else
            v9 = 0;
        v10 = v9 + v8;
        v37 = v9 + v8;
        if ((int)(v9 + v8) < 0)
            v10 = 0;
        v38 = (char*)operator new(260 * v10);
        v11 = v38;
        for (k = (char*)v4[1]; k != a2; v11 += 260)
        {
            if (v11)
            {
                qmemcpy(v11, k, 0x104u);
                v4 = this;
            }
            k += 260;
        }
        v13 = v11;
        if (a3)
        {
            v14 = a3;
            do
            {
                if (v13)
                {
                    qmemcpy(v13, a4, 0x104u);
                    v4 = this;
                }
                v13 += 260;
                --v14;
            } while (v14);
        }
        v15 = (char*)v4[2];
        v40 = v15;
        v16 = &v11[260 * a3];
        v43 = v16;
        if (a2 != v15)
        {
            v17 = a2;
            do
            {
                if (v16)
                {
                    qmemcpy(v16, v17, 0x104u);
                    v4 = this;
                    v15 = v40;
                    v16 = v43;
                }
                v17 += 260;
                v16 += 260;
                v43 = v16;
            } while (v17 != v15);
        }
        sub_4885A6((LPVOID)v4[1]);
        v4[3] = &v38[260 * v37];
        v18 = v4[1];
        if (v18)
            v19 = (v4[2] - v18) / 260;
        else
            v19 = 0;
        v4[1] = v38;
        result = (int)&v38[260 * v19 + 260 * a3];
        v4[2] = result;
    }
    return result;
}

//----- (004486E0) --------------------------------------------------------
char* __thiscall sub_4486E0(_DWORD* this, char* a2, char* a3)
{
    char* v3; // edx
    char* v4; // ebx
    char* v5; // ebp
    const void* v6; // esi
    void* v7; // edi

    v3 = a3;
    v4 = a2;
    v5 = (char*)this[2];
    if (a3 != v5)
    {
        do
        {
            v6 = v3;
            v7 = v4;
            v3 += 260;
            v4 += 260;
            qmemcpy(v7, v6, 0x104u);
        } while (v3 != v5);
    }
    this[2] = v4;
    return a2;
}

//----- (00448730) --------------------------------------------------------
int __thiscall sub_448730(_DWORD* this)
{
    int v1; // edx

    v1 = this[1];
    if (v1)
        return (this[2] - v1) >> 4;
    else
        return 0;
}

//----- (00448750) --------------------------------------------------------
_DWORD* __thiscall sub_448750(_DWORD* this, _DWORD* a2, _DWORD* a3)
{
    _DWORD* v3; // edx
    _DWORD* v4; // esi
    _DWORD* v5; // edi
    _DWORD* v6; // eax
    _DWORD* v7; // ebx
    _DWORD* result; // eax

    v3 = a3;
    v4 = a2;
    v5 = (_DWORD*)this[2];
    if (a3 != v5)
    {
        do
        {
            v6 = v3;
            v7 = v4;
            v3 += 4;
            v4 += 4;
            *v7 = *v6;
            v7[1] = v6[1];
            v7[2] = v6[2];
            v7[3] = v6[3];
        } while (v3 != v5);
    }
    result = a2;
    this[2] = v4;
    return result;
}

//----- (004487A0) --------------------------------------------------------
unsigned int __thiscall sub_4487A0(_DWORD* this, char* a2, unsigned int a3, const void* a4)
{
    _DWORD* v4; // esi
    char* v6; // ebx
    int v7; // edi
    unsigned int v8; // ecx
    int v9; // edx
    unsigned int v10; // eax
    char* v11; // ebx
    char* k; // eax
    char* v13; // eax
    unsigned int v14; // edx
    char* v15; // ecx
    char* v16; // edi
    char* v17; // edx
    int v18; // ebx
    int m; // edi
    int v20; // eax
    int v21; // edx
    unsigned int v22; // ebp
    unsigned int result; // eax
    char* v24; // edi
    int v25; // eax
    char* v26; // edx
    char* v27; // ecx
    char* v28; // ebx
    unsigned int j; // eax
    char* v30; // edx
    char* v31; // eax
    char* v32; // edi
    int v33; // edx
    char* i; // eax
    char* v35; // ebx
    char* v36; // eax
    char* v37; // ebx
    void* v38; // edi
    unsigned int v40; // [esp+14h] [ebp-8h]
    char* v41; // [esp+18h] [ebp-4h]
    int v42; // [esp+18h] [ebp-4h]
    char* v43; // [esp+24h] [ebp+8h]
    char* v44; // [esp+24h] [ebp+8h]
    char* v45; // [esp+24h] [ebp+8h]
    char* v46; // [esp+28h] [ebp+Ch]

    v4 = this;
    v6 = (char*)this[2];
    if ((this[3] - (int)v6) / 860 >= a3)
    {
        v24 = a2;
        result = (unsigned int)((unsigned __int64)(1278501893LL * (v6 - a2)) >> 32) >> 31;
        if ((v6 - a2) / 860 >= a3)
        {
            if (a3)
            {
                v45 = (char*)this[2];
                v33 = 860 * a3;
                for (i = &v6[-860 * a3]; i != v6; v45 += 860)
                {
                    if (v45)
                    {
                        qmemcpy(v45, i, 0x35Cu);
                        v24 = a2;
                        v4 = this;
                    }
                    i += 860;
                }
                v35 = (char*)v4[2];
                v36 = &v35[-v33];
                if (v24 != &v35[-v33])
                {
                    do
                    {
                        v36 -= 860;
                        v35 -= 860;
                        qmemcpy(v35, v36, 0x35Cu);
                    } while (v36 != a2);
                    v4 = this;
                    v24 = a2;
                }
                v37 = &v24[v33];
                result = (unsigned int)v24;
                if (v24 != &v24[v33])
                {
                    do
                    {
                        v38 = (void*)result;
                        result += 860;
                        qmemcpy(v38, a4, 0x35Cu);
                    } while ((char*)result != v37);
                    v4 = this;
                }
                v4[2] += v33;
            }
        }
        else
        {
            v25 = 860 * a3;
            v42 = 860 * a3;
            v26 = &a2[860 * a3];
            if (a2 != v6)
            {
                v27 = &v26[-v25];
                v44 = &v26[-v25];
                do
                {
                    if (v26)
                    {
                        qmemcpy(v26, v44, 0x35Cu);
                        v24 = a2;
                        v4 = this;
                        v27 = v44;
                    }
                    v27 += 860;
                    v26 += 860;
                    v44 = v27;
                } while (v27 != v6);
            }
            v28 = (char*)v4[2];
            for (j = a3 - (v28 - v24) / 860; j; --j)
            {
                if (v28)
                {
                    qmemcpy(v28, a4, 0x35Cu);
                    v24 = a2;
                    v4 = this;
                }
                v28 += 860;
            }
            v30 = (char*)v4[2];
            v31 = v24;
            if (v24 != v30)
            {
                do
                {
                    v32 = v31;
                    v31 += 860;
                    qmemcpy(v32, a4, 0x35Cu);
                } while (v31 != v30);
                v4 = this;
            }
            result = v42 + v4[2];
            v4[2] = result;
        }
    }
    else
    {
        v7 = this[1];
        if (!v7 || (v8 = (int)&v6[-v7] / 860, a3 >= v8))
            v8 = a3;
        if (v7)
            v9 = (int)&v6[-v7] / 860;
        else
            v9 = 0;
        v10 = v9 + v8;
        v40 = v9 + v8;
        if ((int)(v9 + v8) < 0)
            v10 = 0;
        v41 = (char*)operator new(860 * v10);
        v11 = v41;
        for (k = (char*)v4[1]; k != a2; v11 += 860)
        {
            if (v11)
            {
                qmemcpy(v11, k, 0x35Cu);
                v4 = this;
            }
            k += 860;
        }
        v13 = v11;
        if (a3)
        {
            v14 = a3;
            do
            {
                if (v13)
                {
                    qmemcpy(v13, a4, 0x35Cu);
                    v4 = this;
                }
                v13 += 860;
                --v14;
            } while (v14);
        }
        v15 = (char*)v4[2];
        v43 = v15;
        v16 = &v11[860 * a3];
        v46 = v16;
        if (a2 != v15)
        {
            v17 = a2;
            do
            {
                if (v16)
                {
                    qmemcpy(v16, v17, 0x35Cu);
                    v4 = this;
                    v15 = v43;
                    v16 = v46;
                }
                v17 += 860;
                v16 += 860;
                v46 = v16;
            } while (v17 != v15);
        }
        v18 = v4[2];
        for (m = v4[1]; m != v18; m += 860)
            sub_444A90();
        sub_4885A6((LPVOID)v4[1]);
        v20 = v4[1];
        v4[3] = &v41[860 * v40];
        if (v20)
            v21 = (v4[2] - v20) / 860;
        else
            v21 = 0;
        v22 = v21 + a3;
        v4[1] = v41;
        result = 3 * v22;
        v4[2] = &v41[860 * v22];
    }
    return result;
}

//----- (00448B20) --------------------------------------------------------
char* __thiscall sub_448B20(_DWORD* this, char* a2, char* a3)
{
    char* v3; // eax
    char* v4; // ebx
    char* v6; // edx
    const void* v7; // esi
    void* v8; // edi
    char* v9; // edi
    char* i; // esi
    char* result; // eax

    v3 = a3;
    v4 = a2;
    v6 = (char*)this[2];
    if (a3 != v6)
    {
        do
        {
            v7 = v3;
            v8 = v4;
            v3 += 860;
            v4 += 860;
            qmemcpy(v8, v7, 0x35Cu);
        } while (v3 != v6);
    }
    v9 = (char*)this[2];
    for (i = v4; i != v9; i += 860)
        sub_444A90();
    result = a2;
    this[2] = v4;
    return result;
}

//----- (00448B80) --------------------------------------------------------
_DWORD* __stdcall sub_448B80(_DWORD* a1, _DWORD* a2, _DWORD* a3)
{
    _DWORD* v3; // ecx
    _DWORD* result; // eax

    v3 = a1;
    if (a1 == a2)
        return a3;
    result = a3;
    do
    {
        if (result)
            *result = *v3;
        ++v3;
        ++result;
    } while (v3 != a2);
    return result;
}

//----- (00448BB0) --------------------------------------------------------
_DWORD* __cdecl sub_448BB0(int* a1, int* a2, _DWORD* a3)
{
    int* v3; // ecx
    _DWORD* result; // eax
    int v5; // esi

    v3 = a1;
    if (a1 == a2)
        return a3;
    result = a3;
    do
    {
        v5 = *v3++;
        *result++ = v5;
    } while (v3 != a2);
    return result;
}

//----- (00448BE0) --------------------------------------------------------
_DWORD* __cdecl sub_448BE0(_DWORD* a1, _DWORD* a2)
{
    _DWORD* result; // eax

    result = a1;
    if (a1)
        *a1 = *a2;
    return result;
}

//----- (00448C00) --------------------------------------------------------
void* __thiscall sub_448C00(void* this, char a2)
{
    sub_448C20((int)this);
    if ((a2 & 1) != 0)
        sub_4885A6(this);
    return this;
}

//----- (00448C20) --------------------------------------------------------
int __thiscall sub_448C20(int this)
{
    sub_4885A6(*(LPVOID*)(this + 40));
    *(_DWORD*)(this + 40) = 0;
    *(_DWORD*)(this + 44) = 0;
    *(_DWORD*)(this + 48) = 0;
    nullsub_1(this + 16);
    return nullsub_1(this + 4);
}
// 415760: using guessed type int __thiscall nullsub_1(_DWORD);

//----- (00448C90) --------------------------------------------------------
_DWORD* __thiscall sub_448C90(_DWORD* this, char* a2)
{
    char* v2; // ebx

    v2 = a2;
    sub_468FF0(this, a2);
    *this = &off_499A18;
    memset(this + 73, 0, 0x28u);
    if (sub_40ABC0(v2, aImpactnone, 0))
    {
        sub_40AFC0(v2, aImpactnone, &a2);
        sub_469160((int)this, this + 73, a2, aEffect);
    }
    if (sub_40ABC0(v2, aImpactwater, 0))
    {
        sub_40AFC0(v2, aImpactwater, &a2);
        sub_469160((int)this, this + 74, a2, aEffect);
    }
    if (sub_40ABC0(v2, aImpactsand, 0))
    {
        sub_40AFC0(v2, aImpactsand, &a2);
        sub_469160((int)this, this + 75, a2, aEffect);
    }
    if (sub_40ABC0(v2, aImpactrock, 0))
    {
        sub_40AFC0(v2, aImpactrock, &a2);
        sub_469160((int)this, this + 76, a2, aEffect);
    }
    if (sub_40ABC0(v2, aImpactplayer, 0))
    {
        sub_40AFC0(v2, aImpactplayer, &a2);
        sub_469160((int)this, this + 77, a2, aEffect);
    }
    if (sub_40ABC0(v2, aImpactairplane, 0))
    {
        sub_40AFC0(v2, aImpactairplane, &a2);
        sub_469160((int)this, this + 78, a2, aEffect);
    }
    if (sub_40ABC0(v2, aImpactboat, 0))
    {
        sub_40AFC0(v2, aImpactboat, &a2);
        sub_469160((int)this, this + 79, a2, aEffect);
    }
    if (sub_40ABC0(v2, aImpactship, 0))
    {
        sub_40AFC0(v2, aImpactship, &a2);
        sub_469160((int)this, this + 80, a2, aEffect);
    }
    if (sub_40ABC0(v2, aImpacttank, 0))
    {
        sub_40AFC0(v2, aImpacttank, &a2);
        sub_469160((int)this, this + 81, a2, aEffect);
    }
    if (sub_40ABC0(v2, aImpactflesh, 0))
    {
        sub_40AFC0(v2, aImpactflesh, &a2);
        sub_469160((int)this, this + 82, a2, aEffect);
    }
    return this;
}
// 499A18: using guessed type _UNKNOWN *off_499A18;

//----- (00448F60) --------------------------------------------------------
int __thiscall sub_448F60(void* this)
{
    *(_DWORD*)this = &off_499A18;
    return sub_4690A0(this);
}
// 499A18: using guessed type _UNKNOWN *off_499A18;

//----- (00448F70) --------------------------------------------------------
_DWORD* __fastcall sub_448F70(_DWORD* a1, int a2, char* String1, char a4)
{
    char* v4; // edi
    int* v6; // ebp
    int v7; // edx
    _DWORD* v8; // eax
    _DWORD* v9; // eax
    int v10; // ebp
    _DWORD* v11; // eax
    int v12; // edx
    char* v13; // eax
    int v14; // eax
    const char* v16; // [esp-Ch] [ebp-78h]
    const char* v17; // [esp-8h] [ebp-74h]
    char ArgList[4]; // [esp+10h] [ebp-5Ch] BYREF
    int v19; // [esp+14h] [ebp-58h] BYREF
    int v20[2]; // [esp+18h] [ebp-54h] BYREF
    int v21[16]; // [esp+20h] [ebp-4Ch] BYREF
    int v22; // [esp+68h] [ebp-4h]

    v4 = String1;
    v20[1] = (int)a1;
    sub_468FF0(a1, String1);
    v22 = 0;
    *a1 = &off_499A24;
    sub_40AF60(v4, aGravity, (float*)a1 + 73);
    sub_40AF60(v4, aLife, (float*)a1 + 74);
    v6 = a1 + 75;
    sub_40AF60(v4, aDamage, (float*)a1 + 75);
    a1[77] = 0;
    if (sub_40ABC0(v4, aSplashradius, 0))
        sub_40AF60(v4, aSplashradius, (float*)a1 + 77);
    if (*((float*)a1 + 77) > 0.0)
    {
        v7 = *v6;
        *v6 = 0;
        a1[76] = v7;
    }
    *((_BYTE*)a1 + 312) = 1;
    if (sub_40ABC0(v4, aArmorpiercing, 0))
        sub_40B130(v4, aArmorpiercing, (_BYTE*)a1 + 312);
    a1[79] = 0;
    if (sub_40ABC0(v4, aDrag, 0))
        sub_40AF60(v4, aDrag, (float*)a1 + 79);
    *((_BYTE*)a1 + 320) = 0;
    if (sub_40ABC0(v4, aTorpedoaccel, 0))
    {
        *((_BYTE*)a1 + 320) = 1;
        sub_40AF60(v4, aTorpedodepth, (float*)a1 + 81);
        sub_40AF60(v4, aTorpedoaccel, (float*)a1 + 82);
        sub_40AF60(v4, aTorpedospeed, (float*)a1 + 83);
    }
    a1[84] = 0;
    if (sub_40ABC0(v4, aTraileffect, 0))
    {
        sub_40AFC0(v4, aTraileffect, &String1);
        sub_469160((int)a1, a1 + 84, String1, aEffect);
    }
    a1[85] = 0;
    if (sub_40ABC0(v4, aExplodeeffect, 0))
    {
        sub_40AFC0(v4, aExplodeeffect, &String1);
        sub_469160((int)a1, a1 + 85, String1, aEffect);
    }
    v8 = operator new(0x14Cu);
    v19 = (int)v8;
    LOBYTE(v22) = 1;
    if (v8)
        v9 = sub_448C90(v8, v4);
    else
        v9 = 0;
    v10 = (int)(a1 + 86);
    LOBYTE(v22) = 0;
    a1[86] = v9;
    v9[3] = aImpacts;
    sub_469700(*(_DWORD**)(dword_520970 + 200), a1[86], aCustomImpacts);
    sub_469160((int)a1, a1 + 86, 0, 0);
    a1[87] = 0;
    if (sub_40ABC0(v4, aRibbontexture, 0))
    {
        sub_40AFC0(v4, aRibbontexture, ArgList);
        v11 = sub_422400(*(_DWORD**)(dword_520970 + 124), *(char**)ArgList, 0);
        v17 = (const char*)a1[1];
        v16 = *(const char**)ArgList;
        a1[87] = v11;
        sub_40A120(v11 != 0, "failed to load texture %s, see %s : %s", v16, v17, v4 + 16);
        a1[88] = 255;
        if (sub_40ABC0(v4, aRibbonred, 0))
            sub_40AF00(v4, aRibbonred, (char**)a1 + 88);
        a1[89] = 255;
        if (sub_40ABC0(v4, aRibbongreen, 0))
            sub_40AF00(v4, aRibbongreen, (char**)a1 + 89);
        a1[90] = 255;
        if (sub_40ABC0(v4, aRibbonblue, 0))
            sub_40AF00(v4, aRibbonblue, (char**)a1 + 90);
        a1[91] = 1065353216;
        if (sub_40ABC0(v4, aRibbonlength, 0))
            sub_40AF60(v4, aRibbonlength, (float*)a1 + 91);
        *((float*)a1 + 92) = *((float*)a1 + 91) * 0.2;
        if (sub_40ABC0(v4, aRibbonrenderin, 0))
            sub_40AF60(v4, aRibbonrenderin, (float*)a1 + 92);
        if (sub_40ABC0(v4, aRibbonwidth, 0))
        {
            sub_40AF60(v4, aRibbonwidth, (float*)&v19);
            v12 = v19;
            a1[93] = v19;
            a1[94] = v12;
        }
        else
        {
            a1[93] = 1112014848;
            if (sub_40ABC0(v4, aRibbonstartwid, 0))
                sub_40AF60(v4, aRibbonstartwid, (float*)a1 + 93);
            a1[94] = 1112014848;
            if (sub_40ABC0(v4, aRibbonendwidth, 0))
                sub_40AF60(v4, aRibbonendwidth, (float*)a1 + 94);
        }
        *((_BYTE*)a1 + 380) = 1;
        if (sub_40ABC0(v4, aRibbonfacecame, 0))
            sub_40B130(v4, aRibbonfacecame, (_BYTE*)a1 + 380);
        v10 = (int)a1 + 381;
        *((_BYTE*)a1 + 381) = 1;
        if (sub_40ABC0(v4, aRibbonfadeaten, 0))
            sub_40B130(v4, aRibbonfadeaten, (_BYTE*)a1 + 381);
        a1[96] = 0;
        if (sub_40ABC0(v4, aRibbonuvscroll, 0))
            sub_40AF60(v4, aRibbonuvscroll, (float*)a1 + 96);
    }
    if (a4)
    {
        sub_40AFC0(v4, aType_0, &String1);
        if (_strcmpi(String1, aSprite))
        {
            if (_strcmpi(String1, aModel))
            {
                if (_strcmpi(String1, aStrip))
                {
                    sub_40A120(0, "invalid chunk type, see file %s", v4 + 16);
                }
                else
                {
                    a1[97] = 2;
                    sub_40AFC0(v4, aTexturefile, &String1);
                    a1[98] = sub_422400(*(_DWORD**)(dword_520970 + 124), String1, 0);
                    sub_40AF60(v4, aLength_0, (float*)a1 + 103);
                    sub_40AF60(v4, aWidth, (float*)a1 + 104);
                }
            }
            else
            {
                a1[97] = 1;
                sub_40AFC0(v4, aModelfile, &String1);
                v13 = sub_4069C0(*(_DWORD*)(dword_520970 + 128), v10, String1);
                a1[100] = v13;
                if (!v13)
                    sub_40A120(0, "could not load model %s", String1);
                sub_40AFC0(v4, aNodename, &String1);
                v14 = sub_405A30((_DWORD*)a1[100], String1, -1, 1);
                a1[101] = v14;
                if (v14 == -1)
                    sub_40A120(0, "could not find nodeName %s, see %s : %s", String1, (const char*)a1[1], v4 + 16);
                sub_4063E0((_DWORD*)a1[100], a1[101], v21, (float*)a1 + 102, 0.0, 0);
                if (sub_40ABC0(v4, aScale, 0))
                {
                    sub_40AF60(v4, aScale, (float*)v20);
                    *((float*)a1 + 102) = *(float*)v20 * *((float*)a1 + 102);
                }
            }
        }
        else
        {
            a1[97] = 0;
            sub_40AFC0(v4, aTexturefile, &String1);
            a1[98] = sub_422400(*(_DWORD**)(dword_520970 + 124), String1, 0);
            sub_40AF60(v4, aRadius, (float*)a1 + 99);
        }
    }
    return a1;
}
// 499A24: using guessed type _UNKNOWN *off_499A24;
// 520970: using guessed type int dword_520970;

//----- (00449660) --------------------------------------------------------
int __thiscall sub_449660(int** this)
{
    int* v2; // eax

    *this = (int*)&off_499A24;
    v2 = this[97];
    if (!v2)
        goto LABEL_5;
    if (v2 != (int*)1)
    {
        if (v2 != (int*)2)
            return sub_4690A0(this);
    LABEL_5:
        sub_422230(this[98]);
        return sub_4690A0(this);
    }
    sub_403B70(this[100]);
    return sub_4690A0(this);
}
// 499A24: using guessed type _UNKNOWN *off_499A24;

//----- (004496E0) --------------------------------------------------------
int __thiscall sub_4496E0(void* this, char* a2)
{
    char* v2; // ebp
    int v3; // edi
    _DWORD* v4; // esi
    char* v5; // ebx
    _DWORD* v6; // eax
    int v7; // edx
    float* v8; // eax
    int v9; // eax
    int v10; // edx
    float** v11; // eax
    float** v12; // edi
    int v13; // edx
    unsigned int v14; // ecx
    int v15; // eax
    int v16; // eax
    _DWORD* v17; // eax
    float** v18; // ebp
    _DWORD* j; // ebx
    _DWORD* v20; // edi
    int v21; // eax
    float** i; // eax
    int v23; // ecx
    float* v25; // [esp+10h] [ebp-6Ch] BYREF
    int v26; // [esp+14h] [ebp-68h]
    int v27; // [esp+18h] [ebp-64h]
    char* String1; // [esp+1Ch] [ebp-60h] BYREF
    int v29; // [esp+20h] [ebp-5Ch] BYREF
    _DWORD* v30; // [esp+24h] [ebp-58h]
    int v31; // [esp+28h] [ebp-54h]
    char* v32; // [esp+2Ch] [ebp-50h]
    int v33[16]; // [esp+30h] [ebp-4Ch] BYREF
    int v34; // [esp+78h] [ebp-4h]

    v2 = a2;
    v3 = (int)this;
    v27 = (int)this;
    sub_468FF0(this, a2);
    v4 = (_DWORD*)(v3 + 304);
    v34 = 0;
    *(_BYTE*)(v3 + 304) = (_BYTE)a2;
    *(_DWORD*)(v3 + 308) = 0;
    *(_DWORD*)(v3 + 312) = 0;
    *(_DWORD*)(v3 + 316) = 0;
    LOBYTE(v34) = 1;
    *(_DWORD*)v3 = &off_499A30;
    sub_40AFC0(a2, aChunksfile, &String1);
    v5 = sub_4069C0(*(_DWORD*)(dword_520970 + 128), (int)a2, String1);
    v26 = 0;
    v32 = v5;
    if (*((int*)v5 + 2) > 0)
    {
        do
        {
            if (sub_405BE0(v5, v26))
            {
                sub_40ADB0(v2);
                sub_40AFC0(v2, aName_0, &String1);
                v6 = operator new(0x1A4u);
                v31 = (int)v6;
                LOBYTE(v34) = 2;
                if (v6)
                    v8 = (float*)sub_448F70(v6, v7, v2, 0);
                else
                    v8 = 0;
                v25 = v8;
                *((_DWORD*)v8 + 3) = aChunk;
                LOBYTE(v34) = 1;
                *((_DWORD*)v25 + 97) = 1;
                v9 = (int)v25;
                ++*((_DWORD*)v5 + 14);
                v10 = v26;
                *(_DWORD*)(v9 + 400) = v5;
                *((_DWORD*)v25 + 101) = v10;
                sub_4063E0(v5, *((_DWORD*)v25 + 101), v33, v25 + 102, 0.0, 0);
                if (sub_40ABC0(v2, aScale, 0))
                {
                    sub_40AF60(v2, aScale, (float*)&v29);
                    v25[102] = *(float*)&v29 * v25[102];
                }
                sub_469700(*(_DWORD**)(dword_520970 + 200), (int)v25, aCustumChunk);
                sub_469160(v3, &v25, 0, 0);
                v11 = (float**)v4[2];
                v12 = v11;
                if ((v4[3] - (int)v11) >> 2)
                {
                    sub_448B80(v11, v11, v11 + 1);
                    sub_44B480((_DWORD*)v4[2], (_DWORD*)(1 - ((v4[2] - (int)v12) >> 2)), &v25);
                    for (i = (float**)v4[2]; v12 != i; ++v12)
                        *v12 = v25;
                    v4[2] += 4;
                }
                else
                {
                    v13 = v4[1];
                    if (!v13 || (v14 = ((int)v11 - v13) >> 2, v14 <= 1))
                        v14 = 1;
                    if (v13)
                        v15 = ((int)v11 - v13) >> 2;
                    else
                        v15 = 0;
                    v16 = v14 + v15;
                    v31 = v16;
                    if (v16 < 0)
                        v16 = 0;
                    v17 = operator new(4 * v16);
                    v18 = (float**)v4[1];
                    v30 = v17;
                    for (j = v17; v18 != v12; ++j)
                        sub_448BE0(j, v18++);
                    sub_44B480(j, (_DWORD*)1, &v25);
                    sub_448B80(v12, (_DWORD*)v4[2], j + 1);
                    nullsub_8(v4[1], v4[2]);
                    sub_4885A6((LPVOID)v4[1]);
                    v20 = v30;
                    v4[3] = &v30[v31];
                    v21 = sub_4481C0(v4);
                    v5 = v32;
                    v2 = a2;
                    v4[1] = v20;
                    v4[2] = &v20[v21 + 1];
                }
                v3 = v27;
            }
            v23 = *((_DWORD*)v5 + 2);
            ++v26;
        } while (v26 < v23);
    }
    sub_403B70(v5);
    sub_40AFC0(v2, aChunksfile, &String1);
    sub_40B1B0(v2, aMagnitude, (float*)(v3 + 292));
    *(_BYTE*)(v3 + 300) = 0;
    if (sub_40ABC0(v2, aExplodeup, 0))
        sub_40B130(v2, aExplodeup, (_BYTE*)(v3 + 300));
    return v3;
}
// 4497C2: variable 'v7' is possibly undefined
// 499A30: using guessed type _UNKNOWN *off_499A30;
// 520970: using guessed type int dword_520970;

//----- (00449AA0) --------------------------------------------------------
int __thiscall sub_449AA0(LPVOID* this)
{
    *this = &off_499A30;
    sub_4885A6(this[77]);
    this[77] = 0;
    this[78] = 0;
    this[79] = 0;
    return sub_4690A0(this);
}
// 499A30: using guessed type _UNKNOWN *off_499A30;

//----- (00449AE0) --------------------------------------------------------
_DWORD* __thiscall sub_449AE0(_DWORD* this)
{
    _DWORD* result; // eax

    result = this;
    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
    *((_BYTE*)this + 16) = 1;
    *this = &off_499A3C;
    return result;
}
// 499A3C: using guessed type _UNKNOWN *off_499A3C;

//----- (00449B20) --------------------------------------------------------
_DWORD* __thiscall sub_449B20(_DWORD* this)
{
    _DWORD* result; // eax

    *this = &off_499A3C;
    result = sub_411430((_DWORD*)dword_4F5CC4, (int)this);
    *this = &off_499040;
    return result;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 499A3C: using guessed type _UNKNOWN *off_499A3C;
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (00449B70) --------------------------------------------------------
char __thiscall sub_449B70(_DWORD* this)
{
    int v2; // edi
    int v3; // ecx
    int v4; // esi
    _BYTE* v5; // eax
    int v6; // ecx

    this[5] = 0;
    v2 = 0;
    v3 = *(_DWORD*)(dword_520970 + 200);
    if (*(int*)(v3 + 24) > 0)
    {
        while (1)
        {
            v4 = *(_DWORD*)(*(_DWORD*)(v3 + 20) + 4 * v2);
            if (sub_4696E0(v4, aImpacts))
            {
                if (!_strcmpi(*(const char**)(v4 + 4), aDefaultImpacts))
                    break;
            }
            ++v2;
            v3 = *(_DWORD*)(dword_520970 + 200);
            if (v2 >= *(_DWORD*)(v3 + 24))
                goto LABEL_7;
        }
        this[5] = v4;
    }
LABEL_7:
    v5 = this + 8;
    v6 = 2024;
    do
    {
        *v5 = 0;
        v5 += 136;
        --v6;
    } while (v6);
    sub_4113F0((_DWORD*)dword_4F5CC4, (int)this, 65280, 1792, 0);
    this[6] = 2139095039;
    this[7] = -1;
    return 1;
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (00449C10) --------------------------------------------------------
int __thiscall sub_449C10(char* this)
{
    int result; // eax
    _BYTE* i; // ecx

    result = 0;
    for (i = this + 32; *i; i += 136)
    {
        if (++result >= 2024)
            return -1;
    }
    return result;
}
// 449C31: conditional instruction was optimized away because eax.4<7E8

//----- (00449C40) --------------------------------------------------------
char __thiscall sub_449C40(char* this, int a2, _DWORD* a3, _DWORD* a4, char a5, char a6, float a7, int a8)
{
    int v9; // eax
    int v11; // esi
    int v12; // edx
    _DWORD* v13; // eax
    float v14; // eax
    float v15; // ecx
    int v16; // eax
    double v17; // st7
    double v18; // st7
    double v19; // st6
    double v20; // st6
    double v21; // st5
    double v22; // st4
    float v23; // eax
    float v24; // ecx
    float v25; // edx
    double v26; // rt0
    double v27; // st5
    float v28; // eax
    float v29; // ecx
    float v30; // edx
    _DWORD* v31; // eax
    int v32; // edx
    int v33; // eax
    _DWORD* v34; // eax
    int v35; // ecx
    char* v36; // edx
    _DWORD* v37; // eax
    float* v38; // ecx
    int v39; // eax
    char* v40; // esi
    int v41; // eax
    int v42; // edx
    int v43; // eax
    int v44; // ecx
    float v46; // [esp+8h] [ebp-6Ch] BYREF
    float v47; // [esp+Ch] [ebp-68h]
    float v48; // [esp+10h] [ebp-64h]
    float v49; // [esp+14h] [ebp-60h] BYREF
    float v50; // [esp+18h] [ebp-5Ch]
    float v51; // [esp+1Ch] [ebp-58h]
    float v52; // [esp+20h] [ebp-54h]
    float v53; // [esp+24h] [ebp-50h]
    int v54; // [esp+28h] [ebp-4Ch]
    float v55; // [esp+2Ch] [ebp-48h] BYREF
    float v56; // [esp+30h] [ebp-44h]
    float v57; // [esp+34h] [ebp-40h]
    float v58; // [esp+38h] [ebp-3Ch] BYREF
    float v59; // [esp+3Ch] [ebp-38h]
    float v60; // [esp+40h] [ebp-34h]
    _WORD v61[3]; // [esp+44h] [ebp-30h] BYREF
    int v62; // [esp+4Ah] [ebp-2Ah]
    char v63; // [esp+4Eh] [ebp-26h]
    int v64; // [esp+4Fh] [ebp-25h]
    int v65; // [esp+53h] [ebp-21h]
    int v66; // [esp+57h] [ebp-1Dh]
    int v67; // [esp+5Bh] [ebp-19h]
    int v68; // [esp+5Fh] [ebp-15h]
    int v69; // [esp+63h] [ebp-11h]
    int v70; // [esp+70h] [ebp-4h]

    v9 = sub_449C10(this);
    if (v9 == -1)
        return 0;
    v11 = (int)&this[136 * v9 + 32];
    *(_DWORD*)(v11 + 4) = a2;
    *(_BYTE*)v11 = 1;
    *(_BYTE*)(v11 + 1) = 0;
    *(_BYTE*)(v11 + 8) = a5;
    *(_DWORD*)(v11 + 76) = *a3;
    *(_DWORD*)(v11 + 80) = a3[1];
    v12 = a3[2];
    *(_BYTE*)(v11 + 9) = 1;
    *(_DWORD*)(v11 + 84) = v12;
    *(_DWORD*)(v11 + 68) = 0;
    *(_DWORD*)(v11 + 64) = 0;
    *(_DWORD*)(v11 + 60) = 0;
    *(_DWORD*)(v11 + 56) = 0;
    *(_DWORD*)(v11 + 48) = 0;
    *(_DWORD*)(v11 + 44) = 0;
    *(_DWORD*)(v11 + 40) = 0;
    *(_DWORD*)(v11 + 36) = 0;
    *(_DWORD*)(v11 + 28) = 0;
    *(_DWORD*)(v11 + 24) = 0;
    *(_DWORD*)(v11 + 20) = 0;
    *(_DWORD*)(v11 + 16) = 0;
    *(_DWORD*)(v11 + 72) = 1065353216;
    *(_DWORD*)(v11 + 52) = 1065353216;
    *(_DWORD*)(v11 + 32) = 1065353216;
    *(_DWORD*)(v11 + 12) = 1065353216;
    v13 = (_DWORD*)sub_4010C0(v11 + 12);
    *v13 = *a3;
    v13[1] = a3[1];
    v13[2] = a3[2];
    *(_DWORD*)(v11 + 88) = *a4;
    *(_DWORD*)(v11 + 92) = a4[1];
    *(_DWORD*)(v11 + 96) = a4[2];
    *(float*)(v11 + 100) = a7;
    if (a7 != 0.0)
    {
        v14 = *(float*)(v11 + 92);
        v15 = *(float*)(v11 + 96);
        v46 = *(float*)(v11 + 88);
        v47 = v14;
        v48 = v15;
        sub_46B970(&v46, &v46);
        v54 = 0;
        v51 = 0.0;
        v52 = v47 - 0.0;
        v49 = v52;
        v53 = 0.0 - v46;
        v50 = v53;
        v58 = v53 * v48 - 0.0 * v47;
        v55 = v58;
        v59 = 0.0 * v46 - v52 * v48;
        v56 = v59;
        v60 = v52 * v47 - v53 * v46;
        v57 = v60;
        sub_46B970(&v49, &v49);
        sub_46B970(&v55, &v55);
        v16 = *(_DWORD*)(v11 + 4);
        v17 = *(float*)(v16 + 408);
        v46 = v17 * v46;
        v47 = v17 * v47;
        v18 = v17 * v48;
        v48 = v18;
        v19 = *(float*)(v16 + 408);
        v49 = v19 * v49;
        v50 = v19 * v50;
        v51 = v19 * v51;
        v20 = *(float*)(v16 + 408);
        v21 = v20 * v55;
        v22 = v20 * v56;
        v23 = v50;
        v24 = v51;
        *(float*)(v11 + 12) = v49;
        v25 = v46;
        *(float*)(v11 + 16) = v23;
        v56 = v22;
        v26 = v21;
        v27 = v20 * v57;
        v28 = v47;
        *(float*)(v11 + 20) = v24;
        v29 = v56;
        *(float*)(v11 + 28) = v25;
        *(_DWORD*)(v11 + 24) = 0;
        *(float*)(v11 + 32) = v28;
        v57 = v27;
        v30 = v57;
        *(_DWORD*)(v11 + 40) = 0;
        *(float*)(v11 + 36) = v18;
        *(float*)(v11 + 48) = v29;
        *(float*)(v11 + 52) = v30;
        *(float*)(v11 + 44) = v26;
        *(_DWORD*)(v11 + 56) = 0;
        *(_DWORD*)(v11 + 72) = 1065353216;
    }
    sub_46B970(v11 + 104, a8);
    *(_DWORD*)(v11 + 116) = *(_DWORD*)(*(_DWORD*)(v11 + 4) + 296);
    *(_BYTE*)(v11 + 124) = a6;
    *(_BYTE*)(v11 + 125) = a6;
    v31 = sub_409960((_DWORD*)dword_520970, (int)this);
    *(_DWORD*)(v11 + 120) = v31;
    v31[10] = v11;
    *(_DWORD*)(*(_DWORD*)(v11 + 120) + 28) = 0;
    *(_DWORD*)(*(_DWORD*)(v11 + 120) + 36) = 0;
    *(_DWORD*)(*(_DWORD*)(v11 + 120) + 12) = 4;
    if (*(_DWORD*)(*(_DWORD*)(v11 + 4) + 388) == 2)
    {
        *(_DWORD*)(*(_DWORD*)(v11 + 120) + 12) = 5;
        *(_DWORD*)(*(_DWORD*)(v11 + 120) + 36) = *(_DWORD*)(*(_DWORD*)(v11 + 4) + 392);
        *(_DWORD*)(*(_DWORD*)(v11 + 120) + 28) = 1;
        *(_BYTE*)(*(_DWORD*)(v11 + 120) + 44) = 1;
        *(_DWORD*)(*(_DWORD*)(v11 + 120) + 56) = -1;
        *(_BYTE*)(*(_DWORD*)(v11 + 120) + 96) = 1;
        sub_44AF40(v11);
    }
    if (!*(_DWORD*)(*(_DWORD*)(v11 + 4) + 388))
    {
        *(_DWORD*)(*(_DWORD*)(v11 + 120) + 12) = 5;
        *(_DWORD*)(*(_DWORD*)(v11 + 120) + 36) = *(_DWORD*)(*(_DWORD*)(v11 + 4) + 392);
        *(_DWORD*)(*(_DWORD*)(v11 + 120) + 28) = 1;
        *(_DWORD*)(*(_DWORD*)(v11 + 120) + 48) = *(_DWORD*)(*(_DWORD*)(v11 + 4) + 396);
        *(_BYTE*)(*(_DWORD*)(v11 + 120) + 44) = 1;
        *(_DWORD*)(*(_DWORD*)(v11 + 120) + 56) = -1;
        *(_DWORD*)(*(_DWORD*)(v11 + 120) + 80) = 0;
        *(_DWORD*)(*(_DWORD*)(v11 + 120) + 84) = 0;
        *(_DWORD*)(*(_DWORD*)(v11 + 120) + 88) = 1065353216;
        *(_DWORD*)(*(_DWORD*)(v11 + 120) + 92) = 1065353216;
        sub_44AF40(v11);
    }
    v32 = *(_DWORD*)(v11 + 4);
    *(_DWORD*)(v11 + 128) = 0;
    v33 = *(_DWORD*)(v32 + 336);
    if (v33)
        *(_DWORD*)(v11 + 128) = sub_44E3D0(*(char**)(dword_520970 + 240), v33, (const void*)(v11 + 12));
    *(_DWORD*)(v11 + 132) = 0;
    if (*(_DWORD*)(a2 + 348))
    {
        v34 = operator new(0x7Cu);
        v70 = 0;
        if (v34)
        {
            LOBYTE(v35) = *(_BYTE*)(a2 + 381);
            v36 = *(char**)(a2 + 384);
            LOBYTE(v36) = *(_BYTE*)(a2 + 380);
            v37 = sub_463B30(
                v34,
                *(_DWORD**)(a2 + 348),
                *(_DWORD*)(a2 + 352),
                *(_DWORD*)(a2 + 356),
                *(_DWORD*)(a2 + 360),
                *(float*)(a2 + 364),
                *(float*)(a2 + 368),
                *(_DWORD*)(a2 + 372),
                *(_DWORD*)(a2 + 376),
                v36,
                v35,
                *(_DWORD*)(a2 + 384));
        }
        else
        {
            v37 = 0;
        }
        *(_DWORD*)(v11 + 132) = v37;
        v70 = -1;
        sub_4010D0(&v58, v11 + 12);
        v38 = (float*)(*(_DWORD*)(v11 + 132) + 84);
        *v38 = v58;
        v38[1] = v59;
        v38[2] = v60;
        v39 = *(_DWORD*)(v11 + 132);
        v40 = this;
        sub_428680(this, v39);
    }
    else
    {
        v40 = this;
    }
    if (!a6
        && (*(_BYTE*)(dword_4F5CC4 + 936) || *(_BYTE*)(dword_4F5CC4 + 937))
        && a5
        && (*(_DWORD*)(a2 + 8) != *((_DWORD*)v40 + 7) || *((float*)v40 + 6) > 0.1))
    {
        *((_DWORD*)v40 + 6) = 0;
        *((_DWORD*)v40 + 7) = *(_DWORD*)(a2 + 8);
        v63 = a5;
        v64 = *a3;
        v41 = a3[2];
        v65 = a3[1];
        v66 = v41;
        v42 = a4[1];
        v43 = a4[2];
        v67 = *a4;
        v44 = *(_DWORD*)(a2 + 8);
        v68 = v42;
        v62 = v44;
        v69 = v43;
        sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x701, v61, 35, 8, 1000);
    }
    return 1;
}
// 44A094: variable 'v35' is possibly undefined
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (0044A1D0) --------------------------------------------------------
char __thiscall sub_44A1D0(char* this, int a2, float* a3, float* a4, float a5, char a6, char a7, float a8, int a9)
{
    int v11[3]; // [esp+Ch] [ebp-18h] BYREF
    int v12[3]; // [esp+18h] [ebp-Ch] BYREF

    memset(v11, 0, sizeof(v11));
    sub_44A250(a2, a3, (float*)v11, a4, (float*)v11, a5, (float*)v12);
    return sub_449C40(this, a2, a3, v12, a6, a7, a8, a9);
}

//----- (0044A250) --------------------------------------------------------
float* __cdecl sub_44A250(int a1, float* a2, float* a3, float* a4, float* a5, float a6, float* a7)
{
    double v7; // st7
    double v8; // st6
    double v9; // st7
    double v10; // st6
    double v11; // st6
    long double v12; // st7
    double v13; // st6
    float* result; // eax
    long double v15; // st7
    double v16; // st6
    long double v17; // st7
    float v18; // [esp+0h] [ebp-30h] BYREF
    float v19; // [esp+4h] [ebp-2Ch]
    float v20; // [esp+8h] [ebp-28h]
    float v21; // [esp+10h] [ebp-20h]
    float v22; // [esp+14h] [ebp-1Ch]
    float v23; // [esp+1Ch] [ebp-14h]
    float v24; // [esp+20h] [ebp-10h]
    float v25; // [esp+24h] [ebp-Ch]
    float v26; // [esp+28h] [ebp-8h]
    float v27; // [esp+2Ch] [ebp-4h]
    float v28; // [esp+38h] [ebp+8h]
    int v29; // [esp+3Ch] [ebp+Ch]

    v7 = a6 * *a3;
    v8 = a6 * a3[1];
    v20 = 0.0;
    v21 = v8;
    v22 = a6 * a3[2];
    v9 = v7 + *a2;
    v26 = v21 + a2[1];
    v27 = v22 + a2[2];
    v10 = a6 * *a5;
    v21 = a6 * a5[1];
    v22 = a6 * a5[2];
    v11 = v10 + *a4;
    v23 = v21 + a4[1];
    v24 = v22 + a4[2];
    v18 = v11 - v9;
    v19 = v23 - v26;
    *(float*)&v29 = v19 * v19 + v18 * v18;
    sub_46B970(&v18, &v18);
    if (a6 == 0.0)
        v12 = 0.0;
    else
        v12 = sqrt(*(float*)&v29) / a6;
    if (a6 == 0.0)
    {
        v13 = 0.0;
    }
    else
    {
        v28 = v24 - v27;
        v13 = (v28 - a6 * *(float*)(a1 + 292) * a6 * -150.0) / a6;
    }
    result = a7;
    v22 = v13;
    v25 = v18 * v12;
    v26 = v19 * v12;
    v15 = v12 * v20;
    v18 = v25 + (float)0.0;
    v16 = v26 + (float)0.0;
    *a7 = v18;
    v19 = v16;
    v17 = v15 + v22;
    a7[1] = v19;
    v20 = v17;
    a7[2] = v20;
    return result;
}
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);

//----- (0044A3E0) --------------------------------------------------------
double __cdecl sub_44A3E0(float* a1, float* a2, float a3, float a4)
{
    double v4; // st7
    double v5; // st6
    double v6; // st5

    if (a3 == 0.0)
        return 0.0 * a4;
    v6 = a1[2] - a2[2];
    v4 = *a1 - *a2;
    v5 = a1[1] - a2[1];
    return sqrt(v6 * v6 + v4 * v4 + v5 * v5) / a3 * a4;
}

//----- (0044A440) --------------------------------------------------------
char __thiscall sub_44A440(char* this, int a2, _DWORD* a3, _DWORD* a4, char a5, char a6)
{
    int v7[3]; // [esp+0h] [ebp-Ch] BYREF

    v7[0] = 0;
    v7[1] = 0;
    v7[2] = 1065353216;
    return sub_449C40(this, a2, a3, a4, a5, a6, 0.0, (int)v7);
}

//----- (0044A490) --------------------------------------------------------
int __thiscall sub_44A490(char* this, int a2, _DWORD* a3, float* a4, char a5, char a6)
{
    unsigned int i; // edi
    int result; // eax
    bool v11; // zf
    signed int v12; // eax
    double v13; // st7
    bool v14; // zf
    signed int v15; // eax
    double v16; // st7
    bool v17; // zf
    signed int v18; // eax
    double v19; // st7
    long double v20; // st7
    long double v21; // st7
    float v22; // [esp+10h] [ebp-24h]
    float v23; // [esp+14h] [ebp-20h]
    float v24; // [esp+14h] [ebp-20h]
    float v25; // [esp+18h] [ebp-1Ch]
    int v26; // [esp+1Ch] [ebp-18h] BYREF
    float v27; // [esp+20h] [ebp-14h]
    float v28; // [esp+24h] [ebp-10h]
    int v29[3]; // [esp+28h] [ebp-Ch] BYREF
    float v30; // [esp+38h] [ebp+4h]
    float v31; // [esp+40h] [ebp+Ch]

    for (i = 0; ; ++i)
    {
        result = *(_DWORD*)(a2 + 308);
        if (!result)
            break;
        if (i >= (*(_DWORD*)(a2 + 312) - result) >> 2)
            break;
        result = sub_449C10(this);
        if (result == -1)
            break;
        v25 = fabs((double)rand() * 0.000030518509);
        v23 = fabs((double)rand() * 0.000030518509);
        *(float*)&v26 = fabs((double)rand() * 0.000030518509) * 0.89999998 + 0.1;
        v27 = v23 * 0.89999998 + 0.1;
        v28 = v25 * 0.89999998 + 0.1;
        v12 = rand() & 0x80000001;
        v11 = v12 == 0;
        if (v12 < 0)
            v11 = (((_BYTE)v12 - 1) | 0xFFFFFFFE) == -1;
        if (v11)
            v13 = 1.0;
        else
            v13 = -1.0;
        *(float*)&v26 = v13 * *(float*)&v26;
        v15 = rand() & 0x80000001;
        v14 = v15 == 0;
        if (v15 < 0)
            v14 = (((_BYTE)v15 - 1) | 0xFFFFFFFE) == -1;
        if (v14)
            v16 = 1.0;
        else
            v16 = -1.0;
        v27 = v16 * v27;
        v18 = rand() & 0x80000001;
        v17 = v18 == 0;
        if (v18 < 0)
            v17 = (((_BYTE)v18 - 1) | 0xFFFFFFFE) == -1;
        if (v17 || *(_BYTE*)(a2 + 300))
            v19 = 1.0;
        else
            v19 = -1.0;
        v28 = v19 * v28;
        sub_46B970(&v26, &v26);
        v30 = *(float*)(a2 + 292);
        v31 = *(float*)(a2 + 296);
        if (v30 == v31)
            v20 = v30;
        else
            v20 = fabs((double)rand() * 0.000030518509) * (v31 - v30) + v30;
        *(float*)&v26 = v20 * *(float*)&v26;
        v27 = v20 * v27;
        *(float*)&v26 = *(float*)&v26 + *a4;
        v27 = v27 + a4[1];
        v28 = v20 * v28 + a4[2];
        v22 = fabs((double)rand() * 0.000030518509);
        v24 = fabs((double)rand() * 0.000030518509);
        v21 = fabs((double)rand() * 0.000030518509);
        *(float*)v29 = v21 + v21 - 1.0;
        *(float*)&v29[1] = v24 + v24 - 1.0;
        *(float*)&v29[2] = v22 + v22 - 1.0;
        sub_46B970(v29, v29);
        sub_449C40(this, *(_DWORD*)(*(_DWORD*)(a2 + 308) + 4 * i), a3, &v26, a5, a6, 3.1415927, (int)v29);
    }
    return result;
}
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);

//----- (0044A730) --------------------------------------------------------
char __thiscall sub_44A730(int this, int a2)
{
    _DWORD* v2; // edi
    int v3; // esi
    _DWORD* v4; // edx
    double v5; // st7
    void(__thiscall * **v6)(_DWORD, int); // ecx
    double v7; // st7
    int* v8; // ebp
    int* v9; // edx
    int v10; // ecx
    double v11; // st7
    float* v12; // edx
    long double v13; // st6
    int v14; // ecx
    long double v15; // st6
    double v16; // st6
    double v17; // st5
    double v18; // st7
    long double v19; // st7
    double v20; // st7
    double v21; // st7
    int v22; // ecx
    _DWORD* v23; // ecx
    int v24; // edx
    unsigned int v25; // edi
    int v26; // eax
    int v27; // ecx
    int v28; // edx
    int v29; // eax
    int v30; // ecx
    int v31; // ecx
    double v32; // st7
    char v33; // fps^1
    bool v34; // c0
    char v35; // c2
    bool v36; // c3
    int v37; // eax
    int v38; // eax
    int v39; // eax
    float v41; // [esp+0h] [ebp-E4h]
    bool v42; // [esp+17h] [ebp-CDh]
    float v43; // [esp+18h] [ebp-CCh]
    float v44; // [esp+18h] [ebp-CCh]
    int v46; // [esp+20h] [ebp-C4h] BYREF
    int v47; // [esp+24h] [ebp-C0h]
    int v48; // [esp+28h] [ebp-BCh]
    int v49; // [esp+2Ch] [ebp-B8h] BYREF
    int v50; // [esp+30h] [ebp-B4h]
    int v51; // [esp+34h] [ebp-B0h] BYREF
    int v52; // [esp+38h] [ebp-ACh]
    int v53; // [esp+3Ch] [ebp-A8h]
    int v54; // [esp+40h] [ebp-A4h]
    int v55; // [esp+44h] [ebp-A0h]
    int v56; // [esp+48h] [ebp-9Ch]
    float v57; // [esp+4Ch] [ebp-98h]
    _DWORD v58[3]; // [esp+50h] [ebp-94h] BYREF
    int v59[4]; // [esp+5Ch] [ebp-88h] BYREF
    float v60; // [esp+6Ch] [ebp-78h]
    float v61; // [esp+70h] [ebp-74h]
    int v62[3]; // [esp+74h] [ebp-70h] BYREF
    _DWORD v63[3]; // [esp+80h] [ebp-64h] BYREF
    int v64[3]; // [esp+8Ch] [ebp-58h] BYREF
    int v65[3]; // [esp+98h] [ebp-4Ch] BYREF
    _BYTE v66[64]; // [esp+A4h] [ebp-40h] BYREF

    v2 = (_DWORD*)this;
    v50 = 2024;
    v3 = this + 128;
    *(float*)(this + 24) = *(float*)&a2 + *(float*)(this + 24);
    while (1)
    {
        if (!*(_BYTE*)(v3 - 96))
            goto LABEL_75;
        if (*(_BYTE*)(v3 - 95))
        {
            sub_4010D0(v63, v3 - 84);
            v4 = (_DWORD*)(*(_DWORD*)(v3 + 36) + 84);
            *v4 = v63[0];
            v4[1] = v63[1];
            v4[2] = v63[2];
            v5 = *(float*)(v3 + 20) - *(float*)&a2;
            *(float*)(v3 + 20) = v5;
            if (v5 <= 0.0)
            {
                sub_4286C0(v2, *(_DWORD*)(v3 + 36));
                v6 = *(void(__thiscall****)(_DWORD, int))(v3 + 36);
                if (v6)
                    (**v6)(v6, 1);
                *(_BYTE*)(v3 - 96) = 0;
            }
            goto LABEL_75;
        }
        v7 = *(float*)(v3 + 20) - *(float*)&a2;
        *(float*)(v3 + 20) = v7;
        v42 = v7 <= 0.0;
        v8 = (int*)sub_4010C0(v3 - 84);
        v46 = *v8;
        v47 = v8[1];
        v9 = (int*)(v3 - 20);
        v48 = v8[2];
        *v9 = *v8;
        v9[1] = v8[1];
        v9[2] = v8[2];
        v10 = *(_DWORD*)(v3 - 92);
        if (*(_BYTE*)(v10 + 320) && *((float*)v8 + 2) <= 0.0)
        {
            v11 = *(float*)v3;
            *(_DWORD*)v3 = 0;
            v12 = (float*)(v3 - 8);
            v13 = sqrt(
                *(float*)v3 * *(float*)v3
                + *(float*)(v3 - 8) * *(float*)(v3 - 8)
                + *(float*)(v3 - 4) * *(float*)(v3 - 4));
            if (v13 < *(float*)(v10 + 332))
            {
                if (v13 == 0.0)
                {
                    v54 = 0;
                    v55 = 0;
                    v56 = 0;
                    *v12 = 0.0;
                    *((_DWORD*)v12 + 1) = v55;
                    *(_DWORD*)v3 = v56;
                }
                else
                {
                    *v12 = 1.0 / v13 * *v12;
                    *(float*)(v3 - 4) = 1.0 / v13 * *(float*)(v3 - 4);
                    *(float*)v3 = 1.0 / v13 * *(float*)v3;
                }
                v14 = *(_DWORD*)(v3 - 92);
                v15 = v13 + *(float*)&a2 * *(float*)(v14 + 328);
                if (v15 >= *(float*)(v14 + 332))
                    v15 = *(float*)(v14 + 332);
                *v12 = v15 * *v12;
                *(float*)(v3 - 4) = v15 * *(float*)(v3 - 4);
                *(float*)v3 = v15 * *(float*)v3;
            }
            if (-*(float*)(*(_DWORD*)(v3 - 92) + 324) <= *((float*)v8 + 2))
                *(float*)v3 = v11;
        }
        else
        {
            v43 = *(float*)v3 - *(float*)&a2 * *(float*)(v10 + 292) * 300.0;
            *(float*)v3 = v43;
            if (*(float*)(v10 + 316) != 0.0)
            {
                *(_DWORD*)v3 = 0;
                v16 = *(float*)(v3 - 4);
                v17 = *(float*)(v3 - 8);
                v18 = *(float*)v3 * *(float*)v3;
                v57 = v43;
                v19 = sqrt(v18 + v17 * v17 + v16 * v16);
                if (v19 > 100.0)
                {
                    sub_46B970(v3 - 8, v3 - 8);
                    v44 = v19;
                    v20 = v44 - *(float*)&a2 * *(float*)(*(_DWORD*)(v3 - 92) + 316);
                    if (v20 <= 0.0)
                        v20 = 0.0;
                    *(float*)(v3 - 8) = v20 * *(float*)(v3 - 8);
                    *(float*)(v3 - 4) = v20 * *(float*)(v3 - 4);
                    *(float*)v3 = v20 * *(float*)v3;
                }
                *(float*)v3 = v57;
            }
        }
        v21 = *(float*)&a2 * *(float*)(v3 - 8);
        v60 = *(float*)&a2 * *(float*)(v3 - 4);
        v61 = *(float*)&a2 * *(float*)v3;
        *(float*)v8 = v21 + *(float*)v8;
        *((float*)v8 + 1) = v60 + *((float*)v8 + 1);
        *((float*)v8 + 2) = v61 + *((float*)v8 + 2);
        if (*(float*)(v3 + 4) != 0.0)
        {
            v41 = *(float*)&a2 * *(float*)(v3 + 4);
            sub_46BFED((int)v66, v3 + 8, v41);
            sub_46B97C((_BYTE*)(v3 - 84), v66, (_BYTE*)(v3 - 84));
        }
        v22 = *(_DWORD*)(v3 + 32);
        memset(v65, 0, sizeof(v65));
        sub_44E6F0(*(_DWORD**)(dword_520970 + 240), v22, (const void*)(v3 - 84), v65);
        if (*(_DWORD*)(v3 + 36))
        {
            sub_4010D0(v58, v3 - 84);
            v23 = (_DWORD*)(*(_DWORD*)(v3 + 36) + 84);
            *v23 = v58[0];
            v23[1] = v58[1];
            v23[2] = v58[2];
        }
        v25 = sub_42FB40(*(_DWORD**)(dword_520970 + 208), (int*)(v3 - 20), v8, v3 - 96, (float*)&v46);
        if (*(float*)(v3 - 12) < 1000.0 || *((float*)v8 + 2) < 1000.0)
        {
            if (*(_BYTE*)(v3 - 88))
            {
                if (v25)
                    goto LABEL_40;
                v25 = sub_456000(*(_DWORD**)(dword_520970 + 216), v3 - 20, v8, v3 - 96, (int)&v46);
                if (v25)
                    goto LABEL_40;
                v25 = sub_465CF0(*(_DWORD**)(dword_520970 + 220), (int*)(v3 - 20), v8, v3 - 96, (float*)&v46);
                if (v25)
                    goto LABEL_40;
                v26 = sub_442EE0(*(_DWORD**)(dword_520970 + 212), (int*)(v3 - 20), v8, v3 - 96, &v46);
            }
            else
            {
                if (v25)
                    goto LABEL_40;
                v26 = sub_461D40(*(_DWORD*)(dword_520970 + 280), (int*)(v3 - 20), v8, v3 - 96, &v46);
            }
            v25 = v26;
        }
    LABEL_40:
        if ((*(float*)(v3 - 12) < 3000.0 || *((float*)v8 + 2) < 3000.0) && !v25)
        {
            v27 = *(_DWORD*)(v3 - 16);
            v28 = *(_DWORD*)(v3 - 12);
            v59[0] = *(_DWORD*)(v3 - 20);
            v49 = -1;
            v51 = 0;
            v52 = 0;
            v53 = 0;
            v59[1] = v27;
            v59[2] = v28;
            if (!sub_468CA0(*(int**)(dword_520970 + 260), (float*)v59, v8, (float*)&v51, &v49)
                || (v24 = v53, v46 = v51, v47 = v52, v48 = v53, v49 == -1))
            {
                v25 = 0;
            }
            else if (v49)
            {
                switch (v49)
                {
                case 1:
                    v25 = 3;
                    break;
                case 2:
                    v25 = 2;
                    break;
                case 3:
                    v25 = 2;
                    break;
                }
            }
            else
            {
                v25 = 1;
            }
        }
        v29 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v3 - 92) + 344) + 4 * v25 + 292);
        if (v29 || (v29 = *(_DWORD*)(this + 20)) != 0 && (v29 = *(_DWORD*)(v29 + 4 * v25 + 292)) != 0)
        {
            memset(v62, 0, sizeof(v62));
            sub_44DF20(*(char**)(dword_520970 + 240), *(float*)&v29, COERCE_FLOAT(&v46), (float*)v62);
        }
        v30 = *(_DWORD*)(v3 - 92);
        if (*(_BYTE*)(v30 + 320))
        {
            if (v25 > 1)
                goto LABEL_64;
        }
        else if (v25)
        {
            goto LABEL_63;
        }
        if (v42)
        {
        LABEL_63:
            if (v25 != 1)
            {
            LABEL_64:
                if (*(float*)(v3 + 20) > 0.0)
                {
                    memset(v64, 0, sizeof(v64));
                    sub_44DF20(*(char**)(dword_520970 + 240), *(float*)(v30 + 340), *(float*)&v8, (float*)v64);
                }
            }
            v31 = *(_DWORD*)(v3 - 92);
            v32 = *(float*)(v31 + 308);
            v34 = v32 < 0.0;
            v35 = 0;
            v36 = v32 == 0.0;
            BYTE1(v29) = v33;
            if (v32 > 0.0 && !*(_BYTE*)(v3 + 28))
            {
                LOBYTE(v29) = *(_BYTE*)(v3 - 88);
                LOBYTE(v24) = *(_BYTE*)(v31 + 312);
                sub_44AE60(&v46, COERCE_INT(*(float*)(v31 + 308)), *(float*)(v31 + 304), v24, v29);
            }
            v37 = *(_DWORD*)(v3 + 32);
            *(_BYTE*)(v3 - 96) = 0;
            sub_44E7B0(*(_DWORD**)(dword_520970 + 240), v37);
            v38 = *(_DWORD*)(v3 + 36);
            if (v38)
            {
                *(_BYTE*)(v3 - 96) = 1;
                *(_BYTE*)(v3 - 95) = 1;
                *(float*)(v3 + 20) = *(float*)(v38 + 80);
            }
            sub_409A00(dword_520970, *(void**)(v3 + 24));
            *(_DWORD*)(v3 + 24) = 0;
            goto LABEL_75;
        }
        v39 = *(_DWORD*)(v30 + 388);
        if (!v39 || v39 == 2)
            sub_44AF40(v3 - 96);
    LABEL_75:
        v3 += 136;
        if (!--v50)
            return sub_428620((_DWORD*)this, a2);
        v2 = (_DWORD*)this;
    }
}
// 44AD96: variable 'v33' is possibly undefined
// 44ADC2: variable 'v24' is possibly undefined
// 44ADC2: variable 'v29' is possibly undefined
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);
// 520970: using guessed type int dword_520970;

//----- (0044AE60) --------------------------------------------------------
void __stdcall sub_44AE60(int* a1, int a2, float a3, int a4, int a5)
{
    sub_42FBB0(*(_DWORD**)(dword_520970 + 208), a1, *(float*)&a2, a3, a4, a5);
    if ((_BYTE)a5)
    {
        sub_442F30(*(_DWORD**)(dword_520970 + 212), a1, *(float*)&a2, a3, a4, a5);
        sub_456050(*(_DWORD**)(dword_520970 + 216), (float*)a1, a2, a3, a4, a5);
        sub_465D40(*(_DWORD**)(dword_520970 + 220), a1, *(float*)&a2, a3, a4, a5);
    }
    else
    {
        sub_461FD0(*(_DWORD**)(dword_520970 + 280), (float*)a1, *(float*)&a2, a3, a4, 0);
    }
}
// 520970: using guessed type int dword_520970;

//----- (0044AF10) --------------------------------------------------------
int __stdcall sub_44AF10(int a1)
{
    int v1; // eax

    v1 = *(_DWORD*)(a1 + 40);
    if (*(_BYTE*)(v1 + 9) && *(_DWORD*)(*(_DWORD*)(v1 + 4) + 388) == 1)
        return sub_44AF40(v1);
    else
        return 0;
}

//----- (0044AF40) --------------------------------------------------------
int __stdcall sub_44AF40(int a1)
{
    int v1; // eax
    int v2; // eax
    double v3; // st7
    double v4; // st7
    double v5; // st6
    double v6; // st6
    double v7; // st5
    double v8; // st4
    float v9; // eax
    float v10; // ecx
    float v11; // edx
    double v12; // rt0
    double v13; // st5
    float v14; // eax
    float v15; // ecx
    float v16; // edx
    _DWORD* v18; // eax
    _DWORD* v19; // edx
    _DWORD* v20; // eax
    _DWORD* v21; // ecx
    char v22; // al
    double v23; // st7
    int v24; // edx
    double v25; // st7
    double v26; // st7
    float v27; // ecx
    float v28; // eax
    double v29; // st7
    int v30; // ecx
    double v31; // st7
    float v32; // eax
    float v33; // edx
    int v34; // eax
    double v35; // st7
    float v36; // edx
    float v37; // ecx
    float v38; // ecx
    int v39; // edx
    float v40; // eax
    char v41; // [esp+0h] [ebp-44h]
    float v42; // [esp+8h] [ebp-3Ch] BYREF
    float v43; // [esp+Ch] [ebp-38h]
    float v44; // [esp+10h] [ebp-34h]
    float v45; // [esp+14h] [ebp-30h] BYREF
    float v46; // [esp+18h] [ebp-2Ch]
    float v47; // [esp+1Ch] [ebp-28h]
    float v48; // [esp+20h] [ebp-24h]
    float v49; // [esp+24h] [ebp-20h]
    float v50; // [esp+28h] [ebp-1Ch]
    float v51; // [esp+2Ch] [ebp-18h] BYREF
    float v52; // [esp+30h] [ebp-14h]
    float v53; // [esp+34h] [ebp-10h]
    float v54; // [esp+38h] [ebp-Ch] BYREF
    float v55; // [esp+3Ch] [ebp-8h]
    float v56; // [esp+40h] [ebp-4h]

    v1 = *(_DWORD*)(*(_DWORD*)(a1 + 4) + 388);
    if (v1 == 1)
    {
        sub_41BC00((_DWORD*)dword_520A50, 1, 0, 1, 0, 1, -1, 1);
        if (*(float*)(a1 + 100) == 0.0)
        {
            v42 = *(float*)(a1 + 88);
            v43 = *(float*)(a1 + 92);
            v44 = *(float*)(a1 + 96);
            sub_46B970(&v42, &v42);
            v50 = 0.0;
            v47 = 0.0;
            v48 = v43 - 0.0;
            v45 = v48;
            v49 = 0.0 - v42;
            v46 = v49;
            v54 = v49 * v44 - 0.0 * v43;
            v51 = v54;
            v55 = 0.0 * v42 - v48 * v44;
            v52 = v55;
            v56 = v48 * v43 - v49 * v42;
            v53 = v56;
            sub_46B970(&v45, &v45);
            sub_46B970(&v51, &v51);
            v2 = *(_DWORD*)(a1 + 4);
            v3 = *(float*)(v2 + 408);
            v42 = v3 * v42;
            v43 = v3 * v43;
            v4 = v3 * v44;
            v44 = v4;
            v5 = *(float*)(v2 + 408);
            v45 = v5 * v45;
            v46 = v5 * v46;
            v47 = v5 * v47;
            v6 = *(float*)(v2 + 408);
            v7 = v6 * v51;
            v8 = v6 * v52;
            v9 = v46;
            v10 = v47;
            *(float*)(a1 + 12) = v45;
            v11 = v42;
            *(float*)(a1 + 16) = v9;
            v52 = v8;
            v12 = v7;
            v13 = v6 * v53;
            v14 = v43;
            *(float*)(a1 + 20) = v10;
            v15 = v52;
            *(float*)(a1 + 28) = v11;
            *(_DWORD*)(a1 + 24) = 0;
            *(float*)(a1 + 32) = v14;
            v53 = v13;
            v16 = v53;
            *(_DWORD*)(a1 + 40) = 0;
            *(float*)(a1 + 36) = v4;
            *(float*)(a1 + 48) = v15;
            *(float*)(a1 + 52) = v16;
            *(float*)(a1 + 44) = v12;
            *(_DWORD*)(a1 + 56) = 0;
            *(_DWORD*)(a1 + 72) = 1065353216;
        }
        (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 148))(*(_DWORD*)ArgList, 256, a1 + 12);
        return sub_406110(
            *(_DWORD**)(*(_DWORD*)(a1 + 4) + 400),
            *(_DWORD*)(a1 + 4),
            *(_DWORD*)(*(_DWORD*)(a1 + 4) + 404),
            0,
            0,
            v41);
    }
    else if (v1)
    {
        if (v1 == 2)
        {
            v20 = (_DWORD*)sub_4010C0(a1 + 12);
            v21 = (_DWORD*)(*(_DWORD*)(a1 + 120) + 16);
            *v21 = *v20;
            v21[1] = v20[1];
            v21[2] = v20[2];
            sub_4010D0(&v51, a1 + 12);
            sub_46B970(&v54, a1 + 88);
            v22 = *(_BYTE*)(a1 + 125);
            v23 = *(float*)(*(_DWORD*)(a1 + 4) + 412);
            v45 = v54 * v23;
            v46 = v55 * v23;
            v48 = v51 + v45;
            v49 = v52 + v46;
            v50 = v53 + v23 * v56;
            if (v22)
            {
                v42 = 0.0;
                v43 = 0.0;
                v44 = 1.0;
            }
            else
            {
                v47 = 0.0;
                v44 = 0.0;
                v45 = v55 - 0.0;
                v42 = v45;
                v46 = 0.0 - v54;
                v43 = v46;
                sub_46B970(&v42, &v42);
            }
            v24 = *(_DWORD*)(a1 + 120) + 100;
            v25 = *(float*)(*(_DWORD*)(a1 + 4) + 416);
            v42 = v25 * v42;
            v43 = v25 * v43;
            v44 = v25 * v44;
            v45 = v48 - v42;
            v46 = v49 - v43;
            v26 = v50 - v44;
            v27 = v46;
            *(float*)v24 = v45;
            v47 = v26;
            v28 = v47;
            *(float*)(v24 + 4) = v27;
            v29 = v48;
            *(float*)(v24 + 8) = v28;
            v30 = *(_DWORD*)(a1 + 120) + 124;
            v45 = v29 + v42;
            v46 = v49 + v43;
            v31 = v50 + v44;
            v32 = v46;
            *(float*)v30 = v45;
            v47 = v31;
            v33 = v47;
            *(float*)(v30 + 4) = v32;
            *(float*)(v30 + 8) = v33;
            v34 = *(_DWORD*)(a1 + 120) + 136;
            v48 = v51 + v42;
            v49 = v52 + v43;
            v35 = v53 + v44;
            v36 = v49;
            *(float*)v34 = v48;
            v50 = v35;
            v37 = v50;
            *(float*)(v34 + 4) = v36;
            *(float*)(v34 + 8) = v37;
            v48 = v51 - v42;
            v49 = v52 - v43;
            v38 = v49;
            v39 = *(_DWORD*)(a1 + 120) + 112;
            v50 = v53 - v44;
            *(float*)v39 = v48;
            v40 = v50;
            *(float*)(v39 + 4) = v38;
            *(float*)(v39 + 8) = v40;
        }
        return 0;
    }
    else
    {
        v18 = (_DWORD*)sub_4010C0(a1 + 12);
        v19 = (_DWORD*)(*(_DWORD*)(a1 + 120) + 16);
        *v19 = *v18;
        v19[1] = v18[1];
        v19[2] = v18[2];
        return 0;
    }
}
// 44B12E: variable 'v41' is possibly undefined
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);
// 520A50: using guessed type int dword_520A50;

//----- (0044B390) --------------------------------------------------------
char __thiscall sub_44B390(char* this, int a2)
{
    char result; // al
    int v3; // eax
    _DWORD* v4; // edx
    int v5; // eax
    _DWORD* v6; // [esp-14h] [ebp-20h]
    char v7; // [esp-10h] [ebp-1Ch]
    int v8[3]; // [esp+0h] [ebp-Ch] BYREF

    result = a2;
    if (*(_WORD*)(a2 + 12) == 1793)
    {
        v3 = *(_DWORD*)(a2 + 16);
        v7 = *(_BYTE*)(v3 + 10);
        v6 = (_DWORD*)(v3 + 23);
        v4 = (_DWORD*)(v3 + 11);
        v5 = *(_DWORD*)(v3 + 6);
        v8[0] = 0;
        v8[1] = 0;
        v8[2] = 1065353216;
        return sub_449C40(
            this,
            *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(dword_520970 + 200) + 20) + 4 * v5),
            v4,
            v6,
            v7,
            1,
            0.0,
            (int)v8);
    }
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (0044B3F0) --------------------------------------------------------
int __thiscall sub_44B3F0(_DWORD* this)
{
    int v2; // ebp
    _DWORD* v3; // esi
    int result; // eax
    int(__thiscall * **v5)(_DWORD, int); // ecx

    v2 = 2024;
    v3 = this + 38;
    do
    {
        if (*((_BYTE*)v3 - 120))
        {
            *((_BYTE*)v3 - 120) = 0;
            if (!*((_BYTE*)v3 - 119) && *v3)
                sub_409A00(dword_520970, (void*)*v3);
            *v3 = 0;
            result = v3[3];
            if (result)
            {
                result = sub_4286C0(this, v3[3]);
                v5 = (int(__thiscall***)(_DWORD, int))v3[3];
                if (v5)
                    result = (**v5)(v5, 1);
                v3[3] = 0;
            }
        }
        v3 += 34;
        --v2;
    } while (v2);
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (0044B460) --------------------------------------------------------
int __thiscall sub_44B460(_DWORD** this)
{
    return (*(int(__thiscall**)(_DWORD*))(*this[5] + 4))(this[5]);
}

//----- (0044B470) --------------------------------------------------------
int __thiscall sub_44B470(_DWORD** this)
{
    return (*(int(__thiscall**)(_DWORD*))(*this[5] + 8))(this[5]);
}

//----- (0044B480) --------------------------------------------------------
_DWORD* __stdcall sub_44B480(_DWORD* a1, _DWORD* a2, _DWORD* a3)
{
    _DWORD* result; // eax
    _DWORD* v4; // ecx

    result = a2;
    if (a2)
    {
        v4 = a2;
        result = a1;
        do
        {
            if (result)
                *result = *a3;
            ++result;
            v4 = (_DWORD*)((char*)v4 - 1);
        } while (v4);
    }
    return result;
}

//----- (0044B4B0) --------------------------------------------------------
_DWORD* __thiscall sub_44B4B0(_DWORD* this, char* ArgList)
{
    char* v2; // ebx
    int v4; // eax
    int v5; // ecx
    int v6; // eax
    _DWORD* v8; // [esp-Ch] [ebp-30h]
    _DWORD v9[2]; // [esp+10h] [ebp-14h] BYREF
    int v10; // [esp+20h] [ebp-4h]

    v2 = ArgList;
    v9[1] = this;
    sub_468FF0(this, ArgList);
    v10 = 0;
    *((_BYTE*)this + 292) = (_BYTE)ArgList;
    this[74] = 0;
    this[75] = 0;
    this[76] = 0;
    LOBYTE(v10) = 1;
    *this = &off_499A68;
    while (sub_40ABC0(v2, aSystem, 0))
    {
        sub_40AFC0(v2, aSystem, &ArgList);
        v4 = sub_413830(*(_DWORD**)(dword_520970 + 116), ArgList);
        v8 = (_DWORD*)this[75];
        v9[0] = v4;
        sub_44F190((int)(this + 73), v8, 1u, v9);
        v5 = this[74];
        if (v5)
            v6 = (this[75] - v5) >> 2;
        else
            v6 = 0;
        sub_40A120(
            *(_DWORD*)(this[74] + 4 * v6 - 4) != 0,
            "failed to find particle system %s, see %s : %s, and particle.dat",
            ArgList,
            (const char*)this[1],
            v2 + 16);
    }
    return this;
}
// 499A68: using guessed type _UNKNOWN *off_499A68;
// 520970: using guessed type int dword_520970;

//----- (0044B5E0) --------------------------------------------------------
int __thiscall sub_44B5E0(LPVOID* this)
{
    *this = &off_499A68;
    sub_4885A6(this[74]);
    this[74] = 0;
    this[75] = 0;
    this[76] = 0;
    return sub_4690A0(this);
}
// 499A68: using guessed type _UNKNOWN *off_499A68;

//----- (0044B620) --------------------------------------------------------
int __thiscall sub_44B620(int this)
{
    int v2; // eax
    int j; // edi
    int v4; // ecx
    int v5; // eax
    _DWORD* v6; // ebp
    int v7; // ebx
    int v8; // eax
    int i; // [esp+10h] [ebp-10h]
    unsigned int v11; // [esp+14h] [ebp-Ch]
    unsigned int v12; // [esp+18h] [ebp-8h]
    char v13; // [esp+1Ch] [ebp-4h]

    v12 = 0;
    for (i = 0; ; i += 40)
    {
        v2 = *(_DWORD*)(this + 336);
        if (!v2 || v12 >= (*(_DWORD*)(this + 340) - v2) / 40)
            break;
        v11 = 0;
        for (j = 0; ; j += 268)
        {
            v4 = *(_DWORD*)(this + 336);
            v5 = *(_DWORD*)(v4 + i + 28);
            v6 = (_DWORD*)(v4 + i);
            if (!v5 || v11 >= (v6[8] - v5) / 268)
                break;
            v7 = v6[7];
            if (!*(_DWORD*)(v7 + j + 264))
            {
                if (*(_BYTE*)(this + 330) || v6[4] != 1065353216 || (v13 = 0, v6[5] != 1065353216))
                    v13 = 1;
                *(_DWORD*)(j + v7 + 264) = sub_41DE10(
                    *(_DWORD**)(dword_520970 + 120),
                    (char*)(j + v7 + 4),
                    *(_BYTE*)(this + 301) != 0 ? 3 : 1,
                    *(_BYTE*)(this + 294),
                    *(_BYTE*)(this + 292),
                    *(_BYTE*)(this + 293),
                    v13);
                v8 = j + *(_DWORD*)(*(_DWORD*)(this + 336) + i + 28);
                sub_4282E0(
                    *(_DWORD*)(v8 + 264) != 0,
                    "failed to load sound %s, see %s : %s",
                    (const char*)(v8 + 4),
                    *(const char**)(this + 4),
                    (const char*)(this + 16));
            }
            ++v11;
        }
        ++v12;
    }
    return sub_4690E0((_DWORD*)this);
}
// 520970: using guessed type int dword_520970;

//----- (0044B7A0) --------------------------------------------------------
int __thiscall sub_44B7A0(_DWORD* this)
{
    int v1; // eax
    int v3; // eax
    unsigned int v4; // ebp
    int j; // edi
    int v6; // ecx
    int v7; // eax
    int v8; // esi
    _DWORD* v9; // ecx
    int v11; // [esp+10h] [ebp-8h]
    unsigned int i; // [esp+14h] [ebp-4h]

    v1 = 0;
    for (i = 0; ; ++i)
    {
        v11 = v1;
        v3 = this[84];
        if (!v3 || i >= (this[85] - v3) / 40)
            break;
        v4 = 0;
        for (j = 0; ; j += 268)
        {
            v6 = this[84];
            v7 = *(_DWORD*)(v6 + v11 + 28);
            v8 = v6 + v11;
            if (!v7 || v4 >= (*(_DWORD*)(v8 + 32) - v7) / 268)
                break;
            v9 = *(_DWORD**)(*(_DWORD*)(v8 + 28) + j + 264);
            if (v9)
            {
                sub_41D700(v9);
                *(_DWORD*)(*(_DWORD*)(this[84] + v11 + 28) + j + 264) = 0;
            }
            ++v4;
        }
        v1 = v11 + 40;
    }
    return sub_469120(this);
}

//----- (0044B870) --------------------------------------------------------
float* __thiscall sub_44B870(float* this, char* a2)
{
    char* v2; // esi
    double v4; // st7
    unsigned int v5; // edi
    unsigned int v6; // edx
    int v7; // eax
    int v8; // eax
    int v9; // ebx
    int v10; // eax
    int v11; // eax
    int v12; // esi
    int v13; // eax
    int v14; // edi
    int v15; // ecx
    unsigned int v16; // edx
    int v17; // edx
    int v18; // eax
    double v19; // st7
    int v20; // edi
    int v21; // eax
    int v22; // eax
    int v23; // ecx
    int v24; // eax
    int v25; // esi
    unsigned int v26; // edi
    unsigned int v27; // edx
    int v28; // edx
    int v29; // ecx
    int v30; // edx
    int v31; // edx
    double v32; // st7
    double v33; // st7
    int v34; // ecx
    int v35; // eax
    int v36; // edi
    int v37; // eax
    int v38; // eax
    int v39; // edi
    int v40; // eax
    int v41; // edx
    unsigned int v43; // [esp+10h] [ebp-274h]
    unsigned int v44; // [esp+10h] [ebp-274h]
    int v45; // [esp+10h] [ebp-274h]
    unsigned int v46; // [esp+10h] [ebp-274h]
    char v47; // [esp+17h] [ebp-26Dh]
    int v48; // [esp+18h] [ebp-26Ch] BYREF
    float v49; // [esp+1Ch] [ebp-268h]
    int v50; // [esp+20h] [ebp-264h] BYREF
    unsigned int v51; // [esp+24h] [ebp-260h]
    int v52; // [esp+28h] [ebp-25Ch] BYREF
    __int64 v53; // [esp+2Ch] [ebp-258h]
    float* v54; // [esp+34h] [ebp-250h]
    _DWORD v55[6]; // [esp+38h] [ebp-24Ch] BYREF
    LPVOID v56[4]; // [esp+50h] [ebp-234h] BYREF
    _BYTE v57[268]; // [esp+60h] [ebp-224h] BYREF
    _BYTE v58[268]; // [esp+16Ch] [ebp-118h] BYREF
    int v59; // [esp+280h] [ebp-4h]

    v2 = a2;
    v54 = this;
    sub_468FF0(this, a2);
    v59 = 0;
    *((_BYTE*)this + 332) = v47;
    this[84] = 0.0;
    this[85] = 0.0;
    this[86] = 0.0;
    LOBYTE(v59) = 1;
    *(_DWORD*)this = &off_499A74;
    *((_BYTE*)this + 292) = 1;
    if (sub_40ABC0(a2, aAlwaysloaded, 0))
        sub_40B130(a2, aAlwaysloaded, (_BYTE*)this + 292);
    *((_BYTE*)this + 293) = 0;
    if (sub_40ABC0(a2, aStreaming, 0))
        sub_40B130(a2, aStreaming, (_BYTE*)this + 293);
    *((_BYTE*)this + 294) = 0;
    if (sub_40ABC0(a2, aLooping, 0))
        sub_40B130(a2, aLooping, (_BYTE*)this + 294);
    this[74] = 0.30000001;
    if (sub_40ABC0(a2, aFadepercent, 0))
        sub_40AF60(a2, aFadepercent, this + 74);
    *((_BYTE*)this + 300) = 0;
    if (sub_40ABC0(a2, aDontduplicate, 0))
        sub_40B130(a2, aDontduplicate, (_BYTE*)this + 300);
    *((_BYTE*)this + 301) = 0;
    *((_BYTE*)this + 330) = 0;
    if (sub_40ABC0(a2, aEngine, 0))
        sub_40B130(a2, aEngine, (_BYTE*)this + 301);
    if (*((_BYTE*)this + 301))
    {
        this[78] = 1.0;
        this[79] = 1.0;
        this[80] = 1.0;
        this[81] = 1.0;
        *((_BYTE*)this + 294) = 1;
        *((_BYTE*)this + 330) = 1;
        this[76] = 0.0;
        this[77] = 0.0;
        if (sub_40ABC0(a2, aEnginefade, 0))
        {
            sub_40B1B0(a2, aEnginefade, (float*)&v48);
            v4 = v49;
            if (*(float*)&v48 >= (double)v49)
            {
                this[79] = *(float*)&v48;
                this[78] = v4;
            }
            else
            {
                this[76] = *(float*)&v48;
                this[77] = v4;
            }
        }
        if (sub_40ABC0(a2, aEnginepitch, 0))
            sub_40B1D0(a2, aEnginepitch, this + 80, this + 81);
    }
    if (sub_40ABC0(a2, aDoppler_0, 0))
        sub_40B130(a2, aDoppler_0, (_BYTE*)this + 330);
    *((_BYTE*)this + 328) = 0;
    if (sub_40ABC0(a2, aBomb, 0))
        sub_40B130(a2, aBomb, (_BYTE*)this + 328);
    *((_BYTE*)this + 329) = *((_BYTE*)this + 294);
    if (sub_40ABC0(a2, aDiewithpe, 0))
        sub_40B130(a2, aDiewithpe, (_BYTE*)this + 329);
    if (sub_40AE00(a2, aRange) <= 1)
        v5 = 1;
    else
        v5 = sub_40AE00(a2, aRange);
    v6 = 0;
    LOBYTE(v56[0]) = v47;
    memset(&v56[1], 0, 12);
    v7 = *((_DWORD*)this + 84);
    LOBYTE(v59) = 2;
    if (v7)
        v6 = (*((_DWORD*)this + 85) - v7) / 40;
    if (v6 >= v5)
    {
        if (v5 < sub_44E980((_DWORD*)this + 83))
            sub_44F0E0((_DWORD*)this + 83, (_DWORD*)(*((_DWORD*)this + 84) + 40 * v5), *((_DWORD**)this + 85));
    }
    else
    {
        v48 = *((int*)this + 85);
        v8 = sub_44E980((_DWORD*)this + 83);
        sub_44ED60((_DWORD*)this + 83, (char*)v48, v5 - v8, v55);
    }
    LOBYTE(v59) = 1;
    sub_44E9B0(v56);
    v9 = 0;
    v51 = 0;
    while (1)
    {
        v10 = *((_DWORD*)this + 84);
        if (!v10 || v51 >= (*((_DWORD*)this + 85) - v10) / 40)
            break;
        *(_DWORD*)(v9 + *((_DWORD*)this + 84)) = 1133903872;
        *(_DWORD*)(v9 + *((_DWORD*)this + 84) + 4) = 1189765120;
        if (sub_40ABC0(v2, aRange, 0))
            sub_40B1B0(v2, aRange, (float*)(*((_DWORD*)this + 84) + v9));
        *(_DWORD*)(v9 + *((_DWORD*)this + 84) + 8) = 0;
        *(_DWORD*)(v9 + *((_DWORD*)this + 84) + 12) = 1065353216;
        if (sub_40ABC0(v2, aVolume_0, 0))
            sub_40B1B0(v2, aVolume_0, (float*)(v9 + *((_DWORD*)this + 84) + 8));
        *(_DWORD*)(v9 + *((_DWORD*)this + 84) + 16) = 1065353216;
        *(_DWORD*)(v9 + *((_DWORD*)this + 84) + 20) = 1065353216;
        if (sub_40ABC0(v2, aPitch, 0))
            sub_40B1B0(v2, aPitch, (float*)(v9 + *((_DWORD*)this + 84) + 16));
        if (sub_422BA0(AppName, aLoadsounds, 1))
        {
            if (!sub_40ACC0(v2, aSound, aRange) || !sub_40AD80(v2, aSound))
            {
                if (sub_40ACC0(v2, aSound, aRange))
                {
                    do
                    {
                        sub_40AFC0(v2, aSound, &v50);
                        v22 = *((_DWORD*)this + 84);
                        v23 = v9 + v22 + 24;
                        v24 = *(_DWORD*)(v9 + v22 + 28);
                        if (v24)
                            v45 = (*(_DWORD*)(v23 + 8) - v24) / 268;
                        else
                            v45 = 0;
                        v25 = *(_DWORD*)(v23 + 4);
                        v26 = v45 + 1;
                        if (v25)
                            v27 = (*(_DWORD*)(v23 + 8) - v25) / 268;
                        else
                            v27 = 0;
                        if (v27 >= v26)
                        {
                            if (v25 && v26 < (*(_DWORD*)(v23 + 8) - v25) / 268)
                                sub_44ED10((_DWORD*)v23, (char*)(v25 + 268 * v26), *(char**)(v23 + 8));
                        }
                        else
                        {
                            if (v25)
                                v28 = (*(_DWORD*)(v23 + 8) - v25) / 268;
                            else
                                v28 = 0;
                            sub_44E9E0((_DWORD*)v23, *(char**)(v23 + 8), v26 - v28, v58);
                        }
                        *(_DWORD*)(*(_DWORD*)(v9 + *((_DWORD*)this + 84) + 28) + 268 * v45) = 0;
                        v48 = *(_DWORD*)(v9 + *((_DWORD*)this + 84) + 28) + 268 * v45 + 4;
                        strcpy((char*)v48, (const char*)v50);
                        *(_DWORD*)(*(_DWORD*)(v9 + *((_DWORD*)this + 84) + 28) + 268 * v45 + 264) = 0;
                        v2 = a2;
                    } while (sub_40ACC0(a2, aSound, aRange));
                }
                v29 = *((_DWORD*)this + 84);
                v30 = *(_DWORD*)(v9 + v29 + 28);
                if (v30)
                    v31 = (*(_DWORD*)(v9 + v29 + 32) - v30) / 268;
                else
                    v31 = 0;
                v53 = (unsigned int)v31;
                v32 = (double)(unsigned int)v31;
                if (v32 == 0.0)
                    v33 = 0.0;
                else
                    v33 = 1.0 / v32;
                v46 = 0;
                *(float*)&v48 = 0.0;
                while (1)
                {
                    v34 = *((_DWORD*)this + 84);
                    v35 = *(_DWORD*)(v9 + v34 + 28);
                    v36 = v9 + v34;
                    if (!v35 || v46 >= (*(_DWORD*)(v36 + 32) - v35) / 268)
                        break;
                    v37 = v48;
                    *(float*)(*(_DWORD*)(v36 + 28) + v48) = v33;
                    ++v46;
                    v48 = v37 + 268;
                }
                goto LABEL_93;
            }
            if (sub_40ACC0(v2, aSound, aRange))
            {
                do
                {
                    sub_40B420(v2, aSound, (float*)&v52, (const char**)&v50);
                    v11 = *((_DWORD*)this + 84);
                    v12 = v9 + v11 + 24;
                    v13 = *(_DWORD*)(v9 + v11 + 28);
                    if (v13)
                        v14 = (*(_DWORD*)(v12 + 8) - v13) / 268;
                    else
                        v14 = 0;
                    v15 = *(_DWORD*)(v12 + 4);
                    v43 = v14 + 1;
                    if (v15)
                        v16 = (*(_DWORD*)(v12 + 8) - v15) / 268;
                    else
                        v16 = 0;
                    if (v16 >= v43)
                    {
                        if (v43 < sub_44E910((_DWORD*)v12))
                            sub_44ED10((_DWORD*)v12, (char*)(*(_DWORD*)(v12 + 4) + 268 * v43), *(char**)(v12 + 8));
                    }
                    else
                    {
                        if (v15)
                            v17 = (*(_DWORD*)(v12 + 8) - v15) / 268;
                        else
                            v17 = 0;
                        sub_44E9E0((_DWORD*)v12, *(char**)(v12 + 8), v43 - v17, v57);
                    }
                    *(float*)(*(_DWORD*)(v9 + *((_DWORD*)this + 84) + 28) + 268 * v14) = *(float*)&v52 * 0.0099999998;
                    v48 = *(_DWORD*)(v9 + *((_DWORD*)this + 84) + 28) + 268 * v14 + 4;
                    strcpy((char*)v48, (const char*)v50);
                    *(_DWORD*)(*(_DWORD*)(v9 + *((_DWORD*)this + 84) + 28) + 268 * v14 + 264) = 0;
                    v2 = a2;
                } while (sub_40ACC0(a2, aSound, aRange));
            }
            v18 = 0;
            v19 = 0.0;
            v44 = 0;
            v20 = v9 + *((_DWORD*)this + 84);
            while (1)
            {
                v48 = v18;
                v21 = *(_DWORD*)(v20 + 28);
                if (!v21 || v44 >= (*(_DWORD*)(v20 + 32) - v21) / 268)
                    break;
                v19 = v19 + *(float*)(*(_DWORD*)(v20 + 28) + v48);
                v18 = v48 + 268;
                ++v44;
            }
            sub_40A120(v19 <= 1.0, aPercentsForThe, *((_DWORD*)this + 1), v2 + 16);
            v9 += 40;
            ++v51;
        }
        else
        {
        LABEL_93:
            v9 += 40;
            ++v51;
        }
    }
    if (*((_BYTE*)this + 301))
    {
        v38 = *((_DWORD*)this + 84);
        if (v38)
            v39 = (*((_DWORD*)this + 85) - v38) / 40;
        else
            v39 = 0;
        v40 = *((_DWORD*)this + 84);
        if (v40)
            v41 = (*((_DWORD*)this + 85) - v40) / 40;
        else
            v41 = 0;
        sub_40A120(
            v41 == 1,
            "engine sounds must have only one set of sounds (you have %d sound ranges), see %s : %s",
            v39,
            *((const char**)this + 1),
            v2 + 16);
    }
    return this;
}
// 44B8AF: variable 'v47' is possibly undefined
// 499A74: using guessed type _UNKNOWN *off_499A74;

//----- (0044C220) --------------------------------------------------------
int __thiscall sub_44C220(int this)
{
    int result; // eax

    sub_4885A6(*(LPVOID*)(this + 28));
    result = 0;
    *(_DWORD*)(this + 28) = 0;
    *(_DWORD*)(this + 32) = 0;
    *(_DWORD*)(this + 36) = 0;
    return result;
}

//----- (0044C250) --------------------------------------------------------
int __thiscall sub_44C250(_DWORD* this)
{
    _DWORD* v1; // esi
    int v2; // ebp
    LPVOID* v3; // ebp
    char* v4; // ebx
    char* v5; // edi
    char** v6; // esi
    int v8; // [esp+Ch] [ebp-18h]
    int v9; // [esp+10h] [ebp-14h]

    v1 = this;
    *this = &off_499A74;
    v2 = this[84];
    v9 = this[85];
    v8 = v2;
    if (v2 != v9)
    {
        v3 = (LPVOID*)(v2 + 28);
        do
        {
            v4 = (char*)v3[1];
            v5 = (char*)*v3;
            v6 = (char**)(v3 - 1);
            if (*v3 != v4)
            {
                do
                {
                    nullsub_4((int)v5);
                    v5 += 268;
                } while (v5 != v4);
            }
            sub_4885A6(*v3);
            *v3 = 0;
            v6[2] = 0;
            v6[3] = 0;
            v3 += 10;
            v8 += 40;
        } while (v8 != v9);
        v1 = this;
    }
    sub_4885A6((LPVOID)v1[84]);
    v1[84] = 0;
    v1[85] = 0;
    v1[86] = 0;
    return sub_4690A0(v1);
}
// 499A74: using guessed type _UNKNOWN *off_499A74;

//----- (0044C330) --------------------------------------------------------
float* __thiscall sub_44C330(float* this, char* a2)
{
    char* v2; // edi

    v2 = a2;
    sub_468FF0(this, a2);
    *(_DWORD*)this = &off_499A80;
    sub_40AFC0(v2, aBubblysoundeff, &a2);
    sub_469160((int)this, (_DWORD*)this + 73, a2, aSoundEffect);
    sub_40B1B0(v2, aFadepercent, this + 74);
    if (this[74] > 1.0)
        this[74] = this[74] * 0.0099999998;
    if (this[75] > 1.0)
        this[75] = this[75] * 0.0099999998;
    sub_40AFC0(v2, aCreaksoundeffe, &a2);
    sub_469160((int)this, (_DWORD*)this + 76, a2, aSoundEffect);
    sub_40B1B0(v2, aCreakfreq, this + 77);
    return this;
}
// 499A80: using guessed type _UNKNOWN *off_499A80;

//----- (0044C460) --------------------------------------------------------
int __thiscall sub_44C460(void* this)
{
    *(_DWORD*)this = &off_499A80;
    return sub_4690A0(this);
}
// 499A80: using guessed type _UNKNOWN *off_499A80;

//----- (0044C470) --------------------------------------------------------
_DWORD* __thiscall sub_44C470(_DWORD* this, char* a2)
{
    char* v2; // ebp

    v2 = a2;
    sub_468FF0(this, a2);
    *this = &off_499A8C;
    sub_40AFC0(v2, aLoopingdaysoun, &a2);
    strcpy((char*)this + 292, a2);
    sub_40AFC0(v2, aLoopingnightso, &a2);
    strcpy((char*)this + 552, a2);
    sub_40AFC0(v2, aWavesoundeffec, &a2);
    sub_469160((int)this, this + 203, a2, aSoundEffect);
    sub_40B1B0(v2, aSeagullrange, (float*)this + 204);
    sub_40B1B0(v2, aSeagullfreq, (float*)this + 206);
    sub_40AFC0(v2, aSeagullsoundef, &a2);
    sub_469160((int)this, this + 208, a2, aSoundEffect);
    sub_40B1B0(v2, aWindfreq, (float*)this + 209);
    sub_40AFC0(v2, aWindsoundeffec, &a2);
    sub_469160((int)this, this + 211, a2, aSoundEffect);
    return this;
}
// 499A8C: using guessed type _UNKNOWN *off_499A8C;

//----- (0044C610) --------------------------------------------------------
int __thiscall sub_44C610(void* this)
{
    *(_DWORD*)this = &off_499A8C;
    return sub_4690A0(this);
}
// 499A8C: using guessed type _UNKNOWN *off_499A8C;

//----- (0044C620) --------------------------------------------------------
float* __thiscall sub_44C620(float* this, char* String1)
{
    char* v2; // edi

    v2 = String1;
    sub_468FF0(this, String1);
    *(_DWORD*)this = &off_499A98;
    sub_40B1B0(v2, aStartsize, this + 73);
    sub_40B1B0(v2, aExpandrate, this + 75);
    sub_40B1B0(v2, aLifetime, this + 77);
    sub_40B1B0(v2, aFadetime, this + 79);
    sub_40AFC0(v2, aTexturefile, &String1);
    *((_DWORD*)this + 81) = sub_422400(*(_DWORD**)(dword_520970 + 124), String1, 0);
    return this;
}
// 499A98: using guessed type _UNKNOWN *off_499A98;
// 520970: using guessed type int dword_520970;

//----- (0044C710) --------------------------------------------------------
int __thiscall sub_44C710(void* this)
{
    *(_DWORD*)this = &off_499A98;
    return sub_4690A0(this);
}
// 499A98: using guessed type _UNKNOWN *off_499A98;

//----- (0044C720) --------------------------------------------------------
_DWORD* __thiscall sub_44C720(_DWORD* this, char* a2)
{
    char* v2; // ebp
    unsigned int v4; // ebx
    unsigned int v5; // eax
    int v6; // ecx
    unsigned int v7; // edx
    int v8; // edx
    int v9; // eax
    _DWORD v11[2]; // [esp+10h] [ebp-24h] BYREF
    _BYTE v12[4]; // [esp+18h] [ebp-1Ch] BYREF
    _BYTE* v13; // [esp+1Ch] [ebp-18h]
    char* v14; // [esp+20h] [ebp-14h]
    int v15; // [esp+24h] [ebp-10h]
    int v16; // [esp+30h] [ebp-4h]

    v2 = a2;
    v11[1] = this;
    sub_468FF0(this, a2);
    v16 = 0;
    *((_BYTE*)this + 296) = (_BYTE)a2;
    this[75] = 0;
    this[76] = 0;
    this[77] = 0;
    LOBYTE(v16) = 1;
    *this = &off_499AA4;
    this[73] = 0;
    if (sub_40ABC0(v2, aParticleeffect, 0))
    {
        sub_40AFC0(v2, aParticleeffect, &a2);
        sub_469160((int)this, this + 73, a2, aParticleEffect);
    }
    v4 = 0;
    v12[0] = (_BYTE)a2;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    LOBYTE(v16) = 2;
    while (sub_40ABC0(v2, aSoundeffect, 0))
    {
        sub_40AFC0(v2, aSoundeffect, &a2);
        sub_44F190((int)v12, v14, 1u, &a2);
    }
    v11[0] = 0;
    if (v13)
        v5 = (v14 - v13) >> 2;
    else
        v5 = 0;
    v6 = this[75];
    if (v6)
        v7 = (this[76] - v6) >> 2;
    else
        v7 = 0;
    if (v7 >= v5)
    {
        if (v6)
        {
            if (v5 < (this[76] - v6) >> 2)
                sub_448300(this + 74, (_DWORD*)(v6 + 4 * v5), (int*)this[76]);
            v4 = 0;
        }
    }
    else
    {
        if (v6)
            v8 = (this[76] - v6) >> 2;
        else
            v8 = 0;
        sub_44F190((int)(this + 74), (_DWORD*)this[76], v5 - v8, v11);
    }
    while (1)
    {
        v9 = this[75];
        if (!v9 || v4 >= (this[76] - v9) >> 2)
            break;
        sub_469160((int)this, (_DWORD*)(4 * v4 + this[75]), *(const char**)&v13[4 * v4], aSoundEffect);
        ++v4;
    }
    this[78] = 0;
    if (sub_40ABC0(v2, aChunkexplosion, 0))
    {
        sub_40AFC0(v2, aChunkexplosion, &a2);
        sub_469160((int)this, this + 78, a2, aChunkExplosion);
    }
    this[79] = 0;
    if (sub_40ABC0(v2, aRippleeffect, 0))
    {
        sub_40AFC0(v2, aRippleeffect, &a2);
        sub_469160((int)this, this + 79, a2, aRippleEffect);
    }
    sub_4885A6(v13);
    return this;
}
// 499AA4: using guessed type _UNKNOWN *off_499AA4;

//----- (0044C990) --------------------------------------------------------
int __thiscall sub_44C990(LPVOID* this)
{
    *this = &off_499AA4;
    sub_4885A6(this[75]);
    this[75] = 0;
    this[76] = 0;
    this[77] = 0;
    return sub_4690A0(this);
}
// 499AA4: using guessed type _UNKNOWN *off_499AA4;

//----- (0044C9D0) --------------------------------------------------------
_DWORD* __thiscall sub_44C9D0(_DWORD* this)
{
    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
    *((_BYTE*)this + 16) = 1;
    *this = &off_499040;
    sub_41C6A0(this + 7497);
    sub_41C6A0(this + 7584);
    *this = &off_499AB0;
    this[5] = 1;
    return this;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 499AB0: using guessed type int (__stdcall *off_499AB0)(char);

//----- (0044CA40) --------------------------------------------------------
_DWORD* __thiscall sub_44CA40(_DWORD* this, char a2)
{
    sub_44CA60(this);
    if ((a2 & 1) != 0)
        sub_4885A6(this);
    return this;
}

//----- (0044CA60) --------------------------------------------------------
FILE* __thiscall sub_44CA60(_DWORD* this)
{
    int v2; // eax
    int v3; // eax
    FILE* result; // eax

    *this = &off_499AB0;
    v2 = this[7494];
    if (v2)
    {
        (*(void(__stdcall**)(int))(*(_DWORD*)v2 + 8))(v2);
        this[7494] = 0;
    }
    v3 = this[7495];
    if (v3)
    {
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)v3 + 8))(this[7495]);
        this[7495] = 0;
    }
    if (this[7496])
    {
        sub_41CF50((int)(this + 7497));
        sub_41CF50((int)(this + 7584));
    }
    sub_41C700((int)(this + 7584));
    result = sub_41C700((int)(this + 7497));
    *this = &off_499040;
    return result;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 499AB0: using guessed type int (__stdcall *off_499AB0)(char);

//----- (0044CB20) --------------------------------------------------------
char __thiscall sub_44CB20(int this)
{
    INT v2; // eax
    int v3; // ecx
    _DWORD* v4; // eax
    _BYTE* v5; // eax
    int v6; // ecx
    _BYTE* v7; // eax
    int v8; // ecx
    _DWORD* v9; // edi
    int v10; // ebp
    int v11; // ecx
    int v12; // edi
    int v13; // eax
    int v14; // eax
    long double v15; // st7
    int v16; // eax
    char result; // al
    _WORD* v18; // [esp+44h] [ebp-Ch] BYREF
    float v19; // [esp+48h] [ebp-8h]
    int v20; // [esp+4Ch] [ebp-4h]

    v2 = sub_422BA0(AppName, aGore, 1);
    v3 = 128;
    byte_4AC684 = v2 != 0;
    v4 = (_DWORD*)(this + 24);
    do
    {
        *v4 = 0;
        v4 += 53;
        --v3;
    } while (v3);
    v5 = (_BYTE*)(this + 27160);
    v6 = 16;
    do
    {
        *v5 = 0;
        v5 += 16;
        --v6;
    } while (v6);
    v7 = (_BYTE*)(this + 27416);
    v8 = 64;
    do
    {
        *v7 = 0;
        v7 += 40;
        --v8;
    } while (v8);
    v9 = (_DWORD*)(this + 29980);
    if (!(*(int(__stdcall**)(_DWORD, int, int, int, int, int))(**(_DWORD**)ArgList + 96))(
        *(_DWORD*)ArgList,
        12,
        8,
        101,
        1,
        this + 29980))
        (*(void(__stdcall**)(_DWORD, int, int, int, int, int))(**(_DWORD**)ArgList + 92))(
            *(_DWORD*)ArgList,
            96,
            8,
            322,
            1,
            this + 29976);
    v10 = 0;
    (*(void(__stdcall**)(_DWORD, _DWORD, int, _WORD**, _DWORD))(*(_DWORD*)*v9 + 44))(*v9, 0, 8, &v18, 0);
    *v18 = 0;
    v18[1] = 1;
    v18[2] = 3;
    v18[3] = 1;
    v18[4] = 2;
    v18[5] = 3;
    (*(void(__stdcall**)(_DWORD))(*(_DWORD*)*v9 + 48))(*v9);
    *(_DWORD*)(this + 29984) = 0;
    v11 = *(_DWORD*)(dword_520970 + 200);
    if (*(int*)(v11 + 24) > 0)
    {
        do
        {
            v12 = *(_DWORD*)(*(_DWORD*)(v11 + 20) + 4 * v10);
            if (sub_4696E0(v12, aAmbientSounds))
            {
                v13 = *(_DWORD*)(this + 29984);
                if (v13)
                    sub_40A120(
                        0,
                        "more than one [Ambient Sounds] found, there may be only one, see %s and %s",
                        (const char*)(v13 + 16),
                        (const char*)(v12 + 16));
                *(_DWORD*)(this + 29984) = v12;
            }
            ++v10;
            v11 = *(_DWORD*)(dword_520970 + 200);
        } while (v10 < *(_DWORD*)(v11 + 24));
    }
    v14 = *(_DWORD*)(this + 29984);
    if (v14)
    {
        sub_41C760(this + 29988, (const char*)(v14 + 292));
        sub_41C7A0(this + 29988, 1);
        *(_BYTE*)(this + 29988) = 1;
        sub_41CA40(this + 29988);
        sub_41CF50(this + 29988);
        sub_41C760(this + 30336, (const char*)(*(_DWORD*)(this + 29984) + 552));
        sub_41C7A0(this + 30336, 1);
        *(_BYTE*)(this + 30336) = 1;
        sub_41CA40(this + 30336);
        sub_41CF50(this + 30336);
        v19 = *(float*)(*(_DWORD*)(this + 29984) + 828);
        if (0.0 == v19)
        {
            v15 = 0.0;
        }
        else
        {
            v20 = rand();
            v15 = fabs((double)v20 * 0.000030518509) * v19;
        }
        v16 = *(_DWORD*)(this + 29984);
        *(float*)(this + 30684) = v15;
        v19 = *(float*)(v16 + 840);
        if (0.0 == v19)
        {
            result = 1;
            *(float*)(this + 30688) = 0.0;
            return result;
        }
        v20 = rand();
        *(float*)(this + 30688) = fabs((double)v20 * 0.000030518509) * v19;
    }
    return 1;
}
// 4AC684: using guessed type char byte_4AC684;
// 520970: using guessed type int dword_520970;

//----- (0044CD90) --------------------------------------------------------
_DWORD* __thiscall sub_44CD90(_DWORD* this, float* a2)
{
    _DWORD* result; // eax

    result = (_DWORD*)this[7496];
    if (result)
    {
        if (*(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 100) == 6)
            return sub_44DAD0((int*)result[203], a2, 0, 0);
    }
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (0044CDD0) --------------------------------------------------------
char __userpurge sub_44CDD0@<al>(int a1@<ecx>, int a2@<ebp>, int a3)
{
    bool v4; // zf
    char v5; // al
    double v6; // st7
    int v7; // eax
    long double v8; // st7
    float* v9; // eax
    double v10; // st7
    int v11; // eax
    long double v12; // st7
    double v13; // st7
    float* v14; // eax
    int v15; // ecx
    long double v16; // st7
    int* v17; // ebp
    unsigned int i; // edx
    int v19; // ecx
    int v20; // eax
    int* v21; // esi
    int v22; // edi
    _DWORD* v23; // eax
    bool v24; // cc
    float* v25; // esi
    int v26; // edi
    double v27; // st7
    double v28; // st7
    int v29; // eax
    long double v30; // st7
    int v31; // esi
    int v32; // edi
    double v33; // st7
    float v35; // [esp+0h] [ebp-70h]
    char v36; // [esp+13h] [ebp-5Dh]
    float v37; // [esp+14h] [ebp-5Ch]
    int v38; // [esp+14h] [ebp-5Ch]
    float v39; // [esp+14h] [ebp-5Ch]
    int v40; // [esp+18h] [ebp-58h]
    int v41; // [esp+18h] [ebp-58h]
    int v42; // [esp+18h] [ebp-58h]
    int v43; // [esp+18h] [ebp-58h]
    float v44; // [esp+18h] [ebp-58h]
    float v45; // [esp+1Ch] [ebp-54h]
    float v46; // [esp+20h] [ebp-50h]
    float v47; // [esp+24h] [ebp-4Ch] BYREF
    float v48; // [esp+28h] [ebp-48h]
    float v49; // [esp+2Ch] [ebp-44h]
    int v50[16]; // [esp+30h] [ebp-40h] BYREF

    if (*(_DWORD*)(a1 + 29984))
    {
        if (*(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 100) == 6)
        {
            v4 = !sub_4647E0(*(_DWORD**)(dword_520970 + 252));
            v5 = *(_BYTE*)(a1 + 29989);
            if (v4)
            {
                if (v5)
                    sub_41CF50(a1 + 29988);
                if (!*(_BYTE*)(a1 + 30337))
                    sub_41CD90(a1 + 30336);
                sub_41D0C0(a1 + 30336, a2, *(float*)&a3);
            }
            else
            {
                if (!v5)
                    sub_41CD90(a1 + 29988);
                if (*(_BYTE*)(a1 + 30337))
                    sub_41CF50(a1 + 30336);
                sub_41D0C0(a1 + 29988, a2, *(float*)&a3);
                v6 = *(float*)(a1 + 30684) - *(float*)&a3;
                *(float*)(a1 + 30684) = v6;
                if (v6 <= 0.0)
                {
                    v7 = *(_DWORD*)(a1 + 29984);
                    v37 = *(float*)(v7 + 816);
                    v40 = *(int*)(v7 + 820);
                    if (v37 == *(float*)&v40)
                        v8 = v37;
                    else
                        v8 = fabs((double)rand() * 0.000030518509) * (*(float*)&v40 - v37) + v37;
                    v48 = v8;
                    v47 = 0.0;
                    v49 = 0.0;
                    v35 = fabs((double)rand() * 0.000030518509) * 6.2831855;
                    sub_401000(&v47, v35);
                    v9 = (float*)(*(_DWORD*)(dword_520970 + 120) + 56);
                    v47 = v47 + *v9;
                    v48 = v48 + v9[1];
                    v10 = v49 + v9[2];
                    v11 = *(_DWORD*)(a1 + 29984);
                    v49 = v10;
                    sub_44DAD0(*(int**)(v11 + 832), &v47, 0, 0);
                    v41 = *(int*)(*(_DWORD*)(a1 + 29984) + 828);
                    if (0.0 == *(float*)&v41)
                        v12 = 0.0;
                    else
                        v12 = fabs((double)rand() * 0.000030518509) * *(float*)&v41;
                    *(float*)(a1 + 30684) = v12;
                }
            }
            v13 = *(float*)(a1 + 30688) - *(float*)&a3;
            *(float*)(a1 + 30688) = v13;
            if (v13 <= 0.0)
            {
                v47 = 0.0;
                v48 = 0.0;
                v49 = 0.0;
                v14 = (float*)(*(_DWORD*)(dword_520970 + 120) + 56);
                v47 = *v14;
                v48 = v14[1];
                v15 = *(_DWORD*)(a1 + 29984);
                v49 = v14[2];
                sub_44DAD0(*(int**)(v15 + 844), &v47, 0, 0);
                v42 = *(int*)(*(_DWORD*)(a1 + 29984) + 840);
                if (0.0 == *(float*)&v42)
                    v16 = 0.0;
                else
                    v16 = fabs((double)rand() * 0.000030518509) * *(float*)&v42;
                *(float*)(a1 + 30688) = v16;
            }
        }
        else
        {
            if (*(_BYTE*)(a1 + 30337))
                sub_41CF50(a1 + 30336);
            if (*(_BYTE*)(a1 + 29989))
                sub_41CF50(a1 + 29988);
        }
    }
    v38 = 0;
    v43 = 8;
    v17 = (int*)(a1 + 228);
    do
    {
        if (!*(v17 - 51))
            goto LABEL_56;
        if (*((_BYTE*)v17 - 4))
        {
            if ((sub_407690(*v17, v17[1], v50), !sub_407350((_DWORD*)*v17, v17[1])) && !sub_408660((_DWORD*)*v17, v17[1])
                || !*(_BYTE*)(*v17 + 16))
            {
                sub_44E7D0((_DWORD*)a1, v38);
                goto LABEL_56;
            }
        }
        v36 = 0;
        if (*(_DWORD*)(*(v17 - 50) + 292))
        {
            for (i = 0; ; ++i)
            {
                while (1)
                {
                    v19 = *(_DWORD*)(*(_DWORD*)(*(v17 - 50) + 292) + 296);
                    if (!v19 || i >= (*(_DWORD*)(*(_DWORD*)(*(v17 - 50) + 292) + 300) - v19) >> 2)
                        goto LABEL_47;
                    v20 = *(_DWORD*)(a1 + 4 * (i + v43));
                    if (v20)
                        break;
                LABEL_46:
                    ++i;
                }
                if (!*(_BYTE*)(v20 + 112))
                {
                    v36 = 1;
                    if (*((_BYTE*)v17 - 4))
                        qmemcpy((void*)(v20 + 116), v50, 0x40u);
                    goto LABEL_46;
                }
                *(_DWORD*)(a1 + 4 * (i + v43)) = 0;
            }
        }
    LABEL_47:
        v21 = v17 - 17;
        v22 = 16;
        do
        {
            if (*v21)
            {
                if (*(_BYTE*)(*v21 + 53))
                {
                    *v21 = 0;
                }
                else
                {
                    v36 = 1;
                    if (*((_BYTE*)v17 - 4))
                    {
                        v47 = 0.0;
                        v48 = 0.0;
                        v49 = 0.0;
                        v23 = (_DWORD*)sub_4010C0((int)v50);
                        sub_41D960((_DWORD*)*v21, v23, &v47);
                    }
                }
            }
            ++v21;
            --v22;
        } while (v22);
        if (!v36)
            *(v17 - 51) = 0;
    LABEL_56:
        v17 += 53;
        v24 = v43 + 53 < 6792;
        ++v38;
        v43 += 53;
    } while (v24);
    v25 = (float*)(a1 + 27168);
    v26 = 16;
    do
    {
        if (*((_BYTE*)v25 - 8))
        {
            if (*(_BYTE*)(*(_DWORD*)v25 + 53))
            {
                *((_BYTE*)v25 - 8) = 0;
            }
            else
            {
                v27 = v25[1] - *(float*)&a3;
                v25[1] = v27;
                if (v27 <= 0.0)
                {
                    v28 = *(float*)(*(_DWORD*)v25 + 132) - *(float*)(*(_DWORD*)v25 + 20);
                    v44 = *(float*)(*(_DWORD*)v25 + 136);
                    v45 = v28;
                    if (v28 <= 0.0)
                        v45 = 0.0;
                    if (v44 <= 0.0)
                        v44 = 0.0;
                    sub_44DAD0(
                        *(int**)(*((_DWORD*)v25 - 1) + 304),
                        (float*)(*(_DWORD*)v25 + 28),
                        SLODWORD(v45),
                        SLODWORD(v44));
                    v29 = *((_DWORD*)v25 - 1);
                    v39 = *(float*)(v29 + 308);
                    v46 = *(float*)(v29 + 312);
                    if (v39 == v46)
                        v30 = v39;
                    else
                        v30 = fabs((double)rand() * 0.000030518509) * (v46 - v39) + v39;
                    v25[1] = v30;
                }
            }
        }
        v25 += 4;
        --v26;
    } while (v26);
    v31 = a1 + 27436;
    v32 = 64;
    do
    {
        if (*(_BYTE*)(v31 - 20))
        {
            *(float*)v31 = *(float*)&a3 * *(float*)(v31 + 4) + *(float*)v31;
            v33 = *(float*)(v31 + 8) - *(float*)&a3;
            *(float*)(v31 + 8) = v33;
            if (v33 <= 0.0)
            {
                *(_BYTE*)(v31 - 20) = 0;
                sub_409A00(dword_520970, *(void**)(v31 + 16));
                *(_DWORD*)(v31 + 16) = 0;
            }
        }
        v31 += 40;
        --v32;
    } while (v32);
    return sub_428620((_DWORD*)a1, a3);
}
// 520970: using guessed type int dword_520970;

//----- (0044D3B0) --------------------------------------------------------
int __thiscall sub_44D3B0(_DWORD* this, int a2)
{
    int result; // eax
    int v4; // esi
    float* v5; // eax
    double v6; // st7
    double v7; // st6
    double v8; // st7
    double v9; // st7
    double v10; // st7
    double v11; // st7
    int v12; // eax
    unsigned int v13; // ebx
    int v14; // eax
    int v15; // eax
    int v16; // eax
    int v17; // eax
    int v18; // [esp+14h] [ebp-50h] BYREF
    float v19; // [esp+18h] [ebp-4Ch] BYREF
    float v20; // [esp+1Ch] [ebp-48h]
    float v21; // [esp+20h] [ebp-44h]
    _DWORD v22[16]; // [esp+24h] [ebp-40h] BYREF

    result = sub_408F30((_DWORD*)dword_520970);
    if (result)
    {
        v4 = *(_DWORD*)(a2 + 40);
        v5 = (float*)sub_408F30((_DWORD*)dword_520970);
        v6 = v5[10] - *(float*)(v4 + 16);
        v7 = v5[9] - *(float*)(v4 + 12);
        v19 = v5[8] - *(float*)(v4 + 8);
        v20 = v7;
        v21 = v6;
        sub_46B970(&v19, &v19);
        v19 = v19 * 18.0;
        v20 = v20 * 18.0;
        v21 = v21 * 18.0;
        v8 = *(float*)(v4 + 32);
        if (v8 == 0.0)
            v9 = 0.0;
        else
            v9 = *(float*)(v4 + 28) / v8;
        if (v9 <= 1.0)
        {
            v11 = *(float*)(v4 + 32);
            if (v11 == 0.0)
                v10 = 0.0;
            else
                v10 = *(float*)(v4 + 28) / v11;
        }
        else
        {
            v10 = 1.0;
        }
        v12 = this[7494];
        v18 = 0;
        (*(void(__stdcall**)(int, _DWORD, int, int*, _DWORD))(*(_DWORD*)v12 + 44))(v12, 0, 96, &v18, 0);
        v13 = (unsigned int)(__int64)(v10 * 255.0) << 24;
        *(float*)v18 = *(float*)(v4 + 8) - *(float*)(v4 + 20);
        *(float*)(v18 + 4) = *(float*)(v4 + 12) + *(float*)(v4 + 20);
        *(_DWORD*)(v18 + 8) = 0;
        v14 = v18;
        *(float*)v18 = v19 + *(float*)v18;
        *(float*)(v14 + 4) = v20 + *(float*)(v14 + 4);
        *(float*)(v14 + 8) = v21 + *(float*)(v14 + 8);
        *(_DWORD*)(v18 + 12) = v13 | 0xFFFFFF;
        *(_DWORD*)(v18 + 16) = 0;
        *(_DWORD*)(v18 + 20) = 0;
        *(float*)(v18 + 24) = *(float*)(v4 + 20) + *(float*)(v4 + 8);
        *(float*)(v18 + 28) = *(float*)(v4 + 12) + *(float*)(v4 + 20);
        *(_DWORD*)(v18 + 32) = 0;
        v15 = v18 + 24;
        *(float*)(v18 + 24) = v19 + *(float*)(v18 + 24);
        *(float*)(v15 + 4) = v20 + *(float*)(v15 + 4);
        *(float*)(v15 + 8) = v21 + *(float*)(v15 + 8);
        *(_DWORD*)(v18 + 36) = v13 | 0xFFFFFF;
        *(_DWORD*)(v18 + 40) = 1065353216;
        *(_DWORD*)(v18 + 44) = 0;
        *(float*)(v18 + 48) = *(float*)(v4 + 20) + *(float*)(v4 + 8);
        *(float*)(v18 + 52) = *(float*)(v4 + 12) - *(float*)(v4 + 20);
        *(_DWORD*)(v18 + 56) = 0;
        v16 = v18 + 48;
        *(float*)(v18 + 48) = v19 + *(float*)(v18 + 48);
        *(float*)(v16 + 4) = v20 + *(float*)(v16 + 4);
        *(float*)(v16 + 8) = v21 + *(float*)(v16 + 8);
        *(_DWORD*)(v18 + 60) = v13 | 0xFFFFFF;
        *(_DWORD*)(v18 + 64) = 1065353216;
        *(_DWORD*)(v18 + 68) = 1065353216;
        *(float*)(v18 + 72) = *(float*)(v4 + 8) - *(float*)(v4 + 20);
        *(float*)(v18 + 76) = *(float*)(v4 + 12) - *(float*)(v4 + 20);
        *(_DWORD*)(v18 + 80) = 0;
        v17 = v18 + 72;
        *(float*)(v18 + 72) = v19 + *(float*)(v18 + 72);
        *(float*)(v17 + 4) = v20 + *(float*)(v17 + 4);
        *(float*)(v17 + 8) = v21 + *(float*)(v17 + 8);
        *(_DWORD*)(v18 + 84) = v13 | 0xFFFFFF;
        *(_DWORD*)(v18 + 88) = 0;
        *(_DWORD*)(v18 + 92) = 1065353216;
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)this[7494] + 48))(this[7494]);
        memset(&v22[11], 0, 16);
        memset(&v22[6], 0, 16);
        memset(&v22[1], 0, 16);
        v22[15] = 1065353216;
        v22[10] = 1065353216;
        v22[5] = 1065353216;
        v22[0] = 1065353216;
        (*(void(__stdcall**)(_DWORD, int, _DWORD*))(**(_DWORD**)ArgList + 148))(*(_DWORD*)ArgList, 256, v22);
        sub_41BEF0((_DWORD*)dword_520A50, 0, *(_DWORD*)(*(_DWORD*)(v4 + 4) + 324), 1, 0);
        sub_41BC00((_DWORD*)dword_520A50, 1, 1, 1, 1, 2, -1, 0);
        (*(void(__stdcall**)(_DWORD, int))(**(_DWORD**)ArgList + 304))(*(_DWORD*)ArgList, 322);
        (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD, int))(**(_DWORD**)ArgList + 332))(
            *(_DWORD*)ArgList,
            0,
            this[7494],
            24);
        (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD))(**(_DWORD**)ArgList + 340))(*(_DWORD*)ArgList, this[7495], 0);
        (*(void(__stdcall**)(_DWORD, int, _DWORD, int, _DWORD, int))(**(_DWORD**)ArgList + 284))(
            *(_DWORD*)ArgList,
            4,
            0,
            4,
            0,
            2);
        *(float*)dword_520A20 = *(float*)dword_520A20 + 1.0;
        return 2;
    }
    return result;
}
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);
// 520970: using guessed type int dword_520970;
// 520A20: using guessed type int dword_520A20;
// 520A50: using guessed type int dword_520A50;

//----- (0044D740) --------------------------------------------------------
int __thiscall sub_44D740(_DWORD* this)
{
    int result; // eax
    _DWORD* i; // ecx

    result = 0;
    for (i = this + 6; *i; i += 53)
    {
        if (++result >= 128)
            return -1;
    }
    return result;
}
// 44D761: conditional instruction was optimized away because eax.4<80

//----- (0044D770) --------------------------------------------------------
int __thiscall sub_44D770(_DWORD* this, int a2)
{
    int result; // eax
    _DWORD* i; // ecx

    if (!a2)
        return -1;
    result = 0;
    for (i = this + 6; a2 != *i; i += 53)
    {
        if (++result >= 128)
            return -1;
    }
    return result;
}
// 44D79A: conditional instruction was optimized away because eax.4<80

//----- (0044D7B0) --------------------------------------------------------
int __thiscall sub_44D7B0(_DWORD* this)
{
    int result; // eax

    result = this[5];
    this[5] = result + 1;
    return result;
}

//----- (0044D7C0) --------------------------------------------------------
int __stdcall sub_44D7C0(int a1, int* a2, _DWORD* a3)
{
    unsigned int i; // edi
    int result; // eax
    _DWORD* v5; // eax

    for (i = 0; ; ++i)
    {
        result = *(_DWORD*)(a1 + 296);
        if (!result || i >= (*(_DWORD*)(a1 + 300) - result) >> 2)
            break;
        if (a3)
            *a3 = 0;
        v5 = sub_413870(*(_DWORD**)(dword_520970 + 116), *(_DWORD*)(*(_DWORD*)(a1 + 296) + 4 * i));
        if (a3)
            *a3 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 296) + 4 * i) + 368);
        if (v5)
            sub_46BE02((int)(v5 + 29), *a2, a2[1], a2[2]);
    }
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (0044D850) --------------------------------------------------------
void __stdcall sub_44D850(int a1, float* a2, _DWORD* a3, _DWORD* a4)
{
    float* v4; // eax
    double v5; // st7
    double v6; // st6
    unsigned int v7; // esi
    double v8; // st5
    int v9; // ebx
    int v10; // ebp
    double v11; // st7
    float* v12; // ecx
    int v13; // ecx
    int v15; // esi
    unsigned int v16; // edi
    int v17; // ebx
    int v18; // eax
    int v19; // edx
    double v20; // st7
    int v21; // ebx
    unsigned int v22; // edi
    int v23; // ebp
    double v24; // st7
    float v25; // [esp+10h] [ebp-8h]
    int v26; // [esp+14h] [ebp-4h]
    int v27; // [esp+20h] [ebp+8h]
    int v28; // [esp+20h] [ebp+8h]
    int v29; // [esp+20h] [ebp+8h]
    float v30; // [esp+24h] [ebp+Ch]

    v4 = *(float**)(dword_520970 + 120);
    v5 = *a2 - v4[14];
    v6 = a2[1] - v4[15];
    v7 = 0;
    v8 = a2[2] - v4[16];
    v9 = *(_DWORD*)(a1 + 336);
    v26 = -1;
    v25 = 3.4028235e38;
    v10 = 0;
    *(float*)&v27 = sqrt(v8 * v8 + v6 * v6 + v5 * v5);
    v11 = *(float*)&a3;
    while (v9 && v7 < (*(_DWORD*)(a1 + 340) - v9) / 40)
    {
        v12 = (float*)(*(_DWORD*)(a1 + 336) + v10);
        if (*(float*)&v27 > (double)*v12 && *(float*)&v27 < (double)v12[1])
            v11 = 0.0;
        if (*(float*)&v27 < (double)*v12)
            v11 = *v12 - *(float*)&v27;
        if (*(float*)&v27 > (double)v12[1])
            v11 = *(float*)&v27 - v12[1];
        if (v11 < v25)
        {
            v25 = v11;
            v26 = v7;
        }
        ++v7;
        v10 += 40;
    }
    v13 = *(_DWORD*)(a1 + 336);
    *a3 = 0;
    v15 = v13 + 40 * v26;
    if (*(_BYTE*)(a1 + 300))
    {
        v28 = 0;
        while (2)
        {
            v16 = 0;
            v17 = 0;
            v30 = fabs((double)rand() * 0.000030518509);
            while (1)
            {
                v18 = *(_DWORD*)(v15 + 28);
                if (!v18 || v16 >= (*(_DWORD*)(v15 + 32) - v18) / 268)
                    break;
                v19 = *(_DWORD*)(v15 + 28);
                v20 = v30 - *(float*)(v17 + v19);
                v30 = v20;
                if (v20 <= 0.0 && sub_41E3D0(*(_DWORD*)(v17 + v19 + 264)))
                {
                    *a3 = *(_DWORD*)(*(_DWORD*)(v15 + 28) + 268 * v16 + 264);
                    *a4 = v15;
                    return;
                }
                ++v16;
                v17 += 268;
            }
            if (++v28 < 10)
                continue;
            break;
        }
    }
    else
    {
        v29 = rand();
        v21 = *(_DWORD*)(v15 + 28);
        v22 = 0;
        v23 = 0;
        v24 = fabs((double)v29 * 0.000030518509);
        while (v21 && v22 < (*(_DWORD*)(v15 + 32) - v21) / 268)
        {
            v24 = v24 - *(float*)(*(_DWORD*)(v15 + 28) + v23);
            if (v24 <= 0.0)
            {
                *a3 = *(_DWORD*)(*(_DWORD*)(v15 + 28) + 268 * v22 + 264);
                *a4 = v15;
                return;
            }
            ++v22;
            v23 += 268;
        }
    }
}
// 520970: using guessed type int dword_520970;

//----- (0044DAD0) --------------------------------------------------------
_DWORD* __stdcall sub_44DAD0(int* a1, float* a2, int a3, int a4)
{
    int v4; // edi
    int* v5; // ebx
    _BYTE* v6; // eax
    _DWORD* v7; // esi
    _DWORD v9[3]; // [esp+Ch] [ebp-Ch] BYREF

    v4 = (int)a2;
    if (sub_401200(a2))
        v4 = *(_DWORD*)(dword_520970 + 120) + 56;
    v5 = a1;
    if (!a1)
        return 0;
    sub_44D850((int)a1, (float*)v4, &a2, &a1);
    if (*(float*)&a2 == 0.0)
        return 0;
    v6 = (_BYTE*)sub_41E2D0(*(_DWORD**)(dword_520970 + 120), a2, 1, 1);
    v7 = v6;
    if (v6)
    {
        sub_41D8A0(v6, *((_BYTE*)v5 + 330));
        sub_41D8B0(v7, *a1, a1[3], a1[5], a1[1], a1[2], a1[4]);
        sub_41D8E0((int)v7, *((_BYTE*)v5 + 328), *(_DWORD*)(v4 + 8));
        memset(v9, 0, sizeof(v9));
        sub_41D960(v7, (_DWORD*)v4, v9);
        if (*(float*)&a3 != 0.0)
            sub_41D940(v7, a3, a4);
        sub_41D840((int)v7);
    }
    return v7;
}
// 520970: using guessed type int dword_520970;

//----- (0044DBF0) --------------------------------------------------------
void __thiscall sub_44DBF0(char* this, int a2, float* a3, int a4)
{
    int v6; // esi
    _BYTE* i; // eax
    float v8; // eax
    long double v9; // st7
    _DWORD* v10; // eax
    char* v11; // esi
    int v12; // [esp+0h] [ebp-18h]
    int v13; // [esp+1Ch] [ebp+4h]
    float v14; // [esp+24h] [ebp+Ch]

    if (a2)
    {
        v6 = 0;
        for (i = this + 27160; *i; i += 16)
        {
            if (++v6 >= 16)
                return;
        }
        v8 = *(float*)(a2 + 300);
        v13 = *(int*)(a2 + 296);
        if (*(float*)&v13 == v8)
            v9 = *(float*)&v13;
        else
            v9 = fabs((double)rand() * 0.000030518509) * (v8 - *(float*)&v13) + *(float*)&v13;
        *(float*)&v12 = v9 * *(float*)&a4;
        v10 = sub_44DAD0(*(int**)(a2 + 292), a3, a4, v12);
        *(_DWORD*)&this[16 * v6 + 27168] = v10;
        if (v10)
        {
            v11 = &this[16 * v6];
            v11[27160] = 1;
            *((_DWORD*)v11 + 6791) = a2;
            v14 = *(float*)(a2 + 312);
            if (0.0 == v14)
                *((float*)v11 + 6793) = 0.0;
            else
                *((float*)v11 + 6793) = fabs((double)rand() * 0.000030518509) * v14;
        }
    }
}
// 44DC26: conditional instruction was optimized away because esi.4<10

//----- (0044DD20) --------------------------------------------------------
void __thiscall sub_44DD20(char* this, float* a2, _DWORD* a3)
{
    int v4; // edi
    _BYTE* i; // eax
    char* v6; // esi
    long double v7; // st7
    long double v8; // st7
    long double v9; // st7
    long double v10; // st7
    _DWORD* v11; // eax
    float v13; // [esp+14h] [ebp+4h]
    float v14; // [esp+14h] [ebp+4h]
    float v15; // [esp+14h] [ebp+4h]
    float v16; // [esp+14h] [ebp+4h]
    float v17; // [esp+18h] [ebp+8h]
    float v18; // [esp+18h] [ebp+8h]
    float v19; // [esp+18h] [ebp+8h]
    float v20; // [esp+18h] [ebp+8h]

    if (a2)
    {
        v4 = 0;
        for (i = this + 27416; *i; i += 40)
        {
            if (++v4 >= 64)
                return;
        }
        v6 = &this[40 * v4];
        v6[27416] = 1;
        *((_DWORD*)v6 + 6855) = a2;
        *((_DWORD*)v6 + 6856) = *a3;
        *((_DWORD*)v6 + 6857) = a3[1];
        *((_DWORD*)v6 + 6858) = a3[2];
        v13 = a2[73];
        v17 = a2[74];
        if (v13 == v17)
            v7 = v13;
        else
            v7 = fabs((double)rand() * 0.000030518509) * (v17 - v13) + v13;
        *((float*)v6 + 6859) = v7;
        v14 = a2[75];
        v18 = a2[76];
        if (v14 == v18)
            v8 = v14;
        else
            v8 = fabs((double)rand() * 0.000030518509) * (v18 - v14) + v14;
        *(float*)&this[40 * v4 + 27440] = v8;
        v15 = a2[77];
        v19 = a2[78];
        if (v15 == v19)
            v9 = v15;
        else
            v9 = fabs((double)rand() * 0.000030518509) * (v19 - v15) + v15;
        *((float*)v6 + 6861) = v9;
        v16 = a2[79];
        v20 = a2[80];
        if (v16 == v20)
            v10 = v16;
        else
            v10 = fabs((double)rand() * 0.000030518509) * (v20 - v16) + v16;
        *((float*)v6 + 6862) = v10;
        v11 = sub_409960((_DWORD*)dword_520970, (int)this);
        *((_DWORD*)v6 + 6863) = v11;
        v11[10] = v6 + 27416;
        *(_DWORD*)(*((_DWORD*)v6 + 6863) + 28) = 0;
        *(_DWORD*)(*((_DWORD*)v6 + 6863) + 36) = 0;
        *(_DWORD*)(*((_DWORD*)v6 + 6863) + 12) = 3;
    }
}
// 44DD56: conditional instruction was optimized away because edi.4<40
// 520970: using guessed type int dword_520970;

//----- (0044DF20) --------------------------------------------------------
void __thiscall sub_44DF20(char* this, float a2, float a3, float* a4)
{
    int v6; // edx
    int* v7; // ebx
    unsigned int i; // edi
    int v9; // eax
    int v10; // eax
    int v11; // eax
    float* v12; // esi
    int v13; // [esp+0h] [ebp-14h]
    float v14; // [esp+18h] [ebp+4h]

    if (a2 != 0.0)
    {
        v6 = *(_DWORD*)(LODWORD(a2) + 292);
        v7 = (int*)LODWORD(a3);
        v14 = 0.0;
        if (v6 && (byte_4AC684 || _strnicmp(*(const char**)(v6 + 4), aBlood, strlen(aBlood))))
        {
            sub_44D7C0(*(_DWORD*)(LODWORD(a2) + 292), v7, &a3);
            if (a3 >= 0.0)
                v14 = a3;
        }
        for (i = 0; ; ++i)
        {
            v9 = *(_DWORD*)(LODWORD(a2) + 300);
            if (!v9 || i >= (*(_DWORD*)(LODWORD(a2) + 304) - v9) >> 2)
                break;
            v10 = *(_DWORD*)(v9 + 4 * i);
            if (!*(_BYTE*)(v10 + 329))
                v14 = 0.0;
            *(float*)&v13 = v14 * *(float*)(v10 + 296);
            sub_44DAD0((int*)v10, (float*)v7, SLODWORD(v14), v13);
        }
        v11 = *(_DWORD*)(LODWORD(a2) + 312);
        if (v11)
            sub_44A490(*(char**)(dword_520970 + 276), v11, v7, a4, 0, 0);
        v12 = *(float**)(LODWORD(a2) + 316);
        if (v12)
            sub_44DD20(this, v12, v7);
    }
}
// 4AC684: using guessed type char byte_4AC684;
// 520970: using guessed type int dword_520970;

//----- (0044E040) --------------------------------------------------------
int __thiscall sub_44E040(char* this, int a2, int a3, int a4, float a5, int* a6)
{
    int v8; // eax
    int v9; // esi
    float v10; // eax
    float v11; // edi
    int v12; // ebp
    int v13; // eax
    int v14; // ecx
    int v15; // edi
    _DWORD* v16; // ecx
    int v17; // edi
    int* v18; // eax
    _DWORD* v19; // eax
    int v20; // ecx
    int v21; // ebp
    int* v22; // edi
    int v23; // eax
    int v24; // esi
    char* v25; // ebp
    float* v26; // eax
    _BYTE* v27; // eax
    int v28; // esi
    int v29; // eax
    _DWORD* v30; // eax
    int v31; // ebp
    char* v32; // edi
    _DWORD* v33; // eax
    _DWORD* v34; // eax
    int v36; // [esp-4h] [ebp-70h]
    int v37; // [esp+0h] [ebp-6Ch]
    int v38; // [esp+14h] [ebp-58h]
    int v40; // [esp+1Ch] [ebp-50h]
    _DWORD v41[3]; // [esp+20h] [ebp-4Ch] BYREF
    int v42[16]; // [esp+2Ch] [ebp-40h] BYREF
    float v43; // [esp+70h] [ebp+4h]
    unsigned int v44; // [esp+78h] [ebp+Ch]
    int v45; // [esp+78h] [ebp+Ch]

    if (!a2)
        return 0;
    v8 = sub_44D740(this);
    if (v8 == -1)
        return 0;
    v9 = (int)&this[212 * v8 + 24];
    v38 = v9;
    *(_DWORD*)v9 = sub_44D7B0(this);
    v10 = a5;
    v36 = LODWORD(a5);
    *(_DWORD*)(v9 + 4) = a2;
    *(_BYTE*)(v9 + 200) = 1;
    *(_DWORD*)(v9 + 204) = a4;
    *(float*)(v9 + 208) = v10;
    sub_407690(a4, v36, v42);
    v43 = 0.0;
    if (*(_DWORD*)(a2 + 292))
    {
        v44 = 0;
        LODWORD(v11) = -8 - v9;
        v12 = v9 + 8;
        LODWORD(a5) = -8 - v9;
        while (1)
        {
            v13 = *(_DWORD*)(a2 + 292);
            v14 = *(_DWORD*)(v13 + 296);
            if (!v14 || v44 >= (*(_DWORD*)(v13 + 300) - v14) >> 2)
                break;
            v15 = v12 + LODWORD(v11);
            v16 = sub_413870(*(_DWORD**)(dword_520970 + 116), *(_DWORD*)(v15 + *(_DWORD*)(v13 + 296)));
            *(_DWORD*)v12 = v16;
            v17 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a2 + 292) + 296) + v15);
            if (*(float*)(v17 + 368) >= (double)v43)
                v43 = *(float*)(v17 + 368);
            if (v16)
            {
                v18 = a6;
                qmemcpy(v16 + 29, v42, 0x40u);
                v9 = v38;
                *(_DWORD*)(*(_DWORD*)v12 + 180) = *v18;
                *(_DWORD*)(*(_DWORD*)v12 + 184) = v18[1];
                *(_DWORD*)(*(_DWORD*)v12 + 188) = v18[2];
                v19 = (_DWORD*)(*(_DWORD*)v12 + 96);
                *v19 = *(_DWORD*)a3;
                v19[1] = *(_DWORD*)(a3 + 4);
                v19[2] = *(_DWORD*)(a3 + 8);
            }
            v11 = a5;
            v12 += 4;
            ++v44;
        }
    }
    memset((void*)(v9 + 136), 0, 0x40u);
    v20 = 0;
    v21 = -136 - v9;
    v45 = 0;
    v22 = (int*)(v9 + 136);
    v40 = -136 - v9;
    while (1)
    {
        v23 = *(_DWORD*)(a2 + 300);
        if (!v23 || v20 >= (unsigned int)((*(_DWORD*)(a2 + 304) - v23) >> 2) || v20 >= 16)
            break;
        v24 = *(_DWORD*)(a2 + 300);
        v25 = (char*)v22 + v21;
        v26 = (float*)sub_4010C0((int)v42);
        sub_44D850(*(_DWORD*)&v25[v24], v26, &a5, &a6);
        if (a5 != 0.0)
        {
            v27 = (_BYTE*)sub_41E2D0(*(_DWORD**)(dword_520970 + 120), (_DWORD*)LODWORD(a5), 1, 1);
            *v22 = (int)v27;
            if (v27)
            {
                sub_41D8A0(v27, *(_BYTE*)(*(_DWORD*)&v25[*(_DWORD*)(a2 + 300)] + 330));
                sub_41D8B0((_DWORD*)*v22, *a6, a6[3], a6[5], a6[1], a6[2], a6[4]);
                v28 = *(_DWORD*)(a2 + 300);
                v29 = sub_4010C0((int)v42);
                sub_41D8E0(*v22, *(_BYTE*)(*(_DWORD*)&v25[v28] + 328), *(_DWORD*)(v29 + 8));
                memset(v41, 0, sizeof(v41));
                v30 = (_DWORD*)sub_4010C0((int)v42);
                sub_41D960((_DWORD*)*v22, v30, v41);
                v31 = *(_DWORD*)&v25[*(_DWORD*)(a2 + 300)];
                if (*(_BYTE*)(v31 + 329) && v43 != 0.0)
                {
                    *(float*)&v37 = v43 * *(float*)(v31 + 296);
                    sub_41D940((_DWORD*)*v22, SLODWORD(v43), v37);
                }
                sub_41D840(*v22);
            }
        }
        v9 = v38;
        v21 = v40;
        v20 = ++v45;
        ++v22;
    }
    if (*(_DWORD*)(a2 + 312))
    {
        v32 = *(char**)(dword_520970 + 276);
        v33 = (_DWORD*)sub_4010C0((int)v42);
        sub_44A490(v32, *(_DWORD*)(a2 + 312), v33, (float*)a3, 0, 0);
    }
    if (*(_DWORD*)(a2 + 316))
    {
        v34 = (_DWORD*)sub_4010C0((int)v42);
        sub_44DD20(this, *(float**)(a2 + 316), v34);
    }
    return *(_DWORD*)v9;
}
// 520970: using guessed type int dword_520970;

//----- (0044E3D0) --------------------------------------------------------
int __thiscall sub_44E3D0(char* this, int a2, const void* a3)
{
    int v4; // eax
    int v5; // esi
    int v7; // eax
    unsigned int v8; // ebp
    int v9; // eax
    int v10; // ecx
    _DWORD* v11; // ecx
    int v12; // edx
    _DWORD** v13; // esi
    int v14; // ecx
    int v15; // edi
    int v16; // eax
    char* v17; // edi
    float* v18; // eax
    _BYTE* v19; // eax
    int v20; // eax
    _DWORD* v21; // eax
    int v22; // edi
    int v23; // eax
    _DWORD* v24; // eax
    int v26; // [esp+0h] [ebp-3Ch]
    _DWORD* i; // [esp+14h] [ebp-28h]
    int v28; // [esp+14h] [ebp-28h]
    int v29; // [esp+18h] [ebp-24h]
    int v31; // [esp+20h] [ebp-1Ch]
    int v32; // [esp+20h] [ebp-1Ch]
    _DWORD* v33; // [esp+24h] [ebp-18h] BYREF
    int v34; // [esp+28h] [ebp-14h] BYREF
    int v35; // [esp+2Ch] [ebp-10h]
    int v36; // [esp+30h] [ebp-Ch] BYREF
    int v37; // [esp+34h] [ebp-8h]
    int v38; // [esp+38h] [ebp-4h]
    float v39; // [esp+40h] [ebp+4h]

    v4 = sub_44D740(this);
    if (v4 == -1)
        return 0;
    v5 = (int)&this[212 * v4 + 24];
    v29 = v5;
    *(_DWORD*)v5 = sub_44D7B0(this);
    *(_DWORD*)(v5 + 4) = a2;
    *(_BYTE*)(v5 + 200) = 0;
    v7 = *(_DWORD*)(a2 + 292);
    v39 = 0.0;
    if (v7)
    {
        v8 = 0;
        for (i = (_DWORD*)(v5 + 8); ; ++i)
        {
            v9 = *(_DWORD*)(a2 + 292);
            v10 = *(_DWORD*)(v9 + 296);
            if (!v10 || v8 >= (*(_DWORD*)(v9 + 300) - v10) >> 2)
                break;
            v11 = sub_413870(*(_DWORD**)(dword_520970 + 116), *(_DWORD*)(v10 + 4 * v8));
            *i = v11;
            v12 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a2 + 292) + 296) + 4 * v8);
            if (*(float*)(v12 + 368) >= (double)v39)
                v39 = *(float*)(v12 + 368);
            if (v11)
            {
                qmemcpy(v11 + 29, a3, 0x40u);
                v5 = v29;
            }
            ++v8;
        }
    }
    v13 = (_DWORD**)(v5 + 136);
    memset(v13, 0, 0x40u);
    v14 = 0;
    v15 = -136 - v29;
    v28 = 0;
    v35 = -136 - v29;
    while (1)
    {
        v16 = *(_DWORD*)(a2 + 300);
        if (!v16 || v14 >= (unsigned int)((*(_DWORD*)(a2 + 304) - v16) >> 2) || v14 >= 16)
            break;
        v31 = *(_DWORD*)(a2 + 300);
        v17 = (char*)v13 + v15;
        v18 = (float*)sub_4010C0((int)a3);
        sub_44D850(*(_DWORD*)&v17[v31], v18, &v33, &v34);
        if (v33)
        {
            v19 = (_BYTE*)sub_41E2D0(*(_DWORD**)(dword_520970 + 120), v33, 1, 1);
            *v13 = v19;
            if (v19)
            {
                sub_41D8A0(v19, *(_BYTE*)(*(_DWORD*)&v17[*(_DWORD*)(a2 + 300)] + 330));
                sub_41D8B0(
                    *v13,
                    *(_DWORD*)v34,
                    *(_DWORD*)(v34 + 12),
                    *(_DWORD*)(v34 + 20),
                    *(_DWORD*)(v34 + 4),
                    *(_DWORD*)(v34 + 8),
                    *(_DWORD*)(v34 + 16));
                v32 = *(_DWORD*)(a2 + 300);
                v20 = sub_4010C0((int)a3);
                sub_41D8E0((int)*v13, *(_BYTE*)(*(_DWORD*)&v17[v32] + 328), *(_DWORD*)(v20 + 8));
                v36 = 0;
                v37 = 0;
                v38 = 0;
                v21 = (_DWORD*)sub_4010C0((int)a3);
                sub_41D960(*v13, v21, &v36);
                v22 = *(_DWORD*)&v17[*(_DWORD*)(a2 + 300)];
                if (*(_BYTE*)(v22 + 329) && v39 != 0.0)
                {
                    *(float*)&v26 = v39 * *(float*)(v22 + 296);
                    sub_41D940(*v13, SLODWORD(v39), v26);
                }
                sub_41D840((int)*v13);
            }
        }
        v15 = v35;
        v14 = v28 + 1;
        ++v13;
        ++v28;
    }
    if (*(_DWORD*)(a2 + 312))
    {
        v36 = 0;
        v37 = 0;
        v38 = 0;
        v23 = sub_4010C0((int)a3);
        sub_44A490(*(_DWORD*)(a2 + 312), v23, &v36, 0, 0);
    }
    if (*(_DWORD*)(a2 + 316))
    {
        v24 = (_DWORD*)sub_4010C0((int)a3);
        sub_44DD20(this, *(float**)(a2 + 316), v24);
    }
    return *(_DWORD*)v29;
}
// 44A490: using guessed type _DWORD __stdcall sub_44A490(_DWORD, _DWORD, _DWORD, char, char);
// 520970: using guessed type int dword_520970;

//----- (0044E6F0) --------------------------------------------------------
int __thiscall sub_44E6F0(_DWORD* this, int a2, const void* a3, _DWORD* a4)
{
    int result; // eax
    int v6; // edx
    unsigned int v7; // ebx
    int i; // ebp
    int v9; // eax
    int v10; // ecx
    int v11; // eax
    int* v12; // esi
    int v13; // edi
    _DWORD* v14; // eax

    result = sub_44D770(this, a2);
    if (result != -1)
    {
        v6 = (int)&this[53 * result + 6];
        if (*(_DWORD*)(this[53 * result + 7] + 292))
        {
            v7 = 0;
            for (i = (int)&this[53 * result + 8]; ; i += 4)
            {
                v9 = *(_DWORD*)(*(_DWORD*)(v6 + 4) + 292);
                v10 = *(_DWORD*)(v9 + 296);
                v11 = v9 + 292;
                if (!v10 || v7 >= (*(_DWORD*)(v11 + 8) - v10) >> 2)
                    break;
                if (*(_DWORD*)i)
                    qmemcpy((void*)(*(_DWORD*)i + 116), a3, 0x40u);
                ++v7;
            }
        }
        v12 = (int*)(v6 + 136);
        v13 = 16;
        do
        {
            result = *v12;
            if (*v12 && !*(_BYTE*)(result + 53))
            {
                v14 = (_DWORD*)sub_4010C0((int)a3);
                result = sub_41D960((_DWORD*)*v12, v14, a4);
            }
            ++v12;
            --v13;
        } while (v13);
    }
    return result;
}

//----- (0044E7B0) --------------------------------------------------------
char __thiscall sub_44E7B0(_DWORD* this, int a2)
{
    int v3; // eax

    v3 = sub_44D770(this, a2);
    if (v3 != -1)
        LOBYTE(v3) = sub_44E7D0(this, v3);
    return v3;
}

//----- (0044E7D0) --------------------------------------------------------
char __thiscall sub_44E7D0(_DWORD* this, int a2)
{
    int v2; // eax
    _DWORD* v3; // esi
    unsigned int v4; // edi
    _BYTE** i; // ebx
    int v6; // eax
    int v7; // ecx
    int* v8; // edi
    int v9; // ebx
    int v10; // ecx

    v2 = this[53 * a2 + 6];
    v3 = &this[53 * a2 + 6];
    if (v2)
    {
        v2 = this[53 * a2 + 7];
        if (*(_DWORD*)(v2 + 292))
        {
            v4 = 0;
            for (i = (_BYTE**)&this[53 * a2 + 8]; ; ++i)
            {
                v6 = *(_DWORD*)(v3[1] + 292);
                v7 = *(_DWORD*)(v6 + 296);
                v2 = v6 + 292;
                if (!v7 || v4 >= (*(_DWORD*)(v2 + 8) - v7) >> 2)
                    break;
                if (*i)
                    sub_413990(*i);
                ++v4;
            }
        }
        v8 = v3 + 34;
        v9 = 16;
        do
        {
            v10 = *v8;
            if (*v8)
            {
                LOBYTE(v2) = *(_BYTE*)(v10 + 53);
                if (!(_BYTE)v2)
                    LOBYTE(v2) = sub_41D9A0(v10);
            }
            ++v8;
            --v9;
        } while (v9);
        *v3 = 0;
    }
    return v2;
}
// 520970: using guessed type int dword_520970;

//----- (0044E870) --------------------------------------------------------
char __thiscall sub_44E870(_DWORD* this)
{
    int i; // esi
    char result; // al
    _DWORD* v4; // esi
    int v5; // ebp
    int v6; // ecx
    _DWORD* v7; // esi
    int v8; // edi

    for (i = 0; i < 128; ++i)
        result = sub_44E7D0(this, i);
    v4 = this + 6790;
    v5 = 16;
    do
    {
        if (*(_BYTE*)v4)
        {
            v6 = v4[2];
            result = *(_BYTE*)(v6 + 53);
            if (!result)
                result = sub_41D9A0(v6);
            *(_BYTE*)v4 = 0;
        }
        v4 += 4;
        --v5;
    } while (v5);
    v7 = this + 6854;
    v8 = 64;
    do
    {
        if (*(_BYTE*)v7)
        {
            result = sub_409A00(dword_520970, (void*)v7[9]);
            v7[9] = 0;
            *(_BYTE*)v7 = 0;
        }
        v7 += 10;
        --v8;
    } while (v8);
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (0044E8F0) --------------------------------------------------------
int __thiscall sub_44E8F0(_DWORD** this)
{
    return (*(int(__thiscall**)(_DWORD*))(*this[7496] + 4))(this[7496]);
}

//----- (0044E900) --------------------------------------------------------
int __thiscall sub_44E900(_DWORD** this)
{
    return (*(int(__thiscall**)(_DWORD*))(*this[7496] + 8))(this[7496]);
}

//----- (0044E910) --------------------------------------------------------
int __thiscall sub_44E910(_DWORD* this)
{
    int result; // eax

    result = this[1];
    if (result)
        return (this[2] - result) / 268;
    return result;
}

//----- (0044E940) --------------------------------------------------------
int __thiscall sub_44E940(int* this)
{
    int v2; // ebx
    int i; // esi
    int result; // eax

    v2 = this[2];
    for (i = this[1]; i != v2; i += 40)
        sub_44C220(i);
    sub_4885A6((LPVOID)this[1]);
    result = 0;
    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
    return result;
}

//----- (0044E980) --------------------------------------------------------
int __thiscall sub_44E980(_DWORD* this)
{
    int result; // eax

    result = this[1];
    if (result)
        return (this[2] - result) / 40;
    return result;
}

//----- (0044E9B0) --------------------------------------------------------
void __thiscall sub_44E9B0(LPVOID* this)
{
    sub_4885A6(this[1]);
    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
}

//----- (0044E9E0) --------------------------------------------------------
unsigned int __thiscall sub_44E9E0(_DWORD* this, char* a2, unsigned int a3, const void* a4)
{
    _DWORD* v4; // edi
    char* v6; // ebx
    int v7; // esi
    unsigned int v8; // ecx
    int v9; // edx
    unsigned int v10; // eax
    char* v11; // edx
    char* k; // eax
    char* v13; // eax
    unsigned int v14; // ebx
    char* v15; // esi
    char* v16; // ebx
    char* v17; // eax
    int v18; // eax
    int v19; // edx
    unsigned int v20; // ebp
    unsigned int result; // eax
    char* v22; // esi
    int v23; // ecx
    char* v24; // eax
    char* v25; // edx
    char* v26; // ebx
    unsigned int j; // eax
    char* v28; // edx
    char* v29; // eax
    char* v30; // edi
    char* v31; // edx
    int v32; // ebp
    char* i; // eax
    char* v34; // edx
    char* v35; // eax
    void* v36; // edi
    char* v38; // [esp+14h] [ebp-4h]
    unsigned int v39; // [esp+20h] [ebp+8h]
    int v40; // [esp+20h] [ebp+8h]
    char* v41; // [esp+24h] [ebp+Ch]

    v4 = this;
    v6 = (char*)this[2];
    if ((this[3] - (int)v6) / 268 >= a3)
    {
        v22 = a2;
        result = (unsigned int)((unsigned __int64)(128207979LL * (v6 - a2)) >> 32) >> 31;
        if ((v6 - a2) / 268 >= a3)
        {
            if (a3)
            {
                v31 = (char*)this[2];
                v32 = 268 * a3;
                for (i = &v6[-268 * a3]; i != v6; v31 += 268)
                {
                    if (v31)
                    {
                        qmemcpy(v31, i, 0x10Cu);
                        v22 = a2;
                        v4 = this;
                    }
                    i += 268;
                }
                v34 = (char*)v4[2];
                v35 = &v34[-v32];
                if (v22 != &v34[-v32])
                {
                    do
                    {
                        v35 -= 268;
                        v34 -= 268;
                        qmemcpy(v34, v35, 0x10Cu);
                    } while (v35 != a2);
                    v4 = this;
                    v22 = a2;
                }
                result = (unsigned int)v22;
                if (v22 != &v22[v32])
                {
                    do
                    {
                        v36 = (void*)result;
                        result += 268;
                        qmemcpy(v36, a4, 0x10Cu);
                    } while ((char*)result != &v22[v32]);
                    v4 = this;
                }
                v4[2] += v32;
            }
        }
        else
        {
            v23 = 268 * a3;
            v40 = 268 * a3;
            v24 = &a2[268 * a3];
            if (a2 != v6)
            {
                v25 = &v24[-v23];
                do
                {
                    if (v24)
                    {
                        qmemcpy(v24, v25, 0x10Cu);
                        v22 = a2;
                        v4 = this;
                    }
                    v25 += 268;
                    v24 += 268;
                } while (v25 != v6);
            }
            v26 = (char*)v4[2];
            for (j = a3 - (v26 - v22) / 268; j; --j)
            {
                if (v26)
                {
                    qmemcpy(v26, a4, 0x10Cu);
                    v22 = a2;
                    v4 = this;
                }
                v26 += 268;
            }
            v28 = (char*)v4[2];
            v29 = v22;
            if (v22 != v28)
            {
                do
                {
                    v30 = v29;
                    v29 += 268;
                    qmemcpy(v30, a4, 0x10Cu);
                } while (v29 != v28);
                v4 = this;
            }
            result = v40 + v4[2];
            v4[2] = result;
        }
    }
    else
    {
        v7 = this[1];
        if (!v7 || (v8 = (int)&v6[-v7] / 268, a3 >= v8))
            v8 = a3;
        if (v7)
            v9 = (int)&v6[-v7] / 268;
        else
            v9 = 0;
        v10 = v9 + v8;
        v39 = v9 + v8;
        if ((int)(v9 + v8) < 0)
            v10 = 0;
        v38 = (char*)operator new(268 * v10);
        v11 = v38;
        for (k = (char*)v4[1]; k != a2; v11 += 268)
        {
            if (v11)
            {
                qmemcpy(v11, k, 0x10Cu);
                v4 = this;
            }
            k += 268;
        }
        v13 = v11;
        if (a3)
        {
            v14 = a3;
            do
            {
                if (v13)
                {
                    qmemcpy(v13, a4, 0x10Cu);
                    v4 = this;
                }
                v13 += 268;
                --v14;
            } while (v14);
        }
        v15 = (char*)v4[2];
        v41 = v15;
        v16 = &v11[268 * a3];
        if (a2 != v15)
        {
            v17 = a2;
            do
            {
                if (v16)
                {
                    qmemcpy(v16, v17, 0x10Cu);
                    v4 = this;
                    v15 = v41;
                }
                v17 += 268;
                v16 += 268;
            } while (v17 != v15);
        }
        sub_4885A6((LPVOID)v4[1]);
        v4[3] = &v38[268 * v39];
        v18 = v4[1];
        if (v18)
            v19 = (v4[2] - v18) / 268;
        else
            v19 = 0;
        v20 = v19 + a3;
        v4[1] = v38;
        result = 67 * v20;
        v4[2] = &v38[268 * v20];
    }
    return result;
}

//----- (0044ED10) --------------------------------------------------------
char* __thiscall sub_44ED10(_DWORD* this, char* a2, char* a3)
{
    char* v3; // edx
    char* v4; // ebx
    char* v5; // ebp
    const void* v6; // esi
    void* v7; // edi

    v3 = a3;
    v4 = a2;
    v5 = (char*)this[2];
    if (a3 != v5)
    {
        do
        {
            v6 = v3;
            v7 = v4;
            v3 += 268;
            v4 += 268;
            qmemcpy(v7, v6, 0x10Cu);
        } while (v3 != v5);
    }
    this[2] = v4;
    return a2;
}

//----- (0044ED60) --------------------------------------------------------
unsigned int __thiscall sub_44ED60(_DWORD* this, char* a2, unsigned int a3, _DWORD* a4)
{
    char* v4; // esi
    unsigned int v5; // edi
    int v6; // ecx
    unsigned int v7; // ebx
    int v8; // edx
    unsigned int v9; // eax
    int v10; // ebp
    int i; // esi
    int j; // esi
    int v13; // esi
    int v14; // eax
    char* v15; // ebp
    int v16; // ebp
    int k; // esi
    unsigned int result; // eax
    int v19; // ecx
    int v20; // kr00_4
    int v22; // ebx
    int v23; // esi
    bool v24; // zf
    unsigned int v25; // edi
    unsigned int v26; // eax
    unsigned int v28; // ebx
    _DWORD* v29; // esi
    int v30; // edx
    int v31; // edi
    int v32; // ebx
    _DWORD* v33; // eax
    char* v34; // ebx
    _DWORD* v35; // edi
    _DWORD* v36; // esi
    int v37; // ecx
    _DWORD* v38; // esi
    _DWORD* v39; // [esp+10h] [ebp-Ch]
    unsigned int v40; // [esp+14h] [ebp-8h]
    char* v41; // [esp+18h] [ebp-4h]
    int v42; // [esp+20h] [ebp+4h]
    int v43; // [esp+20h] [ebp+4h]
    int v44; // [esp+24h] [ebp+8h]
    _DWORD* v45; // [esp+24h] [ebp+8h]
    char* v46; // [esp+24h] [ebp+8h]
    _DWORD* v47; // [esp+28h] [ebp+Ch]

    v4 = (char*)this[2];
    v5 = a3;
    v39 = this;
    if ((this[3] - (int)v4) / 40 >= a3)
    {
        result = (unsigned int)((unsigned __int64)(1717986919LL * (v4 - a2)) >> 32) >> 31;
        if ((v4 - a2) / 40 >= a3)
        {
            if (!a3)
                return result;
            v30 = 40 * a3;
            v31 = (int)&v4[-40 * a3];
            v32 = this[2];
            v43 = 40 * a3;
            if ((char*)v31 != v4)
            {
                do
                {
                    sub_44F3A0(v32, v31);
                    v31 += 40;
                    v32 += 40;
                } while ((char*)v31 != v4);
                this = v39;
                v30 = 40 * a3;
            }
            v33 = (_DWORD*)this[2];
            v34 = (char*)v33 - v30;
            if (a2 != (char*)v33 - v30)
            {
                v35 = v33 + 4;
                v36 = v34 + 16;
                while (1)
                {
                    v37 = *((_DWORD*)v34 - 10);
                    v34 -= 40;
                    v36 -= 10;
                    v45 = v33 - 10;
                    v35 -= 10;
                    *v45 = v37;
                    v45[1] = *((_DWORD*)v34 + 1);
                    *(v35 - 2) = *(v36 - 2);
                    *(v35 - 1) = *(v36 - 1);
                    *v35 = *v36;
                    v35[1] = v36[1];
                    sub_44F490(v35 + 2, v36 + 2);
                    if (v34 == a2)
                        break;
                    v33 = v45;
                }
                this = v39;
                v30 = v43;
            }
            result = (unsigned int)&a2[v30];
            v46 = &a2[v30];
            if (a2 == &a2[v30])
                goto LABEL_50;
            v38 = a2 + 16;
            do
            {
                *(v38 - 4) = *a4;
                *(v38 - 3) = a4[1];
                *(v38 - 2) = a4[2];
                *(v38 - 1) = a4[3];
                *v38 = a4[4];
                v38[1] = a4[5];
                sub_44F490(v38 + 2, a4 + 6);
                result = (unsigned int)v46;
                v38 += 10;
            } while (v38 - 4 != (_DWORD*)v46);
        }
        else
        {
            v22 = (int)a2;
            v43 = 40 * a3;
            if (a2 != v4)
            {
                v44 = (int)&a2[40 * a3];
                do
                {
                    sub_44F3A0(v44, v22);
                    v22 += 40;
                    v44 += 40;
                } while ((char*)v22 != v4);
                this = v39;
            }
            v23 = this[2];
            v25 = v5 - (v23 - (int)a2) / 40;
            v24 = v25 == 0;
            v26 = v25;
            if (!v24)
            {
                v28 = v26;
                do
                {
                    sub_44F3A0(v23, (int)a4);
                    v23 += 40;
                    --v28;
                } while (v28);
                this = v39;
            }
            result = this[2];
            v47 = (_DWORD*)result;
            if (a2 == (char*)result)
                goto LABEL_49;
            v29 = a2 + 16;
            do
            {
                *(v29 - 4) = *a4;
                *(v29 - 3) = a4[1];
                *(v29 - 2) = a4[2];
                *(v29 - 1) = a4[3];
                *v29 = a4[4];
                v29[1] = a4[5];
                sub_44F490(v29 + 2, a4 + 6);
                result = (unsigned int)v47;
                v29 += 10;
            } while (v29 - 4 != v47);
        }
        this = v39;
    LABEL_49:
        v30 = v43;
    LABEL_50:
        this[2] += v30;
        return result;
    }
    v6 = this[1];
    if (!v6 || (v7 = (int)&v4[-v6] / 40, a3 >= v7))
        v7 = a3;
    if (v6)
        v8 = (int)&v4[-v6] / 40;
    else
        v8 = 0;
    v9 = v8 + v7;
    v40 = v8 + v7;
    if ((int)(v8 + v7) < 0)
        v9 = 0;
    v41 = (char*)operator new(40 * v9);
    v10 = (int)v41;
    for (i = v39[1]; (char*)i != a2; v10 += 40)
    {
        sub_44F3A0(v10, i);
        i += 40;
    }
    for (j = v10; a3; --a3)
    {
        sub_44F3A0(j, (int)a4);
        j += 40;
    }
    v13 = (int)a2;
    v14 = v10 + 40 * v5;
    v15 = (char*)v39[2];
    if (a2 != v15)
    {
        v42 = v14;
        do
        {
            sub_44F3A0(v42, v13);
            v13 += 40;
            v42 += 40;
        } while ((char*)v13 != v15);
    }
    v16 = v39[2];
    for (k = v39[1]; k != v16; k += 40)
        sub_44C220(k);
    sub_4885A6((LPVOID)v39[1]);
    result = v39[1];
    v39[3] = &v41[40 * v40];
    if (result)
    {
        v19 = v39[2];
        v39[1] = v41;
        v20 = v19 - result;
        result = (unsigned int)((unsigned __int64)(1717986919LL * (int)(v19 - result)) >> 32) >> 31;
        v5 += v20 / 40;
    }
    else
    {
        v39[1] = v41;
    }
    v39[2] = &v41[40 * v5];
    return result;
}

//----- (0044F0E0) --------------------------------------------------------
_DWORD* __thiscall sub_44F0E0(_DWORD* this, _DWORD* a2, _DWORD* a3)
{
    _DWORD* result; // eax
    _DWORD* v4; // edi
    _DWORD* v5; // ebx
    _DWORD* v6; // esi
    int v7; // ebp
    _DWORD* v8; // edi
    int v9; // esi
    _DWORD* v10; // [esp+Ch] [ebp-8h]
    _DWORD* v11; // [esp+10h] [ebp-4h]

    result = a2;
    v4 = a3;
    v10 = this;
    v11 = (_DWORD*)this[2];
    v5 = a2;
    if (a3 != v11)
    {
        v6 = a2 + 2;
        v7 = (char*)a3 - (char*)a2;
        do
        {
            *v5 = *v4;
            v5[1] = v4[1];
            *v6 = *(_DWORD*)((char*)v6 + v7);
            v6[1] = *(_DWORD*)((char*)v6 + v7 + 4);
            v6[2] = v4[4];
            v6[3] = v4[5];
            sub_44F490(v6 + 4, v4 + 6);
            v4 += 10;
            v5 += 10;
            v6 += 10;
        } while (v4 != v11);
        this = v10;
        result = a2;
    }
    v8 = (_DWORD*)this[2];
    v9 = (int)v5;
    if (v5 == v8)
    {
        this[2] = v5;
    }
    else
    {
        do
        {
            sub_44C220(v9);
            v9 += 40;
        } while ((_DWORD*)v9 != v8);
        v10[2] = v5;
        return a2;
    }
    return result;
}

//----- (0044F190) --------------------------------------------------------
_DWORD* __thiscall sub_44F190(int this, _DWORD* a2, unsigned int a3, _DWORD* a4)
{
    int v5; // edi
    _DWORD* result; // eax
    int v7; // edx
    unsigned int v8; // ecx
    int v9; // eax
    int v10; // eax
    _DWORD* v11; // ecx
    _DWORD* n; // eax
    _DWORD* v13; // eax
    unsigned int v14; // edx
    _DWORD* v15; // edi
    _DWORD* v16; // edx
    _DWORD* v17; // eax
    int v18; // ecx
    int v19; // eax
    int v20; // ebx
    _DWORD* v21; // esi
    _DWORD* v22; // ecx
    _DWORD* v23; // eax
    unsigned int k; // ebp
    _DWORD* v25; // ecx
    _DWORD* m; // eax
    int v27; // ebp
    _DWORD* v28; // esi
    _DWORD* i; // ecx
    _DWORD* v30; // ecx
    _DWORD* j; // eax
    int v32; // esi
    int v34; // [esp+14h] [ebp-4h]
    _DWORD* v35; // [esp+20h] [ebp+8h]

    v5 = this;
    result = *(_DWORD**)(this + 8);
    if ((*(_DWORD*)(this + 12) - (int)result) >> 2 >= a3)
    {
        if (result - a2 >= a3)
        {
            if (a3)
            {
                v27 = 4 * a3;
                v28 = *(_DWORD**)(this + 8);
                for (i = &result[-a3]; i != result; ++v28)
                {
                    if (v28)
                        *v28 = *i;
                    ++i;
                }
                v30 = *(_DWORD**)(v5 + 8);
                for (j = &v30[v27 / 0xFFFFFFFC]; j != a2; *v30 = v32)
                {
                    v32 = *--j;
                    --v30;
                }
                for (result = a2; result != &a2[v27 / 4u]; ++result)
                    *result = *a4;
                *(_DWORD*)(v5 + 8) += v27;
            }
        }
        else
        {
            v20 = 4 * a3;
            v21 = &a2[a3];
            if (a2 != result)
            {
                v22 = &v21[v20 / 0xFFFFFFFC];
                do
                {
                    if (v21)
                    {
                        *v21 = *v22;
                        v5 = this;
                    }
                    ++v22;
                    ++v21;
                } while (v22 != result);
            }
            v23 = *(_DWORD**)(v5 + 8);
            for (k = a3 - (v23 - a2); k; --k)
            {
                if (v23)
                    *v23 = *a4;
                ++v23;
            }
            v25 = *(_DWORD**)(v5 + 8);
            for (m = a2; m != v25; ++m)
                *m = *a4;
            result = (_DWORD*)(v20 + *(_DWORD*)(v5 + 8));
            *(_DWORD*)(v5 + 8) = result;
        }
    }
    else
    {
        v7 = *(_DWORD*)(this + 4);
        if (!v7 || (v8 = ((int)result - v7) >> 2, a3 >= v8))
            v8 = a3;
        if (v7)
            v9 = ((int)result - v7) >> 2;
        else
            v9 = 0;
        v10 = v8 + v9;
        v34 = v10;
        if (v10 < 0)
            v10 = 0;
        v35 = operator new(4 * v10);
        v11 = v35;
        for (n = *(_DWORD**)(v5 + 4); n != a2; ++v11)
        {
            if (v11)
                *v11 = *n;
            ++n;
        }
        v13 = v11;
        if (a3)
        {
            v14 = a3;
            do
            {
                if (v13)
                {
                    *v13 = *a4;
                    v5 = this;
                }
                ++v13;
                --v14;
            } while (v14);
        }
        v15 = *(_DWORD**)(v5 + 8);
        v16 = &v11[a3];
        if (a2 != v15)
        {
            v17 = a2;
            do
            {
                if (v16)
                    *v16 = *v17;
                ++v17;
                ++v16;
            } while (v17 != v15);
        }
        sub_4885A6(*(LPVOID*)(this + 4));
        *(_DWORD*)(this + 12) = &v35[v34];
        v18 = *(_DWORD*)(this + 4);
        if (v18)
        {
            v19 = *(_DWORD*)(this + 8);
            *(_DWORD*)(this + 4) = v35;
            result = &v35[a3 + ((v19 - v18) >> 2)];
        }
        else
        {
            *(_DWORD*)(this + 4) = v35;
            result = &v35[a3];
        }
        *(_DWORD*)(this + 8) = result;
    }
    return result;
}

//----- (0044F3A0) --------------------------------------------------------
void __cdecl sub_44F3A0(int a1, int a2)
{
    int v2; // eax
    int v3; // edx
    int v4; // eax
    char* v5; // eax
    char* v6; // ebp
    char* v7; // edx
    char* i; // eax

    if (a1)
    {
        *(_DWORD*)a1 = *(_DWORD*)a2;
        *(_DWORD*)(a1 + 4) = *(_DWORD*)(a2 + 4);
        *(_DWORD*)(a1 + 8) = *(_DWORD*)(a2 + 8);
        *(_DWORD*)(a1 + 12) = *(_DWORD*)(a2 + 12);
        *(_DWORD*)(a1 + 16) = *(_DWORD*)(a2 + 16);
        *(_DWORD*)(a1 + 20) = *(_DWORD*)(a2 + 20);
        *(_BYTE*)(a1 + 24) = *(_BYTE*)(a2 + 24);
        v2 = *(_DWORD*)(a2 + 28);
        if (v2)
            v3 = (*(_DWORD*)(a2 + 32) - v2) / 268;
        else
            v3 = 0;
        v4 = v3;
        if (v3 < 0)
            v4 = 0;
        v5 = (char*)operator new(268 * v4);
        *(_DWORD*)(a1 + 28) = v5;
        v6 = *(char**)(a2 + 32);
        v7 = v5;
        for (i = *(char**)(a2 + 28); i != v6; v7 += 268)
        {
            if (v7)
                qmemcpy(v7, i, 0x10Cu);
            i += 268;
        }
        *(_DWORD*)(a1 + 32) = v7;
        *(_DWORD*)(a1 + 36) = v7;
    }
}

//----- (0044F490) --------------------------------------------------------
_DWORD* __thiscall sub_44F490(_DWORD* this, _DWORD* a2)
{
    _DWORD* v3; // edi
    char* v4; // esi
    unsigned int v5; // ebx
    int v6; // ecx
    unsigned int v7; // edx
    char* v8; // ebx
    char* v9; // eax
    char* v10; // edx
    const void* v11; // esi
    void* v12; // edi
    int v13; // eax
    int v14; // edx
    _DWORD* result; // eax
    unsigned int v16; // ebx
    unsigned int v17; // edx
    int v18; // edx
    char* v19; // ebx
    char* v20; // eax
    char* v21; // edx
    const void* v22; // esi
    void* v23; // edi
    char* v24; // ecx
    _DWORD* v25; // esi
    char* v26; // ebx
    char* j; // eax
    int v28; // eax
    int v29; // edx
    int v30; // eax
    int v31; // edx
    int v32; // eax
    char* v33; // eax
    char* v34; // ebx
    char* v35; // edx
    char* i; // eax
    char* v38; // [esp+18h] [ebp+4h]

    v3 = this;
    if (this == a2)
        return v3;
    v4 = (char*)a2[1];
    if (v4)
        v5 = (a2[2] - (int)v4) / 268;
    else
        v5 = 0;
    v6 = this[1];
    if (v6)
        v7 = (v3[2] - v6) / 268;
    else
        v7 = 0;
    if (v5 <= v7)
    {
        v8 = (char*)a2[2];
        v9 = (char*)a2[1];
        v10 = (char*)v3[1];
        if (v4 != v8)
        {
            do
            {
                v11 = v9;
                v12 = v10;
                v9 += 268;
                v10 += 268;
                qmemcpy(v12, v11, 0x10Cu);
            } while (v9 != v8);
            v3 = this;
        }
        v13 = a2[1];
        if (v13)
            v14 = (a2[2] - v13) / 268;
        else
            v14 = 0;
        v3[2] = v3[1] + 268 * v14;
        return v3;
    }
    if (v4)
        v16 = (a2[2] - (int)v4) / 268;
    else
        v16 = 0;
    if (v6)
        v17 = (v3[3] - v6) / 268;
    else
        v17 = 0;
    if (v16 > v17)
    {
        sub_4885A6((LPVOID)v3[1]);
        v30 = a2[1];
        if (v30)
            v31 = (a2[2] - v30) / 268;
        else
            v31 = 0;
        v32 = v31;
        if (v31 < 0)
            v32 = 0;
        v33 = (char*)operator new(268 * v32);
        v3[1] = v33;
        v34 = (char*)a2[2];
        v35 = v33;
        for (i = (char*)a2[1]; i != v34; v35 += 268)
        {
            if (v35)
            {
                qmemcpy(v35, i, 0x10Cu);
                v3 = this;
            }
            i += 268;
        }
        v3[2] = v35;
        v3[3] = v35;
        return v3;
    }
    if (v6)
        v18 = (v3[2] - v6) / 268;
    else
        v18 = 0;
    v19 = (char*)v3[1];
    v20 = (char*)a2[1];
    v21 = &v4[268 * v18];
    if (v4 != v21)
    {
        do
        {
            v22 = v20;
            v23 = v19;
            v20 += 268;
            v19 += 268;
            qmemcpy(v23, v22, 0x10Cu);
        } while (v20 != v21);
    }
    v25 = this;
    v38 = (char*)a2[2];
    v24 = v38;
    v26 = (char*)this[2];
    for (j = v21; j != v24; v26 += 268)
    {
        if (v26)
        {
            qmemcpy(v26, j, 0x10Cu);
            v24 = v38;
            v25 = this;
        }
        j += 268;
    }
    v28 = a2[1];
    if (v28)
        v29 = (a2[2] - v28) / 268;
    else
        v29 = 0;
    result = v25;
    v25[2] = v25[1] + 268 * v29;
    return result;
}

//----- (0044F6F0) --------------------------------------------------------
char __thiscall sub_44F6F0(int this)
{
    char result; // al
    __time32_t v3; // eax
    _BYTE* v4; // eax
    int v5; // eax
    double v6; // st7
    int v7; // ecx
    _BYTE* v8; // eax
    double v9; // st7
    int v10; // eax
    double v11; // st6
    int v12; // ecx
    _BYTE* v13; // eax
    int v14; // eax

    *(_DWORD*)(this + 172) = 0;
    *(_DWORD*)(this + 176) = 0;
    *(_DWORD*)(this + 184) = 0;
    *(_DWORD*)(this + 188) = 0;
    *(_DWORD*)(this + 192) = 0;
    *(_BYTE*)(this + 196) = 0;
    *(_DWORD*)(this + 200) = 0;
    *(_DWORD*)(this + 204) = 0;
    *(_DWORD*)(this + 208) = 0;
    *(_DWORD*)(this + 212) = 0;
    *(_DWORD*)(this + 216) = 0;
    *(_DWORD*)(this + 220) = 0;
    *(_DWORD*)(this + 224) = 0;
    *(_DWORD*)(this + 228) = 0;
    *(_DWORD*)(this + 232) = 0;
    *(_DWORD*)(this + 236) = 0;
    *(_DWORD*)(this + 240) = 0;
    *(_DWORD*)(this + 244) = 0;
    *(_DWORD*)(this + 248) = 0;
    *(_DWORD*)(this + 252) = 0;
    *(_DWORD*)(this + 256) = 0;
    *(_DWORD*)(this + 260) = 0;
    *(_DWORD*)(this + 264) = 0;
    *(_DWORD*)(this + 268) = 0;
    *(_DWORD*)(this + 272) = 0;
    *(_DWORD*)(this + 276) = 0;
    *(_DWORD*)(this + 280) = 0;
    *(_DWORD*)(this + 284) = 0;
    *(_DWORD*)(this + 288) = 0;
    *(_DWORD*)(this + 292) = 0;
    *(_BYTE*)(this + 296) = 0;
    *(_DWORD*)(this + 312) = 0;
    *(_DWORD*)(this + 308) = 0;
    *(_DWORD*)(this + 304) = 0;
    *(_DWORD*)(this + 300) = 0;
    *(_DWORD*)(this + 316) = 0;
    result = sub_408D20(this);
    if (result)
    {
        v3 = time(0);
        srand(v3);
        sub_421810(*(_DWORD*)(this + 132), off_4A70F0, (int)&unk_4A70F8, 0);
        sub_421810(*(_DWORD*)(this + 132), off_4A7B78, (int)&unk_4A7B80, (int)&unk_4A8600);
        sub_421810(*(_DWORD*)(this + 132), off_4A90B8, (int)&unk_4A90C0, (int)&unk_4A9B40);
        v4 = sub_409AD0((int*)this, 1, 0x80u);
        *(_DWORD*)(this + 300) = v4;
        sub_421300((int)v4, 0xFFu, 0xFFu, 0xFFu, 255);
        sub_421370(*(_DWORD**)(this + 300), 0, 0, 0, 255);
        *(_BYTE*)(*(_DWORD*)(this + 300) + 35) = 1;
        v5 = *(_DWORD*)(this + 300);
        v6 = (double)(unsigned int)dword_5209F4;
        *(_DWORD*)(v5 + 16) = 1097859072;
        *(_BYTE*)(v5 + 32) = 1;
        *(float*)(v5 + 12) = v6 * 0.5;
        *(_DWORD*)(*(_DWORD*)(this + 300) + 20) = 1148813312;
        v7 = *(_DWORD*)(this + 300);
        *(_BYTE*)(v7 + 33) = 1;
        sub_421540((void**)v7);
        v8 = sub_409AD0((int*)this, 1, 0x80u);
        *(_DWORD*)(this + 304) = v8;
        sub_421300((int)v8, 0xFFu, 0xFFu, 0xFFu, 255);
        sub_421370(*(_DWORD**)(this + 304), 0, 0, 0, 255);
        *(_BYTE*)(*(_DWORD*)(this + 304) + 35) = 1;
        v9 = (double)(unsigned int)dword_5209D8 * 0.5;
        v10 = *(_DWORD*)(this + 304);
        v11 = (double)(unsigned int)dword_5209F4;
        *(_BYTE*)(v10 + 32) = 1;
        *(float*)(v10 + 12) = v11 * 0.5;
        *(float*)(v10 + 16) = v9;
        *(_DWORD*)(*(_DWORD*)(this + 304) + 20) = 1148813312;
        v12 = *(_DWORD*)(this + 304);
        *(_BYTE*)(v12 + 33) = 1;
        sub_421540((void**)v12);
        v13 = sub_409AD0((int*)this, 2, 0x80u);
        *(_DWORD*)(this + 308) = v13;
        sub_421300((int)v13, 0xFFu, 0xFFu, 0xFFu, 178);
        *(_BYTE*)(this + 168) = 1;
        v14 = sub_450BF0((_DWORD*)this, 1, 1082130432);
        sub_421110(v14, aLoading);
        return 1;
    }
    return result;
}
// 4A70F0: using guessed type char *off_4A70F0;
// 4A7B78: using guessed type char *off_4A7B78;
// 4A90B8: using guessed type char *off_4A90B8;
// 5209D8: using guessed type int dword_5209D8;
// 5209F4: using guessed type int dword_5209F4;

//----- (0044F9E0) --------------------------------------------------------
char __thiscall sub_44F9E0(int this)
{
    char* v2; // eax
    char* v3; // esi
    void* v4; // eax
    int v5; // eax
    _DWORD* v6; // eax
    _DWORD* v7; // eax
    void* v8; // eax
    void* v9; // eax
    _DWORD* v10; // eax
    _DWORD* v11; // eax
    _DWORD* v12; // eax
    _DWORD* v13; // eax
    _DWORD* v14; // eax
    _DWORD* v15; // eax
    double v16; // st7
    _BYTE* v17; // eax
    _BYTE* v18; // eax
    void* v19; // eax
    void* v20; // eax
    void* v21; // eax
    int v22; // eax
    void* v23; // eax
    void* v24; // eax
    void* v25; // eax
    _DWORD* v26; // eax
    char* v27; // eax
    int v28; // esi
    _DWORD* v29; // eax
    _BYTE* v30; // eax
    int v31; // ecx
    int v32; // eax
    double v33; // st7
    double v34; // st6
    _BYTE* v35; // eax
    int v36; // ecx
    int v37; // eax
    double v38; // st7
    double v39; // st6
    _BYTE* v40; // eax
    int v41; // ecx
    double v42; // st7
    int v43; // eax
    double v44; // st6
    void* v45; // eax
    int v46; // eax
    _DWORD* v47; // ecx
    _DWORD* v48; // eax
    _DWORD* v49; // eax
    int v50; // eax
    _DWORD* v51; // eax
    _DWORD* v52; // eax
    int v53; // eax
    _DWORD* v54; // eax
    _DWORD* v55; // eax
    int v56; // edx
    int v57; // eax
    int v58; // ecx
    int v59; // ecx
    void* v60; // eax
    int v61; // eax
    _DWORD* v62; // eax
    int* v63; // eax
    int v64; // edx
    _DWORD* v65; // eax
    _DWORD* v66; // eax
    _DWORD* v67; // eax
    _DWORD* v68; // eax
    void* v69; // eax
    int v70; // eax
    _DWORD* v71; // eax
    int* v72; // eax
    int v73; // edx
    int v74; // edx
    float v76; // [esp+14h] [ebp-50h]
    float v77; // [esp+18h] [ebp-4Ch]
    int v78; // [esp+1Ch] [ebp-48h]
    char v79; // [esp+27h] [ebp-3Dh]
    char* String1; // [esp+28h] [ebp-3Ch]
    int v81; // [esp+2Ch] [ebp-38h] BYREF
    int v82; // [esp+30h] [ebp-34h] BYREF
    DWORD Time; // [esp+34h] [ebp-30h]
    __int64 v84; // [esp+38h] [ebp-2Ch] BYREF
    int v85; // [esp+40h] [ebp-24h] BYREF
    LPVOID lpMem[2]; // [esp+44h] [ebp-20h] BYREF
    int v87; // [esp+4Ch] [ebp-18h]
    LPVOID v88[2]; // [esp+50h] [ebp-14h] BYREF
    int v89; // [esp+60h] [ebp-4h]

    if (*(_BYTE*)(this + 168))
    {
        *(_BYTE*)(this + 168) = 0;
        Time = timeGetTime();
        v2 = (char*)operator new(0x3ECu);
        v82 = (int)v2;
        v89 = 0;
        if (v2)
            v3 = sub_40F510(v2);
        else
            v3 = 0;
        v89 = -1;
        std::codecvt_base::do_always_noconv((std::codecvt_base*)v3);
        sub_428680((_DWORD*)this, (int)v3);
        sub_4113F0((_DWORD*)dword_4F5CC4, this, 65280, 0, 1);
        sub_411EE0(dword_4F5CC4, &v85, (_DWORD*)&v84 + 1, &v84);
        *(_DWORD*)(this + 192) = 0;
        *(_BYTE*)(this + 196) = 0;
        v4 = operator new(0x30u);
        v82 = (int)v4;
        v89 = 1;
        if (v4)
            v5 = sub_468A00((int)v4, this);
        else
            v5 = 0;
        v89 = -1;
        *(_DWORD*)(this + 260) = v5;
        sub_428680((_DWORD*)this, v5);
        *(_DWORD*)(this + 288) = 0;
        v6 = operator new(0x2E18u);
        v82 = (int)v6;
        v89 = 2;
        if (v6)
            v7 = sub_45DF90(v6);
        else
            v7 = 0;
        v89 = -1;
        *(_DWORD*)(this + 280) = v7;
        v8 = operator new(0x13Cu);
        v82 = (int)v8;
        v89 = 3;
        if (v8)
            v9 = sub_4694A0(v8);
        else
            v9 = 0;
        v89 = -1;
        *(_DWORD*)(this + 200) = v9;
        sub_4697A0((int)v9);
        v10 = operator new(0x34u);
        v82 = (int)v10;
        v89 = 4;
        if (v10)
            v11 = sub_403180(v10);
        else
            v11 = 0;
        v89 = -1;
        *(_DWORD*)(this + 204) = v11;
        v12 = operator new(0x43360u);
        v82 = (int)v12;
        v89 = 5;
        if (v12)
            v13 = sub_449AE0(v12);
        else
            v13 = 0;
        v89 = -1;
        *(_DWORD*)(this + 276) = v13;
        sub_449B70(v13);
        v14 = operator new(0xF0u);
        v82 = (int)v14;
        v89 = 6;
        if (v14)
            v15 = sub_458CF0(v14);
        else
            v15 = 0;
        v89 = -1;
        *(_DWORD*)(this + 236) = v15;
        sub_458EE0((int)v15);
        v16 = sub_468BE0((int*)*(_DWORD*)(this + 260), 0, 0, 0);
        lpMem[0] = 0;
        lpMem[1] = 0;
        *(float*)&v87 = v16 + 120.0;
        sub_45E2A0(*(_DWORD*)(this + 280), this, *(_DWORD*)(this + 276), 0, 0, v87);
        sub_408EF0(this, *(_DWORD*)(this + 280));
        *(_DWORD*)(this + 272) = 0;
        v17 = operator new(0x19Cu);
        v82 = (int)v17;
        v89 = 7;
        if (v17)
            v18 = sub_455750(v17);
        else
            v18 = 0;
        v89 = -1;
        *(_DWORD*)(this + 216) = v18;
        sub_455830(v18);
        *(_DWORD*)(this + 256) = -1;
        v19 = operator new(0x38u);
        v82 = (int)v19;
        v89 = 8;
        if (v19)
            v20 = (void*)sub_42CA20((int)v19);
        else
            v20 = 0;
        v89 = -1;
        *(_DWORD*)(this + 208) = v20;
        sub_42CB00(v20);
        v21 = operator new(0x38u);
        v82 = (int)v21;
        v89 = 9;
        if (v21)
            v22 = sub_442440((int)v21);
        else
            v22 = 0;
        v89 = -1;
        *(_DWORD*)(this + 212) = v22;
        sub_442520(v22);
        v23 = operator new(0x24u);
        v82 = (int)v23;
        v89 = 10;
        if (v23)
            v24 = (void*)sub_465C10((int)v23);
        else
            v24 = 0;
        v89 = -1;
        *(_DWORD*)(this + 220) = v24;
        sub_465CD0(v24);
        sub_428680((_DWORD*)this, *(_DWORD*)(this + 204));
        v25 = operator new(0x1A8u);
        v82 = (int)v25;
        v89 = 11;
        if (v25)
            v26 = (_DWORD*)sub_40EC60((int)v25);
        else
            v26 = 0;
        v89 = -1;
        *(_DWORD*)(this + 264) = v26;
        sub_40ED70(v26, 0, -990248960, 1157234688, 0, 1110704128);
        sub_428680((_DWORD*)this, *(_DWORD*)(this + 264));
        *(_DWORD*)(this + 292) = 0;
        *(_DWORD*)(this + 288) = 0;
        String1 = 0;
        v79 = 0;
        if (dword_52233C <= 1)
            goto LABEL_139;
        String1 = *(char**)(dword_522340 + 4);
        if (!_strcmpi(String1, aViewer))
        {
            byte_520A70 = 0;
            sub_4282E0(dword_52233C > 2, aCorrectUsageVi);
            v27 = sub_4069C0(*(_DWORD*)(this + 128), this, *(char**)(dword_522340 + 8));
            *(_DWORD*)(this + 184) = v27;
            if (!v27)
                sub_4281B0("Viewer: Can't load model '%s'", *(const char**)(dword_522340 + 8));
            if (dword_52233C > 3)
            {
                v28 = 3;
                do
                    sub_403E80(*(_DWORD*)(this + 184), this, *(char**)(dword_522340 + 4 * v28++));
                while (v28 < dword_52233C);
            }
            v29 = sub_406A90(*(_DWORD*)(this + 184), 1);
            *(_DWORD*)(this + 188) = v29;
            if (v29)
            {
                v29[9] = 1065353216;
                sub_428680((_DWORD*)this, *(_DWORD*)(this + 188));
            }
            v30 = sub_409AD0((int*)this, 1, 0x100u);
            *(_DWORD*)(this + 288) = v30;
            sub_421300((int)v30, 0xFFu, 0xFFu, 0xFFu, 255);
            sub_421370(*(_DWORD**)(this + 288), 0, 0, 0, 255);
            *(_BYTE*)(*(_DWORD*)(this + 288) + 35) = 1;
            v31 = *(_DWORD*)(this + 288);
            *(_BYTE*)(v31 + 33) = 1;
            sub_421540((void**)v31);
            v32 = *(_DWORD*)(this + 288);
            *(_QWORD*)v88 = (unsigned int)(dword_5209D8 - 10);
            v33 = (double)*(__int64*)v88;
            *(_QWORD*)v88 = (unsigned int)dword_5209F4 >> 1;
            v34 = (double)*(__int64*)v88;
            *(_BYTE*)(v32 + 32) = 1;
            *(float*)(v32 + 12) = v34;
            *(float*)(v32 + 16) = v33;
            *(_DWORD*)(*(_DWORD*)(this + 288) + 20) = 1065353216;
        }
        if (!String1)
        {
        LABEL_139:
            if (sub_422AE0(aViewerIni))
            {
                v35 = sub_409AD0((int*)this, 1, 0x100u);
                *(_DWORD*)(this + 288) = v35;
                sub_421300((int)v35, 0xFFu, 0xFFu, 0, 255);
                sub_421370(*(_DWORD**)(this + 288), 0, 0, 0, 255);
                *(_BYTE*)(*(_DWORD*)(this + 288) + 35) = 1;
                v36 = *(_DWORD*)(this + 288);
                *(_BYTE*)(v36 + 33) = 0;
                sub_421540((void**)v36);
                *(_QWORD*)lpMem = (unsigned int)(dword_5209D8 - 10);
                v37 = *(_DWORD*)(this + 288);
                v38 = (double)*(__int64*)lpMem;
                *(_QWORD*)lpMem = (unsigned int)dword_5209F4 >> 1;
                v39 = (double)*(__int64*)lpMem;
                *(_BYTE*)(v37 + 32) = 1;
                *(float*)(v37 + 12) = v39;
                *(float*)(v37 + 16) = v38;
                v40 = sub_409AD0((int*)this, 1, 0x100u);
                *(_DWORD*)(this + 292) = v40;
                sub_421300((int)v40, 0xFFu, 0xFFu, 0xFFu, 255);
                sub_421370(*(_DWORD**)(this + 292), 0, 0, 0, 255);
                *(_BYTE*)(*(_DWORD*)(this + 292) + 35) = 1;
                v41 = *(_DWORD*)(this + 292);
                *(_BYTE*)(v41 + 33) = 0;
                sub_421540((void**)v41);
                *(_QWORD*)lpMem = (unsigned int)(dword_5209D8 - 30);
                v42 = (double)*(__int64*)lpMem;
                *(_QWORD*)lpMem = (unsigned int)dword_5209F4 >> 1;
                v43 = *(_DWORD*)(this + 292);
                v44 = (double)*(__int64*)lpMem;
                *(_BYTE*)(v43 + 32) = 1;
                *(float*)(v43 + 12) = v44;
                *(float*)(v43 + 16) = v42;
                *(_DWORD*)(*(_DWORD*)(this + 292) + 20) = 1065353216;
                v45 = operator new(0x120u);
                v82 = (int)v45;
                v89 = 12;
                if (v45)
                    v46 = sub_40A1D0((int)v45, aViewerIni);
                else
                    v46 = 0;
                v47 = *(_DWORD**)(this + 264);
                v89 = -1;
                *(_DWORD*)(this + 172) = v46;
                *(_DWORD*)(this + 176) = 0;
                sub_40ED70(v47, 1184901120, 0, 1114636288, -1036779520, 1119092736);
                if (sub_40AAF0(*(_DWORD**)(this + 172), aChasecam, 0))
                {
                    v48 = operator new(0x1A4u);
                    lpMem[0] = v48;
                    v89 = 13;
                    if (v48)
                        v49 = sub_4024C0(v48);
                    else
                        v49 = 0;
                    v89 = -1;
                    *(_DWORD*)(this + 268) = v49;
                    sub_428680((_DWORD*)this, (int)v49);
                    sub_40AA40(*(_DWORD*)(this + 172), aChasecam);
                    sub_40AF60(*(const char**)(this + 172), aRadius_0, (float*)&v82);
                    sub_40AF60(*(const char**)(this + 172), aZrange, (float*)&v81);
                    sub_402670(*(_DWORD**)(this + 268), v82, v81);
                }
                sub_450D30((_DWORD*)this, this);
                (*(void(__thiscall**)(_DWORD, _DWORD))(**(_DWORD**)(this + 260) + 24))(*(_DWORD*)(this + 260), 0);
            }
        }
        if (*(_DWORD*)(this + 184))
        {
            v50 = *(_DWORD*)(this + 268);
            if (!v50)
                v50 = *(_DWORD*)(this + 264);
            sub_408EF0(this, v50);
            *(_DWORD*)(this + 272) = 1;
        }
        v51 = operator new(0x28u);
        lpMem[0] = v51;
        v89 = 14;
        if (v51)
            v52 = sub_464730(v51);
        else
            v52 = 0;
        v89 = -1;
        *(_DWORD*)(this + 252) = v52;
        sub_464810(v52, this, 0, 1);
        sub_428680((_DWORD*)this, *(_DWORD*)(this + 252));
        v53 = *(_DWORD*)(this + 184);
        *(_DWORD*)(this + 284) = 0;
        if (v53)
        {
            v54 = operator new(0x44u);
            lpMem[0] = v54;
            v89 = 15;
            if (v54)
                v55 = sub_409B10(v54);
            else
                v55 = 0;
            v89 = -1;
            *(_DWORD*)(this + 284) = v55;
            sub_409BE0((int)v55, 0, this, 1065353216, -1, -5000.0, 5000.0, -5000.0, 5000.0, 50.0, -8355712, v76, v77, v78);
            sub_428680((_DWORD*)this, *(_DWORD*)(this + 284));
            LOBYTE(v56) = *(_DWORD*)(this + 172) == 0;
            v57 = (*(int(__thiscall**)(_DWORD, int))(**(_DWORD**)(this + 284) + 24))(*(_DWORD*)(this + 284), v56);
            v58 = *(_DWORD*)(this + 260);
            if (v58)
                v57 = (*(int(__thiscall**)(int, _DWORD))(*(_DWORD*)v58 + 24))(v58, 0);
            v59 = *(_DWORD*)(this + 252);
            if (v59)
            {
                LOBYTE(v57) = *(_DWORD*)(this + 172) != 0;
                (*(void(__thiscall**)(int, int))(*(_DWORD*)v59 + 24))(v59, v57);
            }
        }
        else
        {
            v60 = operator new(0x2E4u);
            lpMem[0] = v60;
            v89 = 16;
            if (v60)
                v61 = sub_434270((int)v60);
            else
                v61 = 0;
            *(_DWORD*)(this + 224) = v61;
            v89 = -1;
            *(_BYTE*)(v61 + 40) = 0;
            v62 = operator new(0x34u);
            lpMem[0] = v62;
            v89 = 17;
            if (v62)
                v63 = sub_43A180(v62);
            else
                v63 = 0;
            *(_DWORD*)(this + 228) = v63;
            v64 = *v63;
            v89 = -1;
            (*(void(__thiscall**)(int*, _DWORD))(v64 + 24))(v63, 0);
            v65 = operator new(0x5Cu);
            lpMem[0] = v65;
            v89 = 18;
            if (v65)
                v66 = sub_4243A0(v65);
            else
                v66 = 0;
            v89 = -1;
            *(_DWORD*)(this + 232) = v66;
            v67 = operator new(0x77E4u);
            lpMem[0] = v67;
            v89 = 19;
            if (v67)
                v68 = sub_44C9D0(v67);
            else
                v68 = 0;
            v89 = -1;
            *(_DWORD*)(this + 240) = v68;
            sub_44CB20((int)v68);
            v69 = operator new(0x54u);
            lpMem[0] = v69;
            v89 = 20;
            if (v69)
                v70 = sub_414CF0((int)v69);
            else
                v70 = 0;
            v89 = -1;
            *(_DWORD*)(this + 244) = v70;
            sub_414E60(v70);
            v71 = operator new(0x1F8u);
            lpMem[0] = v71;
            v89 = 21;
            if (v71)
                v72 = sub_4385C0(v71);
            else
                v72 = 0;
            *(_DWORD*)(this + 248) = v72;
            v73 = *v72;
            v89 = -1;
            (*(void(__thiscall**)(int*, _DWORD))(v73 + 24))(v72, 0);
            if (*(_DWORD*)(this + 236))
                sub_428680((_DWORD*)this, *(_DWORD*)(this + 236));
            if (*(_DWORD*)(this + 224))
                sub_428680((_DWORD*)this, *(_DWORD*)(this + 224));
            if (*(_DWORD*)(this + 232))
                sub_428680((_DWORD*)this, *(_DWORD*)(this + 232));
            if (*(_DWORD*)(this + 228))
                sub_428680((_DWORD*)this, *(_DWORD*)(this + 228));
            if (*(_DWORD*)(this + 200))
                sub_428680((_DWORD*)this, *(_DWORD*)(this + 200));
            if (*(_DWORD*)(this + 276))
                sub_428680((_DWORD*)this, *(_DWORD*)(this + 276));
            if (*(_DWORD*)(this + 280))
                sub_428680((_DWORD*)this, *(_DWORD*)(this + 280));
            if (*(_DWORD*)(this + 244))
                sub_428680((_DWORD*)this, *(_DWORD*)(this + 244));
            if (*(_DWORD*)(this + 216))
                sub_428680((_DWORD*)this, *(_DWORD*)(this + 216));
            if (*(_DWORD*)(this + 212))
                sub_428680((_DWORD*)this, *(_DWORD*)(this + 212));
            if (*(_DWORD*)(this + 220))
                sub_428680((_DWORD*)this, *(_DWORD*)(this + 220));
            if (*(_DWORD*)(this + 208))
                sub_428680((_DWORD*)this, *(_DWORD*)(this + 208));
            if (*(_DWORD*)(this + 240))
                sub_428680((_DWORD*)this, *(_DWORD*)(this + 240));
            if (*(_DWORD*)(this + 248))
                sub_428680((_DWORD*)this, *(_DWORD*)(this + 248));
            sub_40A0F0();
            *(_DWORD*)(this + 60) = timeGetTime();
            if (String1)
            {
                if (_strcmpi(String1, aRunmission))
                {
                    if (_strcmpi(String1, aHost_0))
                    {
                        if (_strcmpi(String1, aJoin_0))
                        {
                            _strcmpi(String1, aTakeback);
                        }
                        else
                        {
                            *(_BYTE*)(this + 320) = 1;
                            sub_4282E0(dword_52233C == 4, aCorrectUsageJo);
                            strcpy((char*)(dword_4F5CC4 + 140), *(const char**)(dword_522340 + 8));
                            v74 = dword_522340;
                            strcpy(byte_520C3C, *(const char**)(dword_522340 + 12));
                            sub_43EFC0((void*)dword_4F5CC4, v88, *(const CHAR**)(v74 + 12), 52973);
                            v89 = 23;
                            if (v88[0])
                                sub_4281B0("Unable to Connect to '%s': '%s'", *(const char**)(dword_522340 + 12), (const char*)v88[1]);
                            sub_4261C0(*(_DWORD**)(this + 232), aConnecting, 0);
                            v79 = 1;
                            v89 = -1;
                            sub_488CEE(v88[1]);
                        }
                    }
                    else
                    {
                        *(_BYTE*)(this + 320) = 1;
                        sub_4282E0(dword_52233C == 3, aCorrectUsageHo);
                        strcpy((char*)(dword_4F5CC4 + 140), *(const char**)(dword_522340 + 8));
                        sub_43EF90((void*)dword_4F5CC4, lpMem, 52973);
                        v89 = 22;
                        if (lpMem[0])
                            sub_4281B0("Unable to Host: '%s'", (const char*)lpMem[1]);
                        *(_BYTE*)(dword_4F5CC4 + 108) = 1;
                        sub_4261C0(*(_DWORD**)(this + 232), aStaging, 0);
                        v79 = 1;
                        v89 = -1;
                        sub_488CEE(lpMem[1]);
                    }
                }
                if (!v79)
                    sub_4281B0("Invalid Command Line Argument '%s'", String1);
            }
            else
            {
                sub_4261C0(*(_DWORD**)(this + 232), aMainmenu, 1);
            }
            sub_4227C0(*(_DWORD**)(this + 124));
        }
        *(_QWORD*)lpMem = timeGetTime() - Time;
        sub_4229D0("Load time = %f secs", (double)*(__int64*)lpMem * 0.001);
    }
    return 1;
}
// 450252: variable 'v76' is possibly undefined
// 450252: variable 'v77' is possibly undefined
// 450252: variable 'v78' is possibly undefined
// 450279: variable 'v56' is possibly undefined
// 4F5CC4: using guessed type int dword_4F5CC4;
// 5209D8: using guessed type int dword_5209D8;
// 5209F4: using guessed type int dword_5209F4;
// 520A70: using guessed type char byte_520A70;
// 52233C: using guessed type int dword_52233C;
// 522340: using guessed type int dword_522340;

//----- (00450790) --------------------------------------------------------
void __thiscall sub_450790(_DWORD* this)
{
    _DWORD* v2; // ecx

    if (!this[46])
        sub_45ABF0(*(_DWORD*)(dword_520970 + 236));
    sub_408EE0(this);
    v2 = (_DWORD*)this[46];
    if (v2)
    {
        sub_403B70(v2);
        this[46] = 0;
    }
}
// 520970: using guessed type int dword_520970;

//----- (004507D0) --------------------------------------------------------
char __thiscall sub_4507D0(int this, int a2)
{
    int v4; // eax
    int v5; // ecx
    int v6; // ecx
    int v7; // ecx
    _DWORD* v8; // ecx
    double v10; // st7
    int v11; // ecx
    double v12; // st7
    int v13; // eax
    int v14; // ecx
    int v15; // [esp+4h] [ebp-28h]
    float v16; // [esp+Ch] [ebp-20h]
    int v17; // [esp+1Ch] [ebp-10h]
    int v18[3]; // [esp+20h] [ebp-Ch] BYREF
    float v19; // [esp+30h] [ebp+4h]
    float v20; // [esp+30h] [ebp+4h]

    if (*(_BYTE*)(this + 168))
        return sub_428620((_DWORD*)this, a2);
    v4 = *(_DWORD*)(this + 232);
    if (v4)
    {
        v5 = *(_DWORD*)(this + 300);
        *(_BYTE*)(v5 + 33) = *(_DWORD*)(v4 + 52) == 0;
        sub_421540((void**)v5);
        v6 = *(_DWORD*)(this + 304);
        *(_BYTE*)(v6 + 33) = *(_DWORD*)(*(_DWORD*)(this + 232) + 52) == 0;
        sub_421540((void**)v6);
        v7 = *(_DWORD*)(this + 308);
        *(_BYTE*)(v7 + 33) = *(_DWORD*)(*(_DWORD*)(this + 232) + 52) == 0;
        sub_421540((void**)v7);
    }
    if (*(_BYTE*)(this + 196))
        *(float*)(this + 192) = *(float*)&a2 * 30.0 + *(float*)(this + 192);
    v8 = *(_DWORD**)(this + 188);
    if (v8)
    {
        sub_4074B0(v8, 0);
        v16 = *(float*)(this + 192) * 0.017453292;
        sub_4075B0(*(_DWORD**)(this + 188), 0, v16);
        if (*(_DWORD*)(this + 172))
            v10 = 20000.0;
        else
            v10 = 0.0;
        v11 = *(_DWORD*)(this + 260);
        v17 = (__int64)v10;
        if (!v11
            || !*(_BYTE*)(v11 + 16)
            || (v19 = (float)v17, sub_468BE0((int*)v11, SLODWORD(v19), 0, 0) <= -3.4028235e38)
            || (v12 = sub_468BE0((int*)*(_DWORD*)(this + 260), SLODWORD(v19), 0, 0), v20 = v12, v12 == -3.4028235e38))
        {
            v20 = 0.0;
        }
        *(float*)&v15 = (float)v17;
        sub_407600(*(_DWORD**)(this + 188), 0, v15, 0, SLODWORD(v20));
        sub_414C80(*(_DWORD**)(this + 116), *(_DWORD*)(this + 188));
        v13 = sub_408880(*(_DWORD**)(this + 188));
        sub_421190(
            *(_DWORD*)(this + 288),
            "Model '%s' - Anim %d: %0.1f/%0.1f",
            (const char*)(*(_DWORD*)(this + 184) + 60),
            v13,
            *(float*)(*(_DWORD*)(this + 188) + 32),
            *(float*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 188) + 28) + 48)
                + 4 * *(_DWORD*)(*(_DWORD*)(this + 188) + 44)));
        v14 = *(_DWORD*)(this + 292);
        if (v14)
            sub_421110(v14, aUseAndToCycleA);
        if (*(_DWORD*)(this + 268))
        {
            sub_406D30(*(_DWORD*)(this + 188), *(float*)&a2);
            sub_4085B0(*(_DWORD*)(this + 188), *(_DWORD*)(this + 180), (int)v18);
            sub_402690(*(_DWORD**)(this + 268), v18[0], v18[1], v18[2]);
        }
    }
    return sub_428620((_DWORD*)this, a2);
}

//----- (00450A10) --------------------------------------------------------
char __thiscall sub_450A10(_DWORD* this, int a2, int a3)
{
    return sub_437180(this, a2, a3);
}

//----- (00450A30) --------------------------------------------------------
char __thiscall sub_450A30(int this, int a2)
{
    _DWORD* v4; // ecx

    if (*(_BYTE*)(this + 168))
        return sub_4285C0((_DWORD*)this, a2);
    if ((_BYTE)a2 == 27)
    {
        v4 = *(_DWORD**)(this + 232);
        if (v4)
        {
            if (!v4[13] && !*(_BYTE*)(*(_DWORD*)(this + 248) + 16) && !*(_BYTE*)(*(_DWORD*)(this + 228) + 16))
                sub_4261C0(v4, aIngamemenu, 0);
        }
    }
    return sub_4285C0((_DWORD*)this, a2);
}

//----- (00450AA0) --------------------------------------------------------
void __thiscall sub_450AA0(int** this, int a2, int a3)
{
    sub_468BE0(this[65], a2, a3, 0);
}

//----- (00450AC0) --------------------------------------------------------
int __thiscall sub_450AC0(int this, int a2, int a3)
{
    (*(void(__thiscall**)(_DWORD, bool))(**(_DWORD**)(this + 208) + 24))(*(_DWORD*)(this + 208), (_BYTE)a2 == 0);
    (*(void(__thiscall**)(_DWORD, bool))(**(_DWORD**)(this + 212) + 24))(*(_DWORD*)(this + 212), (_BYTE)a2 == 0);
    (*(void(__thiscall**)(_DWORD, bool))(**(_DWORD**)(this + 216) + 24))(*(_DWORD*)(this + 216), (_BYTE)a2 == 0);
    (*(void(__thiscall**)(_DWORD, bool))(**(_DWORD**)(this + 220) + 24))(*(_DWORD*)(this + 220), (_BYTE)a2 == 0);
    *(_BYTE*)(*(_DWORD*)(this + 224) + 40) = (_BYTE)a2 == 0;
    (*(void(__thiscall**)(_DWORD, bool))(**(_DWORD**)(this + 252) + 24))(*(_DWORD*)(this + 252), (_BYTE)a2 == 0);
    (*(void(__thiscall**)(_DWORD, bool))(**(_DWORD**)(this + 260) + 24))(*(_DWORD*)(this + 260), (_BYTE)a2 == 0);
    (*(void(__thiscall**)(_DWORD, bool))(**(_DWORD**)(this + 280) + 24))(*(_DWORD*)(this + 280), (_BYTE)a2 == 0);
    (*(void(__thiscall**)(_DWORD, bool))(**(_DWORD**)(this + 236) + 24))(*(_DWORD*)(this + 236), (_BYTE)a2 == 0);
    (*(void(__thiscall**)(_DWORD, int))(**(_DWORD**)(this + 248) + 24))(*(_DWORD*)(this + 248), a2);
    if (!(_BYTE)a2)
        return sub_408EF0(this, *(_DWORD*)(this + 280));
    (*(void(__thiscall**)(_DWORD, int))(**(_DWORD**)(this + 264) + 24))(*(_DWORD*)(this + 264), 1);
    sub_408EF0(this, *(_DWORD*)(this + 264));
    if (a3 >= 0)
        return sub_439020(*(_DWORD*)(this + 248), a3);
    else
        return sub_438FF0(*(_DWORD**)(this + 248));
}

//----- (00450BB0) --------------------------------------------------------
char __thiscall sub_450BB0(_DWORD* this)
{
    return *(_BYTE*)(this[62] + 16);
}

//----- (00450BC0) --------------------------------------------------------
BOOL sub_450BC0()
{
    return !*(_BYTE*)(dword_4F5CC4 + 936) && !*(_BYTE*)(dword_4F5CC4 + 937);
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (00450BF0) --------------------------------------------------------
int __thiscall sub_450BF0(_DWORD* this, int a2, int a3)
{
    int v5; // [esp+0h] [ebp-14h]

    if (*(float*)&a3 <= 0.0)
    {
        *(_DWORD*)(this[a2 + 75] + 64) = -1082130432;
        sub_4212C0(this[a2 + 75], 255);
    }
    else
    {
        *(float*)&v5 = *(float*)&a3 + 0.5;
        sub_421430((_DWORD*)this[a2 + 75], a3, v5, 255, 0);
    }
    return this[a2 + 75];
}

//----- (00450C70) --------------------------------------------------------
void __thiscall sub_450C70(_DWORD* this, int a2)
{
    unsigned int v2; // eax
    int v3; // ecx
    int v4; // esi
    int v5; // eax
    int v6; // esi
    int v7; // eax
    int v8; // eax
    const char* v9; // [esp-4h] [ebp-8h]

    v2 = *(unsigned __int16*)(a2 + 12);
    if (v2 > 2)
    {
        if (*(unsigned __int16*)(a2 + 12) >= 0xFF01u && *(unsigned __int16*)(a2 + 12) <= 0xFF03u)
        {
            v6 = *(_DWORD*)(a2 + 16);
            if (*(_WORD*)(a2 + 12) == 0xFF02 && !*(_DWORD*)(this[58] + 52))
            {
                v9 = (const char*)(*(_DWORD*)(v6 + 6) + 12);
                v7 = sub_436A90(this[56]);
                sub_421190(v7, "%s left the game", v9);
            }
            v8 = *(_DWORD*)(v6 + 6);
            if (v8)
            {
                sub_411BB0(dword_4F5CC4, *(_DWORD*)(v8 + 8));
                *(_DWORD*)(v6 + 6) = 0;
            }
        }
    }
    else if (v2 == 2)
    {
        v3 = this[56];
        v4 = *(_DWORD*)(a2 + 16);
        if (v3)
        {
            v5 = sub_436A90(v3);
            sub_421110(v5, (const char*)(v4 + 6));
        }
    }
    else if (v2 == 1)
    {
        this[6] = *(_DWORD*)(*(_DWORD*)(a2 + 16) + 6);
    }
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (00450D30) --------------------------------------------------------
int __usercall sub_450D30@<eax>(_DWORD* a1@<ecx>, int a2@<ebp>)
{
    int v3; // eax
    _DWORD* v4; // ecx
    char* v5; // eax
    const char* v6; // ecx
    int v7; // eax
    int i; // edi
    void(__thiscall * **v9)(_DWORD, int); // ecx
    _DWORD* v10; // eax
    char* v12; // [esp-8h] [ebp-54h]
    const char* v13; // [esp-4h] [ebp-50h]
    char ArgList[4]; // [esp+4h] [ebp-48h] BYREF
    char* String1; // [esp+8h] [ebp-44h] BYREF
    char Buffer[64]; // [esp+Ch] [ebp-40h] BYREF

    if ((int)a1[44] < 0)
        a1[44] = 0;
    sprintf(Buffer, "Model %d", a1[44] + 1);
    while (!sub_40AAF0((_DWORD*)a1[43], Buffer, 0))
    {
        if (!a1[44])
            sub_4281B0(aViewerIniDoesn);
        v3 = a1[44] - 1;
        a1[44] = v3;
        sprintf(Buffer, "Model %d", v3 + 1);
    }
    sub_40AA40(a1[43], Buffer);
    sub_40AFC0((void*)a1[43], aModel_0, ArgList);
    v4 = (_DWORD*)a1[46];
    if (v4)
    {
        sub_403B70(v4);
        a1[46] = 0;
    }
    v5 = sub_4069C0(a1[32], a2, *(char**)ArgList);
    v6 = *(const char**)ArgList;
    a1[46] = v5;
    sub_4282E0(v5 != 0, "Couldn't load model %s", v6);
    if (sub_40ABC0((_DWORD*)a1[43], aChasenode, 0))
    {
        sub_40AFC0((void*)a1[43], aChasenode, &String1);
        v7 = sub_405A30((_DWORD*)a1[46], String1, -1, 1);
        v13 = *(const char**)ArgList;
        v12 = String1;
        a1[45] = v7;
        sub_4282E0(v7 > -1, "Can't find node %s in model %s", v12, v13);
    }
    else
    {
        a1[45] = 0;
    }
    for (i = 1; ; ++i)
    {
        sprintf(Buffer, "Anim%d", i);
        if (!sub_40ABC0((_DWORD*)a1[43], Buffer, 0))
            break;
        sub_40AFC0((void*)a1[43], Buffer, &String1);
        if (sub_403E80(a1[46], a2, String1) < 0)
            sub_4281B0("Couldn't load animation %s", String1);
    }
    if (a1[47])
    {
        sub_4286C0(a1, a1[47]);
        v9 = (void(__thiscall***)(_DWORD, int))a1[47];
        if (v9)
            (**v9)(v9, 1);
    }
    v10 = sub_406A90(a1[46], 1);
    a1[47] = v10;
    if (!v10)
        sub_4281B0(aCouldnTCreateV);
    if (!a1[67])
        v10[9] = 1065353216;
    if (sub_408890((_DWORD**)a1[47]) > 1)
        sub_408860((_DWORD*)a1[47], 1);
    *(_BYTE*)(a1[47] + 48) = 1;
    return sub_428680(a1, a1[47]);
}

//----- (00450FB0) --------------------------------------------------------
void* __thiscall sub_450FB0(void* this, int a2, int a3, int a4)
{
    double v6; // st7
    double v7; // st6
    double v8; // st7
    float* v9; // ebp
    int v10; // ebx
    double v11; // st7
    int v13; // [esp+10h] [ebp-8h]
    float v14; // [esp+10h] [ebp-8h]
    int v15; // [esp+14h] [ebp-4h]
    int i; // [esp+1Ch] [ebp+4h]

    *((_DWORD*)this + 3) = a2;
    *(_DWORD*)this = operator new(4 * a2 * a2);
    sub_408680(
        a3,
        a4,
        (float*)this + 4,
        (float*)this + 5,
        (float*)this + 6,
        (float*)this + 7,
        (float*)this + 8,
        (float*)this + 9);
    v6 = (double)a2 - 1.0;
    if (v6 == 0.0)
        v7 = 1.0;
    else
        v7 = (*((float*)this + 5) - *((float*)this + 4)) / v6;
    *((float*)this + 1) = v7;
    if (v6 == 0.0)
        v8 = 1.0;
    else
        v8 = (*((float*)this + 7) - *((float*)this + 6)) / v6;
    *((float*)this + 2) = v8;
    v9 = *(float**)this;
    for (i = 0; i < a2; ++i)
    {
        v10 = 0;
        v13 = 0;
        *(float*)&v15 = (double)i * *((float*)this + 2) + *((float*)this + 6);
        do
        {
            v14 = (double)v13 * *((float*)this + 1) + *((float*)this + 4);
            v11 = sub_4081A0(a3, a4, v14, *(float*)&v15);
            if (v11 < -1.0)
                v11 = -1.0;
            *v9++ = v11;
            v13 = ++v10;
        } while (v10 < a2);
    }
    return this;
}

//----- (004510D0) --------------------------------------------------------
double __thiscall sub_4510D0(float* this, float a2, float a3)
{
    double v4; // st7
    double v5; // st7
    __int64 v6; // rax
    double v7; // st7
    double v8; // st7
    int v9; // edi
    int v10; // ecx
    float* v11; // ebp
    double v12; // st7
    int v13; // edi
    double v14; // st6
    int v15; // ecx
    double v16; // st5
    float* v17; // ecx
    double v18; // st5
    int v19; // edi
    double v20; // st4
    float* v21; // edx
    double v22; // st4
    double v23; // st3
    double v24; // st3
    double v25; // st3
    double v26; // st3
    double v27; // st3
    double v28; // st2
    double v29; // st2
    double v30; // st2
    double v31; // st1
    double v32; // st1
    double v33; // st1
    double result; // st7
    double v35; // st6
    int v36; // [esp+0h] [ebp-18h]
    float v37; // [esp+0h] [ebp-18h]
    int v38; // [esp+4h] [ebp-14h]
    float v39; // [esp+4h] [ebp-14h]
    float v40; // [esp+4h] [ebp-14h]
    float v41; // [esp+8h] [ebp-10h]
    float v42; // [esp+Ch] [ebp-Ch]
    float v43; // [esp+10h] [ebp-8h]
    float v44; // [esp+14h] [ebp-4h]
    float v45; // [esp+1Ch] [ebp+4h]
    float v46; // [esp+20h] [ebp+8h]

    if (a2 <= (double)this[4] || a2 >= (double)this[5] || a3 <= (double)this[6] || a3 >= (double)this[7])
        return -3.4028235e38;
    v4 = this[1];
    if (v4 == 0.0)
        v5 = 1.0;
    else
        v5 = (a2 - this[4]) / v4;
    v6 = (__int64)v5;
    v7 = this[2];
    if (v7 == 0.0)
        v8 = 1.0;
    else
        v8 = (a3 - this[6]) / v7;
    v38 = v6 + 1;
    v9 = *((_DWORD*)this + 3);
    v10 = (__int64)v8 * v9;
    v36 = (__int64)v8 + 1;
    *((float*)&v6 + 1) = *this;
    v11 = (float*)(*(_DWORD*)this + 4 * (v10 + v6));
    v42 = (double)(int)(__int64)v8 * this[2] + this[6];
    if (*v11 >= 0.0)
        v12 = *v11;
    else
        v12 = 0.0;
    v13 = v36 * v9;
    if (*(float*)(HIDWORD(v6) + 4 * (v13 + v6)) >= 0.0)
        v14 = *(float*)(HIDWORD(v6) + 4 * (v13 + v6));
    else
        v14 = 0.0;
    v15 = v38 + v10;
    v16 = *(float*)(HIDWORD(v6) + 4 * v15);
    v17 = (float*)(HIDWORD(v6) + 4 * v15);
    if (v16 >= 0.0)
        v18 = *v17;
    else
        v18 = 0.0;
    v19 = v38 + v13;
    v20 = *(float*)(HIDWORD(v6) + 4 * v19);
    v21 = (float*)(HIDWORD(v6) + 4 * v19);
    if (v20 >= 0.0)
        v22 = *v21;
    else
        v22 = 0.0;
    v23 = this[1];
    if (v23 == 0.0)
    {
        v24 = 0.0;
    }
    else
    {
        v41 = (double)(int)v6 * this[1] + this[4];
        v24 = (a2 - v41) / v23;
    }
    v39 = 1.0 - v24;
    v25 = this[2];
    if (v25 == 0.0)
        v26 = 0.0;
    else
        v26 = (a3 - v42) / v25;
    v27 = 1.0 - v26;
    v28 = this[1];
    if (v28 == 0.0)
    {
        v29 = 0.0;
    }
    else
    {
        v43 = (double)((int)v6 + 1) * this[1] + this[4];
        v29 = (v43 - a2) / v28;
    }
    v30 = 1.0 - v29;
    v31 = this[2];
    if (v31 == 0.0)
    {
        v32 = 0.0;
    }
    else
    {
        v44 = (double)v36 * this[2] + this[6];
        v32 = (v44 - a3) / v31;
    }
    v33 = 1.0 - v32;
    v37 = v27 * v39;
    v40 = v33 * v39;
    v46 = v30 * v27;
    v45 = v33 * v30;
    result = v12 * v37 + v40 * v14 + v46 * v18 + v45 * v22;
    v35 = v45 + v46 + v40 + v37;
    if (v35 != 0.0)
        return result / v35;
    return result;
}

//----- (00451390) --------------------------------------------------------
char* __thiscall sub_451390(char* this, char* FileName)
{
    _DWORD* v3; // edi
    _DWORD* v4; // ebx
    int v5; // esi
    int* v6; // eax
    int v7; // esi
    bool v8; // cc
    int v9; // edi
    int v10; // ebx
    char* v11; // edx
    unsigned int v12; // edi
    unsigned int v13; // kr04_4
    int v14; // esi
    int v15; // edi
    int v16; // ebx
    int v17; // eax
    int v18; // eax
    int v19; // eax
    int v20; // eax
    int v22; // [esp+10h] [ebp-334h]
    int i; // [esp+10h] [ebp-334h]
    int v24; // [esp+14h] [ebp-330h] BYREF
    char v25[288]; // [esp+18h] [ebp-32Ch] BYREF
    char Buffer[512]; // [esp+138h] [ebp-20Ch] BYREF
    int v27; // [esp+340h] [ebp-4h]

    *(_DWORD*)this = &off_499ADC;
    sub_4229D0(aStartedToLoadI);
    sub_40A1D0((int)v25, FileName);
    v3 = 0;
    v27 = 0;
    sub_40AA40((int)v25, aStrips);
    v4 = this + 4;
    sub_40AF00(v25, aNumstrips, (char**)this + 1);
    v5 = *((_DWORD*)this + 1);
    v6 = (int*)operator new(12 * v5 + 4);
    LOBYTE(v27) = 1;
    if (v6)
    {
        v3 = v6 + 1;
        *v6 = v5;
        `eh vector constructor iterator'(v6 + 1, 0xCu, v5, unknown_libname_27, (void (__thiscall *)(void *))sub_451710);
    }
    v7 = 0;
    v8 = *v4 <= 0;
    LOBYTE(v27) = 0;
    *((_DWORD*)this + 2) = v3;
    if (!v8)
    {
        v9 = 0;
        do
        {
            sub_40AFE0(v25, aStrip_0, (char**)(*((_DWORD*)this + 2) + v9));
            ++v7;
            v9 += 12;
        } while (v7 < *v4);
    }
    sub_40AF00(v25, aNumtextures, (char**)this + 3);
    *((_DWORD*)this + 4) = operator new(264 * *((_DWORD*)this + 3));
    v10 = 0;
    if (*((int*)this + 3) > 0)
    {
        v22 = 0;
        do
        {
            sprintf(Buffer, "texture%d", v10);
            sub_40AFC0(v25, Buffer, &v24);
            v11 = (char*)(*((_DWORD*)this + 4) + v22);
            v13 = strlen((const char*)v24) + 1;
            v12 = v24 + v13;
            qmemcpy(v11, (const void*)v24, 4 * (v13 >> 2));
            qmemcpy(&v11[4 * (v13 >> 2)], (const void*)(v12 - v13 + 4 * (v13 >> 2)), v13 & 3);
            v22 += 264;
            ++v10;
            *(_DWORD*)(v22 + *((_DWORD*)this + 4) - 4) = 0;
        } while (v10 < *((_DWORD*)this + 3));
    }
    v14 = 0;
    for (i = 0; i < *((_DWORD*)this + 1); ++i)
    {
        sub_40AA40((int)v25, *(char**)(v14 + *((_DWORD*)this + 2)));
        sub_40AF00(v25, aNumframes, (char**)(v14 + *((_DWORD*)this + 2) + 4));
        v15 = 0;
        *(_DWORD*)(v14 + *((_DWORD*)this + 2) + 8) = operator new(36 * *(_DWORD*)(v14 + *((_DWORD*)this + 2) + 4));
        if (*(int*)(v14 + *((_DWORD*)this + 2) + 4) > 0)
        {
            v16 = 0;
            do
            {
                sprintf(Buffer, "t%d", v15);
                sub_40AF00(v25, Buffer, (char**)(v16 + *(_DWORD*)(v14 + *((_DWORD*)this + 2) + 8)));
                sprintf(Buffer, "s%d", v15);
                v17 = *(_DWORD*)(v14 + *((_DWORD*)this + 2) + 8) + v16;
                sub_40B1F0(v25, Buffer, (float*)(v17 + 4), (float*)(v17 + 8));
                sprintf(Buffer, "o%d", v15);
                v18 = v16 + *(_DWORD*)(v14 + *((_DWORD*)this + 2) + 8);
                sub_40B1F0(v25, Buffer, (float*)(v18 + 12), (float*)(v18 + 16));
                sprintf(Buffer, "u%d", v15);
                v19 = *(_DWORD*)(v14 + *((_DWORD*)this + 2) + 8) + v16;
                sub_40B1D0(v25, Buffer, (float*)(v19 + 20), (float*)(v19 + 28));
                sprintf(Buffer, "v%d", v15);
                v20 = *(_DWORD*)(v14 + *((_DWORD*)this + 2) + 8) + v16;
                sub_40B1D0(v25, Buffer, (float*)(v20 + 24), (float*)(v20 + 32));
                ++v15;
                v16 += 36;
            } while (v15 < *(_DWORD*)(v14 + *((_DWORD*)this + 2) + 4));
        }
        v14 += 12;
    }
    sub_4229D0(aFinishedLoadin_3);
    v27 = -1;
    sub_40A830((int)v25);
    return this;
}
// 499ADC: using guessed type _UNKNOWN *off_499ADC;

//----- (00451710) --------------------------------------------------------
void __thiscall sub_451710(LPVOID* this)
{
    if (*this)
    {
        sub_4885A6(*this);
        *this = 0;
    }
    if (this[2])
    {
        sub_4885A6(this[2]);
        this[2] = 0;
    }
}

//----- (00451770) --------------------------------------------------------
void __thiscall sub_451770(int this)
{
    char* v2; // eax
    char* v3; // edi

    v2 = *(char**)(this + 8);
    *(_DWORD*)this = &off_499ADC;
    if (v2)
    {
        v3 = v2 - 4;
        `eh vector destructor iterator'(v2, 0xCu, *((_DWORD *)v2 - 1), (void (__thiscall *)(void *))sub_451710);
            sub_4885A6(v3);
        *(_DWORD*)(this + 8) = 0;
    }
    sub_451820((_DWORD*)this);
    if (*(_DWORD*)(this + 16))
    {
        sub_4885A6(*(LPVOID*)(this + 16));
        *(_DWORD*)(this + 16) = 0;
    }
}
// 499ADC: using guessed type _UNKNOWN *off_499ADC;

//----- (004517D0) --------------------------------------------------------
int __thiscall sub_4517D0(_DWORD* this)
{
    int v2; // ebx
    int result; // eax
    int v4; // edi
    int v5; // eax

    v2 = 0;
    result = this[3];
    if (result > 0)
    {
        v4 = 0;
        do
        {
            v5 = v4 + this[4];
            if (!*(_DWORD*)(v5 + 260))
                *(_DWORD*)(this[4] + v4 + 260) = sub_422400(*(_DWORD**)(dword_520970 + 124), (char*)v5, 0);
            result = this[3];
            ++v2;
            v4 += 264;
        } while (v2 < result);
    }
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (00451820) --------------------------------------------------------
int __thiscall sub_451820(_DWORD* this)
{
    int v2; // ebx
    int result; // eax
    int v4; // edi
    int* v5; // ecx

    v2 = 0;
    result = this[3];
    if (result > 0)
    {
        v4 = 0;
        do
        {
            v5 = *(int**)(this[4] + v4 + 260);
            if (v5)
            {
                sub_422230(v5);
                *(_DWORD*)(this[4] + v4 + 260) = 0;
            }
            result = this[3];
            ++v2;
            v4 += 264;
        } while (v2 < result);
    }
    return result;
}

//----- (00451870) --------------------------------------------------------
int __thiscall sub_451870(_DWORD* this)
{
    sub_4517D0((_DWORD*)dword_5216EC[this[73]]);
    return sub_4690E0(this);
}
// 5216EC: using guessed type int dword_5216EC[3];

//----- (00451890) --------------------------------------------------------
int __thiscall sub_451890(_DWORD* this)
{
    sub_451820((_DWORD*)dword_5216EC[this[73]]);
    return sub_469120(this);
}
// 5216EC: using guessed type int dword_5216EC[3];

//----- (004518B0) --------------------------------------------------------
int __thiscall sub_4518B0(char* this)
{
    _DWORD* v2; // ecx
    void(__thiscall * **v3)(_DWORD, int); // ecx

    *(_DWORD*)this = &off_499AE0;
    v2 = (_DWORD*)dword_5216EC[*((_DWORD*)this + 73)];
    if (v2)
    {
        sub_451820(v2);
        v3 = (void(__thiscall***)(_DWORD, int))dword_5216EC[*((_DWORD*)this + 73)];
        if (v3)
            (**v3)(v3, 1);
        dword_5216EC[*((_DWORD*)this + 73)] = 0;
    }
    sub_4885A6(*((LPVOID*)this + 183));
    *((_DWORD*)this + 183) = 0;
    *((_DWORD*)this + 184) = 0;
    *((_DWORD*)this + 185) = 0;
    sub_4885A6(*((LPVOID*)this + 179));
    *((_DWORD*)this + 179) = 0;
    *((_DWORD*)this + 180) = 0;
    *((_DWORD*)this + 181) = 0;
    sub_4885A6(*((LPVOID*)this + 175));
    *((_DWORD*)this + 175) = 0;
    *((_DWORD*)this + 176) = 0;
    *((_DWORD*)this + 177) = 0;
    `eh vector destructor iterator'(this + 372, 0x10u, 20, (void (__thiscall *)(void *))sub_44E9B0);
        return sub_4690A0(this);
}
// 499AE0: using guessed type _UNKNOWN *off_499AE0;
// 5216EC: using guessed type int dword_5216EC[3];

//----- (004519E0) --------------------------------------------------------
_DWORD* __thiscall sub_4519E0(_DWORD* this, char* String1)
{
    char* v2; // edi
    char v4; // cl
    char v5; // dl
    char v6; // al
    int v7; // eax
    char* v8; // eax
    char* v9; // eax
    int v10; // ecx
    const char* v11; // eax
    char* v12; // ecx
    const char* v13; // edx
    int v14; // eax
    int v15; // eax
    const char* v16; // ebp
    char v17; // al
    int v18; // edx
    int v19; // ebx
    int v20; // eax
    _DWORD* v21; // ebp
    bool v22; // cc
    int v23; // edx
    int v24; // ebx
    int v25; // eax
    _DWORD* v26; // ebp
    char v27; // al
    int v28; // edx
    int v29; // ebx
    int v30; // eax
    _DWORD* v31; // ebp
    int v32; // edx
    int v33; // ebx
    int v34; // eax
    _DWORD* v35; // ebp
    char v36; // al
    int v37; // edx
    int v38; // ebx
    int v39; // eax
    _DWORD* v40; // ebp
    int v41; // edx
    int v42; // ebx
    int v43; // eax
    _DWORD* v44; // ebp
    char v45; // al
    int v46; // edx
    int v47; // ebx
    int v48; // eax
    _DWORD* v49; // ebp
    int v50; // edx
    int v51; // ebx
    int v52; // eax
    _DWORD* v53; // ebp
    char v54; // al
    int v55; // edx
    int v56; // ebx
    int v57; // eax
    _DWORD* v58; // ebp
    int v59; // edx
    int v60; // ebx
    int v61; // eax
    _DWORD* v62; // ebp
    char v63; // al
    int v64; // edx
    int v65; // ebx
    int v66; // eax
    _DWORD* v67; // ebp
    int v68; // edx
    int v69; // ebx
    int v70; // eax
    _DWORD* v71; // ebp
    char v72; // al
    int v73; // edx
    int v74; // ebx
    int v75; // eax
    _DWORD* v76; // ebp
    int v77; // edx
    int v78; // ebx
    int v79; // eax
    _DWORD* v80; // ebp
    int v81; // eax
    int v82; // ecx
    int v83; // edx
    int v84; // eax
    int v85; // eax
    int v86; // ecx
    int v87; // edx
    int v88; // eax
    char v89; // al
    unsigned int j; // ebx
    int v91; // eax
    const char* v92; // ebp
    char v93; // al
    int v94; // ecx
    int v95; // ebx
    int v96; // eax
    _DWORD* v97; // ebp
    int v98; // eax
    int v99; // ebx
    int v100; // eax
    _DWORD* v101; // ebp
    char v102; // al
    int v103; // ecx
    int v104; // ebx
    int v105; // eax
    _DWORD* v106; // ebp
    int v107; // eax
    int v108; // ebx
    int v109; // eax
    _DWORD* v110; // ebp
    char v111; // al
    int v112; // ecx
    int v113; // ebx
    int v114; // eax
    _DWORD* v115; // ebp
    int v116; // eax
    int v117; // ebx
    int v118; // eax
    _DWORD* v119; // ebp
    char v120; // al
    int v121; // ecx
    int v122; // ebx
    int v123; // eax
    _DWORD* v124; // ebp
    int v125; // eax
    int v126; // ebx
    int v127; // eax
    _DWORD* v128; // ebp
    char v129; // al
    int v130; // ecx
    int v131; // ebx
    int v132; // eax
    _DWORD* v133; // ebp
    int v134; // eax
    int v135; // ebx
    int v136; // eax
    _DWORD* v137; // ebp
    const char* v138; // ebx
    char v139; // al
    int v140; // eax
    int v141; // ebp
    int v142; // ebx
    int v143; // eax
    int v144; // edx
    int v145; // ebp
    int v146; // ebx
    int v147; // eax
    char v148; // al
    int v149; // edx
    int v150; // ebp
    int v151; // ebx
    int v152; // eax
    int v153; // eax
    int v154; // ebp
    int v155; // ebx
    int v156; // eax
    char v157; // al
    int v158; // edx
    int v159; // ebp
    int v160; // ebx
    int v161; // eax
    int v162; // eax
    int v163; // ebp
    int v164; // ebx
    int v165; // eax
    char v166; // al
    int v167; // edx
    int v168; // ebp
    int v169; // ebx
    int v170; // eax
    int v171; // eax
    int v172; // ebp
    int v173; // ebx
    int v174; // eax
    char v175; // al
    int v176; // edx
    int v177; // ebp
    int v178; // ebx
    int v179; // eax
    int v180; // eax
    int v181; // ebp
    int v182; // ebx
    int v183; // eax
    char v184; // al
    int v185; // edx
    int v186; // ebp
    int v187; // ebx
    int v188; // eax
    int v189; // eax
    int v190; // ebp
    int v191; // ebx
    int v192; // eax
    char v193; // al
    int v194; // edx
    int v195; // ebp
    int v196; // ebx
    int v197; // eax
    int v198; // eax
    int v199; // ebp
    int v200; // ebx
    int v201; // eax
    char v202; // al
    int v203; // edx
    int v204; // ebp
    int v205; // ebx
    int v206; // eax
    int v207; // eax
    int v208; // ebp
    int v209; // ebx
    int v210; // eax
    char v211; // al
    int v212; // edx
    int v213; // ebp
    int v214; // ebx
    int v215; // eax
    int v216; // eax
    int v217; // ebp
    int v218; // ebx
    int v219; // eax
    char v220; // al
    int v221; // edx
    int v222; // ebx
    int v223; // ebp
    int v224; // eax
    int* v225; // ebp
    int v226; // edx
    int v227; // eax
    bool v228; // sf
    char* v229; // eax
    char* v230; // eax
    _DWORD* v231; // ecx
    int v232; // eax
    char* v233; // ecx
    int* v234; // eax
    int* v235; // ecx
    int v236; // edx
    int v237; // ebx
    int v238; // edx
    int v239; // ebx
    int v240; // ebp
    int v241; // eax
    int v242; // ecx
    int* v243; // eax
    int* v244; // ebp
    int v245; // ecx
    int v246; // eax
    char* v247; // eax
    int v248; // eax
    char* v249; // ecx
    int* v250; // eax
    int v251; // ecx
    int v252; // edx
    int v253; // ebx
    char v254; // al
    int v255; // ecx
    int v256; // ebx
    int v257; // ebp
    int v258; // eax
    int v259; // ecx
    int* v260; // eax
    int* v261; // ebx
    int v262; // edx
    unsigned int v263; // ecx
    int v264; // eax
    int v265; // eax
    int v266; // eax
    char* v267; // ecx
    int v268; // eax
    int v269; // ecx
    int v270; // edx
    int v271; // edx
    int v272; // ebx
    int v273; // ebp
    int v274; // eax
    _DWORD* v275; // eax
    _DWORD* v276; // ebp
    int v277; // edx
    unsigned int v278; // ecx
    int v279; // eax
    signed int v280; // eax
    _DWORD* v281; // eax
    char* v282; // ecx
    int v283; // ebp
    _DWORD* v284; // eax
    char* v286; // [esp-Ch] [ebp-60h]
    char* v287; // [esp-Ch] [ebp-60h]
    char* v288; // [esp-Ch] [ebp-60h]
    char* v289; // [esp-Ch] [ebp-60h]
    char* v290; // [esp-Ch] [ebp-60h]
    char* v291; // [esp-Ch] [ebp-60h]
    char* v292; // [esp-Ch] [ebp-60h]
    const char* v293; // [esp-8h] [ebp-5Ch]
    const char* v294; // [esp-8h] [ebp-5Ch]
    const char* v295; // [esp-8h] [ebp-5Ch]
    const char* v296; // [esp-8h] [ebp-5Ch]
    const char* v297; // [esp-8h] [ebp-5Ch]
    const char* v298; // [esp-8h] [ebp-5Ch]
    const char* v299; // [esp-8h] [ebp-5Ch]
    const char* v300; // [esp-8h] [ebp-5Ch]
    const char* v301; // [esp-8h] [ebp-5Ch]
    const char* v302; // [esp-8h] [ebp-5Ch]
    const char* v303; // [esp-8h] [ebp-5Ch]
    const char* v304; // [esp-8h] [ebp-5Ch]
    const char* v305; // [esp-8h] [ebp-5Ch]
    const char* v306; // [esp-8h] [ebp-5Ch]
    const char* v307; // [esp-8h] [ebp-5Ch]
    const char* v308; // [esp-8h] [ebp-5Ch]
    const char* v309; // [esp-8h] [ebp-5Ch]
    const char* v310; // [esp-8h] [ebp-5Ch]
    const char* v311; // [esp-8h] [ebp-5Ch]
    const char* v312; // [esp-8h] [ebp-5Ch]
    const char* v313; // [esp-8h] [ebp-5Ch]
    const char* v314; // [esp-8h] [ebp-5Ch]
    const char* v315; // [esp-8h] [ebp-5Ch]
    int v316; // [esp+10h] [ebp-44h] BYREF
    int* v317; // [esp+14h] [ebp-40h]
    char* v318; // [esp+18h] [ebp-3Ch]
    char* i; // [esp+1Ch] [ebp-38h]
    char* v320; // [esp+20h] [ebp-34h]
    int v321; // [esp+24h] [ebp-30h] BYREF
    int v322; // [esp+28h] [ebp-2Ch] BYREF
    int v323; // [esp+2Ch] [ebp-28h]
    int v324[2]; // [esp+30h] [ebp-24h] BYREF
    int v325; // [esp+38h] [ebp-1Ch] BYREF
    int v326; // [esp+3Ch] [ebp-18h]
    int v327; // [esp+40h] [ebp-14h] BYREF
    int v328; // [esp+44h] [ebp-10h] BYREF
    int v329; // [esp+50h] [ebp-4h]

    v2 = String1;
    v324[1] = (int)this;
    sub_468FF0(this, String1);
    v329 = 0;
    `eh vector constructor iterator'(this + 93, 0x10u, 20, sub_455730, (void (__thiscall *)(void *))sub_44E9B0);
        v4 = (char)String1;
    this[175] = 0;
    *((_BYTE*)this + 696) = v4;
    this[176] = 0;
    this[177] = 0;
    v5 = (char)String1;
    this[179] = 0;
    *((_BYTE*)this + 712) = v5;
    this[180] = 0;
    this[181] = 0;
    v6 = (char)String1;
    this[183] = 0;
    *((_BYTE*)this + 728) = v6;
    this[184] = 0;
    this[185] = 0;
    LOBYTE(v329) = 4;
    *this = &off_499AE0;
    sub_4229D0(aStartedLoading_1);
    sub_40AF00(v2, aAniminfo, (char**)this + 73);
    v7 = this[73];
    if (!dword_5216EC[v7])
    {
        if (v7)
        {
            if (v7 == 1)
                v318 = aTroopbIni;
            else
                v318 = v7 != 2 ? 0 : aTroopcIni;
        }
        else
        {
            v318 = aTroopaIni;
        }
        sub_40A120(v318 != 0, "animInfo must be 0, 1, or 2, see %s : %s", (const char*)this[1], v2 + 16);
        v8 = (char*)operator new(0x14u);
        v324[0] = (int)v8;
        LOBYTE(v329) = 5;
        if (v8)
            v9 = sub_451390(v8, v318);
        else
            v9 = 0;
        v10 = this[73];
        LOBYTE(v329) = 4;
        dword_5216EC[v10] = (int)v9;
    }
    sub_40AFC0(v2, aType_0, &String1);
    if (_strcmpi(String1, aGunGuy))
    {
        if (_strcmpi(String1, aMortarGuy))
            sub_40A120(0, "%s, see %s : %s", aInvalidSoldier, (const char*)this[1], v2 + 16);
        else
            this[74] = 1;
    }
    else
    {
        this[74] = 0;
    }
    this[75] = 1065353216;
    if (sub_40ABC0(v2, aUnitvalue, 0))
        sub_40AF60(v2, aUnitvalue, (float*)this + 75);
    sub_40AFC0(v2, aScoringgroup, &String1);
    v11 = sub_462480(*(_DWORD**)(dword_520970 + 280), String1);
    v12 = String1;
    v13 = (const char*)this[1];
    this[76] = v11;
    sub_4282E0(v11 != 0, "Infantry type %s: couldn't find scoring groups %s", v13, v12);
    sub_40AF60(v2, aWalkspeed, (float*)this + 77);
    sub_40AF60(v2, aHealth, (float*)this + 78);
    sub_40AF60(v2, aSize_0, (float*)this + 79);
    sub_40AF60(v2, aOffsetz, (float*)this + 80);
    sub_40B1B0(v2, aRange, (float*)this + 81);
    v14 = this[74];
    if (v14)
    {
        if (v14 == 1)
        {
            sub_40B1B0(v2, aTimetillsetup, (float*)this + 89);
            sub_40B1B0(v2, aTimetillfire, (float*)this + 91);
        }
        else
        {
            sub_40A120(0, "%s, see %s : %s", aInvalidSoldier, (const char*)this[1], v2 + 16);
        }
    }
    else
    {
        sub_40B1B0(v2, aActivetime, (float*)this + 83);
        sub_40B1B0(v2, aInactivetime, (float*)this + 85);
        sub_40B1B0(v2, aTimetillgrenad, (float*)this + 87);
    }
    v15 = this[74];
    if (v15)
    {
        if (v15 == 1)
        {
            v138 = v2 + 16;
            v305 = (const char*)this[1];
            v139 = sub_40ABC0(v2, aWalkingleft, 0);
            sub_40A120(v139, "no strips found for %s, see %s : %s", aWalkingleft, v305, v2 + 16);
            if (sub_40AD80(v2, aWalkingleft))
            {
                while (sub_40ABC0(v2, aWalkingleft, 0))
                {
                    sub_40B310(v2, aWalkingleft, &v316, (const char**)&String1);
                    v140 = this[73];
                    v141 = 0;
                    i = String1;
                    v142 = dword_5216EC[v140];
                    if (*(int*)(v142 + 4) <= 0)
                    {
                    LABEL_244:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v141 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v142 + 8)]))
                        {
                            v143 = *(_DWORD*)(v142 + 4);
                            ++v141;
                            v318 += 12;
                            if (v141 >= v143)
                                goto LABEL_244;
                        }
                    }
                    v138 = v2 + 16;
                    sub_40A120(
                        v141 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aWalkingleft,
                        (const char*)this[1],
                        v2 + 16);
                    v325 = v316;
                    v326 = v141;
                    sub_4638A0((int)(this + 97), (char*)this[99], 1u, &v325);
                }
            }
            else
            {
                while (sub_40ABC0(v2, aWalkingleft, 0))
                {
                    sub_40AFC0(v2, aWalkingleft, &String1);
                    v144 = this[73];
                    v145 = 0;
                    i = String1;
                    v146 = dword_5216EC[v144];
                    if (*(int*)(v146 + 4) <= 0)
                    {
                    LABEL_252:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v145 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v146 + 8)]))
                        {
                            v147 = *(_DWORD*)(v146 + 4);
                            ++v145;
                            v318 += 12;
                            if (v145 >= v147)
                                goto LABEL_252;
                        }
                    }
                    v138 = v2 + 16;
                    sub_40A120(
                        v145 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aWalkingleft,
                        (const char*)this[1],
                        v2 + 16);
                    v325 = 3;
                    v326 = v145;
                    sub_4638A0((int)(this + 97), (char*)this[99], 1u, &v325);
                }
            }
            v306 = (const char*)this[1];
            v148 = sub_40ABC0(v2, aWalkingfastlef, 0);
            sub_40A120(v148, "no strips found for %s, see %s : %s", aWalkingfastlef, v306, v138);
            if (sub_40AD80(v2, aWalkingfastlef))
            {
                while (sub_40ABC0(v2, aWalkingfastlef, 0))
                {
                    sub_40B310(v2, aWalkingfastlef, &v316, (const char**)&String1);
                    v149 = this[73];
                    v150 = 0;
                    i = String1;
                    v151 = dword_5216EC[v149];
                    if (*(int*)(v151 + 4) <= 0)
                    {
                    LABEL_260:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v150 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v151 + 8)]))
                        {
                            v152 = *(_DWORD*)(v151 + 4);
                            ++v150;
                            v318 += 12;
                            if (v150 >= v152)
                                goto LABEL_260;
                        }
                    }
                    v138 = v2 + 16;
                    sub_40A120(
                        v150 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aWalkingfastlef,
                        (const char*)this[1],
                        v2 + 16);
                    v325 = v316;
                    v326 = v150;
                    sub_4638A0((int)(this + 101), (char*)this[103], 1u, &v325);
                }
            }
            else
            {
                while (sub_40ABC0(v2, aWalkingfastlef, 0))
                {
                    sub_40AFC0(v2, aWalkingfastlef, &String1);
                    v153 = this[73];
                    v154 = 0;
                    i = String1;
                    v155 = dword_5216EC[v153];
                    if (*(int*)(v155 + 4) <= 0)
                    {
                    LABEL_268:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v154 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v155 + 8)]))
                        {
                            v156 = *(_DWORD*)(v155 + 4);
                            ++v154;
                            v318 += 12;
                            if (v154 >= v156)
                                goto LABEL_268;
                        }
                    }
                    v138 = v2 + 16;
                    sub_40A120(
                        v154 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aWalkingfastlef,
                        (const char*)this[1],
                        v2 + 16);
                    v325 = 3;
                    v326 = v154;
                    sub_4638A0((int)(this + 101), (char*)this[103], 1u, &v325);
                }
            }
            v307 = (const char*)this[1];
            v157 = sub_40ABC0(v2, aWalkingright, 0);
            sub_40A120(v157, "no strips found for %s, see %s : %s", aWalkingright, v307, v138);
            if (sub_40AD80(v2, aWalkingright))
            {
                while (sub_40ABC0(v2, aWalkingright, 0))
                {
                    sub_40B310(v2, aWalkingright, &v316, (const char**)&String1);
                    v158 = this[73];
                    v159 = 0;
                    i = String1;
                    v160 = dword_5216EC[v158];
                    if (*(int*)(v160 + 4) <= 0)
                    {
                    LABEL_276:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v159 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v160 + 8)]))
                        {
                            v161 = *(_DWORD*)(v160 + 4);
                            ++v159;
                            v318 += 12;
                            if (v159 >= v161)
                                goto LABEL_276;
                        }
                    }
                    v138 = v2 + 16;
                    sub_40A120(
                        v159 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aWalkingright,
                        (const char*)this[1],
                        v2 + 16);
                    v325 = v316;
                    v326 = v159;
                    sub_4638A0((int)(this + 105), (char*)this[107], 1u, &v325);
                }
            }
            else
            {
                while (sub_40ABC0(v2, aWalkingright, 0))
                {
                    sub_40AFC0(v2, aWalkingright, &String1);
                    v162 = this[73];
                    v163 = 0;
                    i = String1;
                    v164 = dword_5216EC[v162];
                    if (*(int*)(v164 + 4) <= 0)
                    {
                    LABEL_284:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v163 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v164 + 8)]))
                        {
                            v165 = *(_DWORD*)(v164 + 4);
                            ++v163;
                            v318 += 12;
                            if (v163 >= v165)
                                goto LABEL_284;
                        }
                    }
                    v138 = v2 + 16;
                    sub_40A120(
                        v163 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aWalkingright,
                        (const char*)this[1],
                        v2 + 16);
                    v325 = 3;
                    v326 = v163;
                    sub_4638A0((int)(this + 105), (char*)this[107], 1u, &v325);
                }
            }
            v308 = (const char*)this[1];
            v166 = sub_40ABC0(v2, aWalkingfastrig, 0);
            sub_40A120(v166, "no strips found for %s, see %s : %s", aWalkingfastrig, v308, v138);
            if (sub_40AD80(v2, aWalkingfastrig))
            {
                while (sub_40ABC0(v2, aWalkingfastrig, 0))
                {
                    sub_40B310(v2, aWalkingfastrig, &v316, (const char**)&String1);
                    v167 = this[73];
                    v168 = 0;
                    i = String1;
                    v169 = dword_5216EC[v167];
                    if (*(int*)(v169 + 4) <= 0)
                    {
                    LABEL_292:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v168 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v169 + 8)]))
                        {
                            v170 = *(_DWORD*)(v169 + 4);
                            ++v168;
                            v318 += 12;
                            if (v168 >= v170)
                                goto LABEL_292;
                        }
                    }
                    v138 = v2 + 16;
                    sub_40A120(
                        v168 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aWalkingfastrig,
                        (const char*)this[1],
                        v2 + 16);
                    v325 = v316;
                    v326 = v168;
                    sub_4638A0((int)(this + 109), (char*)this[111], 1u, &v325);
                }
            }
            else
            {
                while (sub_40ABC0(v2, aWalkingfastrig, 0))
                {
                    sub_40AFC0(v2, aWalkingfastrig, &String1);
                    v171 = this[73];
                    v172 = 0;
                    i = String1;
                    v173 = dword_5216EC[v171];
                    if (*(int*)(v173 + 4) <= 0)
                    {
                    LABEL_300:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v172 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v173 + 8)]))
                        {
                            v174 = *(_DWORD*)(v173 + 4);
                            ++v172;
                            v318 += 12;
                            if (v172 >= v174)
                                goto LABEL_300;
                        }
                    }
                    v138 = v2 + 16;
                    sub_40A120(
                        v172 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aWalkingfastrig,
                        (const char*)this[1],
                        v2 + 16);
                    v325 = 3;
                    v326 = v172;
                    sub_4638A0((int)(this + 109), (char*)this[111], 1u, &v325);
                }
            }
            v309 = (const char*)this[1];
            v175 = sub_40ABC0(v2, aSettingupmorta, 0);
            sub_40A120(v175, "no strips found for %s, see %s : %s", aSettingupmorta, v309, v138);
            if (sub_40AD80(v2, aSettingupmorta))
            {
                while (sub_40ABC0(v2, aSettingupmorta, 0))
                {
                    sub_40B310(v2, aSettingupmorta, &v316, (const char**)&String1);
                    v176 = this[73];
                    v177 = 0;
                    i = String1;
                    v178 = dword_5216EC[v176];
                    if (*(int*)(v178 + 4) <= 0)
                    {
                    LABEL_308:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v177 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v178 + 8)]))
                        {
                            v179 = *(_DWORD*)(v178 + 4);
                            ++v177;
                            v318 += 12;
                            if (v177 >= v179)
                                goto LABEL_308;
                        }
                    }
                    v138 = v2 + 16;
                    sub_40A120(
                        v177 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aSettingupmorta,
                        (const char*)this[1],
                        v2 + 16);
                    v325 = v316;
                    v326 = v177;
                    sub_4638A0((int)(this + 129), (char*)this[131], 1u, &v325);
                }
            }
            else
            {
                while (sub_40ABC0(v2, aSettingupmorta, 0))
                {
                    sub_40AFC0(v2, aSettingupmorta, &String1);
                    v180 = this[73];
                    v181 = 0;
                    i = String1;
                    v182 = dword_5216EC[v180];
                    if (*(int*)(v182 + 4) <= 0)
                    {
                    LABEL_316:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v181 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v182 + 8)]))
                        {
                            v183 = *(_DWORD*)(v182 + 4);
                            ++v181;
                            v318 += 12;
                            if (v181 >= v183)
                                goto LABEL_316;
                        }
                    }
                    v138 = v2 + 16;
                    sub_40A120(
                        v181 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aSettingupmorta,
                        (const char*)this[1],
                        v2 + 16);
                    v325 = 3;
                    v326 = v181;
                    sub_4638A0((int)(this + 129), (char*)this[131], 1u, &v325);
                }
            }
            v310 = (const char*)this[1];
            v184 = sub_40ABC0(v2, aReloadingandfi, 0);
            sub_40A120(v184, "no strips found for %s, see %s : %s", aReloadingandfi, v310, v138);
            if (sub_40AD80(v2, aReloadingandfi))
            {
                while (sub_40ABC0(v2, aReloadingandfi, 0))
                {
                    sub_40B310(v2, aReloadingandfi, &v316, (const char**)&String1);
                    v185 = this[73];
                    v186 = 0;
                    i = String1;
                    v187 = dword_5216EC[v185];
                    if (*(int*)(v187 + 4) <= 0)
                    {
                    LABEL_324:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v186 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v187 + 8)]))
                        {
                            v188 = *(_DWORD*)(v187 + 4);
                            ++v186;
                            v318 += 12;
                            if (v186 >= v188)
                                goto LABEL_324;
                        }
                    }
                    v138 = v2 + 16;
                    sub_40A120(
                        v186 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aReloadingandfi,
                        (const char*)this[1],
                        v2 + 16);
                    v325 = v316;
                    v326 = v186;
                    sub_4638A0((int)(this + 133), (char*)this[135], 1u, &v325);
                }
            }
            else
            {
                while (sub_40ABC0(v2, aReloadingandfi, 0))
                {
                    sub_40AFC0(v2, aReloadingandfi, &String1);
                    v189 = this[73];
                    v190 = 0;
                    i = String1;
                    v191 = dword_5216EC[v189];
                    if (*(int*)(v191 + 4) <= 0)
                    {
                    LABEL_332:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v190 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v191 + 8)]))
                        {
                            v192 = *(_DWORD*)(v191 + 4);
                            ++v190;
                            v318 += 12;
                            if (v190 >= v192)
                                goto LABEL_332;
                        }
                    }
                    v138 = v2 + 16;
                    sub_40A120(
                        v190 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aReloadingandfi,
                        (const char*)this[1],
                        v2 + 16);
                    v325 = 3;
                    v326 = v190;
                    sub_4638A0((int)(this + 133), (char*)this[135], 1u, &v325);
                }
            }
            v311 = (const char*)this[1];
            v193 = sub_40ABC0(v2, aIdlingwhileset, 0);
            sub_40A120(v193, "no strips found for %s, see %s : %s", aIdlingwhileset, v311, v138);
            if (sub_40AD80(v2, aIdlingwhileset))
            {
                while (sub_40ABC0(v2, aIdlingwhileset, 0))
                {
                    sub_40B310(v2, aIdlingwhileset, &v316, (const char**)&String1);
                    v194 = this[73];
                    v195 = 0;
                    i = String1;
                    v196 = dword_5216EC[v194];
                    if (*(int*)(v196 + 4) <= 0)
                    {
                    LABEL_340:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v195 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v196 + 8)]))
                        {
                            v197 = *(_DWORD*)(v196 + 4);
                            ++v195;
                            v318 += 12;
                            if (v195 >= v197)
                                goto LABEL_340;
                        }
                    }
                    v138 = v2 + 16;
                    sub_40A120(
                        v195 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aIdlingwhileset,
                        (const char*)this[1],
                        v2 + 16);
                    v325 = v316;
                    v326 = v195;
                    sub_4638A0((int)(this + 137), (char*)this[139], 1u, &v325);
                }
            }
            else
            {
                while (sub_40ABC0(v2, aIdlingwhileset, 0))
                {
                    sub_40AFC0(v2, aIdlingwhileset, &String1);
                    v198 = this[73];
                    v199 = 0;
                    i = String1;
                    v200 = dword_5216EC[v198];
                    if (*(int*)(v200 + 4) <= 0)
                    {
                    LABEL_348:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v199 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v200 + 8)]))
                        {
                            v201 = *(_DWORD*)(v200 + 4);
                            ++v199;
                            v318 += 12;
                            if (v199 >= v201)
                                goto LABEL_348;
                        }
                    }
                    v138 = v2 + 16;
                    sub_40A120(
                        v199 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aIdlingwhileset,
                        (const char*)this[1],
                        v2 + 16);
                    v325 = 3;
                    v326 = v199;
                    sub_4638A0((int)(this + 137), (char*)this[139], 1u, &v325);
                }
            }
            v312 = (const char*)this[1];
            v202 = sub_40ABC0(v2, aDyingwhilesetu, 0);
            sub_40A120(v202, "no strips found for %s, see %s : %s", aDyingwhilesetu, v312, v138);
            if (sub_40AD80(v2, aDyingwhilesetu))
            {
                while (sub_40ABC0(v2, aDyingwhilesetu, 0))
                {
                    sub_40B310(v2, aDyingwhilesetu, &v316, (const char**)&String1);
                    v203 = this[73];
                    v204 = 0;
                    i = String1;
                    v205 = dword_5216EC[v203];
                    if (*(int*)(v205 + 4) <= 0)
                    {
                    LABEL_356:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v204 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v205 + 8)]))
                        {
                            v206 = *(_DWORD*)(v205 + 4);
                            ++v204;
                            v318 += 12;
                            if (v204 >= v206)
                                goto LABEL_356;
                        }
                    }
                    v138 = v2 + 16;
                    sub_40A120(
                        v204 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aDyingwhilesetu,
                        (const char*)this[1],
                        v2 + 16);
                    v325 = v316;
                    v326 = v204;
                    sub_4638A0((int)(this + 157), (char*)this[159], 1u, &v325);
                }
            }
            else
            {
                while (sub_40ABC0(v2, aDyingwhilesetu, 0))
                {
                    sub_40AFC0(v2, aDyingwhilesetu, &String1);
                    v207 = this[73];
                    v208 = 0;
                    i = String1;
                    v209 = dword_5216EC[v207];
                    if (*(int*)(v209 + 4) <= 0)
                    {
                    LABEL_364:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v208 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v209 + 8)]))
                        {
                            v210 = *(_DWORD*)(v209 + 4);
                            ++v208;
                            v318 += 12;
                            if (v208 >= v210)
                                goto LABEL_364;
                        }
                    }
                    v138 = v2 + 16;
                    sub_40A120(
                        v208 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aDyingwhilesetu,
                        (const char*)this[1],
                        v2 + 16);
                    v325 = 3;
                    v326 = v208;
                    sub_4638A0((int)(this + 157), (char*)this[159], 1u, &v325);
                }
            }
            v313 = (const char*)this[1];
            v211 = sub_40ABC0(v2, aDyingwhilesetu_0, 0);
            sub_40A120(v211, "no strips found for %s, see %s : %s", aDyingwhilesetu_0, v313, v138);
            if (sub_40AD80(v2, aDyingwhilesetu_0))
            {
                while (sub_40ABC0(v2, aDyingwhilesetu_0, 0))
                {
                    sub_40B310(v2, aDyingwhilesetu_0, &v316, (const char**)&String1);
                    v212 = this[73];
                    v213 = 0;
                    i = String1;
                    v214 = dword_5216EC[v212];
                    if (*(int*)(v214 + 4) <= 0)
                    {
                    LABEL_372:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v213 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v214 + 8)]))
                        {
                            v215 = *(_DWORD*)(v214 + 4);
                            ++v213;
                            v318 += 12;
                            if (v213 >= v215)
                                goto LABEL_372;
                        }
                    }
                    v138 = v2 + 16;
                    sub_40A120(
                        v213 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aDyingwhilesetu_0,
                        (const char*)this[1],
                        v2 + 16);
                    v325 = v316;
                    v326 = v213;
                    sub_4638A0((int)(this + 161), (char*)this[163], 1u, &v325);
                }
            }
            else
            {
                while (sub_40ABC0(v2, aDyingwhilesetu_0, 0))
                {
                    sub_40AFC0(v2, aDyingwhilesetu_0, &String1);
                    v216 = this[73];
                    v217 = 0;
                    i = String1;
                    v218 = dword_5216EC[v216];
                    if (*(int*)(v218 + 4) <= 0)
                    {
                    LABEL_380:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v217 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v218 + 8)]))
                        {
                            v219 = *(_DWORD*)(v218 + 4);
                            ++v217;
                            v318 += 12;
                            if (v217 >= v219)
                                goto LABEL_380;
                        }
                    }
                    v138 = v2 + 16;
                    sub_40A120(
                        v217 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aDyingwhilesetu_0,
                        (const char*)this[1],
                        v2 + 16);
                    v325 = 3;
                    v326 = v217;
                    sub_4638A0((int)(this + 161), (char*)this[163], 1u, &v325);
                }
            }
            v314 = (const char*)this[1];
            v220 = sub_40ABC0(v2, aDyingwhilestan, 0);
            sub_40A120(v220, "no strips found for %s, see %s : %s", aDyingwhilestan, v314, v138);
            if (sub_40AD80(v2, aDyingwhilestan))
            {
                while (sub_40ABC0(v2, aDyingwhilestan, 0))
                {
                    sub_40B310(v2, aDyingwhilestan, &v316, (const char**)&String1);
                    v221 = this[73];
                    v222 = 0;
                    i = String1;
                    v223 = dword_5216EC[v221];
                    if (*(int*)(v223 + 4) <= 0)
                    {
                    LABEL_388:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v222 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v223 + 8)]))
                        {
                            v224 = *(_DWORD*)(v223 + 4);
                            ++v222;
                            v318 += 12;
                            if (v222 >= v224)
                                goto LABEL_388;
                        }
                    }
                    sub_40A120(
                        v222 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aDyingwhilestan,
                        (const char*)this[1],
                        v2 + 16);
                    v326 = v222;
                    v325 = v316;
                    v225 = (int*)this[167];
                    v226 = (this[168] - (int)v225) >> 3;
                    v317 = this + 167;
                    if (v226)
                    {
                        sub_458C00(v225, v225, v225 + 2);
                        sub_458C40((_DWORD*)*v317, (_DWORD*)(1 - ((*v317 - (int)v225) >> 3)), &v325);
                        v234 = v225;
                        v235 = (int*)*v317;
                        if (v225 != (int*)*v317)
                        {
                            v236 = v326;
                            v237 = v325;
                            do
                            {
                                *v234 = v237;
                                v234[1] = v236;
                                v234 += 2;
                            } while (v234 != v235);
                        }
                        *v317 += 8;
                    }
                    else
                    {
                        if ((unsigned int)sub_4589E0(this + 165) <= 1)
                            i = (char*)1;
                        else
                            i = (char*)sub_4589E0(this + 165);
                        v227 = sub_4589E0(this + 165);
                        v228 = (int)&i[v227] < 0;
                        v229 = &i[v227];
                        v318 = v229;
                        if (v228)
                            v229 = 0;
                        v230 = (char*)operator new(8 * (_DWORD)v229);
                        v231 = (_DWORD*)this[166];
                        i = v230;
                        v320 = (char*)sub_458C00(v231, v225, v230);
                        sub_458C40(v320, (_DWORD*)1, &v325);
                        sub_458C00(v225, (_DWORD*)*v317, (_DWORD*)v320 + 2);
                        nullsub_8(this[166], *v317);
                        sub_4885A6((LPVOID)this[166]);
                        this[168] = &i[8 * (_DWORD)v318];
                        v232 = sub_4589E0(this + 165);
                        v233 = i;
                        *v317 = (int)&i[8 * v232 + 8];
                        this[166] = v233;
                    }
                }
            }
            else
            {
                while (sub_40ABC0(v2, aDyingwhilestan, 0))
                {
                    sub_40AFC0(v2, aDyingwhilestan, &String1);
                    v238 = this[73];
                    v239 = 0;
                    i = String1;
                    v240 = dword_5216EC[v238];
                    if (*(int*)(v240 + 4) <= 0)
                    {
                    LABEL_407:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v239 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v240 + 8)]))
                        {
                            v241 = *(_DWORD*)(v240 + 4);
                            ++v239;
                            v318 += 12;
                            if (v239 >= v241)
                                goto LABEL_407;
                        }
                    }
                    sub_40A120(
                        v239 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aDyingwhilestan,
                        (const char*)this[1],
                        v2 + 16);
                    v326 = v239;
                    v325 = 3;
                    v242 = this[168];
                    v317 = this + 167;
                    v243 = (int*)this[167];
                    v244 = v243;
                    if ((v242 - (int)v243) >> 3)
                    {
                        sub_458C00(v243, v243, v243 + 2);
                        sub_458C40((_DWORD*)*v317, (_DWORD*)(1 - ((*v317 - (int)v244) >> 3)), &v325);
                        v250 = v244;
                        v251 = *v317;
                        if (v244 != (int*)*v317)
                        {
                            v252 = v326;
                            v253 = v325;
                            do
                            {
                                *v250 = v253;
                                v250[1] = v252;
                                v250 += 2;
                            } while (v250 != (int*)v251);
                        }
                        *v317 += 8;
                    }
                    else
                    {
                        v245 = this[166];
                        if (v245 && (unsigned int)(((int)v243 - v245) >> 3) > 1)
                            i = (char*)sub_4589E0(this + 165);
                        else
                            i = (char*)1;
                        v246 = sub_4589E0(this + 165);
                        v228 = (int)&i[v246] < 0;
                        v247 = &i[v246];
                        v318 = v247;
                        if (v228)
                            v247 = 0;
                        i = (char*)operator new(8 * (_DWORD)v247);
                        v320 = (char*)sub_458C00((_DWORD*)this[166], v244, i);
                        sub_458C40(v320, (_DWORD*)1, &v325);
                        sub_458C00(v244, (_DWORD*)*v317, (_DWORD*)v320 + 2);
                        nullsub_8(this[166], *v317);
                        sub_4885A6((LPVOID)this[166]);
                        this[168] = &i[8 * (_DWORD)v318];
                        v248 = sub_4589E0(this + 165);
                        v249 = i;
                        *v317 = (int)&i[8 * v248 + 8];
                        this[166] = v249;
                    }
                }
            }
            v315 = (const char*)this[1];
            v254 = sub_40ABC0(v2, aDyingwhilestan_0, 0);
            sub_40A120(v254, "no strips found for %s, see %s : %s", aDyingwhilestan_0, v315, v2 + 16);
            if (sub_40AD80(v2, aDyingwhilestan_0))
            {
                while (sub_40ABC0(v2, aDyingwhilestan_0, 0))
                {
                    sub_40B310(v2, aDyingwhilestan_0, &v316, (const char**)&String1);
                    v255 = this[73];
                    i = String1;
                    v256 = 0;
                    v257 = dword_5216EC[v255];
                    if (*(int*)(v257 + 4) <= 0)
                    {
                    LABEL_427:
                        sub_40A120(0, "Infantry animation strip not found: %s", i);
                        v256 = -1;
                    }
                    else
                    {
                        v318 = 0;
                        while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)(v257 + 8)]))
                        {
                            v258 = *(_DWORD*)(v257 + 4);
                            ++v256;
                            v318 += 12;
                            if (v256 >= v258)
                                goto LABEL_427;
                        }
                    }
                    sub_40A120(
                        v256 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aDyingwhilestan_0,
                        (const char*)this[1],
                        v2 + 16);
                    v325 = v316;
                    v326 = v256;
                    v259 = this[172];
                    v317 = this + 171;
                    v260 = (int*)this[171];
                    v261 = v260;
                    if ((v259 - (int)v260) >> 3)
                    {
                        sub_458C00(v260, v260, v260 + 2);
                        sub_458C40((_DWORD*)*v317, (_DWORD*)(1 - ((*v317 - (int)v261) >> 3)), &v325);
                        v268 = *v317;
                        if (v261 != (int*)*v317)
                        {
                            v269 = v326;
                            v270 = v325;
                            do
                            {
                                *v261 = v270;
                                v261[1] = v269;
                                v261 += 2;
                            } while (v261 != (int*)v268);
                        }
                        *v317 += 8;
                    }
                    else
                    {
                        v262 = this[170];
                        if (!v262 || (v263 = ((int)v260 - v262) >> 3, v263 <= 1))
                            v263 = 1;
                        if (v262)
                            v264 = ((int)v260 - v262) >> 3;
                        else
                            v264 = 0;
                        v265 = v263 + v264;
                        v323 = v265;
                        if (v265 < 0)
                            v265 = 0;
                        v320 = (char*)operator new(8 * v265);
                        v318 = v320;
                        for (i = (char*)this[170]; i != (char*)v261; i += 8)
                        {
                            sub_458CD0(v318, i);
                            v318 += 8;
                        }
                        sub_458CD0(v318, &v325);
                        sub_458C00(v261, (_DWORD*)*v317, (_DWORD*)v318 + 2);
                        nullsub_8(this[170], *v317);
                        sub_4885A6((LPVOID)this[170]);
                        this[172] = &v320[8 * v323];
                        v266 = sub_4589E0(this + 169);
                        v267 = v320;
                        *v317 = (int)&v320[8 * v266 + 8];
                        this[170] = v267;
                    }
                }
            }
            else
            {
                while (sub_40ABC0(v2, aDyingwhilestan_0, 0))
                {
                    sub_40AFC0(v2, aDyingwhilestan_0, &String1);
                    v271 = this[73];
                    v272 = 0;
                    v320 = String1;
                    v273 = dword_5216EC[v271];
                    if (*(int*)(v273 + 4) <= 0)
                    {
                    LABEL_451:
                        sub_40A120(0, "Infantry animation strip not found: %s", v320);
                        v272 = -1;
                    }
                    else
                    {
                        i = 0;
                        while (_strcmpi(v320, *(const char**)&i[*(_DWORD*)(v273 + 8)]))
                        {
                            v274 = *(_DWORD*)(v273 + 4);
                            ++v272;
                            i += 12;
                            if (v272 >= v274)
                                goto LABEL_451;
                        }
                    }
                    sub_40A120(
                        v272 != -1,
                        "failed to find strip for %s, see %s : %s",
                        aDyingwhilestan_0,
                        (const char*)this[1],
                        v2 + 16);
                    v326 = v272;
                    v325 = 3;
                    v275 = (_DWORD*)this[171];
                    v276 = v275;
                    if ((this[172] - (int)v275) >> 3)
                    {
                        sub_458C00(v275, v275, v275 + 2);
                        sub_458C40((_DWORD*)this[171], (_DWORD*)(1 - ((this[171] - (int)v276) >> 3)), &v325);
                        sub_458C70(v276, (_DWORD*)this[171], &v325);
                        this[171] += 8;
                    }
                    else
                    {
                        v277 = this[170];
                        if (!v277 || (v278 = ((int)v275 - v277) >> 3, v278 <= 1))
                            v278 = 1;
                        if (v277)
                            v279 = ((int)v275 - v277) >> 3;
                        else
                            v279 = 0;
                        v280 = v278 + v279;
                        v320 = (char*)v280;
                        if (v280 < 0)
                            v280 = 0;
                        v323 = (int)operator new(8 * v280);
                        v318 = (char*)v323;
                        v281 = (_DWORD*)this[170];
                        if (v281 != v276)
                        {
                            v282 = v318;
                            do
                            {
                                if (v282)
                                {
                                    *(_DWORD*)v282 = *v281;
                                    *((_DWORD*)v282 + 1) = v281[1];
                                }
                                v281 += 2;
                                v282 += 8;
                            } while (v281 != v276);
                            v318 = v282;
                        }
                        sub_458C40(v318, (_DWORD*)1, &v325);
                        sub_458C00(v276, (_DWORD*)this[171], (_DWORD*)v318 + 2);
                        nullsub_8(this[170], this[171]);
                        sub_458BF0((void*)this[170], (this[172] - this[170]) >> 3);
                        v283 = v323;
                        this[172] = v323 + 8 * (_DWORD)v320;
                        this[171] = v283 + 8 * sub_4589E0(this + 169) + 8;
                        this[170] = v283;
                    }
                    sub_458BE0(this + 169);
                }
            }
            v284 = (_DWORD*)sub_458A00(this + 97, 0);
            sub_458A10(this + 93, v284);
            sub_40AFC0(v2, aMortarbulletty, v324);
            sub_469160((int)this, this + 194, (const char*)v324[0], aBullet);
            this[195] = 1082130432;
            this[196] = 1082130432;
            if (sub_40ABC0(v2, aMortarairtime, 0))
                sub_40B1B0(v2, aMortarairtime, (float*)this + 195);
            sub_40AF00(v2, aMortarfirefram, (char**)this + 197);
            sub_40B1F0(v2, aMortaroffset, (float*)this + 198, (float*)this + 199);
        }
    }
    else
    {
        v16 = v2 + 16;
        v293 = (const char*)this[1];
        v17 = sub_40ABC0(v2, aWalkingleft, 0);
        sub_40A120(v17, "no strips found for %s, see %s : %s", aWalkingleft, v293, v2 + 16);
        if (sub_40AD80(v2, aWalkingleft))
        {
            while (sub_40ABC0(v2, aWalkingleft, 0))
            {
                sub_40B310(v2, aWalkingleft, &v316, (const char**)&String1);
                v18 = this[73];
                i = String1;
                v19 = 0;
                v20 = dword_5216EC[v18];
                v21 = (_DWORD*)(v20 + 4);
                if (*(int*)(v20 + 4) <= 0)
                {
                LABEL_30:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v19 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v20 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v19 < *v21;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_30;
                    }
                }
                v16 = v2 + 16;
                sub_40A120(v19 != -1, "failed to find strip for %s, see %s : %s", aWalkingleft, (const char*)this[1], v2 + 16);
                v325 = v316;
                v286 = (char*)this[99];
                v326 = v19;
                sub_4638A0((int)(this + 97), v286, 1u, &v325);
            }
        }
        else
        {
            while (sub_40ABC0(v2, aWalkingleft, 0))
            {
                sub_40AFC0(v2, aWalkingleft, &String1);
                v23 = this[73];
                i = String1;
                v24 = 0;
                v25 = dword_5216EC[v23];
                v26 = (_DWORD*)(v25 + 4);
                if (*(int*)(v25 + 4) <= 0)
                {
                LABEL_38:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v24 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v25 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v24 < *v26;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_38;
                    }
                }
                v16 = v2 + 16;
                sub_40A120(v24 != -1, "failed to find strip for %s, see %s : %s", aWalkingleft, (const char*)this[1], v2 + 16);
                v287 = (char*)this[99];
                v325 = 3;
                v326 = v24;
                sub_4638A0((int)(this + 97), v287, 1u, &v325);
            }
        }
        v294 = (const char*)this[1];
        v27 = sub_40ABC0(v2, aWalkingfastlef, 0);
        sub_40A120(v27, "no strips found for %s, see %s : %s", aWalkingfastlef, v294, v16);
        if (sub_40AD80(v2, aWalkingfastlef))
        {
            while (sub_40ABC0(v2, aWalkingfastlef, 0))
            {
                sub_40B310(v2, aWalkingfastlef, &v316, (const char**)&String1);
                v28 = this[73];
                i = String1;
                v29 = 0;
                v30 = dword_5216EC[v28];
                v31 = (_DWORD*)(v30 + 4);
                if (*(int*)(v30 + 4) <= 0)
                {
                LABEL_46:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v29 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v30 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v29 < *v31;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_46;
                    }
                }
                v16 = v2 + 16;
                sub_40A120(
                    v29 != -1,
                    "failed to find strip for %s, see %s : %s",
                    aWalkingfastlef,
                    (const char*)this[1],
                    v2 + 16);
                v325 = v316;
                v288 = (char*)this[103];
                v326 = v29;
                sub_4638A0((int)(this + 101), v288, 1u, &v325);
            }
        }
        else
        {
            while (sub_40ABC0(v2, aWalkingfastlef, 0))
            {
                sub_40AFC0(v2, aWalkingfastlef, &String1);
                v32 = this[73];
                i = String1;
                v33 = 0;
                v34 = dword_5216EC[v32];
                v35 = (_DWORD*)(v34 + 4);
                if (*(int*)(v34 + 4) <= 0)
                {
                LABEL_54:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v33 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v34 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v33 < *v35;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_54;
                    }
                }
                v16 = v2 + 16;
                sub_40A120(
                    v33 != -1,
                    "failed to find strip for %s, see %s : %s",
                    aWalkingfastlef,
                    (const char*)this[1],
                    v2 + 16);
                v289 = (char*)this[103];
                v325 = 3;
                v326 = v33;
                sub_4638A0((int)(this + 101), v289, 1u, &v325);
            }
        }
        v295 = (const char*)this[1];
        v36 = sub_40ABC0(v2, aWalkingright, 0);
        sub_40A120(v36, "no strips found for %s, see %s : %s", aWalkingright, v295, v16);
        if (sub_40AD80(v2, aWalkingright))
        {
            while (sub_40ABC0(v2, aWalkingright, 0))
            {
                sub_40B310(v2, aWalkingright, &v316, (const char**)&String1);
                v37 = this[73];
                i = String1;
                v38 = 0;
                v39 = dword_5216EC[v37];
                v40 = (_DWORD*)(v39 + 4);
                if (*(int*)(v39 + 4) <= 0)
                {
                LABEL_62:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v38 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v39 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v38 < *v40;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_62;
                    }
                }
                v16 = v2 + 16;
                sub_40A120(v38 != -1, "failed to find strip for %s, see %s : %s", aWalkingright, (const char*)this[1], v2 + 16);
                v325 = v316;
                v290 = (char*)this[107];
                v326 = v38;
                sub_4638A0((int)(this + 105), v290, 1u, &v325);
            }
        }
        else
        {
            while (sub_40ABC0(v2, aWalkingright, 0))
            {
                sub_40AFC0(v2, aWalkingright, &String1);
                v41 = this[73];
                i = String1;
                v42 = 0;
                v43 = dword_5216EC[v41];
                v44 = (_DWORD*)(v43 + 4);
                if (*(int*)(v43 + 4) <= 0)
                {
                LABEL_70:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v42 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v43 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v42 < *v44;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_70;
                    }
                }
                v16 = v2 + 16;
                sub_40A120(v42 != -1, "failed to find strip for %s, see %s : %s", aWalkingright, (const char*)this[1], v2 + 16);
                v291 = (char*)this[107];
                v325 = 3;
                v326 = v42;
                sub_4638A0((int)(this + 105), v291, 1u, &v325);
            }
        }
        v296 = (const char*)this[1];
        v45 = sub_40ABC0(v2, aWalkingfastrig, 0);
        sub_40A120(v45, "no strips found for %s, see %s : %s", aWalkingfastrig, v296, v16);
        if (sub_40AD80(v2, aWalkingfastrig))
        {
            while (sub_40ABC0(v2, aWalkingfastrig, 0))
            {
                sub_40B310(v2, aWalkingfastrig, &v316, (const char**)&String1);
                v46 = this[73];
                i = String1;
                v47 = 0;
                v48 = dword_5216EC[v46];
                v49 = (_DWORD*)(v48 + 4);
                if (*(int*)(v48 + 4) <= 0)
                {
                LABEL_78:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v47 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v48 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v47 < *v49;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_78;
                    }
                }
                v16 = v2 + 16;
                sub_40A120(
                    v47 != -1,
                    "failed to find strip for %s, see %s : %s",
                    aWalkingfastrig,
                    (const char*)this[1],
                    v2 + 16);
                v325 = v316;
                v292 = (char*)this[111];
                v326 = v47;
                sub_4638A0((int)(this + 109), v292, 1u, &v325);
            }
        }
        else
        {
            while (sub_40ABC0(v2, aWalkingfastrig, 0))
            {
                sub_40AFC0(v2, aWalkingfastrig, &String1);
                v50 = this[73];
                i = String1;
                v51 = 0;
                v52 = dword_5216EC[v50];
                v53 = (_DWORD*)(v52 + 4);
                if (*(int*)(v52 + 4) <= 0)
                {
                LABEL_86:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v51 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v52 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v51 < *v53;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_86;
                    }
                }
                v16 = v2 + 16;
                sub_40A120(
                    v51 != -1,
                    "failed to find strip for %s, see %s : %s",
                    aWalkingfastrig,
                    (const char*)this[1],
                    v2 + 16);
                v325 = 3;
                v326 = v51;
                sub_4638A0((int)(this + 109), (char*)this[111], 1u, &v325);
            }
        }
        v297 = (const char*)this[1];
        v54 = sub_40ABC0(v2, aAiming, 0);
        sub_40A120(v54, "no strips found for %s, see %s : %s", aAiming, v297, v16);
        if (sub_40AD80(v2, aAiming))
        {
            while (sub_40ABC0(v2, aAiming, 0))
            {
                sub_40B310(v2, aAiming, &v316, (const char**)&String1);
                v55 = this[73];
                i = String1;
                v56 = 0;
                v57 = dword_5216EC[v55];
                v58 = (_DWORD*)(v57 + 4);
                if (*(int*)(v57 + 4) <= 0)
                {
                LABEL_94:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v56 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v57 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v56 < *v58;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_94;
                    }
                }
                v16 = v2 + 16;
                sub_40A120(v56 != -1, "failed to find strip for %s, see %s : %s", aAiming, (const char*)this[1], v2 + 16);
                v325 = v316;
                v326 = v56;
                sub_4638A0((int)(this + 117), (char*)this[119], 1u, &v325);
            }
        }
        else
        {
            while (sub_40ABC0(v2, aAiming, 0))
            {
                sub_40AFC0(v2, aAiming, &String1);
                v59 = this[73];
                i = String1;
                v60 = 0;
                v61 = dword_5216EC[v59];
                v62 = (_DWORD*)(v61 + 4);
                if (*(int*)(v61 + 4) <= 0)
                {
                LABEL_102:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v60 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v61 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v60 < *v62;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_102;
                    }
                }
                v16 = v2 + 16;
                sub_40A120(v60 != -1, "failed to find strip for %s, see %s : %s", aAiming, (const char*)this[1], v2 + 16);
                v325 = 3;
                v326 = v60;
                sub_4638A0((int)(this + 117), (char*)this[119], 1u, &v325);
            }
        }
        v298 = (const char*)this[1];
        v63 = sub_40ABC0(v2, aFiring, 0);
        sub_40A120(v63, "no strips found for %s, see %s : %s", aFiring, v298, v16);
        if (sub_40AD80(v2, aFiring))
        {
            while (sub_40ABC0(v2, aFiring, 0))
            {
                sub_40B310(v2, aFiring, &v316, (const char**)&String1);
                v64 = this[73];
                i = String1;
                v65 = 0;
                v66 = dword_5216EC[v64];
                v67 = (_DWORD*)(v66 + 4);
                if (*(int*)(v66 + 4) <= 0)
                {
                LABEL_110:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v65 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v66 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v65 < *v67;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_110;
                    }
                }
                v16 = v2 + 16;
                sub_40A120(v65 != -1, "failed to find strip for %s, see %s : %s", aFiring, (const char*)this[1], v2 + 16);
                v325 = v316;
                v326 = v65;
                sub_4638A0((int)(this + 125), (char*)this[127], 1u, &v325);
            }
        }
        else
        {
            while (sub_40ABC0(v2, aFiring, 0))
            {
                sub_40AFC0(v2, aFiring, &String1);
                v68 = this[73];
                i = String1;
                v69 = 0;
                v70 = dword_5216EC[v68];
                v71 = (_DWORD*)(v70 + 4);
                if (*(int*)(v70 + 4) <= 0)
                {
                LABEL_118:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v69 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v70 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v69 < *v71;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_118;
                    }
                }
                v16 = v2 + 16;
                sub_40A120(v69 != -1, "failed to find strip for %s, see %s : %s", aFiring, (const char*)this[1], v2 + 16);
                v325 = 3;
                v326 = v69;
                sub_4638A0((int)(this + 125), (char*)this[127], 1u, &v325);
            }
        }
        v299 = (const char*)this[1];
        v72 = sub_40ABC0(v2, aUnaiming, 0);
        sub_40A120(v72, "no strips found for %s, see %s : %s", aUnaiming, v299, v16);
        if (sub_40AD80(v2, aUnaiming))
        {
            while (sub_40ABC0(v2, aUnaiming, 0))
            {
                sub_40B310(v2, aUnaiming, &v316, (const char**)&String1);
                v73 = this[73];
                i = String1;
                v74 = 0;
                v75 = dword_5216EC[v73];
                v76 = (_DWORD*)(v75 + 4);
                if (*(int*)(v75 + 4) <= 0)
                {
                LABEL_126:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v74 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v75 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v74 < *v76;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_126;
                    }
                }
                v16 = v2 + 16;
                sub_40A120(v74 != -1, "failed to find strip for %s, see %s : %s", aUnaiming, (const char*)this[1], v2 + 16);
                v325 = v316;
                v326 = v74;
                sub_4638A0((int)(this + 121), (char*)this[123], 1u, &v325);
            }
        }
        else
        {
            while (sub_40ABC0(v2, aUnaiming, 0))
            {
                sub_40AFC0(v2, aUnaiming, &String1);
                v77 = this[73];
                i = String1;
                v78 = 0;
                v79 = dword_5216EC[v77];
                v80 = (_DWORD*)(v79 + 4);
                if (*(int*)(v79 + 4) <= 0)
                {
                LABEL_134:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v78 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v79 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v78 < *v80;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_134;
                    }
                }
                v16 = v2 + 16;
                sub_40A120(v78 != -1, "failed to find strip for %s, see %s : %s", aUnaiming, (const char*)this[1], v2 + 16);
                v325 = 3;
                v326 = v78;
                sub_4638A0((int)(this + 121), (char*)this[123], 1u, &v325);
            }
        }
        v81 = this[118];
        if (v81)
            v82 = (this[119] - v81) >> 3;
        else
            v82 = 0;
        v83 = this[126];
        if (v83)
            v84 = (this[127] - v83) >> 3;
        else
            v84 = 0;
        v89 = 0;
        if (v82 == v84)
        {
            v85 = this[118];
            v86 = v85 ? (this[119] - v85) >> 3 : 0;
            v87 = this[122];
            v88 = v87 ? (this[123] - v87) >> 3 : 0;
            if (v86 == v88)
                v89 = 1;
        }
        sub_40A120(
            v89,
            "for every aiming, there should be a firing and a unaiming animation, see %s : %s",
            (const char*)this[1],
            v16);
        for (j = 0; ; ++j)
        {
            v91 = this[118];
            if (!v91 || j >= (this[119] - v91) >> 3)
                break;
            sub_40AF00(v2, aShotframe, (char**)&v316);
            sub_44F190((int)(this + 174), (_DWORD*)this[176], 1u, &v316);
            sub_40B1F0(v2, aShotoffset, (float*)&v327, (float*)&v328);
            sub_44F190((int)(this + 178), (_DWORD*)this[180], 1u, &v327);
            sub_44F190((int)(this + 182), (_DWORD*)this[184], 1u, &v328);
        }
        v92 = v2 + 16;
        v300 = (const char*)this[1];
        v93 = sub_40ABC0(v2, aThrowinggrenad, 0);
        sub_40A120(v93, "no strips found for %s, see %s : %s", aThrowinggrenad, v300, v2 + 16);
        if (sub_40AD80(v2, aThrowinggrenad))
        {
            while (sub_40ABC0(v2, aThrowinggrenad, 0))
            {
                sub_40B310(v2, aThrowinggrenad, &v316, (const char**)&String1);
                v94 = this[73];
                i = String1;
                v95 = 0;
                v96 = dword_5216EC[v94];
                v97 = (_DWORD*)(v96 + 4);
                if (*(int*)(v96 + 4) <= 0)
                {
                LABEL_162:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v95 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v96 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v95 < *v97;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_162;
                    }
                }
                v92 = v2 + 16;
                sub_40A120(
                    v95 != -1,
                    "failed to find strip for %s, see %s : %s",
                    aThrowinggrenad,
                    (const char*)this[1],
                    v2 + 16);
                v325 = v316;
                v326 = v95;
                sub_4638A0((int)(this + 113), (char*)this[115], 1u, &v325);
            }
        }
        else
        {
            while (sub_40ABC0(v2, aThrowinggrenad, 0))
            {
                sub_40AFC0(v2, aThrowinggrenad, &String1);
                v98 = this[73];
                v99 = 0;
                i = String1;
                v100 = dword_5216EC[v98];
                v101 = (_DWORD*)(v100 + 4);
                if (*(int*)(v100 + 4) <= 0)
                {
                LABEL_170:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v99 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v100 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v99 < *v101;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_170;
                    }
                }
                v92 = v2 + 16;
                sub_40A120(
                    v99 != -1,
                    "failed to find strip for %s, see %s : %s",
                    aThrowinggrenad,
                    (const char*)this[1],
                    v2 + 16);
                v325 = 3;
                v326 = v99;
                sub_4638A0((int)(this + 113), (char*)this[115], 1u, &v325);
            }
        }
        v301 = (const char*)this[1];
        v102 = sub_40ABC0(v2, aDyingfromshot, 0);
        sub_40A120(v102, "no strips found for %s, see %s : %s", aDyingfromshot, v301, v92);
        if (sub_40AD80(v2, aDyingfromshot))
        {
            while (sub_40ABC0(v2, aDyingfromshot, 0))
            {
                sub_40B310(v2, aDyingfromshot, &v316, (const char**)&String1);
                v103 = this[73];
                i = String1;
                v104 = 0;
                v105 = dword_5216EC[v103];
                v106 = (_DWORD*)(v105 + 4);
                if (*(int*)(v105 + 4) <= 0)
                {
                LABEL_178:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v104 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v105 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v104 < *v106;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_178;
                    }
                }
                v92 = v2 + 16;
                sub_40A120(
                    v104 != -1,
                    "failed to find strip for %s, see %s : %s",
                    aDyingfromshot,
                    (const char*)this[1],
                    v2 + 16);
                v325 = v316;
                v326 = v104;
                sub_4638A0((int)(this + 141), (char*)this[143], 1u, &v325);
            }
        }
        else
        {
            while (sub_40ABC0(v2, aDyingfromshot, 0))
            {
                sub_40AFC0(v2, aDyingfromshot, &String1);
                v107 = this[73];
                v108 = 0;
                i = String1;
                v109 = dword_5216EC[v107];
                v110 = (_DWORD*)(v109 + 4);
                if (*(int*)(v109 + 4) <= 0)
                {
                LABEL_186:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v108 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v109 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v108 < *v110;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_186;
                    }
                }
                v92 = v2 + 16;
                sub_40A120(
                    v108 != -1,
                    "failed to find strip for %s, see %s : %s",
                    aDyingfromshot,
                    (const char*)this[1],
                    v2 + 16);
                v325 = 3;
                v326 = v108;
                sub_4638A0((int)(this + 141), (char*)this[143], 1u, &v325);
            }
        }
        v302 = (const char*)this[1];
        v111 = sub_40ABC0(v2, aDyingfromshotl, 0);
        sub_40A120(v111, "no strips found for %s, see %s : %s", aDyingfromshotl, v302, v92);
        if (sub_40AD80(v2, aDyingfromshotl))
        {
            while (sub_40ABC0(v2, aDyingfromshotl, 0))
            {
                sub_40B310(v2, aDyingfromshotl, &v316, (const char**)&String1);
                v112 = this[73];
                i = String1;
                v113 = 0;
                v114 = dword_5216EC[v112];
                v115 = (_DWORD*)(v114 + 4);
                if (*(int*)(v114 + 4) <= 0)
                {
                LABEL_194:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v113 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v114 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v113 < *v115;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_194;
                    }
                }
                v92 = v2 + 16;
                sub_40A120(
                    v113 != -1,
                    "failed to find strip for %s, see %s : %s",
                    aDyingfromshotl,
                    (const char*)this[1],
                    v2 + 16);
                v325 = v316;
                v326 = v113;
                sub_4638A0((int)(this + 145), (char*)this[147], 1u, &v325);
            }
        }
        else
        {
            while (sub_40ABC0(v2, aDyingfromshotl, 0))
            {
                sub_40AFC0(v2, aDyingfromshotl, &String1);
                v116 = this[73];
                v117 = 0;
                i = String1;
                v118 = dword_5216EC[v116];
                v119 = (_DWORD*)(v118 + 4);
                if (*(int*)(v118 + 4) <= 0)
                {
                LABEL_202:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v117 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v118 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v117 < *v119;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_202;
                    }
                }
                v92 = v2 + 16;
                sub_40A120(
                    v117 != -1,
                    "failed to find strip for %s, see %s : %s",
                    aDyingfromshotl,
                    (const char*)this[1],
                    v2 + 16);
                v325 = 3;
                v326 = v117;
                sub_4638A0((int)(this + 145), (char*)this[147], 1u, &v325);
            }
        }
        v303 = (const char*)this[1];
        v120 = sub_40ABC0(v2, aDyingfromshotr, 0);
        sub_40A120(v120, "no strips found for %s, see %s : %s", aDyingfromshotr, v303, v92);
        if (sub_40AD80(v2, aDyingfromshotr))
        {
            while (sub_40ABC0(v2, aDyingfromshotr, 0))
            {
                sub_40B310(v2, aDyingfromshotr, &v316, (const char**)&String1);
                v121 = this[73];
                i = String1;
                v122 = 0;
                v123 = dword_5216EC[v121];
                v124 = (_DWORD*)(v123 + 4);
                if (*(int*)(v123 + 4) <= 0)
                {
                LABEL_210:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v122 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v123 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v122 < *v124;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_210;
                    }
                }
                v92 = v2 + 16;
                sub_40A120(
                    v122 != -1,
                    "failed to find strip for %s, see %s : %s",
                    aDyingfromshotr,
                    (const char*)this[1],
                    v2 + 16);
                v325 = v316;
                v326 = v122;
                sub_4638A0((int)(this + 149), (char*)this[151], 1u, &v325);
            }
        }
        else
        {
            while (sub_40ABC0(v2, aDyingfromshotr, 0))
            {
                sub_40AFC0(v2, aDyingfromshotr, &String1);
                v125 = this[73];
                v126 = 0;
                i = String1;
                v127 = dword_5216EC[v125];
                v128 = (_DWORD*)(v127 + 4);
                if (*(int*)(v127 + 4) <= 0)
                {
                LABEL_218:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v126 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v127 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v126 < *v128;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_218;
                    }
                }
                v92 = v2 + 16;
                sub_40A120(
                    v126 != -1,
                    "failed to find strip for %s, see %s : %s",
                    aDyingfromshotr,
                    (const char*)this[1],
                    v2 + 16);
                v325 = 3;
                v326 = v126;
                sub_4638A0((int)(this + 149), (char*)this[151], 1u, &v325);
            }
        }
        v304 = (const char*)this[1];
        v129 = sub_40ABC0(v2, aDyingfromexplo, 0);
        sub_40A120(v129, "no strips found for %s, see %s : %s", aDyingfromexplo, v304, v92);
        if (sub_40AD80(v2, aDyingfromexplo))
        {
            while (sub_40ABC0(v2, aDyingfromexplo, 0))
            {
                sub_40B310(v2, aDyingfromexplo, &v316, (const char**)&String1);
                v130 = this[73];
                i = String1;
                v131 = 0;
                v132 = dword_5216EC[v130];
                v133 = (_DWORD*)(v132 + 4);
                if (*(int*)(v132 + 4) <= 0)
                {
                LABEL_226:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v131 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v132 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v131 < *v133;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_226;
                    }
                }
                sub_40A120(
                    v131 != -1,
                    "failed to find strip for %s, see %s : %s",
                    aDyingfromexplo,
                    (const char*)this[1],
                    v2 + 16);
                v325 = v316;
                v326 = v131;
                sub_4638A0((int)(this + 153), (char*)this[155], 1u, &v325);
            }
        }
        else
        {
            while (sub_40ABC0(v2, aDyingfromexplo, 0))
            {
                sub_40AFC0(v2, aDyingfromexplo, &String1);
                v134 = this[73];
                v135 = 0;
                i = String1;
                v136 = dword_5216EC[v134];
                v137 = (_DWORD*)(v136 + 4);
                if (*(int*)(v136 + 4) <= 0)
                {
                LABEL_234:
                    sub_40A120(0, "Infantry animation strip not found: %s", i);
                    v135 = -1;
                }
                else
                {
                    v318 = 0;
                    v320 = (char*)(v136 + 8);
                    while (_strcmpi(i, *(const char**)&v318[*(_DWORD*)v320]))
                    {
                        v22 = ++v135 < *v137;
                        v318 += 12;
                        if (!v22)
                            goto LABEL_234;
                    }
                }
                sub_40A120(
                    v135 != -1,
                    "failed to find strip for %s, see %s : %s",
                    aDyingfromexplo,
                    (const char*)this[1],
                    v2 + 16);
                v325 = 3;
                v326 = v135;
                sub_4638A0((int)(this + 153), (char*)this[155], 1u, &v325);
            }
        }
        sub_4638A0((int)(this + 93), (char*)this[95], 1u, (_DWORD*)this[118]);
        sub_40AFC0(v2, aShotbullettype, &v321);
        sub_469160((int)this, this + 173, (const char*)v321, aBullet);
        sub_40AFC0(v2, aGrenadebullett, &v322);
        sub_469160((int)this, this + 186, (const char*)v322, aBullet);
        sub_40B1B0(v2, aGrenadespinrat, (float*)this + 187);
        *((float*)this + 187) = *((float*)this + 187) * 0.017453292;
        *((float*)this + 188) = *((float*)this + 188) * 0.017453292;
        sub_40B1B0(v2, aGrenadeairtime, (float*)this + 189);
        sub_40AF00(v2, aGrenadeframe, (char**)this + 191);
        sub_40B1F0(v2, aGrenadeoffset, (float*)this + 192, (float*)this + 193);
    }
    this[200] = 0;
    if (sub_40ABC0(v2, aScreamsoundeff, 0))
    {
        sub_40AFC0(v2, aScreamsoundeff, &String1);
        sub_469160((int)this, this + 200, String1, aSoundEffect);
    }
    this[201] = 0;
    if (sub_40ABC0(v2, aSoftthudsounde, 0))
    {
        sub_40AFC0(v2, aSoftthudsounde, &String1);
        sub_469160((int)this, this + 201, String1, aSoundEffect);
    }
    this[202] = 0;
    if (sub_40ABC0(v2, aHardthudsounde, 0))
    {
        sub_40AFC0(v2, aHardthudsounde, &String1);
        sub_469160((int)this, this + 202, String1, aSoundEffect);
    }
    this[203] = 0;
    if (sub_40ABC0(v2, aFireeffect, 0))
    {
        sub_40AFC0(v2, aFireeffect, &String1);
        sub_469160((int)this, this + 203, String1, aEffect);
    }
    sub_4229D0(aFinishedLoadin_2);
    return this;
}
// 499AE0: using guessed type _UNKNOWN *off_499AE0;
// 520970: using guessed type int dword_520970;
// 5216EC: using guessed type int dword_5216EC[3];

//----- (00455730) --------------------------------------------------------
void __thiscall sub_455730(_DWORD* this)
{
    *(_BYTE*)this = HIBYTE(this);
    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
}

//----- (00455750) --------------------------------------------------------
_BYTE* __thiscall sub_455750(_BYTE* this)
{
    char v3; // [esp+7h] [ebp-1h]

    sub_401270((int)this);
    this[396] = v3;
    *((_DWORD*)this + 100) = 0;
    *((_DWORD*)this + 101) = 0;
    *((_DWORD*)this + 102) = 0;
    *(_DWORD*)this = &off_499AEC;
    return this;
}
// 45575D: variable 'v3' is possibly undefined
// 499AEC: using guessed type _UNKNOWN *off_499AEC;

//----- (004557B0) --------------------------------------------------------
int __thiscall sub_4557B0(int this)
{
    *(_DWORD*)this = &off_499AEC;
    sub_411430((_DWORD*)dword_4F5CC4, this);
    sub_4885A6(*(LPVOID*)(this + 400));
    *(_DWORD*)(this + 400) = 0;
    *(_DWORD*)(this + 404) = 0;
    *(_DWORD*)(this + 408) = 0;
    return sub_4013F0((_DWORD*)this);
}
// 499AEC: using guessed type _UNKNOWN *off_499AEC;
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (00455830) --------------------------------------------------------
char __thiscall sub_455830(void* this)
{
    sub_4113F0((_DWORD*)dword_4F5CC4, (int)this, 65280, 2304, 0);
    return 1;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (00455850) --------------------------------------------------------
int __thiscall sub_455850(_DWORD* this, int a2, int* a3, int a4)
{
    _DWORD* v4; // esi
    int v5; // edi
    int v6; // eax
    _DWORD* v7; // eax
    int v8; // esi
    _DWORD* v9; // eax
    int v10; // edx
    _DWORD* v11; // esi
    int* v12; // eax
    int* v13; // edi
    int v14; // edx
    unsigned int v15; // ecx
    int v16; // eax
    int v17; // eax
    _DWORD* v18; // eax
    int* v19; // ebx
    _DWORD* j; // ebp
    int v21; // eax
    int* i; // eax
    __int16 v25[3]; // [esp+14h] [ebp-28h] BYREF
    int v26; // [esp+1Ah] [ebp-22h]
    int v27; // [esp+1Eh] [ebp-1Eh]
    int v28; // [esp+22h] [ebp-1Ah]
    int v29; // [esp+26h] [ebp-16h]
    int v30; // [esp+2Ah] [ebp-12h]
    int v31; // [esp+38h] [ebp-4h]
    int v32; // [esp+40h] [ebp+4h]
    _DWORD* v33; // [esp+44h] [ebp+8h]

    v4 = this;
    v5 = a4;
    if (*(_BYTE*)(dword_4F5CC4 + 936))
    {
        v26 = *(_DWORD*)(a2 + 8);
        v28 = *a3;
        v6 = a3[1];
        v27 = a4;
        v29 = v6;
        v30 = a3[2];
        sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x901, v25, 26, 15, 0);
    }
    v7 = operator new(0x564u);
    v31 = 0;
    if (v7)
    {
        v8 = v4[100];
        if (v8)
            v9 = sub_4560B0(v7, a2, a3, (this[101] - v8) >> 2, v5);
        else
            v9 = sub_4560B0(v7, a2, a3, 0, v5);
        v4 = this;
    }
    else
    {
        v9 = 0;
    }
    v10 = v4[102];
    v11 = v4 + 99;
    a4 = (int)v9;
    v31 = -1;
    v12 = (int*)v11[2];
    v13 = v12;
    if ((v10 - (int)v12) >> 2)
    {
        sub_448B80(v12, v12, v12 + 1);
        sub_44B480((_DWORD*)v11[2], (_DWORD*)(1 - ((v11[2] - (int)v13) >> 2)), &a4);
        for (i = (int*)v11[2]; v13 != i; ++v13)
            *v13 = a4;
        v11[2] += 4;
    }
    else
    {
        v14 = v11[1];
        if (!v14 || (v15 = ((int)v12 - v14) >> 2, v15 <= 1))
            v15 = 1;
        if (v14)
            v16 = ((int)v12 - v14) >> 2;
        else
            v16 = 0;
        v17 = v15 + v16;
        v32 = v17;
        if (v17 < 0)
            v17 = 0;
        v18 = operator new(4 * v17);
        v19 = (int*)v11[1];
        v33 = v18;
        for (j = v18; v19 != v13; ++j)
            sub_448BE0(j, v19++);
        sub_44B480(j, (_DWORD*)1, &a4);
        sub_448B80(v13, (_DWORD*)v11[2], j + 1);
        nullsub_8(v11[1], v11[2]);
        sub_4885A6((LPVOID)v11[1]);
        v11[3] = &v33[v32];
        v21 = sub_4481C0(v11);
        v11[1] = v33;
        v11[2] = &v33[v21 + 1];
    }
    return sub_428680(this, a4);
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (00455AC0) --------------------------------------------------------
int __thiscall sub_455AC0(_DWORD* this, int a2, int a3, float* a4, float* a5, float a6, float a7)
{
    double v9; // st6
    double v10; // st7
    int v11; // ebp
    long double v12; // st7
    long double v13; // st7
    long double v14; // st7
    long double v15; // st7
    int v16; // ecx
    int v17; // ebp
    long double v18; // st7
    long double v19; // st7
    float* v20; // eax
    float v21; // edx
    int v22; // eax
    int result; // eax
    int v24; // [esp+0h] [ebp-68h]
    int v25; // [esp+0h] [ebp-68h]
    int v26; // [esp+0h] [ebp-68h]
    int v27; // [esp+4h] [ebp-64h]
    int v28; // [esp+4h] [ebp-64h]
    int v29; // [esp+4h] [ebp-64h]
    int v30; // [esp+8h] [ebp-60h]
    int v31; // [esp+8h] [ebp-60h]
    int v32; // [esp+8h] [ebp-60h]
    int v33; // [esp+1Ch] [ebp-4Ch]
    float v34; // [esp+20h] [ebp-48h] BYREF
    float v35; // [esp+24h] [ebp-44h]
    float v36; // [esp+28h] [ebp-40h]
    float v37; // [esp+2Ch] [ebp-3Ch] BYREF
    float v38; // [esp+30h] [ebp-38h]
    float v39; // [esp+34h] [ebp-34h]
    float v40; // [esp+38h] [ebp-30h] BYREF
    float v41; // [esp+3Ch] [ebp-2Ch]
    float v42; // [esp+40h] [ebp-28h]
    float v43; // [esp+44h] [ebp-24h] BYREF
    float v44; // [esp+48h] [ebp-20h]
    float v45; // [esp+4Ch] [ebp-1Ch]
    float v46; // [esp+50h] [ebp-18h] BYREF
    float v47; // [esp+54h] [ebp-14h]
    float v48; // [esp+5Ch] [ebp-Ch] BYREF
    float v49; // [esp+60h] [ebp-8h]
    float v50; // [esp+64h] [ebp-4h]
    int v51; // [esp+78h] [ebp+10h]
    int v52; // [esp+78h] [ebp+10h]

    v9 = a5[1] - 0.0;
    v39 = 0.0;
    v36 = 0.0;
    v37 = v9;
    v10 = 0.0 - *a5;
    v34 = v37;
    v38 = v10;
    v35 = v38;
    sub_46B970(&v34, &v34);
    v11 = sub_45A7E0(*(_DWORD**)(dword_520970 + 236));
    v33 = sub_45A810(*(_DWORD**)(dword_520970 + 236));
    if (a2 > 0)
    {
        *(float*)&v51 = -a7;
        do
        {
            if (*(float*)&v51 == a7)
                v12 = *(float*)&v51;
            else
                v12 = fabs((double)rand() * 0.000030518509) * (a7 - *(float*)&v51) + *(float*)&v51;
            v40 = v34 * v12;
            v41 = v35 * v12;
            v42 = v36 * v12;
            if (0.0 == a6)
                v13 = 0.0;
            else
                v13 = fabs((double)rand() * 0.000030518509) * a6;
            v46 = v13 * *a5;
            v47 = v13 * a5[1];
            v14 = v13 * a5[2];
            v48 = v46 + *a4;
            v49 = v47 + a4[1];
            v15 = v14 + a4[2];
            v43 = v48 + v40;
            v37 = v43;
            v16 = this[98];
            v44 = v49 + v41;
            v38 = v44;
            v45 = v15 + v42;
            v39 = v45;
            sub_455850(this, v11, (int*)&v37, v16);
            --a2;
        } while (a2);
    }
    v17 = a3;
    if (a3 > 0)
    {
        *(float*)&v52 = -a7;
        do
        {
            if (*(float*)&v52 == a7)
                v18 = *(float*)&v52;
            else
                v18 = fabs((double)rand() * 0.000030518509) * (a7 - *(float*)&v52) + *(float*)&v52;
            *(float*)&v30 = v36 * v18;
            *(float*)&v27 = v35 * v18;
            *(float*)&v24 = v34 * v18;
            sub_40F4A0(&v46, v24, v27, v30);
            if (0.0 == a6)
                v19 = 0.0;
            else
                v19 = fabs((double)rand() * 0.000030518509) * a6;
            *(float*)&v31 = v19 * a5[2];
            *(float*)&v28 = v19 * a5[1];
            *(float*)&v25 = v19 * *a5;
            sub_40F4A0(&v48, v25, v28, v31);
            *(float*)&v32 = v50 + a4[2];
            *(float*)&v29 = v49 + a4[1];
            *(float*)&v26 = v48 + *a4;
            sub_40F4A0(&v43, v26, v29, v32);
            v20 = sub_4162C0(&v43, &v40, &v46);
            v37 = *v20;
            v38 = v20[1];
            v21 = v20[2];
            v22 = this[98];
            v39 = v21;
            sub_455850(this, v33, (int*)&v37, v22);
            --v17;
        } while (v17);
    }
    result = this[98];
    this[98] = result + 1;
    return result;
}
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);
// 520970: using guessed type int dword_520970;

//----- (00455DC0) --------------------------------------------------------
int __thiscall sub_455DC0(_DWORD* this, int a2)
{
    unsigned int i; // edi
    int result; // eax
    int v5; // ecx
    _WORD v6[3]; // [esp+Ch] [ebp-Ch] BYREF
    int v7; // [esp+12h] [ebp-6h]

    if (*(_BYTE*)(dword_4F5CC4 + 936))
    {
        v7 = a2;
        sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x902, v6, 10, 15, 0);
    }
    for (i = 0; ; ++i)
    {
        result = this[100];
        if (!result || i >= (this[101] - result) >> 2)
            break;
        v5 = *(_DWORD*)(result + 4 * i);
        if (*(_DWORD*)(v5 + 400) == a2)
            sub_456370(v5);
    }
    return result;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (00455E30) --------------------------------------------------------
int __thiscall sub_455E30(_DWORD* this)
{
    int v2; // eax
    int v3; // ebx
    int i; // edi
    void(__thiscall * **v5)(_DWORD, int); // ecx
    int result; // eax

    v2 = this[100];
    if (v2)
        v3 = (this[101] - v2) >> 2;
    else
        v3 = 0;
    for (i = 0; i < v3; ++i)
    {
        sub_428720(*(_DWORD**)(this[100] + 4 * i));
        sub_4286C0(this, *(_DWORD*)(this[100] + 4 * i));
        v5 = *(void(__thiscall****)(_DWORD, int))(this[100] + 4 * i);
        if (v5)
            (**v5)(v5, 1);
    }
    result = this[101];
    this[101] = this[100];
    this[98] = 0;
    return result;
}

//----- (00455ED0) --------------------------------------------------------
char __thiscall sub_455ED0(_DWORD* this)
{
    int v1; // edx
    int v2; // eax
    int v3; // edx
    int i; // ecx

    v1 = this[100];
    if (v1)
        v2 = (this[101] - v1) >> 2;
    else
        v2 = 0;
    v3 = 0;
    if (v2 <= 0)
        return 1;
    for (i = this[100]; !*(_BYTE*)(*(_DWORD*)i + 404); i += 4)
    {
        if (++v3 >= v2)
            return 1;
    }
    return 0;
}

//----- (00455F20) --------------------------------------------------------
int __thiscall sub_455F20(_DWORD* this, int a2)
{
    __int16 v2; // ax
    int result; // eax
    int v4; // esi

    v2 = *(_WORD*)(a2 + 12);
    if (v2 == 2305)
        return sub_455850(
            this,
            *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(dword_520970 + 200) + 20) + 4 * *(_DWORD*)(*(_DWORD*)(a2 + 16) + 6)),
            (int*)(*(_DWORD*)(a2 + 16) + 14),
            *(_DWORD*)(*(_DWORD*)(a2 + 16) + 10));
    if (v2 == 2306)
        return sub_455DC0(this, *(_DWORD*)(*(_DWORD*)(a2 + 16) + 6));
    result = *(_DWORD*)(*(_DWORD*)(a2 + 16) + 6);
    if (result >= 0)
    {
        v4 = this[100];
        if (v4)
        {
            if (result < (unsigned int)((this[101] - v4) >> 2))
                return (*(int(__thiscall**)(_DWORD, int))(**(_DWORD**)(v4 + 4 * result) + 28))(
                    *(_DWORD*)(v4 + 4 * result),
                    a2);
        }
    }
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (00455FB0) --------------------------------------------------------
char __thiscall sub_455FB0(float* this, int a2)
{
    if ((float*)sub_408F30((_DWORD*)dword_520970) == this)
    {
        sub_401450(this);
        sub_4014C0(this, 1.5707964, 0.0, 0.0);
        sub_401480(this, 0.0, 0.0, 9000.0);
    }
    return sub_428620(this, a2);
}
// 520970: using guessed type int dword_520970;

//----- (00456000) --------------------------------------------------------
int __thiscall sub_456000(_DWORD* this, int a2, int* a3, int a4, int a5)
{
    int result; // eax
    unsigned int i; // edi
    int v8; // ecx

    result = 0;
    for (i = 0; ; ++i)
    {
        v8 = this[100];
        if (!v8)
            break;
        if (i >= (this[101] - v8) >> 2)
            break;
        result = sub_456870(*(_DWORD*)(v8 + 4 * i), a2, a3, a4, a5);
        if (result)
            break;
    }
    return result;
}

//----- (00456050) --------------------------------------------------------
int __thiscall sub_456050(_DWORD* this, float* a2, int a3, float a4, int a5, int a6)
{
    unsigned int i; // esi
    int result; // eax

    for (i = 0; ; ++i)
    {
        result = this[100];
        if (!result || i >= (this[101] - result) >> 2)
            break;
        sub_456A40(*(_DWORD*)(this[100] + 4 * i), a2, a3, a4, a5, a6);
    }
    return result;
}

//----- (004560B0) --------------------------------------------------------
_DWORD* __thiscall sub_4560B0(_DWORD* this, int a2, _DWORD* a3, int a4, int a5)
{
    int v6; // eax
    int v7; // ecx
    int v8; // edi
    int v9; // edx
    int v10; // eax
    int v11; // ecx
    int v12; // edx
    long double v13; // st7
    int v14; // eax
    _DWORD* v15; // eax
    _DWORD* result; // eax
    float v17; // [esp+34h] [ebp+Ch]
    float v18; // [esp+38h] [ebp+10h]

    sub_401270((int)this);
    Iostream_init::Iostream_init((Iostream_init*)(this + 123));
    this[99] = a4;
    this[100] = a5;
    this[98] = a2;
    *this = &off_499B10;
    *((_BYTE*)this + 404) = 1;
    *((_BYTE*)this + 420) = 0;
    this[107] = *a3;
    this[108] = a3[1];
    this[109] = a3[2];
    *((float*)this + 109) = sub_468BE0((int*)*(_DWORD*)(dword_520970 + 260), this[107], this[108], 0);
    this[110] = 0;
    this[113] = 0;
    this[114] = 0;
    this[111] = 1065353216;
    v6 = this[98] + 372;
    this[112] = 0;
    v7 = *(_DWORD*)(v6 + 4);
    if (v7)
        v8 = (*(_DWORD*)(v6 + 8) - v7) >> 3;
    else
        v8 = 0;
    v9 = rand() % v8;
    v10 = this[98];
    v11 = 16 * this[114];
    this[115] = v9;
    v12 = *(_DWORD*)(*(_DWORD*)(v11 + v10 + 376) + 8 * v9 + 4);
    this[117] = 0;
    this[116] = v12;
    this[121] = 0;
    v17 = *(float*)(v10 + 324);
    v18 = *(float*)(v10 + 328);
    if (v17 == v18)
        v13 = v17;
    else
        v13 = fabs((double)rand() * 0.000030518509) * (v18 - v17) + v17;
    v14 = this[98];
    *((float*)this + 333) = v13;
    *((float*)this + 334) = *(float*)(v14 + 328) - *(float*)(v14 + 324) + v13;
    this[335] = *(_DWORD*)(v14 + 312);
    v15 = sub_409960((_DWORD*)dword_520970, (int)this);
    this[344] = v15;
    v15[3] = 5;
    *(_DWORD*)(this[344] + 48) = *(_DWORD*)(this[98] + 316);
    *(_DWORD*)(this[344] + 52) = 0;
    *(_DWORD*)(this[344] + 56) = -1;
    *(_BYTE*)(this[344] + 60) = 1;
    result = this;
    *(_BYTE*)(this[344] + 44) = 0;
    *(_DWORD*)(this[344] + 28) = 1;
    return result;
}
// 499B10: using guessed type void *(__thiscall *off_499B10)(std::strstreambuf *__hidden this, unsigned int);
// 520970: using guessed type int dword_520970;

//----- (00456370) --------------------------------------------------------
void __thiscall sub_456370(int this)
{
    _DWORD* v2; // eax
    int v3; // edx
    int v4; // ecx
    int v5; // edi
    int v6; // edx
    int v7; // ecx
    int v8; // eax
    int v9; // ecx
    int v10; // eax
    int v11; // ecx
    long double v12; // st7
    int v13; // eax
    int v14; // eax
    float v15; // [esp+8h] [ebp-18h]
    float v16; // [esp+8h] [ebp-18h]
    float v17; // [esp+8h] [ebp-18h]
    float v18; // [esp+Ch] [ebp-14h]
    float v19; // [esp+Ch] [ebp-14h]

    if (*(float*)(this + 1340) > 0.0)
    {
        *(_DWORD*)(this + 440) = 0;
        *(_DWORD*)(this + 444) = 1065353216;
        *(_DWORD*)(this + 448) = 0;
        v2 = *(_DWORD**)(this + 392);
        v3 = v2[77];
        *(_DWORD*)(this + 456) = 1;
        *(_DWORD*)(this + 452) = v3;
        v4 = v2[98];
        if (v4)
            v5 = (v2[99] - v4) >> 3;
        else
            v5 = 0;
        v6 = rand() % v5;
        v7 = *(_DWORD*)(this + 392);
        v8 = 16 * *(_DWORD*)(this + 456);
        *(_DWORD*)(this + 460) = v6;
        v9 = *(_DWORD*)(*(_DWORD*)(v8 + v7 + 376) + 8 * v6 + 4);
        *(_DWORD*)(this + 468) = 0;
        *(_DWORD*)(this + 464) = v9;
        *(_DWORD*)(this + 484) = 0;
        sub_41C060((_DWORD*)(this + 492), 1065353216, -1077342245, 1070141403);
        sub_41C0B0(this + 492, 0.0);
        sub_41C0B0(this + 492, 0.0);
        sub_41C0B0(this + 492, 0.0);
        sub_41C0B0(this + 492, 0.0);
        v10 = *(_DWORD*)(this + 392);
        *(_DWORD*)(this + 1328) = 0;
        v11 = *(_DWORD*)(v10 + 296);
        if (v11)
        {
            if (v11 == 1)
            {
                v17 = *(float*)(v10 + 356);
                v19 = *(float*)(v10 + 360);
                if (v17 == v19)
                {
                    *(_BYTE*)(this + 1368) = 0;
                    *(float*)(this + 1364) = v17;
                }
                else
                {
                    v14 = rand();
                    *(_BYTE*)(this + 1368) = 0;
                    *(float*)(this + 1364) = fabs((double)v14 * 0.000030518509) * (v19 - v17) + v17;
                }
            }
        }
        else
        {
            *(_BYTE*)(this + 1344) = 0;
            v15 = *(float*)(v10 + 344);
            if (0.0 == v15)
                v12 = 0.0;
            else
                v12 = fabs((double)rand() * 0.000030518509) * v15;
            v13 = *(_DWORD*)(this + 392);
            *(float*)(this + 1348) = v12;
            v16 = *(float*)(v13 + 348);
            v18 = *(float*)(v13 + 352);
            if (v16 == v18)
                *(float*)(this + 1356) = v16;
            else
                *(float*)(this + 1356) = fabs((double)rand() * 0.000030518509) * (v18 - v16) + v16;
        }
    }
}

//----- (004565B0) --------------------------------------------------------
int __thiscall sub_4565B0(int this)
{
    int v2; // eax
    float* v3; // edi
    float* v4; // ebx
    int v5; // ecx
    int v6; // edx
    int v7; // ecx
    int v8; // eax
    double v9; // st7
    float* v10; // ecx
    double v11; // st7
    int result; // eax
    float v13; // [esp+10h] [ebp-8h]
    float v14; // [esp+14h] [ebp-4h]

    v2 = *(_DWORD*)(this + 456);
    if (v2 >= 1 && v2 <= 4)
    {
        v3 = (float*)(this + 472);
        v4 = (float*)(this + 440);
        if (sub_401100((float*)(this + 440), (float*)(this + 472)) >= 0.78539819)
            v5 = *(float*)(this + 476) * *v4 - *(float*)(this + 444) * *v3 <= 0.0 ? 4 : 2;
        else
            v5 = *(float*)(this + 476) * *v4 - *(float*)(this + 444) * *v3 <= 0.0 ? 3 : 1;
        v6 = *(_DWORD*)(this + 460);
        *(_DWORD*)(this + 456) = v5;
        *(_DWORD*)(this + 464) = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 392) + 16 * v5 + 376) + 8 * v6 + 4);
    }
    v7 = *(_DWORD*)(this + 392);
    v8 = dword_5216EC[*(_DWORD*)(v7 + 292)];
    if (*(_DWORD*)(this + 468) >= *(_DWORD*)(*(_DWORD*)(v8 + 8) + 12 * *(_DWORD*)(this + 464) + 4))
        *(_DWORD*)(this + 468) = 0;
    v13 = *(float*)(this + 432);
    v9 = *(float*)(v7 + 320) * *(float*)(v7 + 316);
    v10 = (float*)(*(_DWORD*)(this + 1376) + 16);
    v11 = v9 + *(float*)(this + 436);
    *v10 = *(float*)(this + 428);
    v14 = v11;
    v10[1] = v13;
    v10[2] = v14;
    *(_DWORD*)(*(_DWORD*)(this + 1376) + 36) = *(_DWORD*)(*(_DWORD*)(v8 + 16)
        + 264
        * *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v8 + 8)
            + 12 * *(_DWORD*)(this + 464)
            + 8)
            + 36 * *(_DWORD*)(this + 468))
        + 260);
    *(_BYTE*)(*(_DWORD*)(this + 1376) + 60) = 1;
    *(_DWORD*)(*(_DWORD*)(this + 1376) + 64) = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v8 + 8)
        + 12 * *(_DWORD*)(this + 464)
        + 8)
        + 36 * *(_DWORD*)(this + 468)
        + 4);
    *(_DWORD*)(*(_DWORD*)(this + 1376) + 68) = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v8 + 8)
        + 12 * *(_DWORD*)(this + 464)
        + 8)
        + 36 * *(_DWORD*)(this + 468)
        + 8);
    *(_DWORD*)(*(_DWORD*)(this + 1376) + 72) = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v8 + 8)
        + 12 * *(_DWORD*)(this + 464)
        + 8)
        + 36 * *(_DWORD*)(this + 468)
        + 12);
    *(_DWORD*)(*(_DWORD*)(this + 1376) + 76) = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v8 + 8)
        + 12 * *(_DWORD*)(this + 464)
        + 8)
        + 36 * *(_DWORD*)(this + 468)
        + 16);
    *(_DWORD*)(*(_DWORD*)(this + 1376) + 80) = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v8 + 8)
        + 12 * *(_DWORD*)(this + 464)
        + 8)
        + 36 * *(_DWORD*)(this + 468)
        + 20);
    *(_DWORD*)(*(_DWORD*)(this + 1376) + 88) = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v8 + 8)
        + 12 * *(_DWORD*)(this + 464)
        + 8)
        + 36 * *(_DWORD*)(this + 468)
        + 28);
    *(_DWORD*)(*(_DWORD*)(this + 1376) + 84) = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v8 + 8)
        + 12 * *(_DWORD*)(this + 464)
        + 8)
        + 36 * *(_DWORD*)(this + 468)
        + 24);
    result = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v8 + 8) + 12 * *(_DWORD*)(this + 464) + 8)
        + 36 * *(_DWORD*)(this + 468)
        + 32);
    *(_DWORD*)(*(_DWORD*)(this + 1376) + 92) = result;
    *(float*)(*(_DWORD*)(this + 1376) + 32) = *(float*)(*(_DWORD*)(this + 392) + 316) * 1.4141999;
    return result;
}
// 5216EC: using guessed type int dword_5216EC[3];

//----- (00456860) --------------------------------------------------------
int __stdcall sub_456860(int a1)
{
    return 0;
}

//----- (00456870) --------------------------------------------------------
int __thiscall sub_456870(int this, int a2, int* a3, int a4, int a5)
{
    int v6; // eax
    int v7; // edx
    int v8; // edx
    int v9; // ecx
    float* v10; // ecx
    int v11; // edx
    int v12; // ecx
    int v14; // edx
    int v15; // [esp+0h] [ebp-68h]
    int v16[3]; // [esp+28h] [ebp-40h] BYREF
    int v17; // [esp+34h] [ebp-34h] BYREF
    float v18; // [esp+38h] [ebp-30h]
    float v19; // [esp+3Ch] [ebp-2Ch]
    _WORD v20[3]; // [esp+40h] [ebp-28h] BYREF
    int v21; // [esp+46h] [ebp-22h]
    float v22; // [esp+4Ah] [ebp-1Eh]
    int v23; // [esp+4Eh] [ebp-1Ah]
    int v24; // [esp+52h] [ebp-16h]
    int v25; // [esp+56h] [ebp-12h]
    char v26; // [esp+5Ah] [ebp-Eh]

    v6 = *(_DWORD*)(this + 392);
    v7 = dword_5216EC[*(_DWORD*)(v6 + 292)];
    v16[0] = *a3;
    v16[1] = a3[1];
    v8 = *(_DWORD*)(v7 + 8);
    v16[2] = a3[2];
    v17 = *(int*)a2;
    v18 = *(float*)(a2 + 4);
    v9 = *(_DWORD*)(this + 464);
    v19 = *(float*)(a2 + 8);
    v10 = (float*)(*(_DWORD*)(v8 + 12 * v9 + 8) + 36 * *(_DWORD*)(this + 468));
    *(float*)&v15 = *(float*)(v6 + 320) * *(float*)(v6 + 316) + *(float*)(this + 436);
    if (!sub_420600(
        (float*)&v17,
        (float*)v16,
        *(_DWORD*)(this + 428),
        *(_DWORD*)(this + 432),
        v15,
        *(float*)(v6 + 316),
        0.0,
        (float*)a5,
        v10[1],
        v10[2],
        v10[3],
        v10[4]))
        return 0;
    if (*(_BYTE*)(dword_4F5CC4 + 936) || *(_BYTE*)(dword_4F5CC4 + 937))
    {
        if (!*(_BYTE*)(a4 + 124))
        {
            v21 = *(_DWORD*)(this + 396);
            v22 = *(float*)a5;
            v23 = *(_DWORD*)(a5 + 4);
            v11 = *(_DWORD*)(a4 + 4);
            v24 = *(_DWORD*)(a5 + 8);
            v25 = *(_DWORD*)(v11 + 300);
            v26 = 0;
            sub_4117D0(dword_4F5CC4, (int**)0x904, v20, 39, 2, 2000);
        }
        v12 = *(_DWORD*)(a4 + 4);
        *(float*)&v17 = 0.0;
        v18 = 0.0;
        v19 = 0.0;
        sub_456C50(this, (float*)a5, *(float*)(v12 + 300), 0, &v17);
        return 9;
    }
    else
    {
        *(float*)&v17 = 0.0;
        v18 = 0.0;
        v14 = *(_DWORD*)(a4 + 4);
        v19 = 0.0;
        sub_456C50(this, (float*)a5, *(float*)(v14 + 300), 0, &v17);
        return 9;
    }
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 5216EC: using guessed type int dword_5216EC[3];

//----- (00456A40) --------------------------------------------------------
char __thiscall sub_456A40(int this, float* a2, int a3, float a4, int a5, int a6)
{
    int v7; // eax
    float* v8; // ecx
    char result; // al
    double v10; // st6
    float v11; // ebx
    float v12; // edi
    float v13; // ecx
    double v14; // st6
    float v15; // edx
    int v16; // [esp+0h] [ebp-78h]
    float v17; // [esp+18h] [ebp-60h]
    int v18; // [esp+2Ch] [ebp-4Ch] BYREF
    float v19; // [esp+30h] [ebp-48h]
    float v20; // [esp+34h] [ebp-44h]
    int v21; // [esp+38h] [ebp-40h]
    float v22; // [esp+3Ch] [ebp-3Ch]
    float v23; // [esp+40h] [ebp-38h]
    int v24; // [esp+44h] [ebp-34h] BYREF
    float v25; // [esp+48h] [ebp-30h]
    float v26; // [esp+4Ch] [ebp-2Ch]
    _WORD v27[3]; // [esp+50h] [ebp-28h] BYREF
    int v28; // [esp+56h] [ebp-22h]
    int v29; // [esp+5Ah] [ebp-1Eh]
    float v30; // [esp+5Eh] [ebp-1Ah]
    float v31; // [esp+62h] [ebp-16h]
    float v32; // [esp+66h] [ebp-12h]
    char v33; // [esp+6Ah] [ebp-Eh]
    int v34; // [esp+6Bh] [ebp-Dh]
    float v35; // [esp+6Fh] [ebp-9h]
    float v36; // [esp+73h] [ebp-5h]

    *(float*)&v18 = 0.0;
    v19 = 0.0;
    v7 = *(_DWORD*)(this + 392);
    v20 = 0.0;
    v8 = (float*)(*(_DWORD*)(*(_DWORD*)(dword_5216EC[*(_DWORD*)(v7 + 292)] + 8) + 12 * *(_DWORD*)(this + 464) + 8)
        + 36 * *(_DWORD*)(this + 468));
    *(float*)&v16 = *(float*)(v7 + 320) * *(float*)(v7 + 316) + *(float*)(this + 436);
    result = sub_420B50(
        a2,
        *(float*)&a3,
        *(_DWORD*)(this + 428),
        *(_DWORD*)(this + 432),
        v16,
        *(float*)(v7 + 316),
        0.0,
        (float*)&v18,
        (float*)&a3,
        v8[1],
        v8[2],
        v8[3],
        v8[4]);
    if (result)
    {
        if (*(_BYTE*)(dword_4F5CC4 + 936) || *(_BYTE*)(dword_4F5CC4 + 937))
        {
            v28 = *(_DWORD*)(this + 396);
            v21 = v18;
            v32 = *(float*)&a3 * a4;
            v10 = *(float*)&v18 - *a2;
            v11 = a2[1];
            v22 = v19;
            v12 = a2[2];
            v25 = v11;
            *(float*)&v21 = v10;
            v26 = v12;
            v29 = v18;
            v30 = v19;
            v34 = v21;
            v22 = v19 - v11;
            v31 = v20;
            v35 = v22;
            v23 = v20 - v12;
            v33 = 1;
            v36 = v23;
            return sub_4117D0(dword_4F5CC4, (int**)0x904, v27, 39, 2, 2000);
        }
        else
        {
            v13 = a2[1];
            v14 = *(float*)&v18 - *a2;
            v21 = v18;
            v15 = a2[2];
            *(float*)&v21 = v14;
            v24 = v21;
            v22 = v19 - v13;
            v25 = v22;
            v23 = v20 - v15;
            v26 = v23;
            v17 = *(float*)&a3 * a4;
            return sub_456C50(this, (float*)&v18, v17, 1, &v24);
        }
    }
    return result;
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 5216EC: using guessed type int dword_5216EC[3];

//----- (00456C50) --------------------------------------------------------
char __thiscall sub_456C50(int this, float* a2, float a3, char a4, _DWORD* a5)
{
    double v7; // st7
    char v8; // cl
    int v9; // ecx
    int v10; // eax
    int v11; // eax
    int v12; // eax
    int v13; // eax
    int v14; // ecx
    int v15; // edi
    int v16; // edx
    _DWORD* v17; // eax
    int v18; // ecx
    int v19; // ecx
    int v20; // eax
    int v21; // eax
    int v22; // eax
    int v23; // edx
    int v24; // ecx
    int v25; // eax
    int v26; // edi
    int v27; // edx
    _DWORD* v28; // eax
    int v29; // ecx

    if (*(float*)(this + 1340) <= 0.0)
        return 0;
    v7 = *(float*)(this + 1340) - a3;
    v8 = 0;
    *(float*)(this + 1340) = v7;
    if (v7 <= 0.0)
    {
        sub_458880(this);
        if (a4)
        {
            v19 = *(_DWORD*)(this + 392);
            *(_BYTE*)(this + 420) = 1;
            v20 = *(_DWORD*)(v19 + 296);
            if (v20)
            {
                if (v20 != 1)
                    sub_4281B0(aInvalidInfantr);
                v21 = *(_DWORD*)(this + 456);
                if (v21 < 9 || v21 > 11)
                    *(_DWORD*)(this + 456) = 19;
                else
                    *(_DWORD*)(this + 456) = 17;
            }
            else
            {
                *(_DWORD*)(this + 456) = 15;
            }
            v22 = *(_DWORD*)(this + 392);
            v23 = 16 * *(_DWORD*)(this + 456);
            v24 = *(_DWORD*)(v23 + v22 + 376);
            v25 = v23 + v22 + 372;
            if (v24)
                v26 = (*(_DWORD*)(v25 + 8) - v24) >> 3;
            else
                v26 = 0;
            v27 = rand() % v26;
            v28 = (_DWORD*)(16 * *(_DWORD*)(this + 456) + *(_DWORD*)(this + 392) + 376);
            *(_DWORD*)(this + 460) = v27;
            v29 = *(_DWORD*)(*v28 + 8 * v27 + 4);
            *(_DWORD*)(this + 468) = 0;
            *(_DWORD*)(this + 464) = v29;
            *(_DWORD*)(this + 484) = 0;
            *(float*)(this + 424) = (double)*(int*)(*v28 + 8 * v27) * 0.06666667;
            *(_DWORD*)(this + 440) = *a5;
            *(_DWORD*)(this + 444) = a5[1];
            *(_DWORD*)(this + 448) = a5[2];
            *(_DWORD*)(this + 448) = 0;
            sub_46B970(this + 440, this + 440);
            if (sub_401200((float*)(this + 440)))
                *(_DWORD*)(this + 448) = 1065353216;
            *(float*)(this + 440) = *(float*)(this + 440) * 160.0;
            *(float*)(this + 444) = *(float*)(this + 444) * 160.0;
            *(float*)(this + 448) = *(float*)(this + 448) * 160.0;
            *(float*)(this + 448) = *(float*)(this + 424) * 150.0;
            *(float*)(this + 436) = *(float*)(this + 436) + 20.0;
        }
        else
        {
            v9 = *(_DWORD*)(this + 392);
            v10 = *(_DWORD*)(v9 + 296);
            if (v10)
            {
                if (v10 == 1)
                {
                    v12 = *(_DWORD*)(this + 456);
                    if (v12 < 9 || v12 > 11)
                        *(_DWORD*)(this + 456) = 18;
                    else
                        *(_DWORD*)(this + 456) = 16;
                }
            }
            else
            {
                v11 = *(_DWORD*)(this + 456);
                if (v11 == 1 || v11 == 2)
                {
                    *(_DWORD*)(this + 456) = 13;
                }
                else if (v11 == 3 || v11 == 4)
                {
                    *(_DWORD*)(this + 456) = 14;
                }
                else
                {
                    *(_DWORD*)(this + 456) = 12;
                }
            }
            v13 = 16 * *(_DWORD*)(this + 456) + v9 + 372;
            v14 = *(_DWORD*)(16 * *(_DWORD*)(this + 456) + v9 + 376);
            if (v14)
                v15 = (*(_DWORD*)(v13 + 8) - v14) >> 3;
            else
                v15 = 0;
            v16 = rand() % v15;
            v17 = (_DWORD*)(16 * *(_DWORD*)(this + 456) + *(_DWORD*)(this + 392) + 376);
            *(_DWORD*)(this + 460) = v16;
            v18 = *(_DWORD*)(*v17 + 8 * v16 + 4);
            *(_DWORD*)(this + 468) = 0;
            *(_DWORD*)(this + 464) = v18;
            *(_DWORD*)(this + 484) = 0;
            *(float*)(this + 424) = (double)*(int*)(*v17 + 8 * v16) * 0.06666667;
        }
        sub_44DAD0(*(int**)(*(_DWORD*)(this + 392) + 800), a2, 0, 0);
        return 1;
    }
    return v8;
}
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);
// 520970: using guessed type int dword_520970;

//----- (00456F30) --------------------------------------------------------
int __thiscall sub_456F30(int this, float a2)
{
    int v3; // eax
    __int64 v4; // rax
    int v5; // ebp
    int v6; // ecx
    double v7; // st7
    int v8; // edi
    double v9; // st7
    int v10; // eax
    int v12; // [esp+10h] [ebp+4h]

    v3 = *(_DWORD*)(this + 392);
    *(_BYTE*)(this + 488) = 0;
    HIDWORD(v4) = *(_DWORD*)(v3 + 292);
    LODWORD(v4) = *(_DWORD*)(this + 456);
    v5 = dword_5216EC[HIDWORD(v4)];
    if ((_DWORD)v4)
    {
        if ((int)v4 < 12)
        {
            v9 = a2 + *(float*)(this + 484);
            v10 = *(_DWORD*)(this + 464);
            *(float*)(this + 484) = v9;
            v12 = *(_DWORD*)(12 * v10 + *(_DWORD*)(v5 + 8) + 4);
            if ((int)(__int64)(v9 * 15.0) >= v12)
            {
                do
                {
                    *(_BYTE*)(this + 488) = 1;
                    *(float*)(this + 484) = *(float*)(this + 484) - (double)v12 * 0.06666667;
                    v12 = *(_DWORD*)(12 * v10 + *(_DWORD*)(v5 + 8) + 4);
                } while ((int)(__int64)(*(float*)(this + 484) * 15.0) >= v12);
            }
            v4 = (__int64)(*(float*)(this + 484) * 15.0);
            *(_DWORD*)(this + 468) = v4;
        }
        else
        {
            v4 = (__int64)(*(float*)(this + 484) * 15.0);
            v6 = *(_DWORD*)(this + 464);
            *(_DWORD*)(this + 468) = v4;
            if ((int)v4 < *(_DWORD*)(12 * v6 + *(_DWORD*)(v5 + 8) + 4) - 1)
            {
                v7 = a2 + *(float*)(this + 484);
                *(float*)(this + 484) = v7;
                v4 = (__int64)(v7 * 15.0);
                *(_DWORD*)(this + 468) = v4;
                v8 = *(_DWORD*)(12 * v6 + *(_DWORD*)(v5 + 8) + 4);
                if ((int)v4 >= v8)
                {
                    LODWORD(v4) = v8 - 1;
                    *(_BYTE*)(this + 488) = 1;
                    *(_DWORD*)(this + 468) = v8 - 1;
                    *(float*)(this + 484) = (double)(v8 - 1) * 0.06666667;
                }
            }
        }
    }
    else
    {
        *(_DWORD*)(this + 468) = 0;
        *(_BYTE*)(this + 488) = 1;
    }
    return v4;
}
// 5216EC: using guessed type int dword_5216EC[3];

//----- (004570A0) --------------------------------------------------------
char __thiscall sub_4570A0(int this, int a2)
{
    float* v3; // ecx
    double v4; // st7
    long double v5; // st7
    double v6; // st7
    int v7; // eax
    _DWORD* v8; // ecx
    int v9; // eax
    double v10; // st7
    int v11; // eax
    int v12; // edi
    int v13; // edx
    int v14; // ecx
    int v15; // eax
    int v16; // eax
    long double v17; // st7
    int v18; // ecx
    int v19; // eax
    int v20; // eax
    float* v21; // ecx
    float v22; // edx
    float v23; // edx
    int v24; // ecx
    int v25; // eax
    double v26; // st7
    double v27; // st6
    double v28; // st7
    int v29; // edx
    double v30; // st6
    double v31; // st7
    double v32; // st6
    double v33; // st5
    int v34; // eax
    double v35; // st7
    double v36; // st7
    int v37; // eax
    double v38; // st7
    int v39; // ecx
    int v40; // eax
    bool v41; // zf
    signed int v42; // eax
    double v43; // st7
    int v44; // eax
    int v45; // eax
    int v46; // ecx
    int v47; // edi
    int v48; // eax
    long double v49; // st7
    char v50; // cl
    int v51; // eax
    int v52; // eax
    int v53; // ecx
    int v54; // edi
    int v55; // edx
    int v56; // ecx
    int v57; // eax
    int v58; // ecx
    int v59; // eax
    float* v60; // edx
    float v61; // ecx
    float v62; // eax
    float* v63; // eax
    double v64; // st7
    double v65; // st6
    double v66; // st7
    double v67; // st6
    double v68; // st7
    double v69; // st6
    double v70; // st5
    int v71; // eax
    bool v72; // zf
    signed int v73; // eax
    double v74; // st7
    int v75; // eax
    int v76; // eax
    int v77; // ecx
    int v78; // edi
    int v79; // eax
    int v80; // eax
    int v81; // eax
    int v82; // ecx
    int v83; // edi
    int v84; // edx
    int v85; // ecx
    int v86; // eax
    int v87; // ecx
    int v88; // eax
    int v89; // eax
    int v90; // ecx
    int v91; // edi
    int v92; // edx
    int v93; // ecx
    int v94; // eax
    int v95; // ecx
    int v96; // eax
    float* v97; // edx
    float v98; // ecx
    float v99; // eax
    float* v100; // eax
    double v101; // st7
    double v102; // st6
    double v103; // st7
    double v104; // st6
    double v105; // st7
    double v106; // st6
    double v107; // st5
    int v108; // eax
    int v109; // edx
    double v110; // st7
    double v111; // st7
    int v112; // eax
    int v113; // eax
    int v114; // eax
    int v115; // ecx
    int v116; // edi
    int v117; // edx
    int v118; // ecx
    int v119; // eax
    int v120; // ecx
    int v121; // eax
    long double v122; // st7
    double v123; // st7
    char v124; // al
    int v125; // eax
    int v126; // eax
    int v127; // ecx
    int v128; // edi
    int v129; // edx
    int v130; // eax
    int v131; // ecx
    int v132; // ecx
    int v133; // edi
    int v134; // edx
    int v135; // ecx
    int v136; // eax
    int v137; // ecx
    double v138; // st7
    double v139; // st7
    double v140; // st7
    int v141; // ecx
    int v142; // edx
    int v143; // ecx
    double v144; // st7
    double v145; // st7
    double v146; // st7
    double v147; // st7
    float v148; // ecx
    double v149; // st7
    float v150; // edx
    float v151; // eax
    float v152; // edx
    int v153; // eax
    int v155; // [esp+0h] [ebp-90h]
    int v156; // [esp+4h] [ebp-8Ch]
    float v157; // [esp+4h] [ebp-8Ch]
    char v158; // [esp+1Bh] [ebp-75h]
    float v159; // [esp+1Ch] [ebp-74h]
    float v160; // [esp+1Ch] [ebp-74h]
    float v161; // [esp+20h] [ebp-70h]
    float v162; // [esp+20h] [ebp-70h]
    float v163; // [esp+20h] [ebp-70h]
    float v164; // [esp+20h] [ebp-70h]
    float v165; // [esp+20h] [ebp-70h]
    float v166; // [esp+20h] [ebp-70h]
    float v167; // [esp+20h] [ebp-70h]
    float v168; // [esp+24h] [ebp-6Ch]
    float v169; // [esp+24h] [ebp-6Ch]
    float v170; // [esp+24h] [ebp-6Ch]
    float v171; // [esp+24h] [ebp-6Ch]
    float v172; // [esp+24h] [ebp-6Ch]
    float v173; // [esp+28h] [ebp-68h] BYREF
    float v174; // [esp+2Ch] [ebp-64h] BYREF
    float v175; // [esp+30h] [ebp-60h] BYREF
    float v176; // [esp+34h] [ebp-5Ch]
    float v177; // [esp+38h] [ebp-58h]
    float v178; // [esp+3Ch] [ebp-54h] BYREF
    float v179; // [esp+40h] [ebp-50h]
    float v180; // [esp+44h] [ebp-4Ch]
    float v181; // [esp+48h] [ebp-48h]
    float v182; // [esp+4Ch] [ebp-44h]
    float v183; // [esp+50h] [ebp-40h]
    float v184; // [esp+54h] [ebp-3Ch] BYREF
    float v185; // [esp+58h] [ebp-38h]
    float v186; // [esp+5Ch] [ebp-34h]
    float v187; // [esp+60h] [ebp-30h]
    float v188; // [esp+64h] [ebp-2Ch]
    float v189; // [esp+68h] [ebp-28h]
    float v190; // [esp+6Ch] [ebp-24h]
    float v191; // [esp+70h] [ebp-20h]
    int v192; // [esp+78h] [ebp-18h] BYREF
    float v193; // [esp+7Ch] [ebp-14h]
    float v194; // [esp+80h] [ebp-10h]
    int v195; // [esp+84h] [ebp-Ch] BYREF
    float v196; // [esp+88h] [ebp-8h]
    float v197; // [esp+8Ch] [ebp-4h]

    sub_456F30(this, *(float*)&a2);
    v3 = (float*)(this + 472);
    v184 = -*(float*)(this + 428);
    v185 = -*(float*)(this + 432);
    v4 = -*(float*)(this + 436);
    *(float*)(this + 472) = v184;
    v186 = v4;
    *(float*)(this + 476) = v185;
    *(float*)(this + 480) = v186;
    *(_DWORD*)(this + 480) = 0;
    v5 = sqrt(
        *(float*)(this + 472) * *(float*)(this + 472)
        + *(float*)(this + 476) * *(float*)(this + 476)
        + *(float*)(this + 480) * *(float*)(this + 480));
    v159 = v5;
    if (v5 == 0.0)
    {
        v184 = 0.0;
        v185 = 0.0;
        *v3 = 0.0;
        v186 = 0.0;
        *(_DWORD*)(this + 476) = 0;
        *(_DWORD*)(this + 480) = 0;
    }
    else
    {
        v6 = 1.0 / v159;
        *v3 = v6 * *v3;
        *(float*)(this + 476) = v6 * *(float*)(this + 476);
        *(float*)(this + 480) = v6 * *(float*)(this + 480);
    }
    v7 = *(_DWORD*)(this + 456);
    if (v7 < 1 || (v158 = 1, v7 > 4))
        v158 = 0;
    if (*(float*)(this + 1340) > 0.0)
    {
        v8 = *(_DWORD**)(this + 392);
        v9 = v8[74];
        if (v9)
        {
            if (v9 == 1)
            {
                if (*(float*)(this + 1364) > 0.0)
                    *(float*)(this + 1364) = *(float*)(this + 1364) - *(float*)&a2;
                if (*(float*)(this + 1364) <= 0.0 && *(_BYTE*)(this + 488) && v158 && v159 <= (double)*(float*)(this + 1336))
                {
                    sub_45F160(*(float**)(dword_520970 + 280), (float*)(this + 408));
                    v80 = *(_DWORD*)(this + 392);
                    *(_DWORD*)(this + 456) = 9;
                    v81 = v80 + 516;
                    v82 = *(_DWORD*)(v81 + 4);
                    if (v82)
                        v83 = (*(_DWORD*)(v81 + 8) - v82) >> 3;
                    else
                        v83 = 0;
                    v84 = rand() % v83;
                    v85 = *(_DWORD*)(this + 392);
                    v86 = 16 * *(_DWORD*)(this + 456);
                    *(_DWORD*)(this + 460) = v84;
                    v87 = *(_DWORD*)(*(_DWORD*)(v86 + v85 + 376) + 8 * v84 + 4);
                    *(_BYTE*)(this + 488) = 0;
                    *(_DWORD*)(this + 464) = v87;
                    sub_456F30(this, 0.0);
                }
                if (*(_DWORD*)(this + 456) == 9 && *(_BYTE*)(this + 488))
                {
                    v88 = *(_DWORD*)(this + 392);
                    *(_DWORD*)(this + 456) = 10;
                    v89 = v88 + 532;
                    v90 = *(_DWORD*)(v89 + 4);
                    if (v90)
                        v91 = (*(_DWORD*)(v89 + 8) - v90) >> 3;
                    else
                        v91 = 0;
                    v92 = rand() % v91;
                    v93 = *(_DWORD*)(this + 392);
                    v94 = 16 * *(_DWORD*)(this + 456);
                    *(_DWORD*)(this + 460) = v92;
                    v95 = *(_DWORD*)(*(_DWORD*)(v94 + v93 + 376) + 8 * v92 + 4);
                    *(_BYTE*)(this + 488) = 0;
                    *(_DWORD*)(this + 464) = v95;
                    sub_456F30(this, 0.0);
                    *(_BYTE*)(this + 1368) = 0;
                }
                if (*(_DWORD*)(this + 456) == 10
                    && *(_DWORD*)(this + 468) == *(_DWORD*)(*(_DWORD*)(this + 392) + 788)
                    && !*(_BYTE*)(this + 1368))
                {
                    *(_BYTE*)(this + 1368) = 1;
                    v96 = sub_408F30((_DWORD*)dword_520970);
                    v181 = *(float*)(v96 + 56);
                    v182 = *(float*)(v96 + 60);
                    v97 = (float*)(v96 + 44);
                    v98 = *(float*)(v96 + 64);
                    v96 += 32;
                    v183 = v98;
                    v178 = *v97;
                    v179 = v97[1];
                    v180 = v97[2];
                    v187 = *(float*)v96;
                    v188 = *(float*)(v96 + 4);
                    v99 = *(float*)(v96 + 8);
                    v178 = v178 - v187;
                    v189 = v99;
                    v179 = v179 - v188;
                    v180 = v180 - v99;
                    sub_46B970(&v178, &v178);
                    v187 = v183 * v179 - v182 * v180;
                    v184 = v187;
                    v188 = v180 * v181 - v183 * v178;
                    v185 = v188;
                    v189 = v182 * v178 - v179 * v181;
                    v186 = v189;
                    sub_46B970(&v184, &v184);
                    v175 = *(float*)(this + 428);
                    v176 = *(float*)(this + 432);
                    v100 = *(float**)(this + 392);
                    v177 = *(float*)(this + 436);
                    v101 = v100[198];
                    *(float*)&v195 = v184 * v101;
                    v196 = v101 * v185;
                    v102 = v100[79];
                    *(float*)&v192 = *(float*)&v195 * v102;
                    v193 = v196 * v102;
                    v175 = *(float*)&v192 + v175;
                    v176 = v193 + v176;
                    v177 = v101 * v186 * v102 + v177;
                    v103 = v100[80];
                    *(float*)&v195 = v103 * v181;
                    v196 = v182 * v103;
                    v104 = v100[79];
                    v190 = *(float*)&v195 * v104;
                    v191 = v196 * v104;
                    v105 = v103 * v183 * v104;
                    v106 = v100[199];
                    *(float*)&v195 = v106 * v181;
                    v196 = v182 * v106;
                    v107 = v100[79];
                    *(float*)&v192 = *(float*)&v195 * v107;
                    v193 = v196 * v107;
                    *(float*)&v195 = *(float*)&v192 + v190;
                    v196 = v193 + v191;
                    v175 = *(float*)&v195 + v175;
                    v176 = v196 + v176;
                    v177 = v105 + v106 * v183 * v107 + v177;
                    v166 = v100[195];
                    v173 = v100[196];
                    if (v166 == v173)
                    {
                        v173 = v166;
                    }
                    else
                    {
                        v174 = COERCE_FLOAT(rand());
                        v173 = fabs((double)SLODWORD(v174) * 0.000030518509) * (v173 - v166) + v166;
                    }
                    v108 = *(_DWORD*)(this + 392);
                    *(float*)&v195 = 0.0;
                    v196 = 0.0;
                    v197 = 1.0;
                    sub_44A1D0(
                        *(char**)(dword_520970 + 276),
                        *(_DWORD*)(v108 + 776),
                        &v175,
                        (float*)(this + 408),
                        v173,
                        0,
                        0,
                        0.0,
                        (int)&v195);
                    v109 = *(_DWORD*)(this + 392);
                    v196 = v179 * 18.0;
                    *(float*)&v195 = 0.0;
                    v197 = v180 * 18.0;
                    v175 = v175 - v178 * 18.0;
                    v110 = v176 - v196;
                    v196 = 0.0;
                    v176 = v110;
                    v111 = v177 - v197;
                    v197 = 0.0;
                    v177 = v111;
                    sub_44DF20(*(char**)(dword_520970 + 240), *(float*)(v109 + 812), COERCE_FLOAT(&v175), (float*)&v195);
                }
                v112 = *(_DWORD*)(this + 456);
                if (v112 == 10
                    && *(_DWORD*)(this + 468) != *(_DWORD*)(*(_DWORD*)(this + 392) + 788)
                    && *(_BYTE*)(this + 1368))
                {
                    *(_BYTE*)(this + 1368) = 0;
                }
                if (v112 == 10 && *(_BYTE*)(this + 488))
                {
                    v113 = *(_DWORD*)(this + 392);
                    *(_DWORD*)(this + 456) = 11;
                    v114 = v113 + 548;
                    v115 = *(_DWORD*)(v114 + 4);
                    if (v115)
                        v116 = (*(_DWORD*)(v114 + 8) - v115) >> 3;
                    else
                        v116 = 0;
                    v117 = rand() % v116;
                    v118 = *(_DWORD*)(this + 392);
                    v119 = 16 * *(_DWORD*)(this + 456);
                    *(_DWORD*)(this + 460) = v117;
                    v120 = *(_DWORD*)(*(_DWORD*)(v119 + v118 + 376) + 8 * v117 + 4);
                    *(_BYTE*)(this + 488) = 0;
                    *(_DWORD*)(this + 464) = v120;
                    sub_456F30(this, 0.0);
                    v121 = *(_DWORD*)(this + 392);
                    v167 = *(float*)(v121 + 364);
                    v173 = *(float*)(v121 + 368);
                    if (v167 == v173)
                    {
                        v122 = v167;
                    }
                    else
                    {
                        v174 = COERCE_FLOAT(rand());
                        v122 = fabs((double)SLODWORD(v174) * 0.000030518509) * (v173 - v167) + v167;
                    }
                    *(float*)(this + 1372) = v122;
                }
                if (*(_DWORD*)(this + 456) == 11)
                {
                    v123 = *(float*)(this + 1372) - *(float*)&a2;
                    *(float*)(this + 1372) = v123;
                    v124 = *(_BYTE*)(this + 488);
                    if (v123 > 0.0)
                    {
                        if (v124)
                        {
                            v132 = *(_DWORD*)(*(_DWORD*)(this + 392) + 552);
                            if (v132)
                                v133 = (*(_DWORD*)(*(_DWORD*)(this + 392) + 556) - v132) >> 3;
                            else
                                v133 = 0;
                            v134 = rand() % v133;
                            v135 = *(_DWORD*)(this + 392);
                            v136 = 16 * *(_DWORD*)(this + 456);
                            *(_DWORD*)(this + 460) = v134;
                            v137 = *(_DWORD*)(*(_DWORD*)(v136 + v135 + 376) + 8 * v134 + 4);
                            *(_BYTE*)(this + 488) = 0;
                            *(_DWORD*)(this + 464) = v137;
                        }
                    }
                    else if (v124)
                    {
                        v125 = *(_DWORD*)(this + 392);
                        *(_DWORD*)(this + 456) = 10;
                        v126 = v125 + 532;
                        v127 = *(_DWORD*)(v126 + 4);
                        if (v127)
                            v128 = (*(_DWORD*)(v126 + 8) - v127) >> 3;
                        else
                            v128 = 0;
                        v129 = rand() % v128;
                        v130 = *(_DWORD*)(this + 392);
                        v131 = 16 * *(_DWORD*)(this + 456);
                        *(_DWORD*)(this + 460) = v129;
                        *(_DWORD*)(this + 464) = *(_DWORD*)(*(_DWORD*)(v131 + v130 + 376) + 8 * v129 + 4);
                        *(_BYTE*)(this + 488) = 0;
                        sub_456F30(this, 0.0);
                        *(_BYTE*)(this + 1368) = 0;
                    }
                }
            }
        }
        else
        {
            if (!*(_BYTE*)(this + 1344))
            {
                v10 = *(float*)(this + 1348) - *(float*)&a2;
                *(float*)(this + 1348) = v10;
                if (v10 <= 0.0)
                    *(_BYTE*)(this + 1344) = 1;
            }
            if (*(_BYTE*)(this + 1344) && v158 && *(_BYTE*)(this + 488) && v159 <= (double)*(float*)(this + 1336))
            {
                *(_DWORD*)(this + 456) = 6;
                v11 = v8[118];
                if (v11)
                    v12 = (v8[119] - v11) >> 3;
                else
                    v12 = 0;
                v13 = rand() % v12;
                v14 = *(_DWORD*)(this + 392);
                v15 = 16 * *(_DWORD*)(this + 456);
                *(_DWORD*)(this + 460) = v13;
                *(_DWORD*)(this + 464) = *(_DWORD*)(*(_DWORD*)(v15 + v14 + 376) + 8 * v13 + 4);
                sub_456F30(this, 0.0);
                v16 = *(_DWORD*)(this + 392);
                v161 = *(float*)(v16 + 332);
                v168 = *(float*)(v16 + 336);
                if (v161 == v168)
                {
                    v17 = v161;
                }
                else
                {
                    v173 = COERCE_FLOAT(rand());
                    v17 = fabs((double)SLODWORD(v173) * 0.000030518509) * (v168 - v161) + v161;
                }
                *(float*)(this + 1348) = v17;
                sub_45F160(*(float**)(dword_520970 + 280), (float*)(this + 408));
            }
            if (*(_DWORD*)(this + 456) == 6 && *(_BYTE*)(this + 488))
            {
                v18 = *(_DWORD*)(this + 392);
                v19 = *(_DWORD*)(this + 460);
                *(_DWORD*)(this + 456) = 8;
                *(_DWORD*)(this + 464) = *(_DWORD*)(*(_DWORD*)(v18 + 504) + 8 * v19 + 4);
                sub_456F30(this, 0.0);
                *(_BYTE*)(this + 1352) = 0;
            }
            if (*(_DWORD*)(this + 456) == 8
                && *(_DWORD*)(this + 468) == *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 392) + 700)
                    + 4 * *(_DWORD*)(this + 460))
                && !*(_BYTE*)(this + 1352))
            {
                *(_BYTE*)(this + 1352) = 1;
                v20 = sub_408F30((_DWORD*)dword_520970);
                v181 = *(float*)(v20 + 56);
                v182 = *(float*)(v20 + 60);
                v21 = (float*)(v20 + 44);
                v22 = *(float*)(v20 + 64);
                v20 += 32;
                v183 = v22;
                v178 = *v21;
                v179 = v21[1];
                v180 = v21[2];
                v187 = *(float*)v20;
                v188 = *(float*)(v20 + 4);
                v23 = *(float*)(v20 + 8);
                v178 = v178 - v187;
                v189 = v23;
                v179 = v179 - v188;
                v180 = v180 - v23;
                sub_46B970(&v178, &v178);
                v187 = v183 * v179 - v182 * v180;
                v184 = v187;
                v188 = v180 * v181 - v183 * v178;
                v185 = v188;
                v189 = v182 * v178 - v179 * v181;
                v186 = v189;
                sub_46B970(&v184, &v184);
                v175 = *(float*)(this + 428);
                v24 = *(_DWORD*)(this + 460);
                v176 = *(float*)(this + 432);
                v177 = *(float*)(this + 436);
                v25 = *(_DWORD*)(this + 392);
                v24 *= 4;
                v26 = *(float*)(*(_DWORD*)(v25 + 716) + v24);
                v187 = v184 * v26;
                v188 = v26 * v185;
                v27 = *(float*)(v25 + 316);
                v190 = v187 * v27;
                v191 = v188 * v27;
                v175 = v190 + v175;
                v176 = v191 + v176;
                v177 = v26 * v186 * v27 + v177;
                v28 = *(float*)(v25 + 320);
                v29 = *(_DWORD*)(v25 + 732);
                v190 = v28 * v181;
                v191 = v182 * v28;
                v30 = *(float*)(v25 + 316);
                *(float*)&v192 = v190 * v30;
                v193 = v191 * v30;
                v31 = v28 * v183 * v30;
                v32 = *(float*)(v29 + v24);
                v190 = v32 * v181;
                v191 = v182 * v32;
                v33 = *(float*)(v25 + 316);
                v187 = v190 * v33;
                v188 = v191 * v33;
                v190 = v187 + *(float*)&v192;
                *(float*)&v192 = 0.0;
                v191 = v188 + v193;
                v193 = 0.0;
                v194 = 1.0;
                v175 = v190 + v175;
                v176 = v191 + v176;
                v177 = v31 + v32 * v183 * v33 + v177;
                sub_44A1D0(
                    *(char**)(dword_520970 + 276),
                    *(_DWORD*)(v25 + 692),
                    &v175,
                    (float*)(this + 408),
                    0.5,
                    0,
                    0,
                    0.0,
                    (int)&v192);
                v34 = *(_DWORD*)(this + 392);
                v193 = v179 * 18.0;
                *(float*)&v192 = 0.0;
                v194 = v180 * 18.0;
                v175 = v175 - v178 * 18.0;
                v35 = v176 - v193;
                v193 = 0.0;
                v176 = v35;
                v36 = v177 - v194;
                v194 = 0.0;
                v177 = v36;
                sub_44DF20(*(char**)(dword_520970 + 240), *(float*)(v34 + 812), COERCE_FLOAT(&v175), (float*)&v192);
            }
            v37 = *(_DWORD*)(this + 456);
            if (v37 == 8
                && *(_DWORD*)(this + 468) != *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 392) + 700)
                    + 4 * *(_DWORD*)(this + 460))
                && *(_BYTE*)(this + 1352))
            {
                *(_BYTE*)(this + 1352) = 0;
            }
            if (v37 == 8)
            {
                v38 = *(float*)(this + 1348) - *(float*)&a2;
                *(float*)(this + 1348) = v38;
                if (v38 <= 0.0)
                {
                    if (*(_BYTE*)(this + 488))
                    {
                        v39 = *(_DWORD*)(this + 392);
                        v40 = *(_DWORD*)(this + 460);
                        *(_DWORD*)(this + 456) = 7;
                        *(_DWORD*)(this + 464) = *(_DWORD*)(*(_DWORD*)(v39 + 488) + 8 * v40 + 4);
                        sub_456F30(this, 0.0);
                        *(_BYTE*)(this + 1352) = 0;
                    }
                }
            }
            if (*(_DWORD*)(this + 456) == 7 && *(_BYTE*)(this + 488))
            {
                if (*(float*)(this + 1328) != 0.0)
                {
                    v42 = rand() & 0x80000001;
                    v41 = v42 == 0;
                    if (v42 < 0)
                        v41 = (((_BYTE)v42 - 1) | 0xFFFFFFFE) == -1;
                    if (v41)
                        v43 = -1.0;
                    else
                        v43 = 1.0;
                    *(float*)(this + 1328) = v43;
                }
                sub_41C050((_DWORD*)(this + 492));
                v44 = *(_DWORD*)(this + 392);
                *(_DWORD*)(this + 456) = 1;
                v45 = v44 + 388;
                v46 = *(_DWORD*)(v45 + 4);
                if (v46)
                    v47 = (*(_DWORD*)(v45 + 8) - v46) >> 3;
                else
                    v47 = 0;
                v158 = 1;
                *(_DWORD*)(this + 460) = rand() % v47;
                sub_456F30(this, 0.0);
                v48 = *(_DWORD*)(this + 392);
                *(_BYTE*)(this + 1344) = 0;
                v162 = *(float*)(v48 + 340);
                v169 = *(float*)(v48 + 344);
                if (v162 == v169)
                {
                    v49 = v162;
                }
                else
                {
                    v173 = COERCE_FLOAT(rand());
                    v49 = fabs((double)SLODWORD(v173) * 0.000030518509) * (v169 - v162) + v162;
                }
                *(float*)(this + 1348) = v49;
            }
            v50 = *(_BYTE*)(this + 1344);
            if (!v50 && *(float*)(this + 1356) > 0.0)
                *(float*)(this + 1356) = *(float*)(this + 1356) - *(float*)&a2;
            if (!v50
                && *(float*)(this + 1356) <= 0.0
                && *(_BYTE*)(this + 488)
                && v158
                && v159 <= (double)*(float*)(this + 1336))
            {
                v51 = *(_DWORD*)(this + 392);
                *(_DWORD*)(this + 456) = 5;
                v52 = v51 + 452;
                v53 = *(_DWORD*)(v52 + 4);
                if (v53)
                    v54 = (*(_DWORD*)(v52 + 8) - v53) >> 3;
                else
                    v54 = 0;
                v55 = rand() % v54;
                v56 = *(_DWORD*)(this + 392);
                v57 = 16 * *(_DWORD*)(this + 456);
                *(_DWORD*)(this + 460) = v55;
                v58 = *(_DWORD*)(*(_DWORD*)(v57 + v56 + 376) + 8 * v55 + 4);
                *(_DWORD*)(this + 468) = 0;
                *(_DWORD*)(this + 464) = v58;
                *(_DWORD*)(this + 484) = 0;
                sub_456F30(this, 0.0);
                *(_BYTE*)(this + 1360) = 0;
            }
            if (*(_DWORD*)(this + 456) == 5)
            {
                if (*(_DWORD*)(this + 468) == *(_DWORD*)(*(_DWORD*)(this + 392) + 764) && !*(_BYTE*)(this + 1360))
                {
                    *(_BYTE*)(this + 1360) = 1;
                    v59 = sub_408F30((_DWORD*)dword_520970);
                    v181 = *(float*)(v59 + 56);
                    v182 = *(float*)(v59 + 60);
                    v60 = (float*)(v59 + 44);
                    v61 = *(float*)(v59 + 64);
                    v59 += 32;
                    v183 = v61;
                    v178 = *v60;
                    v179 = v60[1];
                    v180 = v60[2];
                    v187 = *(float*)v59;
                    v188 = *(float*)(v59 + 4);
                    v62 = *(float*)(v59 + 8);
                    v178 = v178 - v187;
                    v189 = v62;
                    v179 = v179 - v188;
                    v180 = v180 - v62;
                    sub_46B970(&v178, &v178);
                    v187 = v183 * v179 - v182 * v180;
                    v184 = v187;
                    v188 = v180 * v181 - v183 * v178;
                    v185 = v188;
                    v189 = v182 * v178 - v179 * v181;
                    v186 = v189;
                    sub_46B970(&v184, &v184);
                    v175 = *(float*)(this + 428);
                    v176 = *(float*)(this + 432);
                    v63 = *(float**)(this + 392);
                    v177 = *(float*)(this + 436);
                    v64 = v63[192];
                    *(float*)&v192 = v184 * v64;
                    v193 = v64 * v185;
                    v65 = v63[79];
                    v190 = *(float*)&v192 * v65;
                    v191 = v193 * v65;
                    v175 = v190 + v175;
                    v176 = v191 + v176;
                    v177 = v64 * v186 * v65 + v177;
                    v66 = v63[80];
                    *(float*)&v192 = v66 * v181;
                    v193 = v182 * v66;
                    v67 = v63[79];
                    v187 = *(float*)&v192 * v67;
                    v188 = v193 * v67;
                    v68 = v66 * v183 * v67;
                    v69 = v63[193];
                    *(float*)&v192 = v69 * v181;
                    v193 = v182 * v69;
                    v70 = v63[79];
                    v190 = *(float*)&v192 * v70;
                    v191 = v193 * v70;
                    *(float*)&v192 = v190 + v187;
                    *(float*)&v195 = -1.0;
                    v196 = 0.0;
                    v197 = 0.0;
                    v193 = v191 + v188;
                    v175 = *(float*)&v192 + v175;
                    v176 = v193 + v176;
                    v177 = v68 + v69 * v183 * v70 + v177;
                    v163 = v63[187];
                    v170 = v63[188];
                    if (v163 == v170)
                        v173 = v63[187];
                    else
                        v173 = fabs((double)rand() * 0.000030518509) * (v170 - v163) + v163;
                    v71 = *(_DWORD*)(this + 392);
                    v164 = *(float*)(v71 + 756);
                    v171 = *(float*)(v71 + 760);
                    if (v164 == v171)
                    {
                        sub_44A1D0(
                            *(char**)(dword_520970 + 276),
                            *(_DWORD*)(*(_DWORD*)(this + 392) + 744),
                            &v175,
                            (float*)(this + 408),
                            *(float*)(v71 + 756),
                            0,
                            0,
                            v173,
                            (int)&v195);
                    }
                    else
                    {
                        v174 = COERCE_FLOAT(rand());
                        v172 = fabs((double)SLODWORD(v174) * 0.000030518509) * (v171 - v164) + v164;
                        sub_44A1D0(
                            *(char**)(dword_520970 + 276),
                            *(_DWORD*)(*(_DWORD*)(this + 392) + 744),
                            &v175,
                            (float*)(this + 408),
                            v172,
                            0,
                            0,
                            v173,
                            (int)&v195);
                    }
                }
                if (*(_DWORD*)(this + 456) == 5 && *(_BYTE*)(this + 488))
                {
                    if (*(float*)(this + 1328) != 0.0)
                    {
                        v73 = rand() & 0x80000001;
                        v72 = v73 == 0;
                        if (v73 < 0)
                            v72 = (((_BYTE)v73 - 1) | 0xFFFFFFFE) == -1;
                        if (v72)
                            v74 = -1.0;
                        else
                            v74 = 1.0;
                        *(float*)(this + 1328) = v74;
                    }
                    sub_41C050((_DWORD*)(this + 492));
                    v75 = *(_DWORD*)(this + 392);
                    *(_DWORD*)(this + 456) = 1;
                    v76 = v75 + 388;
                    v77 = *(_DWORD*)(v76 + 4);
                    if (v77)
                        v78 = (*(_DWORD*)(v76 + 8) - v77) >> 3;
                    else
                        v78 = 0;
                    v158 = 1;
                    *(_DWORD*)(this + 460) = rand() % v78;
                    sub_456F30(this, 0.0);
                    v79 = *(_DWORD*)(this + 392);
                    v165 = *(float*)(v79 + 348);
                    v173 = *(float*)(v79 + 352);
                    if (v165 == v173)
                    {
                        *(float*)(this + 1356) = v165;
                    }
                    else
                    {
                        v174 = COERCE_FLOAT(rand());
                        *(float*)(this + 1356) = fabs((double)SLODWORD(v174) * 0.000030518509) * (v173 - v165) + v165;
                    }
                }
            }
        }
    }
    if (*(float*)(this + 1340) > 0.0 && v158)
    {
        if (v159 <= (double)*(float*)(this + 1336))
        {
            v138 = *(float*)(this + 1336) - *(float*)(this + 1332);
            if (v138 == 0.0)
            {
                v160 = 0.0;
            }
            else
            {
                v160 = (*(float*)(this + 1336) - v159) / v138;
                if (v160 >= 1.0)
                    v160 = 1.0;
            }
            if (*(float*)(this + 1328) == 0.0)
            {
                if (sub_41C200((float*)(this + 492), 0.0) >= 0.0)
                    v139 = 1.0;
                else
                    v139 = -1.0;
                *(float*)(this + 1328) = v139;
            }
            if (*(float*)(this + 1328) >= 0.0)
            {
                *(float*)&v155 = v160 * 1.5707964;
                sub_41C090((_DWORD*)(this + 492), v155, 1070141403);
            }
            else
            {
                *(float*)&v156 = v160 * -1.5707964;
                sub_41C090((_DWORD*)(this + 492), -1077342245, v156);
            }
        }
        v140 = sub_41C200((float*)(this + 492), *(float*)&a2);
        v141 = *(_DWORD*)(this + 472);
        v142 = *(_DWORD*)(this + 476);
        v174 = v140;
        *(_DWORD*)(this + 440) = v141;
        v143 = *(_DWORD*)(this + 480);
        *(_DWORD*)(this + 444) = v142;
        v157 = v174;
        *(_DWORD*)(this + 448) = v143;
        sub_401000((float*)(this + 440), v157);
        v144 = *(float*)(this + 452);
        *(float*)&v195 = v144 * *(float*)(this + 440);
        v196 = v144 * *(float*)(this + 444);
        v145 = v144 * *(float*)(this + 448);
        *(float*)&v192 = *(float*)&v195 * *(float*)&a2;
        v193 = v196 * *(float*)&a2;
        *(float*)(this + 428) = *(float*)&v192 + *(float*)(this + 428);
        *(float*)(this + 432) = v193 + *(float*)(this + 432);
        *(float*)(this + 436) = v145 * *(float*)&a2 + *(float*)(this + 436);
        *(float*)(this + 436) = sub_468BE0(
            (int*)*(_DWORD*)(dword_520970 + 260),
            *(_DWORD*)(this + 428),
            *(_DWORD*)(this + 432),
            (int*)&v173);
    }
    if (*(float*)(this + 1340) <= 0.0 && *(float*)(this + 424) > 0.0 && !*(_BYTE*)(this + 420))
    {
        v146 = *(float*)(this + 424) - *(float*)&a2;
        *(float*)(this + 424) = v146;
        if (v146 <= 0.0)
            sub_44DAD0(*(int**)(*(_DWORD*)(this + 392) + 804), (float*)(this + 428), 0, 0);
    }
    if (*(float*)(this + 1340) <= 0.0)
    {
        if (*(_BYTE*)(this + 420))
        {
            *(float*)(this + 448) = *(float*)(this + 448) - *(float*)&a2 * 300.0;
            v147 = *(float*)&a2 * *(float*)(this + 440);
            v196 = *(float*)&a2 * *(float*)(this + 444);
            v197 = *(float*)&a2 * *(float*)(this + 448);
            *(float*)(this + 428) = v147 + *(float*)(this + 428);
            *(float*)(this + 432) = v196 + *(float*)(this + 432);
            *(float*)(this + 436) = v197 + *(float*)(this + 436);
            v148 = *(float*)(this + 432);
            v187 = *(float*)(this + 428);
            v188 = v148;
            v149 = sub_468BE0(
                (int*)*(_DWORD*)(dword_520970 + 260),
                *(_DWORD*)(this + 428),
                *(_DWORD*)(this + 432),
                (int*)&v174);
            v189 = v149;
            if (v149 >= *(float*)(this + 436))
            {
                v150 = v187;
                v151 = v188;
                *(_BYTE*)(this + 420) = 0;
                *(float*)(this + 428) = v150;
                v152 = v189;
                *(float*)(this + 432) = v151;
                v153 = *(_DWORD*)(this + 392);
                *(float*)(this + 436) = v152;
                sub_44DAD0(*(int**)(v153 + 808), (float*)(this + 428), 0, 0);
            }
        }
    }
    sub_4565B0(this);
    return sub_428620((_DWORD*)this, a2);
}
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);
// 520970: using guessed type int dword_520970;

//----- (00458880) --------------------------------------------------------
char __thiscall sub_458880(int this)
{
    char result; // al
    int v3; // ecx

    result = *(_BYTE*)(this + 404);
    if (result)
    {
        if (!*(_BYTE*)(dword_4F5CC4 + 937))
        {
            if (dword_5216E8)
                sub_462520(*(_DWORD**)(dword_520970 + 280), *(_DWORD*)(*(_DWORD*)(this + 392) + 304), dword_5216E8);
        }
        v3 = *(_DWORD*)(this + 392);
        *(_BYTE*)(this + 404) = 0;
        return sub_45A420(*(float**)(dword_520970 + 236), v3, 1, 0, 1);
    }
    return result;
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;
// 5216E8: using guessed type int dword_5216E8;

//----- (004588F0) --------------------------------------------------------
char __thiscall sub_4588F0(_DWORD* this, int a2)
{
    int v3; // esi
    __int16 v4; // ax
    int v5; // edx
    int v6; // eax
    int v7; // ecx
    int v8; // edx
    int v9; // ecx
    int v10; // edx
    int v11; // eax
    _WORD v13[3]; // [esp+8h] [ebp-2Ch] BYREF
    int v14; // [esp+Eh] [ebp-26h]
    int v15; // [esp+12h] [ebp-22h]
    int v16; // [esp+16h] [ebp-1Eh]
    int v17; // [esp+1Ah] [ebp-1Ah]
    int v18; // [esp+1Eh] [ebp-16h]
    char v19; // [esp+22h] [ebp-12h]
    int v20; // [esp+23h] [ebp-11h]
    int v21; // [esp+27h] [ebp-Dh]
    int v22; // [esp+2Bh] [ebp-9h]
    int v23; // [esp+2Fh] [ebp-5h]

    v3 = *(_DWORD*)(a2 + 16);
    if (*(_WORD*)(a2 + 12) == 2308)
    {
        LOBYTE(v4) = dword_4F5CC4;
        if (*(_BYTE*)(dword_4F5CC4 + 936))
        {
            dword_5216E8 = *(_DWORD*)(a2 + 4);
            sub_456C50((int)this, (float*)(v3 + 10), *(float*)(v3 + 22), *(_BYTE*)(v3 + 26), (_DWORD*)(v3 + 27));
            v5 = *(_DWORD*)(v3 + 10);
            v6 = *(_DWORD*)(v3 + 14);
            v14 = this[99];
            v7 = *(_DWORD*)(v3 + 18);
            v15 = v5;
            v8 = *(_DWORD*)(v3 + 22);
            v17 = v7;
            v9 = *(_DWORD*)(v3 + 27);
            v16 = v6;
            LOBYTE(v6) = *(_BYTE*)(v3 + 26);
            v20 = v9;
            v18 = v8;
            v10 = *(_DWORD*)(v3 + 31);
            v19 = v6;
            v11 = *(_DWORD*)(v3 + 35);
            v21 = v10;
            v22 = v11;
            v23 = 0;
            LOBYTE(v4) = sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x905, v13, 43, 10, 2000);
            dword_5216E8 = 0;
        }
    }
    else
    {
        v4 = *(_WORD*)(a2 + 12) - 2309;
        if (*(_WORD*)(a2 + 12) == 2309)
            LOBYTE(v4) = sub_456C50(
                (int)this,
                (float*)(v3 + 10),
                *(float*)(v3 + 22),
                *(_BYTE*)(v3 + 26),
                (_DWORD*)(v3 + 27));
    }
    return v4;
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 5216E8: using guessed type int dword_5216E8;

//----- (004589E0) --------------------------------------------------------
int __thiscall sub_4589E0(_DWORD* this)
{
    int v1; // edx

    v1 = this[1];
    if (v1)
        return (this[2] - v1) >> 3;
    else
        return 0;
}

//----- (00458A00) --------------------------------------------------------
int __thiscall sub_458A00(_DWORD* this, int a2)
{
    return this[1] + 8 * a2;
}

//----- (00458A10) --------------------------------------------------------
int __thiscall sub_458A10(int* this, _DWORD* a2)
{
    _DWORD* v3; // eax
    _DWORD* v4; // edi
    int v5; // edx
    unsigned int v6; // ecx
    int v7; // eax
    int v8; // eax
    _DWORD* v9; // eax
    _DWORD* v10; // ebp
    _DWORD* i; // ebx
    int v12; // eax
    int result; // eax
    int v14; // ecx
    _DWORD* v15; // ecx
    _DWORD* v16; // eax
    _DWORD* v17; // [esp+Ch] [ebp-8h]
    int v18; // [esp+10h] [ebp-4h]

    v3 = (_DWORD*)this[2];
    v4 = v3;
    if ((this[3] - (int)v3) >> 3)
    {
        sub_458C00(v3, v3, v3 + 2);
        sub_458C40((_DWORD*)this[2], (_DWORD*)(1 - ((this[2] - (int)v4) >> 3)), a2);
        v15 = (_DWORD*)this[2];
        v16 = v4;
        if (v4 == v15)
        {
            result = this[2] + 8;
            this[2] = result;
        }
        else
        {
            do
            {
                *v16 = *a2;
                v16[1] = a2[1];
                v16 += 2;
            } while (v16 != v15);
            result = this[2] + 8;
            this[2] = result;
        }
    }
    else
    {
        v5 = this[1];
        if (!v5 || (v6 = ((int)v3 - v5) >> 3, v6 <= 1))
            v6 = 1;
        if (v5)
            v7 = ((int)v3 - v5) >> 3;
        else
            v7 = 0;
        v8 = v6 + v7;
        v18 = v8;
        if (v8 < 0)
            v8 = 0;
        v9 = operator new(8 * v8);
        v10 = (_DWORD*)this[1];
        v17 = v9;
        for (i = v9; v10 != v4; i += 2)
        {
            sub_458CD0(i, v10);
            v10 += 2;
        }
        sub_458C40(i, (_DWORD*)1, a2);
        sub_458C00(v4, (_DWORD*)this[2], i + 2);
        nullsub_8(this[1], this[2]);
        sub_4885A6((LPVOID)this[1]);
        v12 = this[1];
        this[3] = (int)&v17[2 * v18];
        if (v12)
        {
            v14 = this[2];
            this[1] = (int)v17;
            result = (int)&v17[2 * ((v14 - v12) >> 3) + 2];
            this[2] = result;
        }
        else
        {
            this[1] = (int)v17;
            result = (int)(v17 + 2);
            this[2] = (int)(v17 + 2);
        }
    }
    return result;
}

//----- (00458BE0) --------------------------------------------------------
int __thiscall sub_458BE0(_DWORD* this)
{
    return this[1];
}

//----- (00458BF0) --------------------------------------------------------
void __stdcall sub_458BF0(void* a1, int a2)
{
    sub_4885A6(a1);
}

//----- (00458C00) --------------------------------------------------------
_DWORD* __stdcall sub_458C00(_DWORD* a1, _DWORD* a2, _DWORD* a3)
{
    _DWORD* v3; // ecx
    _DWORD* result; // eax

    v3 = a1;
    if (a1 == a2)
        return a3;
    result = a3;
    do
    {
        if (result)
        {
            *result = *v3;
            result[1] = v3[1];
        }
        v3 += 2;
        result += 2;
    } while (v3 != a2);
    return result;
}

//----- (00458C40) --------------------------------------------------------
_DWORD* __stdcall sub_458C40(_DWORD* a1, _DWORD* a2, _DWORD* a3)
{
    _DWORD* result; // eax
    _DWORD* v4; // edx

    result = a2;
    if (a2)
    {
        v4 = a2;
        result = a1;
        do
        {
            if (result)
            {
                *result = *a3;
                result[1] = a3[1];
            }
            result += 2;
            v4 = (_DWORD*)((char*)v4 - 1);
        } while (v4);
    }
    return result;
}

//----- (00458C70) --------------------------------------------------------
_DWORD* __cdecl sub_458C70(_DWORD* a1, _DWORD* a2, _DWORD* a3)
{
    _DWORD* result; // eax

    for (result = a1; result != a2; result += 2)
    {
        *result = *a3;
        result[1] = a3[1];
    }
    return result;
}

//----- (00458CA0) --------------------------------------------------------
_DWORD* __cdecl sub_458CA0(int a1, int a2, _DWORD* a3)
{
    int v3; // ecx
    _DWORD* result; // eax
    int v5; // esi

    v3 = a2;
    if (a1 == a2)
        return a3;
    result = a3;
    do
    {
        v5 = *(_DWORD*)(v3 - 8);
        v3 -= 8;
        result -= 2;
        *result = v5;
        result[1] = *(_DWORD*)(v3 + 4);
    } while (v3 != a1);
    return result;
}

//----- (00458CD0) --------------------------------------------------------
_DWORD* __cdecl sub_458CD0(_DWORD* a1, _DWORD* a2)
{
    _DWORD* result; // eax

    result = a1;
    if (a1)
    {
        *a1 = *a2;
        a1[1] = a2[1];
    }
    return result;
}

//----- (00458CF0) --------------------------------------------------------
_DWORD* __thiscall sub_458CF0(_DWORD* this)
{
    char v3; // [esp+Bh] [ebp-11h]

    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
    *((_BYTE*)this + 16) = 1;
    *this = &off_499040;
    `eh vector constructor iterator'(this + 6, 0x10u, 3, sub_458DD0, (void (__thiscall *)(void *))sub_45C880);
        * ((_BYTE*)this + 116) = v3;
    this[30] = 0;
    this[31] = 0;
    this[32] = 0;
    *((_BYTE*)this + 208) = v3;
    this[53] = 0;
    this[54] = 0;
    this[55] = 0;
    this[57] = 0;
    this[58] = 0;
    this[59] = 0;
    *this = &off_499B48;
    this[5] = 1;
    return this;
}
// 458D48: variable 'v3' is possibly undefined
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 499B48: using guessed type _UNKNOWN *off_499B48;

//----- (00458DD0) --------------------------------------------------------
void __thiscall sub_458DD0(_BYTE* this)
{
    this[12] = 1;
    *(_DWORD*)this = 0;
    *((_DWORD*)this + 1) = 0;
    *((_DWORD*)this + 2) = 0;
}

//----- (00458DE0) --------------------------------------------------------
void __thiscall sub_458DE0(char* this)
{
    void* v2; // edi
    void* v3; // edi
    void* v4; // edi

    *(_DWORD*)this = &off_499B48;
    v2 = (void*)*((_DWORD*)this + 57);
    if (v2)
    {
        sub_41C700((int)v2);
        sub_4885A6(v2);
    }
    v3 = (void*)*((_DWORD*)this + 59);
    if (v3)
    {
        sub_41C700(*((_DWORD*)this + 59));
        sub_4885A6(v3);
    }
    v4 = (void*)*((_DWORD*)this + 58);
    if (v4)
    {
        sub_41C700(*((_DWORD*)this + 58));
        sub_4885A6(v4);
    }
    sub_411430((_DWORD*)dword_4F5CC4, (int)this);
    sub_4885A6(*((LPVOID*)this + 53));
    *((_DWORD*)this + 53) = 0;
    *((_DWORD*)this + 54) = 0;
    *((_DWORD*)this + 55) = 0;
    sub_4885A6(*((LPVOID*)this + 30));
    *((_DWORD*)this + 30) = 0;
    *((_DWORD*)this + 31) = 0;
    *((_DWORD*)this + 32) = 0;
    `eh vector destructor iterator'(this + 24, 0x10u, 3, (void (__thiscall *)(void *))sub_45C880);
        * (_DWORD*)this = &off_499040;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 499B48: using guessed type _UNKNOWN *off_499B48;
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (00458EE0) --------------------------------------------------------
char __fastcall sub_458EE0(int a1)
{
    int v1; // esi
    _DWORD* v2; // eax
    _DWORD* v3; // eax
    _DWORD* v4; // eax
    _DWORD* v5; // eax
    int v6; // eax
    char* v7; // ebp
    char v8; // al
    int v9; // ecx
    int v10; // edi
    int v11; // eax
    int v12; // esi
    int v13; // eax
    char* v14; // eax
    int v15; // edi
    int v16; // ecx
    int v17; // ecx
    int v18; // eax
    unsigned int v19; // ecx
    int v20; // eax
    unsigned int v21; // edx
    int v22; // edx
    int v23; // edi
    char* v24; // eax
    int v25; // eax
    int v26; // eax
    double v27; // st7
    int v28; // eax
    char v29; // al
    int v30; // eax
    char v31; // al
    int v32; // eax
    int v33; // eax
    int v34; // eax
    int v35; // eax
    _DWORD* v36; // eax
    void* v37; // esi
    int v38; // eax
    int v39; // ecx
    int v40; // eax
    char* v41; // eax
    int v42; // edi
    int v43; // ecx
    _DWORD* v44; // ebx
    int v45; // eax
    int v46; // ecx
    int v47; // eax
    char* v48; // eax
    int v49; // edi
    int v50; // ecx
    int v51; // eax
    int v52; // eax
    _DWORD* v53; // ebx
    int v54; // eax
    int v55; // ecx
    void* v56; // edx
    int v57; // eax
    char* v58; // eax
    int v59; // edi
    int v60; // ecx
    int v61; // eax
    int i; // esi
    void* v63; // eax
    int v64; // eax
    int* v65; // ebx
    int v66; // eax
    int v67; // ecx
    int v68; // eax
    char* v69; // eax
    int v70; // esi
    int v71; // ecx
    int v72; // eax
    int v73; // ecx
    char v74; // al
    int v75; // eax
    int v76; // eax
    int v77; // edi
    int v78; // ecx
    int j; // edx
    int v80; // edi
    int v81; // ecx
    int k; // edx
    signed int v83; // edx
    char* v84; // esi
    int v85; // eax
    int v86; // ecx
    void* v87; // ecx
    int v88; // eax
    char* v89; // eax
    int v90; // edi
    int v91; // ecx
    int v92; // eax
    _DWORD* v93; // esi
    bool v94; // al
    int v95; // ecx
    int v96; // ebp
    int v97; // ecx
    unsigned int v98; // edx
    unsigned int v99; // eax
    _DWORD* v100; // eax
    unsigned int v101; // ebx
    _DWORD* v102; // edi
    unsigned int v103; // edx
    unsigned int v104; // edx
    int v105; // eax
    int v106; // eax
    _DWORD* v107; // ecx
    _DWORD* ii; // eax
    _DWORD* jj; // eax
    _DWORD* v110; // ebx
    _DWORD* v111; // edx
    _DWORD* v112; // eax
    int v113; // edx
    int v114; // ecx
    signed int v115; // ecx
    int v116; // eax
    int v117; // eax
    int v118; // ebp
    _DWORD* v119; // eax
    unsigned int m; // ebx
    _DWORD* v121; // ecx
    _DWORD* n; // eax
    int v123; // eax
    float v125; // [esp+0h] [ebp-58Ch]
    float v126; // [esp+0h] [ebp-58Ch]
    void* v127; // [esp+0h] [ebp-58Ch]
    char ArgList[4]; // [esp+14h] [ebp-578h] BYREF
    int v129; // [esp+18h] [ebp-574h]
    signed int v130; // [esp+1Ch] [ebp-570h] BYREF
    char* v131; // [esp+20h] [ebp-56Ch] BYREF
    int v132; // [esp+24h] [ebp-568h]
    char v133; // [esp+2Bh] [ebp-561h]
    int v134; // [esp+2Ch] [ebp-560h] BYREF
    int v135; // [esp+30h] [ebp-55Ch] BYREF
    char* v136; // [esp+34h] [ebp-558h] BYREF
    int v137; // [esp+38h] [ebp-554h] BYREF
    int v138; // [esp+3Ch] [ebp-550h] BYREF
    _DWORD v139[4]; // [esp+40h] [ebp-54Ch] BYREF
    char v140[272]; // [esp+50h] [ebp-53Ch] BYREF
    _DWORD v141[72]; // [esp+160h] [ebp-42Ch] BYREF
    char String2[256]; // [esp+280h] [ebp-30Ch] BYREF
    char Buffer[256]; // [esp+380h] [ebp-20Ch] BYREF
    char FileName[256]; // [esp+480h] [ebp-10Ch] BYREF
    int v145; // [esp+588h] [ebp-4h]

    v1 = a1;
    v132 = a1;
    *(_DWORD*)(a1 + 228) = 0;
    v2 = operator new(0x15Cu);
    v129 = (int)v2;
    v145 = 0;
    if (v2)
        v3 = sub_41C6A0(v2);
    else
        v3 = 0;
    v145 = -1;
    *(_DWORD*)(v1 + 232) = v3;
    sub_41C760((int)v3, aSoundsMissionc);
    sub_41C7E0(*(_BYTE**)(v1 + 232), 1);
    sub_41C7A0(*(_DWORD*)(v1 + 232), 1);
    v125 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
    sub_41CFD0(*(_DWORD*)(v1 + 232), v125);
    v4 = operator new(0x15Cu);
    v129 = (int)v4;
    v145 = 1;
    if (v4)
        v5 = sub_41C6A0(v4);
    else
        v5 = 0;
    v145 = -1;
    *(_DWORD*)(v1 + 236) = v5;
    sub_41C760((int)v5, aSoundsMissionf);
    sub_41C7E0(*(_BYTE**)(v1 + 236), 1);
    sub_41C7A0(*(_DWORD*)(v1 + 236), 1);
    v126 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
    sub_41CFD0(*(_DWORD*)(v1 + 236), v126);
    sub_4229D0(aStartedLoading);
    byte_5216F8 = sub_422BA0(AppName, aShowmissionwav, 0) != 0;
    *(_DWORD*)(v1 + 88) = 0;
    *(_DWORD*)(v1 + 84) = 0;
    *(_BYTE*)(v1 + 140) = 0;
    *(_DWORD*)(v1 + 92) = sub_403620((_DWORD*)dword_4B5AB0, aCommander);
    *(_BYTE*)(v1 + 96) = 1;
    *(_DWORD*)(v1 + 20) = 0;
    do
    {
        v6 = *(_DWORD*)(v1 + 20);
        if (v6)
        {
            if (v6 == 1)
            {
                sprintf(Buffer, aMissionsMissio_0);
                sprintf(FileName, aMissionsSpecia_0);
            }
            else if (v6 == 2)
            {
                sprintf(Buffer, aMissionsMissio_1);
                sprintf(FileName, aMissionsSpecia_1);
            }
        }
        else
        {
            sprintf(Buffer, aMissionsMissio);
            sprintf(FileName, aMissionsSpecia);
        }
        sub_40A1D0((int)v139, Buffer);
        v145 = 2;
        sub_40A1D0((int)v141, FileName);
        LOBYTE(v145) = 3;
        if (sub_40AAF0(v139, aMission, 0))
        {
            do
            {
                v7 = (char*)operator new(0x1CCu);
                v129 = (int)v7;
                if (v7)
                {
                    v8 = v133;
                    *((_DWORD*)v7 + 76) = 0;
                    v7[300] = v8;
                    *((_DWORD*)v7 + 77) = 0;
                    *((_DWORD*)v7 + 78) = 0;
                    *((_DWORD*)v7 + 102) = 0;
                    *((_DWORD*)v7 + 103) = 0;
                    *((_DWORD*)v7 + 104) = 0;
                    v7[420] = 1;
                    LOBYTE(v145) = 6;
                    sub_45C860((_DWORD*)v7 + 106, 1);
                    LOBYTE(v145) = 7;
                    sub_45C860((_DWORD*)v7 + 111, 1);
                }
                else
                {
                    v7 = 0;
                }
                v9 = *(_DWORD*)(v1 + 20);
                LOBYTE(v145) = 3;
                v9 *= 16;
                v10 = *(_DWORD*)(v9 + v1 + 28);
                v11 = *(_DWORD*)(v9 + v1 + 32);
                v12 = v9 + v1 + 24;
                *(_DWORD*)(v12 + 4) = v10 + 1;
                if (v10 + 1 > v11)
                {
                    v13 = v11 + 8;
                    *(_DWORD*)(v12 + 8) = v13;
                    v14 = (char*)sub_488DD7(*(LPVOID*)v12, 4 * v13);
                    if (v14)
                    {
                        v15 = *(_DWORD*)(v12 + 4);
                        v16 = *(_DWORD*)(v12 + 8) - v15;
                        *(_DWORD*)v12 = v14;
                        memset(&v14[4 * v15], 0, 4 * v16);
                    }
                }
                *(_DWORD*)(*(_DWORD*)v12 + 4 * *(_DWORD*)(v12 + 4) - 4) = v7;
                sub_40AA40((int)v139, aMission);
                sub_40AFC0(v139, aName_0, ArgList);
                strcpy(v7, *(const char**)ArgList);
                sub_40AF60((const char*)v139, aPlayerhealth, (float*)v7 + 64);
                memset(v7 + 260, 0, 0x28u);
                for (; sub_40ABC0(v139, aGuntype, 0); *(_DWORD*)v24 += v138)
                {
                    v17 = *((_DWORD*)v7 + 76);
                    v130 = 0;
                    if (v17)
                        v18 = (*((_DWORD*)v7 + 77) - v17) >> 2;
                    else
                        v18 = 0;
                    v19 = v18 + 1;
                    v20 = *((_DWORD*)v7 + 76);
                    if (v20)
                        v21 = (*((_DWORD*)v7 + 77) - v20) >> 2;
                    else
                        v21 = 0;
                    if (v21 >= v19)
                    {
                        if (v20 && v19 < (*((_DWORD*)v7 + 77) - v20) >> 2)
                            sub_448300((_DWORD*)v7 + 75, (_DWORD*)(v20 + 4 * v19), *((int**)v7 + 77));
                    }
                    else
                    {
                        if (v20)
                            v22 = (*((_DWORD*)v7 + 77) - v20) >> 2;
                        else
                            v22 = 0;
                        sub_44F190((int)(v7 + 300), *((_DWORD**)v7 + 77), v19 - v22, &v130);
                    }
                    sub_40B310((const char*)v139, aGuntype, &v138, (const char**)ArgList);
                    v23 = *((_DWORD*)v7 + 77);
                    *(_DWORD*)(v23 - 4) = sub_469650(*(_DWORD**)(dword_520970 + 200), *(char**)ArgList, aGun_0, 1);
                    sub_40A120(
                        *(_DWORD*)(*((_DWORD*)v7 + 77) - 4) != 0,
                        "failed to load gun %s, see file %s",
                        *(const char**)ArgList,
                        v140);
                    v24 = &v7[4 * *(_DWORD*)(*(_DWORD*)(*((_DWORD*)v7 + 77) - 4) + 296) + 260];
                }
                v25 = sub_469650(*(_DWORD**)(dword_520970 + 200), aCargoShip, aBoat, 1);
                *((_DWORD*)v7 + 79) = v25;
                sub_40A120(v25 != 0, aCargoShipBoatN);
                v26 = sub_469650(*(_DWORD**)(dword_520970 + 200), aJunkers, aAirplane, 1);
                *((_DWORD*)v7 + 80) = v26;
                sub_40A120(v26 != 0, aJunkersAirplan);
                sub_40B1B0((const char*)v139, aResupplyhealth, (float*)v7 + 81);
                *((float*)v7 + 81) = *((float*)v7 + 81) * 0.0099999998;
                *((float*)v7 + 82) = *((float*)v7 + 82) * 0.0099999998;
                sub_40B1B0((const char*)v139, aResupplyammo, (float*)v7 + 83);
                v27 = *((float*)v7 + 83) * 0.0099999998;
                *((_DWORD*)v7 + 85) = 0;
                *((float*)v7 + 83) = v27;
                *((float*)v7 + 84) = *((float*)v7 + 84) * 0.0099999998;
                if (sub_40ABC0(v139, aResupplymaxuni, 0))
                {
                    sub_40AF00((const char*)v139, aResupplymaxuni, (char**)v7 + 85);
                    sub_40B1B0((const char*)v139, aResupplyfreq, (float*)v7 + 86);
                }
                *((_DWORD*)v7 + 88) = 0;
                if (sub_40ABC0(v139, aGunguys, 0))
                {
                    sub_40AFC0(v139, aGunguys, ArgList);
                    v28 = sub_469650(*(_DWORD**)(dword_520970 + 200), *(char**)ArgList, aInfantry, 1);
                    *((_DWORD*)v7 + 88) = v28;
                    v29 = v28 && !*(_DWORD*)(v28 + 296);
                    sub_40A120(v29, "invalid gunGuys, see mission %s", v7);
                }
                *((_DWORD*)v7 + 89) = 0;
                if (sub_40ABC0(v139, aMortarguys, 0))
                {
                    sub_40AFC0(v139, aMortarguys, ArgList);
                    v30 = sub_469650(*(_DWORD**)(dword_520970 + 200), *(char**)ArgList, aInfantry, 1);
                    *((_DWORD*)v7 + 89) = v30;
                    v31 = v30 && *(_DWORD*)(v30 + 296) == 1;
                    sub_40A120(v31, "invalid mortarGuys, see mission %s", v7);
                }
                *((_DWORD*)v7 + 90) = 0;
                if (sub_40ABC0(v139, aTanks, 0))
                {
                    sub_40AFC0(v139, aTanks, ArgList);
                    v32 = sub_469650(*(_DWORD**)(dword_520970 + 200), *(char**)ArgList, aTank, 1);
                    *((_DWORD*)v7 + 90) = v32;
                    sub_40A120(v32 != 0, "invalid tanks, see mission %s", v7);
                }
                *((_DWORD*)v7 + 91) = 0;
                if (sub_40ABC0(v139, aAirstrikeairpl, 0))
                {
                    sub_40AFC0(v139, aAirstrikeairpl, ArgList);
                    v33 = sub_469650(*(_DWORD**)(dword_520970 + 200), *(char**)ArgList, aAirplane, 1);
                    *((_DWORD*)v7 + 91) = v33;
                    sub_40A120(v33 != 0, "invalid air-strike airplane type, see mission %s", v7);
                    sub_40AF00((const char*)v139, aAirstrikenumpl, (char**)v7 + 92);
                    sub_40AF60((const char*)v139, aAirstrikereloa, (float*)v7 + 93);
                    sub_40AF60((const char*)v139, aAirstriketime, (float*)v7 + 94);
                }
                *((_DWORD*)v7 + 95) = 0;
                if (sub_40ABC0(v139, aTorpedorunairp, 0))
                {
                    sub_40AFC0(v139, aTorpedorunairp, ArgList);
                    v34 = sub_469650(*(_DWORD**)(dword_520970 + 200), *(char**)ArgList, aAirplane, 1);
                    *((_DWORD*)v7 + 95) = v34;
                    sub_40A120(v34 != 0, "invalid torpedo run airplane '%s' type, see mission %s", *(const char**)ArgList, v7);
                    sub_40AF00((const char*)v139, aTorpedorunnump, (char**)v7 + 96);
                    sub_40AF60((const char*)v139, aTorpedorunrelo, (float*)v7 + 97);
                }
                *((_DWORD*)v7 + 98) = 0;
                if (sub_40ABC0(v139, aBombingrunairp, 0))
                {
                    sub_40AFC0(v139, aBombingrunairp, ArgList);
                    v35 = sub_469650(*(_DWORD**)(dword_520970 + 200), *(char**)ArgList, aAirplane, 1);
                    *((_DWORD*)v7 + 98) = v35;
                    sub_40A120(v35 != 0, "invalid bombing run airplane '%s' type, see mission %s", *(const char**)ArgList, v7);
                    sub_40AF00((const char*)v139, aBombingrunnump, (char**)v7 + 99);
                    sub_40AF60((const char*)v139, aBombingrunrelo, (float*)v7 + 100);
                }
                v129 = (int)(v7 + 404);
                *((_DWORD*)v7 + 101) = -1;
                while (sub_40AAF0(v139, aMissionWave, 1))
                {
                    v36 = operator new(0x34u);
                    if (v36)
                    {
                        v36[5] = 0;
                        v36[6] = 0;
                        v36[7] = 0;
                        *((_BYTE*)v36 + 32) = 1;
                        v36[9] = 0;
                        v36[10] = 0;
                        v36[11] = 0;
                        *((_BYTE*)v36 + 48) = 1;
                        v37 = v36;
                    }
                    else
                    {
                        v37 = 0;
                    }
                    v38 = *((_DWORD*)v7 + 104);
                    v39 = *((_DWORD*)v7 + 103) + 1;
                    *((_DWORD*)v7 + 103) = v39;
                    if (v39 > v38)
                    {
                        v40 = v38 + 8;
                        *((_DWORD*)v7 + 104) = v40;
                        v41 = (char*)sub_488DD7(*((LPVOID*)v7 + 102), 4 * v40);
                        if (v41)
                        {
                            v42 = *((_DWORD*)v7 + 103);
                            v43 = *((_DWORD*)v7 + 104) - v42;
                            *((_DWORD*)v7 + 102) = v41;
                            memset(&v41[4 * v42], 0, 4 * v43);
                        }
                    }
                    *(_DWORD*)(*((_DWORD*)v7 + 102) + 4 * *((_DWORD*)v7 + 103) - 4) = v37;
                    sub_40AA40((int)v139, aMissionWave);
                    *(_DWORD*)v37 = 0;
                    if (sub_40ABC0(v139, aTime, 0))
                        sub_40AF60((const char*)v139, aTime, (float*)v37);
                    *((_DWORD*)v37 + 1) = 0;
                    if (sub_40ABC0(v139, aUnitstokill, 0))
                        sub_40AF60((const char*)v139, aUnitstokill, (float*)v37 + 1);
                    *((_BYTE*)v37 + 8) = 0;
                    if (!sub_40AAF0(v139, aMissionWave, 1))
                        *((_BYTE*)v37 + 8) = 1;
                    if (sub_40ABC0(v139, aMustkillalluni, 0))
                        sub_40B130((const char*)v139, aMustkillalluni, (_BYTE*)v37 + 8);
                    *((_BYTE*)v37 + 9) = 0;
                    *((_DWORD*)v37 + 3) = -1;
                    *((_DWORD*)v37 + 4) = 0;
                    while (sub_40ABC0(v139, aBoattype, 0))
                    {
                        v44 = operator new(0x18u);
                        v45 = *((_DWORD*)v37 + 7);
                        v46 = *((_DWORD*)v37 + 6) + 1;
                        *((_DWORD*)v37 + 6) = v46;
                        if (v46 > v45)
                        {
                            v47 = v45 + 8;
                            *((_DWORD*)v37 + 7) = v47;
                            v48 = (char*)sub_488DD7(*((LPVOID*)v37 + 5), 4 * v47);
                            if (v48)
                            {
                                v49 = *((_DWORD*)v37 + 6);
                                v50 = *((_DWORD*)v37 + 7) - v49;
                                *((_DWORD*)v37 + 5) = v48;
                                memset(&v48[4 * v49], 0, 4 * v50);
                            }
                        }
                        *(_DWORD*)(*((_DWORD*)v37 + 5) + 4 * *((_DWORD*)v37 + 6) - 4) = v44;
                        sub_40B530((const char*)v139, aBoattype, v44, v44 + 1, (const char**)ArgList);
                        v51 = sub_469650(*(_DWORD**)(dword_520970 + 200), *(char**)ArgList, aBoat, 1);
                        v44[2] = v51;
                        sub_4282E0(v51 != 0, "failed to load boat %s, see file %s", *(const char**)ArgList, v140);
                        if ((int)v44[1] > 0)
                            *((_BYTE*)v37 + 9) = 1;
                        if (*(_DWORD*)(v44[2] + 292) == 6)
                        {
                            sub_40B530((const char*)v139, aCarrierwaves, v44 + 3, v44 + 4, (const char**)ArgList);
                            v52 = sub_469650(*(_DWORD**)(dword_520970 + 200), *(char**)ArgList, aAirplane, 1);
                            v44[5] = v52;
                            sub_40A120(v52 != 0, "failed to load carrier airplane %s, see file %s", *(const char**)ArgList, v140);
                        }
                    }
                    while (sub_40ABC0(v139, aAirplanetype, 0))
                    {
                        v53 = operator new(0xCu);
                        v54 = *((_DWORD*)v37 + 11);
                        v55 = *((_DWORD*)v37 + 10) + 1;
                        *((_DWORD*)v37 + 10) = v55;
                        if (v55 > v54)
                        {
                            v56 = (void*)*((_DWORD*)v37 + 9);
                            v57 = v54 + 8;
                            *((_DWORD*)v37 + 11) = v57;
                            v58 = (char*)sub_488DD7(v56, 4 * v57);
                            if (v58)
                            {
                                v59 = *((_DWORD*)v37 + 10);
                                v60 = *((_DWORD*)v37 + 11) - v59;
                                *((_DWORD*)v37 + 9) = v58;
                                memset(&v58[4 * v59], 0, 4 * v60);
                            }
                        }
                        *(_DWORD*)(*((_DWORD*)v37 + 9) + 4 * *((_DWORD*)v37 + 10) - 4) = v53;
                        sub_40B530((const char*)v139, aAirplanetype, v53, v53 + 1, (const char**)ArgList);
                        v61 = sub_469650(*(_DWORD**)(dword_520970 + 200), *(char**)ArgList, aAirplane, 1);
                        v53[2] = v61;
                        sub_40A120(v61 != 0, "failed to load airplane %s, see file %s", *(const char**)ArgList, v140);
                        if ((int)v53[1] > 0)
                            *((_BYTE*)v37 + 9) = 1;
                    }
                }
                if (v7[436])
                {
                    for (i = 0; i < *((_DWORD*)v7 + 107); ++i)
                        sub_4885A6(*(LPVOID*)(*((_DWORD*)v7 + 106) + 4 * i));
                }
                memset(*((void**)v7 + 106), 0, 4 * *((_DWORD*)v7 + 107));
                v63 = (void*)*((_DWORD*)v7 + 106);
                *((_DWORD*)v7 + 107) = 0;
                sub_488CEE(v63);
                v64 = v132;
                *((_DWORD*)v7 + 108) = 0;
                *((_DWORD*)v7 + 106) = 0;
                *((_DWORD*)v7 + 110) = -10;
                sprintf(String2, "Mission %d", *(_DWORD*)(16 * *(_DWORD*)(v64 + 20) + v64 + 28));
                if (sub_40AAF0(v141, String2, 0))
                {
                    sub_40AA40((int)v141, String2);
                    while (sub_40ABC0(v141, aMustkillunit, 0))
                    {
                        v65 = (int*)operator new(0x94u);
                        v66 = *((_DWORD*)v7 + 108);
                        v67 = *((_DWORD*)v7 + 107) + 1;
                        *((_DWORD*)v7 + 107) = v67;
                        if (v67 > v66)
                        {
                            v68 = v66 + 8;
                            *((_DWORD*)v7 + 108) = v68;
                            v69 = (char*)sub_488DD7(*((LPVOID*)v7 + 106), 4 * v68);
                            if (v69)
                            {
                                v70 = *((_DWORD*)v7 + 107);
                                v71 = *((_DWORD*)v7 + 108) - v70;
                                *((_DWORD*)v7 + 106) = v69;
                                memset(&v69[4 * v70], 0, 4 * v71);
                            }
                        }
                        *(_DWORD*)(*((_DWORD*)v7 + 106) + 4 * *((_DWORD*)v7 + 107) - 4) = v65;
                        v65[4] = 0;
                        *((_BYTE*)v65 + 20) = 0;
                        sub_40B310((const char*)v141, aMustkillunit, v65 + 3, (const char**)&v131);
                        if (sub_40ABC0(v141, aMustkilltext, 0))
                        {
                            sub_40B310((const char*)v141, aMustkilltext, v65 + 4, (const char**)ArgList);
                            --v65[4];
                            strcpy((char*)v65 + 20, *(const char**)ArgList);
                        }
                        v65[1] = sub_469650(*(_DWORD**)(dword_520970 + 200), v131, aAirplane, 0);
                        v72 = sub_469650(*(_DWORD**)(dword_520970 + 200), v131, aBoat, 0);
                        v73 = v65[1];
                        *v65 = v72;
                        v74 = v73 || v72;
                        sub_40A120(
                            v74,
                            "failed to find a 'mustKillUnit', must be a Boat or Airplane, see %s : %s : SpecialMissions.ini",
                            v131,
                            String2);
                        v65[2] = 0;
                        v75 = *((_DWORD*)v7 + 103);
                        v130 = 0;
                        if (v75 > 0)
                        {
                            v76 = 0;
                            do
                            {
                                v77 = *v65;
                                if (*v65)
                                {
                                    v78 = *((_DWORD*)v7 + 102);
                                    for (j = 0; j < *(_DWORD*)(*(_DWORD*)(v76 + v78) + 24); ++j)
                                    {
                                        if (v77 == *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v76 + v78) + 20) + 4 * j) + 8))
                                            v65[2] += **(_DWORD**)(*(_DWORD*)(*(_DWORD*)(v76 + v78) + 20) + 4 * j);
                                        v78 = *((_DWORD*)v7 + 102);
                                    }
                                }
                                v80 = v65[1];
                                if (v80)
                                {
                                    v81 = *((_DWORD*)v7 + 102);
                                    for (k = 0; k < *(_DWORD*)(*(_DWORD*)(v76 + v81) + 40); ++k)
                                    {
                                        if (v80 == *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v76 + v81) + 36) + 4 * k) + 8))
                                            v65[2] += **(_DWORD**)(*(_DWORD*)(*(_DWORD*)(v76 + v81) + 36) + 4 * k);
                                        v81 = *((_DWORD*)v7 + 102);
                                    }
                                }
                                v83 = *((_DWORD*)v7 + 103);
                                v76 += 4;
                                ++v130;
                            } while (v130 < v83);
                        }
                        sub_40A120(
                            v65[2] >= v65[3],
                            "there are not enough %s's in %s to kill %d of them, see SpecialMissions.ini",
                            v131,
                            String2,
                            v65[3]);
                    }
                    if (sub_40ABC0(v141, aMustkilleveryt, 0))
                    {
                        sub_40AF00((const char*)v141, aMustkilleveryt, (char**)v7 + 110);
                        --*((_DWORD*)v7 + 110);
                    }
                    while (sub_40ABC0(v141, aObjectivetimet, 0))
                    {
                        v84 = (char*)operator new(0x84u);
                        v85 = *((_DWORD*)v7 + 113);
                        v86 = *((_DWORD*)v7 + 112) + 1;
                        *((_DWORD*)v7 + 112) = v86;
                        if (v86 > v85)
                        {
                            v87 = (void*)*((_DWORD*)v7 + 111);
                            v88 = v85 + 8;
                            *((_DWORD*)v7 + 113) = v88;
                            v89 = (char*)sub_488DD7(v87, 4 * v88);
                            if (v89)
                            {
                                v90 = *((_DWORD*)v7 + 112);
                                v91 = *((_DWORD*)v7 + 113) - v90;
                                *((_DWORD*)v7 + 111) = v89;
                                memset(&v89[4 * v90], 0, 4 * v91);
                            }
                        }
                        *(_DWORD*)(*((_DWORD*)v7 + 111) + 4 * *((_DWORD*)v7 + 112) - 4) = v84;
                        sub_40B310((const char*)v141, aObjectivetimet, v84, (const char**)ArgList);
                        --*(_DWORD*)v84;
                        strcpy(v84 + 4, *(const char**)ArgList);
                    }
                    while (sub_40ABC0(v141, aDialogue, 0))
                    {
                        sub_40AFC0(v141, aDialogue, &v136);
                        if (sscanf(v136, "%d,%d,%f", &v134, &v137, &v135) == 3)
                        {
                            if (v134 - 1 < *((_DWORD*)v7 + 103))
                            {
                                v92 = *(_DWORD*)(*((_DWORD*)v7 + 102) + 4 * v134 - 4);
                                *(_DWORD*)(v92 + 12) = v137 - 1;
                                *(_DWORD*)(v92 + 16) = v135;
                            }
                        }
                        else
                        {
                            sub_40A120(0, aDialogueShould);
                        }
                    }
                    if (sub_40ABC0(v141, aProvincetaken, 0))
                    {
                        v93 = (_DWORD*)v129;
                        sub_40AF00((const char*)v141, aProvincetaken, (char**)v129);
                        --*v93;
                    }
                }
                v94 = sub_40AAF0(v139, aMission, 0);
                v1 = v132;
            } while (v94);
        }
        LOBYTE(v145) = 2;
        sub_40A830((int)v141);
        v145 = -1;
        sub_40A830((int)v139);
        v95 = *(_DWORD*)(v1 + 20) + 1;
        *(_DWORD*)(v1 + 20) = v95;
    } while (v95 < 3);
    v96 = 0;
    *(_DWORD*)(v1 + 20) = 1;
    *(_DWORD*)(v1 + 72) = -1;
    *(_DWORD*)(v1 + 76) = 0;
    *(_DWORD*)(v1 + 100) = 0;
    v97 = *(_DWORD*)(v1 + 120);
    v98 = *(_DWORD*)(*(_DWORD*)(dword_520970 + 200) + 24);
    if (v97)
        v99 = (*(_DWORD*)(v1 + 124) - v97) >> 2;
    else
        v99 = 0;
    if (v99 >= v98)
    {
        if (v97 && v98 < (*(_DWORD*)(v1 + 124) - v97) >> 2)
        {
            v123 = *(_DWORD*)(v1 + 124);
            *(_DWORD*)(v1 + 124) = v97 + 4 * v98;
            v129 = v123;
        }
    }
    else
    {
        if (v97)
            v96 = (*(_DWORD*)(v1 + 124) - v97) >> 2;
        v100 = *(_DWORD**)(v1 + 124);
        v101 = v98 - v96;
        v102 = v100;
        v103 = (*(_DWORD*)(v1 + 128) - (int)v100) >> 2;
        v130 = v101;
        if (v103 >= v101)
        {
            if (v101)
            {
                v118 = 4 * v101;
                v129 = 4 * v101;
                v119 = *(_DWORD**)(v1 + 124);
                for (m = v101 - (v119 - v102); m; --m)
                {
                    if (v119)
                        *v119 = 0;
                    ++v119;
                }
                v121 = *(_DWORD**)(v1 + 124);
                for (n = v102; n != v121; ++n)
                    *n = 0;
                *(_DWORD*)(v1 + 124) += v118;
            }
        }
        else
        {
            if (!v97 || (v104 = ((int)v100 - v97) >> 2, v101 >= v104))
                v104 = v101;
            if (v97)
                v105 = ((int)v100 - v97) >> 2;
            else
                v105 = 0;
            v106 = v104 + v105;
            v132 = v106;
            if (v106 < 0)
                v106 = 0;
            v129 = (int)operator new(4 * v106);
            v107 = (_DWORD*)v129;
            for (ii = *(_DWORD**)(v1 + 120); ii != v102; ++v107)
            {
                if (v107)
                    *v107 = *ii;
                ++ii;
            }
            for (jj = v107; v101; --v101)
            {
                if (jj)
                    *jj = 0;
                ++jj;
            }
            v110 = *(_DWORD**)(v1 + 124);
            v111 = &v107[v130];
            if (v102 != v110)
            {
                v112 = v102;
                do
                {
                    if (v111)
                        *v111 = *v112;
                    ++v112;
                    ++v111;
                } while (v112 != v110);
            }
            v127 = *(void**)(v1 + 120);
            v131 = *(char**)(v1 + 124);
            sub_4885A6(v127);
            v113 = v129;
            *(_DWORD*)(v1 + 128) = v129 + 4 * v132;
            v114 = *(_DWORD*)(v1 + 120);
            if (v114)
            {
                v117 = *(_DWORD*)(v1 + 124);
                *(_DWORD*)(v1 + 120) = v113;
                v116 = v113 + 4 * (((v117 - v114) >> 2) + v130);
            }
            else
            {
                v115 = v130;
                *(_DWORD*)(v1 + 120) = v113;
                v116 = v113 + 4 * v115;
            }
            *(_DWORD*)(v1 + 124) = v116;
        }
    }
    sub_4113F0((_DWORD*)dword_4F5CC4, v1, 65280, 1280, 0);
    sub_4229D0(aStartedLoading);
    return 1;
}
// 4B5AB0: using guessed type int dword_4B5AB0;
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;
// 5216F8: using guessed type char byte_5216F8;

//----- (0045A420) --------------------------------------------------------
int __thiscall sub_45A420(float* this, int a2, int a3, char a4, int a5)
{
    int v5; // edi
    float* v6; // ebx
    int v7; // ebp
    _DWORD* v8; // eax
    int v9; // eax
    int v10; // eax
    long double v11; // st7
    int v12; // edx
    int v13; // ecx
    long double v14; // st7
    int v15; // eax
    double v16; // st6
    float* v17; // edx
    int v18; // ebp
    int v19; // edi
    int v20; // esi
    int v21; // eax
    long double v22; // st7
    double v23; // st7
    int v24; // ecx
    _DWORD* v25; // ecx
    int result; // eax
    int v27; // esi
    int v28; // ecx
    _DWORD* v29; // eax
    int v30; // eax
    _DWORD* v31; // eax
    float v32; // [esp+10h] [ebp-10h]
    float v33; // [esp+10h] [ebp-10h]
    float v34; // [esp+14h] [ebp-Ch]
    float v36; // [esp+2Ch] [ebp+Ch]
    float v37; // [esp+2Ch] [ebp+Ch]
    float v38; // [esp+2Ch] [ebp+Ch]
    float v39; // [esp+2Ch] [ebp+Ch]

    v5 = a2;
    v6 = this;
    v7 = a5;
    v8 = (_DWORD*)(*((_DWORD*)this + 30) + 4 * *(_DWORD*)(a2 + 8));
    *v8 += a5;
    if (a4)
    {
        if ((_BYTE)a3)
        {
            sub_4696E0(a2, aAirplane);
            v9 = sub_436A90(*(_DWORD*)(dword_520970 + 224));
            sub_421190(v9, aYouSalvagedAmm);
            v10 = *((_DWORD*)v6 + 19);
            v37 = *(float*)(v10 + 324);
            v32 = *(float*)(v10 + 328);
            if (v37 == v32)
                v11 = v37;
            else
                v11 = fabs((double)rand() * 0.000030518509) * (v32 - v37) + v37;
            v12 = *((_DWORD*)v6 + 19);
            v13 = *(_DWORD*)(dword_520970 + 280);
            v14 = v11 * *(float*)(v12 + 256);
            v15 = *(_DWORD*)(v13 + 512);
            if (v15 >= 0)
                v16 = *(float*)(352 * v15 + v13 + 924);
            else
                v16 = 0.0;
            v38 = *(float*)(v12 + 256) - v16;
            if (v14 >= v38)
                v14 = v38;
            v17 = (float*)(352 * *(_DWORD*)(v13 + 512) + v13 + 924);
            if (*v17 > 0.0)
            {
                *(float*)(v13 + 11612) = v14 + *(float*)(v13 + 11612);
                *v17 = v14 + *v17;
            }
            v18 = 0;
            v19 = 0;
            v20 = 260;
            do
            {
                v21 = *((_DWORD*)v6 + 19);
                v39 = *(float*)(v21 + 332);
                v33 = *(float*)(v21 + 336);
                if (v39 == v33)
                    v22 = v39;
                else
                    v22 = fabs((double)rand() * 0.000030518509) * (v33 - v39) + v39;
                v34 = (double)*(int*)(*((_DWORD*)v6 + 19) + v20) * v22;
                v23 = (double)(*(_DWORD*)(*((_DWORD*)v6 + 19) + v20) - sub_4629B0(*(_DWORD*)(dword_520970 + 280), v18));
                if (v34 < v23)
                    v23 = v34;
                v20 += 4;
                v19 += 16;
                v24 = *(_DWORD*)(dword_520970 + 280);
                *(_DWORD*)(v19 + v24 + 11612) += (__int64)v23;
                v6 = this;
                v25 = (_DWORD*)(v24 + 4 * (v18 + 88 * *(_DWORD*)(v24 + 512)) + 932);
                ++v18;
                *v25 += (__int64)v23;
            } while (v20 < 300);
            v7 = a5;
            v5 = a2;
        }
    }
    else
    {
        v36 = 1.0;
        if (sub_4696E0(a2, aAirplane))
        {
            v36 = *(float*)(a2 + 296);
            sub_443210(*(_DWORD**)(dword_520970 + 212), a2, a3, a5);
        LABEL_4:
            v6[28] = (double)a5 * v36 + v6[28];
            goto LABEL_30;
        }
        if (sub_4696E0(a2, aBoat))
        {
            v6[28] = (double)a5 * *(float*)(a2 + 296) + v6[28];
        }
        else if (sub_4696E0(a2, aInfantry))
        {
            v6[28] = (double)a5 * *(float*)(a2 + 300) + v6[28];
        }
        else
        {
            if (!sub_4696E0(a2, aTank))
                goto LABEL_4;
            v6[28] = (double)a5 * *(float*)(a2 + 292) + v6[28];
        }
    }
LABEL_30:
    result = *((_DWORD*)v6 + 19);
    v27 = 0;
    if (*(int*)(result + 428) > 0)
    {
        v28 = 0;
        do
        {
            v29 = *(_DWORD**)(*(_DWORD*)(result + 424) + 4 * v27);
            if (v5 == v29[1] || v5 == *v29)
            {
                v30 = *((_DWORD*)v6 + 53);
                if ((_BYTE)a3)
                    v31 = (_DWORD*)(v30 + v28 + 8);
                else
                    v31 = (_DWORD*)(v30 + v28 + 4);
                *v31 += v7;
                *((_BYTE*)v6 + 96) = 1;
            }
            result = *((_DWORD*)v6 + 19);
            ++v27;
            v28 += 12;
        } while (v27 < *(_DWORD*)(result + 428));
    }
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (0045A7E0) --------------------------------------------------------
int __thiscall sub_45A7E0(_DWORD* this)
{
    sub_4282E0(
        *(_DWORD*)(this[19] + 352) != 0,
        "Higgins boat in a mission where gunGuys was not specified, see mission %s",
        (const char*)this[19]);
    return *(_DWORD*)(this[19] + 352);
}

//----- (0045A810) --------------------------------------------------------
int __thiscall sub_45A810(_DWORD* this)
{
    sub_4282E0(
        *(_DWORD*)(this[19] + 356) != 0,
        "Higgins boat in a mission where mortarGuys was not specified, see mission %s",
        (const char*)this[19]);
    return *(_DWORD*)(this[19] + 356);
}

//----- (0045A840) --------------------------------------------------------
int __thiscall sub_45A840(_DWORD* this)
{
    sub_4282E0(
        *(_DWORD*)(this[19] + 360) != 0,
        "LCT or LST in a mission where tanks was not specified, see mission %s",
        (const char*)this[19]);
    return *(_DWORD*)(this[19] + 360);
}

//----- (0045A870) --------------------------------------------------------
int __thiscall sub_45A870(_DWORD* this, int a2)
{
    return *(_DWORD*)(this[4 * this[5] + 6] + 4 * a2);
}

//----- (0045A890) --------------------------------------------------------
int __thiscall sub_45A890(_DWORD* this, int ArgList, int a3, int a4)
{
    unsigned int v5; // eax

    sub_4229D0("StartSinglePlayerMission(mission=%d, sky=%d, clouds=%d)", ArgList, a3, a4);
    sub_436E20(*(char**)(dword_520970 + 224));
    v5 = sub_436E40(*(char**)(dword_520970 + 224), AppName);
    sub_436EC0(*(_DWORD**)(dword_520970 + 224), v5, 1065353216, 0);
    sub_45EC70(*(_DWORD**)(dword_520970 + 280));
    return sub_45A920(this, ArgList, a3, a4);
}
// 520970: using guessed type int dword_520970;

//----- (0045A920) --------------------------------------------------------
int __thiscall sub_45A920(_DWORD* this, int ArgList, int a3, int a4)
{
    int v5; // eax
    _DWORD* v6; // eax
    int v7; // ecx

    sub_4229D0("StartMission(mission=%d, sky=%d, clouds=%d)", ArgList, a3, a4);
    v5 = this[5];
    this[21] = a3;
    v6 = &this[4 * v5];
    this[22] = a4;
    v7 = v6[7] - 1;
    if (ArgList < v7)
        v7 = ArgList;
    this[18] = v7;
    this[19] = *(_DWORD*)(v6[6] + 4 * v7);
    sub_436FA0(*(_DWORD*)(dword_520970 + 224), 0, 0.0);
    this[25] = 2;
    sub_4630D0(*(char**)(dword_520970 + 280));
    sub_463150(*(_DWORD**)(dword_520970 + 280));
    *(_BYTE*)(*(_DWORD*)(dword_520970 + 224) + 40) = 1;
    return sub_4262D0(*(int**)(dword_520970 + 232));
}
// 520970: using guessed type int dword_520970;

//----- (0045A9D0) --------------------------------------------------------
void __thiscall sub_45A9D0(_DWORD* this)
{
    int v2; // ebx
    int v3; // edi
    int v4; // eax
    int v5; // edi
    int v6; // eax

    if (*(_BYTE*)(dword_4F5CC4 + 936))
    {
        v2 = this[18] + 1;
        if (v2 >= this[4 * this[5] + 7])
            v2 = this[4 * this[5] + 7];
        v3 = rand() % 10;
        v4 = rand();
        sub_45B150(this, v2, v4 % 10, v3);
    }
    else if (!*(_BYTE*)(dword_4F5CC4 + 937))
    {
        if (dword_4AD1B0 <= -1)
        {
            sub_45ABF0((int)this);
            v5 = rand() % 10;
            v6 = rand();
            sub_45A920(this, this[18] + 1, v6 % 10, v5);
        }
        else
        {
            sub_45B4B0(this, dword_4AD1B0 + 1);
        }
    }
}
// 4AD1B0: using guessed type int dword_4AD1B0;
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (0045AA80) --------------------------------------------------------
char __thiscall sub_45AA80(_DWORD* this)
{
    char result; // al
    int v3; // edi
    int v4; // eax
    int v5; // edi
    int v6; // eax

    sub_41CF50(this[59]);
    result = dword_4F5CC4;
    if (*(_BYTE*)(dword_4F5CC4 + 936))
    {
        v3 = rand() % 10;
        v4 = rand();
        return sub_45B150(this, this[18], v4 % 10, v3);
    }
    else if (!*(_BYTE*)(dword_4F5CC4 + 937))
    {
        sub_45ABF0((int)this);
        v5 = rand() % 10;
        v6 = rand();
        return sub_45A920(this, this[18], v6 % 10, v5);
    }
    return result;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (0045AB10) --------------------------------------------------------
BOOL sub_45AB10()
{
    return sub_42FE50(*(_DWORD**)(dword_520970 + 208))
        && sub_443130(*(_DWORD**)(dword_520970 + 212))
        && sub_455ED0(*(_DWORD**)(dword_520970 + 216))
        && sub_465FB0(*(_DWORD**)(dword_520970 + 220));
}
// 520970: using guessed type int dword_520970;

//----- (0045AB70) --------------------------------------------------------
int __thiscall sub_45AB70(_DWORD* this)
{
    int v1; // edi
    int v2; // edx
    int v3; // esi
    int v4; // ebx
    int result; // eax

    v1 = 0;
    *(float*)(352 * *(_DWORD*)(*(_DWORD*)(dword_520970 + 280) + 512) + *(_DWORD*)(dword_520970 + 280) + 924) = *(float*)(this[19] + 256);
    v2 = 260;
    *(_BYTE*)(*(_DWORD*)(dword_520970 + 280) + 11796) = 0;
    do
    {
        v3 = *(_DWORD*)(dword_520970 + 280);
        v4 = *(_DWORD*)(this[19] + v2);
        v2 += 4;
        result = v1 + 88 * *(_DWORD*)(v3 + 512);
        ++v1;
        *(_DWORD*)(v3 + 4 * result + 932) = v4;
    } while (v2 < 300);
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (0045ABF0) --------------------------------------------------------
int __thiscall sub_45ABF0(int this)
{
    int v2; // ecx
    void* v3; // edi
    int v4; // ecx
    int v5; // eax
    int result; // eax

    sub_4229D0(aCancelmission);
    v2 = *(_DWORD*)(this + 228);
    if (v2)
    {
        sub_41CF50(v2);
        v3 = *(void**)(this + 228);
        if (v3)
        {
            sub_41C700(*(_DWORD*)(this + 228));
            sub_4885A6(v3);
        }
        *(_DWORD*)(this + 228) = 0;
    }
    v4 = *(_DWORD*)(this + 236);
    if (v4)
        sub_41CF50(v4);
    sub_402FC0(*(_DWORD*)(this + 92));
    sub_44B3F0(*(_DWORD**)(dword_520970 + 276));
    sub_443080(*(_DWORD**)(dword_520970 + 212));
    sub_455E30(*(_DWORD**)(dword_520970 + 216));
    sub_42FDD0(*(_DWORD**)(dword_520970 + 208));
    sub_465F20(*(_DWORD**)(dword_520970 + 220));
    sub_45F080(*(_DWORD**)(dword_520970 + 280));
    sub_4134A0(*(_DWORD**)(dword_520970 + 116));
    sub_44E870(*(_DWORD**)(dword_520970 + 240));
    sub_4151F0(*(_DWORD*)(dword_520970 + 244));
    sub_436D70(*(_DWORD**)(dword_520970 + 224));
    sub_45AF60((_DWORD*)this);
    sub_4630B0(*(_DWORD**)(dword_520970 + 280));
    *(_BYTE*)(*(_DWORD*)(dword_520970 + 280) + 11796) = 0;
    *(_BYTE*)(*(_DWORD*)(dword_520970 + 224) + 40) = 0;
    v5 = sub_450BF0((_DWORD*)dword_520970, 1, 1082130432);
    sub_421110(v5, AppName);
    *(_DWORD*)(this + 76) = 0;
    *(_DWORD*)(this + 100) = 0;
    *(_BYTE*)(this + 81) = 0;
    *(_BYTE*)(this + 80) = 0;
    result = *(_DWORD*)(this + 216);
    *(_DWORD*)(this + 216) = *(_DWORD*)(this + 212);
    return result;
}
// 45ABF0: could not find valid save-restore pair for ebp
// 520970: using guessed type int dword_520970;

//----- (0045ADB0) --------------------------------------------------------
void __thiscall sub_45ADB0(_DWORD* this)
{
    int v2; // esi
    int v3; // ecx
    int v4; // ecx
    int v5; // ecx
    int v6; // ecx
    int v7; // ecx
    int v8; // ecx
    int v9; // ecx
    int v10; // ecx
    int v11; // eax
    int v12; // eax
    int j; // edi
    int v14; // ecx
    int v15; // eax
    int v16; // ecx
    int v17; // edi
    int v18; // eax
    int v19; // ecx
    int i; // [esp+8h] [ebp-4h]

    v2 = 0;
    if (this[19] && !byte_520A10)
    {
        sub_44E8F0(*(_DWORD***)(dword_520970 + 240));
        sub_44B460(*(_DWORD***)(dword_520970 + 276));
        v3 = *(_DWORD*)(this[19] + 364);
        if (v3)
            (*(void(__thiscall**)(int))(*(_DWORD*)v3 + 4))(v3);
        v4 = *(_DWORD*)(this[19] + 380);
        if (v4)
            (*(void(__thiscall**)(int))(*(_DWORD*)v4 + 4))(v4);
        v5 = *(_DWORD*)(this[19] + 392);
        if (v5)
            (*(void(__thiscall**)(int))(*(_DWORD*)v5 + 4))(v5);
        v6 = *(_DWORD*)(this[19] + 316);
        if (v6)
            (*(void(__thiscall**)(int))(*(_DWORD*)v6 + 4))(v6);
        v7 = *(_DWORD*)(this[19] + 320);
        if (v7)
            (*(void(__thiscall**)(int))(*(_DWORD*)v7 + 4))(v7);
        v8 = *(_DWORD*)(this[19] + 352);
        if (v8)
            (*(void(__thiscall**)(int))(*(_DWORD*)v8 + 4))(v8);
        v9 = *(_DWORD*)(this[19] + 356);
        if (v9)
            (*(void(__thiscall**)(int))(*(_DWORD*)v9 + 4))(v9);
        v10 = *(_DWORD*)(this[19] + 360);
        if (v10)
            (*(void(__thiscall**)(int))(*(_DWORD*)v10 + 4))(v10);
        v11 = this[19];
        for (i = 0; i < *(_DWORD*)(v11 + 412); ++i)
        {
            v12 = *(_DWORD*)(v11 + 408);
            for (j = 0; j < *(_DWORD*)(*(_DWORD*)(v2 + v12) + 24); v12 = *(_DWORD*)(this[19] + 408))
            {
                v14 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v2 + v12) + 20) + 4 * j) + 8);
                (*(void(__thiscall**)(int))(*(_DWORD*)v14 + 4))(v14);
                v15 = *(_DWORD*)(this[19] + 408) + v2;
                if (*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)v15 + 20) + 4 * j) + 8) + 292) == 6)
                {
                    v16 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)v15 + 20) + 4 * j) + 20);
                    (*(void(__thiscall**)(int))(*(_DWORD*)v16 + 4))(v16);
                }
                ++j;
            }
            v17 = 0;
            v18 = *(_DWORD*)(*(_DWORD*)(this[19] + 408) + v2);
            if (*(int*)(v18 + 40) > 0)
            {
                do
                {
                    v19 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v18 + 36) + 4 * v17) + 8);
                    (*(void(__thiscall**)(int))(*(_DWORD*)v19 + 4))(v19);
                    ++v17;
                    v18 = *(_DWORD*)(*(_DWORD*)(this[19] + 408) + v2);
                } while (v17 < *(_DWORD*)(v18 + 40));
            }
            v11 = this[19];
            v2 += 4;
        }
    }
}
// 520970: using guessed type int dword_520970;
// 520A10: using guessed type char byte_520A10;

//----- (0045AF60) --------------------------------------------------------
char __thiscall sub_45AF60(_DWORD* this)
{
    int v2; // esi
    int v3; // eax
    int v4; // ecx
    int v5; // ecx
    int v6; // ecx
    int v7; // ecx
    int v8; // ecx
    int v9; // ecx
    int v10; // ecx
    int v11; // ecx
    int v12; // eax
    int v13; // eax
    int j; // edi
    int v15; // ecx
    int v16; // eax
    int v17; // ecx
    int v18; // edi
    int v19; // eax
    int v20; // ecx
    int v21; // ebx
    int v22; // esi
    int v23; // edi
    int i; // [esp+Ch] [ebp-4h]

    v2 = 0;
    v3 = this[19];
    if (v3)
    {
        LOBYTE(v3) = byte_520A10;
        if (!byte_520A10)
        {
            sub_44E900(*(_DWORD***)(dword_520970 + 240));
            sub_44B470(*(_DWORD***)(dword_520970 + 276));
            v4 = *(_DWORD*)(this[19] + 364);
            if (v4)
                (*(void(__thiscall**)(int))(*(_DWORD*)v4 + 8))(v4);
            v5 = *(_DWORD*)(this[19] + 380);
            if (v5)
                (*(void(__thiscall**)(int))(*(_DWORD*)v5 + 8))(v5);
            v6 = *(_DWORD*)(this[19] + 392);
            if (v6)
                (*(void(__thiscall**)(int))(*(_DWORD*)v6 + 8))(v6);
            v7 = *(_DWORD*)(this[19] + 316);
            if (v7)
                (*(void(__thiscall**)(int))(*(_DWORD*)v7 + 8))(v7);
            v8 = *(_DWORD*)(this[19] + 320);
            if (v8)
                (*(void(__thiscall**)(int))(*(_DWORD*)v8 + 8))(v8);
            v9 = *(_DWORD*)(this[19] + 352);
            if (v9)
                (*(void(__thiscall**)(int))(*(_DWORD*)v9 + 8))(v9);
            v10 = *(_DWORD*)(this[19] + 356);
            if (v10)
                (*(void(__thiscall**)(int))(*(_DWORD*)v10 + 8))(v10);
            v11 = *(_DWORD*)(this[19] + 360);
            if (v11)
                (*(void(__thiscall**)(int))(*(_DWORD*)v11 + 8))(v11);
            v12 = this[19];
            for (i = 0; i < *(_DWORD*)(v12 + 412); ++i)
            {
                v13 = *(_DWORD*)(v12 + 408);
                for (j = 0; j < *(_DWORD*)(*(_DWORD*)(v2 + v13) + 24); v13 = *(_DWORD*)(this[19] + 408))
                {
                    v15 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v2 + v13) + 20) + 4 * j) + 8);
                    (*(void(__thiscall**)(int))(*(_DWORD*)v15 + 8))(v15);
                    v16 = *(_DWORD*)(this[19] + 408) + v2;
                    if (*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)v16 + 20) + 4 * j) + 8) + 292) == 6)
                    {
                        v17 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)v16 + 20) + 4 * j) + 20);
                        (*(void(__thiscall**)(int))(*(_DWORD*)v17 + 8))(v17);
                    }
                    ++j;
                }
                v18 = 0;
                v19 = *(_DWORD*)(*(_DWORD*)(this[19] + 408) + v2);
                if (*(int*)(v19 + 40) > 0)
                {
                    do
                    {
                        v20 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v19 + 36) + 4 * v18) + 8);
                        (*(void(__thiscall**)(int))(*(_DWORD*)v20 + 8))(v20);
                        ++v18;
                        v19 = *(_DWORD*)(*(_DWORD*)(this[19] + 408) + v2);
                    } while (v18 < *(_DWORD*)(v19 + 40));
                }
                v12 = this[19];
                v2 += 4;
            }
            sub_41F0F0(*(_DWORD**)(dword_520970 + 120));
            v21 = 0;
            v22 = *(_DWORD*)(dword_520970 + 200);
            v3 = *(_DWORD*)(v22 + 24);
            if (v3 > 0)
            {
                do
                {
                    v23 = *(_DWORD*)(*(_DWORD*)(v22 + 20) + 4 * v21);
                    if (sub_4696E0(v23, aSoundEffect))
                        (*(void(__thiscall**)(int))(*(_DWORD*)v23 + 8))(v23);
                    v3 = *(_DWORD*)(v22 + 24);
                    ++v21;
                } while (v21 < v3);
            }
        }
    }
    return v3;
}
// 520970: using guessed type int dword_520970;
// 520A10: using guessed type char byte_520A10;

//----- (0045B150) --------------------------------------------------------
char __thiscall sub_45B150(_DWORD* this, int ArgList, int a3, int a4)
{
    char result; // al
    int v6; // edx
    int v7; // eax
    _BYTE* v8; // ecx
    int v9; // ecx
    _WORD v10[3]; // [esp+10h] [ebp-18h] BYREF
    int v11; // [esp+16h] [ebp-12h]
    int v12; // [esp+1Ah] [ebp-Eh]
    int v13; // [esp+1Eh] [ebp-Ah]
    int v14; // [esp+22h] [ebp-6h]

    sub_4229D0("StartMultiplayerMission(mission=%d, sky=%d, clouds=%d)", ArgList, a3, a4);
    result = dword_4F5CC4;
    if (*(_BYTE*)(dword_4F5CC4 + 936))
    {
        *(_BYTE*)(dword_4F5CC4 + 108) = 0;
        v6 = *(_DWORD*)(dword_520970 + 280);
        v7 = 0;
        if (*(int*)(v6 + 520) > 0)
        {
            v8 = (_BYTE*)(v6 + 897);
            do
            {
                *v8 = 0;
                ++v7;
                v8 += 352;
            } while (v7 < *(_DWORD*)(v6 + 520));
        }
        v9 = this[5];
        this[25] = 10;
        v14 = v9;
        v11 = ArgList;
        v12 = a3;
        v13 = a4;
        return sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x501, v10, 22, 7, 0);
    }
    return result;
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (0045B200) --------------------------------------------------------
char __usercall sub_45B200@<al>(int* a1@<ecx>, int a2@<edi>)
{
    int v3; // ecx
    int v4; // eax

    v3 = a1[58];
    if (v3)
        sub_41CF50(v3);
    v4 = sub_450BF0((_DWORD*)dword_520970, 1, 0);
    sub_421110(v4, AppName);
    sub_402FC0(a1[23]);
    if (!*(_BYTE*)(dword_4F5CC4 + 936) && !*(_BYTE*)(dword_4F5CC4 + 937))
        sub_45EA00(*(_DWORD**)(dword_520970 + 280), a1[18]);
    sub_4626F0(*(_DWORD*)(dword_520970 + 280), a2);
    a1[25] = 7;
    *(_BYTE*)(*(_DWORD*)(dword_520970 + 280) + 11796) = 1;
    return sub_4261C0(*(_DWORD**)(dword_520970 + 232), aScoring, 1);
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (0045B2B0) --------------------------------------------------------
char __thiscall sub_45B2B0(int this, const char* a2)
{
    int v3; // eax
    int v4; // eax
    _WORD v6[3]; // [esp+10h] [ebp-48h] BYREF
    char v7[66]; // [esp+16h] [ebp-42h] BYREF

    sub_41CF50(*(_DWORD*)(this + 236));
    if (*(_BYTE*)(dword_4F5CC4 + 936))
    {
        sub_4229D0(aHostIsAborting);
        strcpy(v7, a2);
        sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x504, v6, 70, 15, 0);
    }
    v3 = dword_520970;
    if (!*(_BYTE*)(dword_520970 + 296))
    {
        *(_BYTE*)(dword_520970 + 296) = 1;
        v3 = dword_520970;
    }
    if (!*(_BYTE*)(dword_4F5CC4 + 936) && !*(_BYTE*)(dword_4F5CC4 + 937))
        *(_BYTE*)(v3 + 20) = 1;
    *(_DWORD*)(this + 100) = 11;
    strcpy((char*)(this + 140), a2);
    sub_4262D0(*(int**)(dword_520970 + 232));
    sub_436FA0(*(_DWORD*)(dword_520970 + 224), 0, 1.0);
    v4 = sub_450BF0((_DWORD*)dword_520970, 1, 0);
    return sub_421110(v4, AppName);
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (0045B3E0) --------------------------------------------------------
char __thiscall sub_45B3E0(int this, float* a2)
{
    int v2; // ebp
    int v3; // edi
    int v4; // esi
    int v5; // ebx
    int v6; // eax
    int v7; // edx
    int v8; // eax
    int v10; // eax
    float* v11; // edx

    if (*(_DWORD*)(this + 100) != 6)
        return 0;
    v2 = *(_DWORD*)(this + 104);
    if (v2 == -1)
        return 0;
    v3 = 0;
    v4 = *(_DWORD*)(dword_520970 + 208);
    v5 = *(_DWORD*)(v4 + 24);
    while (1)
    {
        v6 = v5 ? (*(_DWORD*)(v4 + 28) - v5) >> 2 : 0;
        if (v3 >= v6)
            break;
        v7 = *(_DWORD*)(*(_DWORD*)(v4 + 24) + 4 * v3);
        if (*(_BYTE*)(v7 + 396))
        {
            v8 = *(_DWORD*)(v7 + 428);
            if (!*(_DWORD*)(v8 + 292) && *(float*)(v8 + 920) != 0.0)
            {
                *a2 = *(float*)(v7 + 1356);
                return 1;
            }
        }
        ++v3;
    }
    v10 = *(_DWORD*)(this + 76);
    if (*(_DWORD*)(v10 + 440) != v2)
        return 0;
    v11 = *(float**)(*(_DWORD*)(v10 + 408) + 4 * v2);
    if (*v11 == 0.0)
        return 0;
    *a2 = *v11 - *(float*)(this + 108);
    return 1;
}
// 520970: using guessed type int dword_520970;

//----- (0045B4B0) --------------------------------------------------------
void __thiscall sub_45B4B0(_DWORD* this, int ArgList)
{
    this[25] = 8;
    dword_4AD1B0 = ArgList;
    sub_43A230(*(int**)(dword_520970 + 228), ArgList);
}
// 4AD1B0: using guessed type int dword_4AD1B0;
// 520970: using guessed type int dword_520970;

//----- (0045B4E0) --------------------------------------------------------
char __usercall sub_45B4E0@<al>(int* a1@<ecx>, int a2@<edi>)
{
    if (a1[25] != 6)
        return 0;
    *(_BYTE*)(*(_DWORD*)(dword_520970 + 280) + 11796) = 1;
    sub_45B200(a1, a2);
    return 1;
}
// 520970: using guessed type int dword_520970;

//----- (0045B510) --------------------------------------------------------
char __userpurge sub_45B510@<al>(int a1@<ecx>, int a2@<edi>, int a3)
{
    int v4; // ecx
    int v5; // ecx
    int v6; // ecx
    int v7; // eax
    int v8; // eax
    int v9; // ecx
    int v10; // eax
    unsigned int i; // edi
    int v12; // eax
    int v13; // ecx
    int v14; // edi
    int j; // ecx
    int v16; // edx
    int v17; // eax
    unsigned int k; // eax
    int v19; // ecx
    int v20; // ecx
    int v21; // eax
    float v22; // edx
    long double v23; // st7
    int v24; // edx
    int v25; // eax
    unsigned int v26; // ebx
    unsigned int v27; // edx
    char* v28; // ebp
    int v29; // eax
    unsigned int v30; // ebx
    int m; // ebp
    int v32; // eax
    int v33; // eax
    int v34; // eax
    _DWORD* v35; // eax
    _DWORD* v36; // eax
    int v37; // eax
    char v38; // dl
    int n; // ebx
    int v40; // eax
    void** v41; // ecx
    int v42; // ecx
    int v43; // eax
    double v44; // st7
    int v45; // eax
    double v46; // st7
    bool v47; // bl
    int v48; // ecx
    int v49; // ecx
    int v50; // ecx
    unsigned int ii; // eax
    int v52; // ecx
    int v53; // edi
    unsigned int v54; // eax
    int v55; // ecx
    int v56; // eax
    int v57; // eax
    int* v58; // eax
    int v59; // eax
    int v60; // ecx
    int* v61; // ecx
    int v62; // ebx
    int v63; // ebp
    int v64; // eax
    int* v65; // eax
    int v66; // eax
    double v67; // st7
    int v68; // eax
    int v69; // eax
    float v70; // ecx
    long double v71; // st7
    _DWORD* v72; // eax
    int v73; // ecx
    int v74; // edx
    _DWORD* v75; // eax
    int v76; // eax
    unsigned int v77; // ebx
    int v78; // eax
    int v79; // eax
    int v80; // edi
    char* v81; // ebp
    int v82; // eax
    int v83; // eax
    int v84; // eax
    float v85; // ecx
    int v86; // edi
    __int64 v87; // rax
    int v88; // eax
    int v89; // ecx
    int v90; // eax
    int v91; // edi
    int v92; // ecx
    int v93; // edi
    int v94; // edx
    int v95; // eax
    _BYTE* v96; // ecx
    int v98; // [esp+0h] [ebp-40h]
    float v99; // [esp+4h] [ebp-3Ch]
    float v100; // [esp+4h] [ebp-3Ch]
    float v101; // [esp+4h] [ebp-3Ch]
    const char* v102; // [esp+4h] [ebp-3Ch]
    int v103; // [esp+4h] [ebp-3Ch]
    _DWORD* v104; // [esp+8h] [ebp-38h]
    bool v105; // [esp+18h] [ebp-28h]
    char v106; // [esp+19h] [ebp-27h] BYREF
    char v107; // [esp+1Ah] [ebp-26h] BYREF
    char v108; // [esp+1Bh] [ebp-25h]
    float v109[2]; // [esp+1Ch] [ebp-24h] BYREF
    float v110; // [esp+24h] [ebp-1Ch]
    float v111[3]; // [esp+28h] [ebp-18h] BYREF
    int v112; // [esp+3Ch] [ebp-4h]

    v4 = *(_DWORD*)(a1 + 228);
    if (v4)
    {
        v110 = *(float*)(dword_520970 + 68);
        sub_41D0C0(v4, 0, v110);
        v99 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
        sub_41CFD0(*(_DWORD*)(a1 + 228), v99);
    }
    v5 = *(_DWORD*)(a1 + 232);
    if (v5)
    {
        v110 = *(float*)(dword_520970 + 68);
        sub_41D0C0(v5, 0, v110);
        v100 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
        sub_41CFD0(*(_DWORD*)(a1 + 232), v100);
    }
    v6 = *(_DWORD*)(a1 + 236);
    if (v6)
    {
        v110 = *(float*)(dword_520970 + 68);
        sub_41D0C0(v6, 0, v110);
        v101 = (double)*(int*)&dword_4A34C0 * 0.0099999998 * 0.40000001 + 0.60000002;
        sub_41CFD0(*(_DWORD*)(a1 + 236), v101);
    }
    v7 = *(_DWORD*)(a1 + 100);
    v108 = *(_BYTE*)(a1 + 80);
    switch (v7)
    {
    case 1:
        return sub_428620((_DWORD*)a1, a3);
    case 2:
        v8 = sub_450BF0((_DWORD*)dword_520970, 1, 0);
        sub_421110(v8, aLoadingMission);
        *(_DWORD*)(a1 + 100) = 3;
        return sub_428620((_DWORD*)a1, a3);
    case 3:
        *(_DWORD*)(a1 + 100) = 4;
        return sub_428620((_DWORD*)a1, a3);
    case 4:
        v9 = *(_DWORD*)(a1 + 84);
        if (v9 > -1 && *(int*)(a1 + 88) > -1)
            sub_464810(*(_DWORD**)(dword_520970 + 252), 0, v9, *(_DWORD*)(a1 + 88));
        *(_BYTE*)(a1 + 80) = 0;
        *(_BYTE*)(a1 + 81) = 0;
        sub_45ADB0((_DWORD*)a1);
        if (*(_BYTE*)(dword_4F5CC4 + 936) || *(_BYTE*)(dword_4F5CC4 + 937))
        {
            v10 = sub_450BF0((_DWORD*)dword_520970, 1, 0);
            sub_421110(v10, aWaitingForPlay);
            sub_4117D0(dword_4F5CC4, (int**)0x502, v111, 6, 7, 0);
            *(_DWORD*)(a1 + 100) = 10;
        }
        else
        {
            *(_DWORD*)(a1 + 100) = 5;
        }
        return sub_428620((_DWORD*)a1, a3);
    case 5:
        *(float*)(352 * *(_DWORD*)(*(_DWORD*)(dword_520970 + 280) + 512) + *(_DWORD*)(dword_520970 + 280) + 924) = *(float*)(*(_DWORD*)(a1 + 76) + 256);
        sub_45F080(*(_DWORD**)(dword_520970 + 280));
        for (i = 0; ; ++i)
        {
            v12 = *(_DWORD*)(a1 + 76);
            v13 = *(_DWORD*)(v12 + 304);
            if (!v13 || i >= (*(_DWORD*)(v12 + 308) - v13) >> 2)
                break;
            sub_45ED50(*(_DWORD*)(dword_520970 + 280), i, *(_DWORD**)(v13 + 4 * i), v104);
        }
        v14 = 0;
        for (j = 260; j < 300; *(_DWORD*)(v16 + 4 * v17 + 932) = *(_DWORD*)(j + *(_DWORD*)(a1 + 76) - 4))
        {
            j += 4;
            v16 = *(_DWORD*)(dword_520970 + 280);
            v17 = v14 + 88 * *(_DWORD*)(v16 + 512);
            ++v14;
        }
        sub_45F2E0(
            *(float**)(dword_520970 + 280),
            0,
            *(_DWORD*)(*(_DWORD*)(a1 + 76) + 364),
            *(_DWORD*)(*(_DWORD*)(a1 + 76) + 368),
            *(_DWORD*)(*(_DWORD*)(a1 + 76) + 372),
            *(float*)(*(_DWORD*)(a1 + 76) + 376));
        sub_45F2E0(
            *(float**)(dword_520970 + 280),
            1,
            *(_DWORD*)(*(_DWORD*)(a1 + 76) + 380),
            *(_DWORD*)(*(_DWORD*)(a1 + 76) + 384),
            *(_DWORD*)(*(_DWORD*)(a1 + 76) + 388),
            0.0);
        sub_45F2E0(
            *(float**)(dword_520970 + 280),
            2,
            *(_DWORD*)(*(_DWORD*)(a1 + 76) + 392),
            *(_DWORD*)(*(_DWORD*)(a1 + 76) + 396),
            *(_DWORD*)(*(_DWORD*)(a1 + 76) + 400),
            0.0);
        *(_DWORD*)(a1 + 104) = -1;
        *(_DWORD*)(a1 + 108) = 0;
        *(_DWORD*)(a1 + 112) = 0;
        for (k = 0; ; ++k)
        {
            v19 = *(_DWORD*)(a1 + 120);
            if (!v19 || k >= (*(_DWORD*)(a1 + 124) - v19) >> 2)
                break;
            *(_DWORD*)(v19 + 4 * k) = 0;
        }
        v20 = *(_DWORD*)(a1 + 76);
        v21 = *(_DWORD*)(v20 + 340);
        *(_DWORD*)(a1 + 132) = v21;
        if (v21)
        {
            v22 = *(float*)(v20 + 348);
            v109[0] = *(float*)(v20 + 344);
            v110 = v22;
            if (v109[0] == v22)
            {
                v23 = v109[0];
            }
            else
            {
                LODWORD(v111[0]) = rand();
                v23 = fabs((double)SLODWORD(v111[0]) * 0.000030518509) * (v110 - v109[0]) + v109[0];
            }
            *(float*)(a1 + 136) = v23;
        }
        sub_462660(*(_DWORD**)(dword_520970 + 280));
        v24 = *(_DWORD*)(a1 + 76);
        *(_DWORD*)(a1 + 100) = 6;
        v25 = *(_DWORD*)(a1 + 212);
        v26 = *(_DWORD*)(v24 + 428);
        if (v25)
            v27 = (*(_DWORD*)(a1 + 216) - v25) / 12;
        else
            v27 = 0;
        if (v27 >= v26)
        {
            if (v26 < sub_45C900((_DWORD*)(a1 + 208)))
                sub_45CC50((_DWORD*)(a1 + 208), (_DWORD*)(*(_DWORD*)(a1 + 212) + 12 * v26), *(_DWORD**)(a1 + 216));
        }
        else
        {
            v28 = *(char**)(a1 + 216);
            v29 = sub_45C900((_DWORD*)(a1 + 208));
            sub_45C920((_DWORD*)(a1 + 208), v28, v26 - v29, v111);
        }
        v30 = 0;
        for (m = 0; ; m += 12)
        {
            v32 = *(_DWORD*)(a1 + 212);
            if (!v32 || v30 >= (*(_DWORD*)(a1 + 216) - v32) / 12)
                break;
            *(_DWORD*)(*(_DWORD*)(a1 + 212) + m) = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 76) + 424)
                + 4 * v30++)
                + 8);
            *(_DWORD*)(*(_DWORD*)(a1 + 212) + m + 4) = 0;
            *(_DWORD*)(*(_DWORD*)(a1 + 212) + m + 8) = 0;
        }
        *(_BYTE*)(a1 + 96) = 1;
        v33 = sub_450BF0((_DWORD*)dword_520970, 1, 1082130432);
        sub_421110(v33, AppName);
        *(_BYTE*)(dword_520970 + 20) = 0;
        *(_BYTE*)(dword_520970 + 296) = 0;
        sub_436FD0(*(_DWORD*)(dword_520970 + 224), 1082130432, 1.0);
        v102 = *(const char**)(*(_DWORD*)(16 * *(_DWORD*)(a1 + 20) + a1 + 24) + 4 * *(_DWORD*)(a1 + 72));
        v34 = sub_450BF0((_DWORD*)dword_520970, 1, 1082130432);
        sub_421110(v34, v102);
        v35 = operator new(0x15Cu);
        LODWORD(v111[0]) = v35;
        v112 = 0;
        if (v35)
            v36 = sub_41C6A0(v35);
        else
            v36 = 0;
        v112 = -1;
        *(_DWORD*)(a1 + 228) = v36;
        v37 = rand();
        if (v37 % 3)
        {
            if (v37 % 3 == 1)
            {
                sub_41C760(*(_DWORD*)(a1 + 228), aSoundsDatespla_0);
            }
            else if (v37 % 3 == 2)
            {
                sub_41C760(*(_DWORD*)(a1 + 228), aSoundsDatespla_1);
            }
        }
        else
        {
            sub_41C760(*(_DWORD*)(a1 + 228), aSoundsDatespla);
        }
        sub_41C7E0(*(_BYTE**)(a1 + 228), 1);
        sub_41C7A0(*(_DWORD*)(a1 + 228), 1);
        sub_41CD90(*(_DWORD*)(a1 + 228));
        *(_DWORD*)(a1 + 204) = 0;
        return sub_428620((_DWORD*)a1, a3);
    }
    if (v7 != 6)
    {
        if (v7 == 7)
        {
            if (*(_DWORD*)(*(_DWORD*)(dword_520970 + 232) + 52))
                return sub_428620((_DWORD*)a1, a3);
            v89 = *(_DWORD*)(a1 + 76);
            if (*(int*)(v89 + 404) > -1 && !*(_BYTE*)(dword_4F5CC4 + 936) && !*(_BYTE*)(dword_4F5CC4 + 937))
            {
                *(_DWORD*)(a1 + 100) = 8;
                sub_43A230(*(int**)(dword_520970 + 228), *(_DWORD*)(v89 + 404));
                return sub_428620((_DWORD*)a1, a3);
            }
            *(_DWORD*)(a1 + 100) = 9;
            sub_436FA0(*(_DWORD*)(dword_520970 + 224), 0, 1.0);
        }
        else
        {
            if (v7 != 8)
            {
                if (v7 == 9)
                {
                    if (sub_437000(*(float**)(dword_520970 + 224)))
                    {
                        *(_BYTE*)(dword_520970 + 296) = 0;
                        v90 = *(_DWORD*)(a1 + 76);
                        if (v90)
                            v91 = *(_DWORD*)(v90 + 404);
                        else
                            v91 = dword_4AD1B0;
                        sub_45ABF0(a1);
                        *(_DWORD*)(a1 + 100) = 0;
                        if (v91 <= -1 || *(_BYTE*)(dword_4F5CC4 + 936) || *(_BYTE*)(dword_4F5CC4 + 937))
                        {
                            v92 = *(_DWORD*)(a1 + 72);
                            *(_DWORD*)(a1 + 100) = 1;
                            *(_DWORD*)dword_5216E0 = v92 + 1;
                            byte_5216E4 = 1;
                            sub_4261C0(*(_DWORD**)(dword_520970 + 232), aObjectives, 1);
                        }
                        else
                        {
                            sub_450AC0(dword_520970, 1, v91);
                        }
                    }
                }
                else if (v7 == 11)
                {
                    if (sub_437000(*(float**)(dword_520970 + 224)))
                    {
                        sub_45ABF0(a1);
                        sub_462F90(*(_DWORD**)(dword_520970 + 280));
                        sub_4261C0(*(_DWORD**)(dword_520970 + 232), (char*)(a1 + 140), 0);
                        *(_BYTE*)(a1 + 140) = 0;
                        sub_436FD0(*(_DWORD*)(dword_520970 + 224), 0, 0.5);
                        *(_DWORD*)(a1 + 100) = 0;
                    }
                }
                else if (v7 == 10 && *(_BYTE*)(dword_4F5CC4 + 936))
                {
                    v93 = 0;
                    v94 = *(_DWORD*)(dword_520970 + 280);
                    v95 = *(_DWORD*)(v94 + 520);
                    if (v95 > 0)
                    {
                        v96 = (_BYTE*)(v94 + 897);
                        do
                        {
                            if (*v96)
                                ++v93;
                            v96 += 352;
                            --v95;
                        } while (v95);
                    }
                    if (v93 == *(_DWORD*)(v94 + 520))
                    {
                        sub_45ECD0(*(_DWORD*)(dword_520970 + 280));
                        sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x503, v109, 6, 7, 0);
                    }
                }
                return sub_428620((_DWORD*)a1, a3);
            }
            if (*(_BYTE*)(*(_DWORD*)(dword_520970 + 228) + 16))
                return sub_428620((_DWORD*)a1, a3);
            *(_DWORD*)(a1 + 100) = 9;
        }
        if (!*(_BYTE*)(dword_520970 + 296))
            *(_BYTE*)(dword_520970 + 296) = 1;
        return sub_428620((_DWORD*)a1, a3);
    }
    v38 = *(_BYTE*)(a1 + 81);
    v105 = v38 == 0;
    if (!v38 && !*(_BYTE*)(dword_4F5CC4 + 937))
    {
        a2 = 0;
        for (n = 0; ; n += 12)
        {
            v40 = *(_DWORD*)(a1 + 212);
            if (!v40 || a2 >= (unsigned int)((*(_DWORD*)(a1 + 216) - v40) / 12))
                break;
            if (*(_DWORD*)(n + *(_DWORD*)(a1 + 212) + 4) > *(_DWORD*)(n + *(_DWORD*)(a1 + 212))
                - *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 76) + 424)
                    + 4 * a2)
                    + 12))
            {
                if (*(_BYTE*)(dword_4F5CC4 + 936))
                    sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x507, v111, 6, 15, 0);
                sub_41CD90(*(_DWORD*)(a1 + 236));
                *(_BYTE*)(*(_DWORD*)(dword_520970 + 280) + 11796) = 1;
                sub_4261C0(*(_DWORD**)(dword_520970 + 232), aMissionfailed, 0);
                *(_BYTE*)(a1 + 81) = 1;
            }
            if (*(_DWORD*)(n + *(_DWORD*)(a1 + 212) + 8) < *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 76) + 424)
                + 4 * a2)
                + 12))
                v105 = 0;
            ++a2;
        }
    }
    if (byte_5216F8)
    {
        v41 = (void**)dword_520A04;
        *(_BYTE*)(dword_520A04 + 33) = 1;
        sub_421540(v41);
        v42 = *(_DWORD*)(dword_520970 + 280);
        v43 = *(_DWORD*)(v42 + 512);
        if (v43 >= 0)
            v44 = *(float*)(352 * v43 + v42 + 924);
        else
            v44 = 0.0;
        sub_421190(
            dword_520A04,
            "mission = %s\nwave = %d\nhealth = %0.2f",
            *(const char**)(a1 + 76),
            *(_DWORD*)(a1 + 104) + 1,
            v44);
    }
    if (!*(_BYTE*)(a1 + 80) && !*(_BYTE*)(a1 + 81) && !*(_BYTE*)(dword_4F5CC4 + 937))
    {
        v45 = *(_DWORD*)(a1 + 104);
        v46 = *(float*)&a3 + *(float*)(a1 + 108);
        v47 = v45 == -1;
        *(float*)(a1 + 108) = v46;
        if (v45 != -1)
        {
            v48 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 76) + 408) + 4 * v45);
            if (*(float*)v48 <= 0.0 || v46 < *(float*)v48)
            {
                if (*(_BYTE*)(v48 + 8) && sub_45AB10())
                {
                    v47 = 1;
                }
                else
                {
                    v49 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 76) + 408) + 4 * *(_DWORD*)(a1 + 104));
                    if (*(float*)(v49 + 4) <= 0.0 || *(float*)(a1 + 112) < (double)*(float*)(v49 + 4))
                    {
                        if (*(_BYTE*)(v49 + 9))
                        {
                            v50 = *(_DWORD*)(a1 + 120);
                            v47 = 1;
                            for (ii = 0; v50 && ii < (*(_DWORD*)(a1 + 124) - v50) >> 2; ++ii)
                            {
                                if (*(int*)(*(_DWORD*)(a1 + 120) + 4 * ii) < 0)
                                {
                                    v47 = 0;
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        v47 = 1;
                    }
                }
            }
            else
            {
                v47 = 1;
            }
        }
        if (v105 && !*(_BYTE*)(dword_4F5CC4 + 937))
        {
            if (*(_DWORD*)(*(_DWORD*)(a1 + 76) + 440) == *(_DWORD*)(a1 + 104) && v47 && !sub_45AB10())
            {
                if (*(_BYTE*)(dword_4F5CC4 + 936))
                    sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x507, v111, 6, 15, 0);
                sub_41CD90(*(_DWORD*)(a1 + 236));
                *(_BYTE*)(*(_DWORD*)(dword_520970 + 280) + 11796) = 1;
                sub_4261C0(*(_DWORD**)(dword_520970 + 232), aMissionfailed, 0);
                *(_BYTE*)(a1 + 81) = 1;
            }
            if (*(_DWORD*)(*(_DWORD*)(a1 + 76) + 440) == *(_DWORD*)(a1 + 104) && !sub_45AB10())
                v105 = 0;
        }
        if (v47)
        {
            v52 = *(_DWORD*)(a1 + 76);
            a2 = *(_DWORD*)(a1 + 104) + 1;
            *(_BYTE*)(a1 + 96) = 1;
            *(_DWORD*)(a1 + 104) = a2;
            if (a2 < *(_DWORD*)(v52 + 412))
            {
                if (*(_BYTE*)(dword_4F5CC4 + 936))
                {
                    *(_DWORD*)((char*)&v111[1] + 2) = a2;
                    sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x508, v111, 10, 15, 0);
                }
                v53 = 0;
                v54 = 0;
                *(_DWORD*)(a1 + 108) = 0;
                *(_DWORD*)(a1 + 112) = 0;
                while (1)
                {
                    v55 = *(_DWORD*)(a1 + 120);
                    if (!v55 || v54 >= (*(_DWORD*)(a1 + 124) - v55) >> 2)
                        break;
                    *(_DWORD*)(v55 + 4 * v54++) = 0;
                }
                v56 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 76) + 408) + 4 * *(_DWORD*)(a1 + 104));
                if (*(int*)(v56 + 12) > -1)
                    sub_4030B0(*(_DWORD**)(a1 + 92), *(_DWORD*)(v56 + 16), aCommanderspeci, *(_DWORD*)(v56 + 12));
                v57 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 76) + 408) + 4 * *(_DWORD*)(a1 + 104));
                if (*(int*)(v57 + 24) > 0)
                {
                    do
                    {
                        v58 = *(int**)(*(_DWORD*)(v57 + 20) + 4 * v53);
                        v59 = sub_4426B0(*(_DWORD**)(dword_520970 + 212), *v58, v58[2]);
                        v60 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 76) + 408) + 4
                            * *(_DWORD*)(a1 + 104))
                            + 20)
                            + 4 * v53);
                        *(_DWORD*)(*(_DWORD*)(a1 + 120) + 4 * *(_DWORD*)(*(_DWORD*)(v60 + 8) + 8)) -= *(_DWORD*)(v60 + 4);
                        v61 = *(int**)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 76) + 408) + 4 * *(_DWORD*)(a1 + 104))
                            + 20)
                            + 4 * v53);
                        if (*(_DWORD*)(v61[2] + 292) == 6)
                        {
                            v62 = 0;
                            if (*v61 > 0)
                            {
                                v63 = 4 * v59;
                                do
                                {
                                    sub_447720(
                                        *(_DWORD**)(*(_DWORD*)(*(_DWORD*)(dword_520970 + 212) + 24) + v63),
                                        v61[3],
                                        v61[4],
                                        v61[5]);
                                    ++v62;
                                    v63 += 4;
                                    v61 = *(int**)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 76) + 408)
                                        + 4 * *(_DWORD*)(a1 + 104))
                                        + 20)
                                        + 4 * v53);
                                } while (v62 < *v61);
                            }
                        }
                        ++v53;
                        v57 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 76) + 408) + 4 * *(_DWORD*)(a1 + 104));
                    } while (v53 < *(_DWORD*)(v57 + 24));
                }
                a2 = 0;
                v64 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 76) + 408) + 4 * *(_DWORD*)(a1 + 104));
                if (*(int*)(v64 + 40) > 0)
                {
                    do
                    {
                        v65 = *(int**)(*(_DWORD*)(v64 + 36) + 4 * a2);
                        sub_42CB30(*(_DWORD**)(dword_520970 + 208), *v65, v65[2]);
                        v66 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 76) + 408) + 4
                            * *(_DWORD*)(a1 + 104))
                            + 36)
                            + 4 * a2++);
                        *(_DWORD*)(*(_DWORD*)(a1 + 120) + 4 * *(_DWORD*)(*(_DWORD*)(v66 + 8) + 8)) -= *(_DWORD*)(v66 + 4);
                        v64 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 76) + 408) + 4 * *(_DWORD*)(a1 + 104));
                    } while (a2 < *(_DWORD*)(v64 + 40));
                }
            }
            else
            {
                *(_BYTE*)(a1 + 80) = 1;
                if (*(_BYTE*)(dword_4F5CC4 + 936))
                    sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x505, v111, 6, 15, 0);
            }
        }
        if (*(_DWORD*)(a1 + 132))
        {
            v67 = *(float*)(a1 + 136) - *(float*)&a3;
            *(float*)(a1 + 136) = v67;
            if (v67 <= 0.0)
            {
                v68 = *(_DWORD*)(a1 + 132);
                if (v68 > 0)
                    *(_DWORD*)(a1 + 132) = v68 - 1;
                v69 = *(_DWORD*)(a1 + 76);
                v70 = *(float*)(v69 + 348);
                v109[0] = *(float*)(v69 + 344);
                v110 = v70;
                if (v109[0] == v70)
                {
                    v71 = v109[0];
                }
                else
                {
                    LODWORD(v111[0]) = rand();
                    v71 = fabs((double)SLODWORD(v111[0]) * 0.000030518509) * (v110 - v109[0]) + v109[0];
                }
                *(float*)(a1 + 136) = v71;
                sub_462A80(*(_DWORD**)(dword_520970 + 280), &v106, &v107);
                if (v106 == v107 && rand() % 2 == 1 || v106 && !v107)
                {
                    sub_4426B0(*(_DWORD**)(dword_520970 + 212), 1, *(_DWORD*)(*(_DWORD*)(a1 + 76) + 316));
                    v72 = *(_DWORD**)(a1 + 76);
                    a2 = v72[79];
                }
                else
                {
                    sub_42CB30(*(_DWORD**)(dword_520970 + 208), 1, *(_DWORD*)(*(_DWORD*)(a1 + 76) + 320));
                    v72 = *(_DWORD**)(a1 + 76);
                    a2 = v72[80];
                }
                v73 = 0;
                if ((int)v72[107] > 0)
                {
                    v74 = 0;
                    do
                    {
                        v75 = *(_DWORD**)(v72[106] + 4 * v73);
                        if (a2 == v75[1] || a2 == *v75)
                            ++*(_DWORD*)(v74 + *(_DWORD*)(a1 + 212));
                        v72 = *(_DWORD**)(a1 + 76);
                        ++v73;
                        v74 += 12;
                    } while (v73 < v72[107]);
                }
            }
        }
    }
    if (!*(_BYTE*)(dword_4F5CC4 + 937) && !v108)
    {
        if (!*(_BYTE*)(a1 + 80))
            goto LABEL_158;
        if (v105)
        {
            v76 = sub_450BF0((_DWORD*)dword_520970, 1, 0);
            sub_421110(v76, aMissionComplet);
            sub_41CD90(*(_DWORD*)(a1 + 232));
        }
    }
    if (*(_BYTE*)(a1 + 80) && v105 && !*(_BYTE*)(dword_520970 + 296) && sub_408F40(49))
    {
        if (*(_BYTE*)(dword_4F5CC4 + 936) || *(_BYTE*)(dword_4F5CC4 + 937))
            sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x506, v111, 6, 2, 5000);
        else
            sub_45B200((int*)a1, a2);
    }
LABEL_158:
    v111[0] = *(float*)(a1 + 204);
    if (sub_45B3E0(a1, (float*)(a1 + 204)) && (__int64)v111[0] != (__int64)*(float*)(a1 + 204))
        *(_BYTE*)(a1 + 96) = 1;
    if (*(_BYTE*)(a1 + 96))
    {
        *(_BYTE*)(a1 + 96) = 0;
        sub_436D70(*(_DWORD**)(dword_520970 + 224));
        v77 = 0;
        for (v109[0] = 0.0; ; LODWORD(v109[0]) += 12)
        {
            while (1)
            {
                v78 = *(_DWORD*)(a1 + 212);
                if (!v78 || v77 >= (*(_DWORD*)(a1 + 216) - v78) / 12)
                {
                    v84 = *(_DWORD*)(a1 + 76);
                    v85 = 0.0;
                    v110 = 0.0;
                    if (*(int*)(v84 + 448) > 0)
                    {
                        do
                        {
                            v86 = *(_DWORD*)(*(_DWORD*)(v84 + 444) + 4 * LODWORD(v85));
                            if (*(_DWORD*)(a1 + 104) == *(_DWORD*)v86)
                            {
                                v87 = (__int64)*(float*)(a1 + 204);
                                v103 = (int)v87 % 60;
                                v98 = (int)v87 / 60;
                                v88 = sub_436DD0(*(_DWORD**)(dword_520970 + 224));
                                sub_421190(v88, (char*)(v86 + 4), v98, v103);
                                v85 = v110;
                            }
                            v84 = *(_DWORD*)(a1 + 76);
                            ++LODWORD(v85);
                            v110 = v85;
                        } while (SLODWORD(v85) < *(_DWORD*)(v84 + 448));
                    }
                    return sub_428620((_DWORD*)a1, a3);
                }
                v79 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 76) + 424) + 4 * v77);
                if (*(_DWORD*)(a1 + 104) >= *(_DWORD*)(v79 + 16))
                {
                    v80 = *(_DWORD*)(v79 + 12) - *(_DWORD*)(*(_DWORD*)(a1 + 212) + LODWORD(v109[0]) + 8);
                    if (v80 > 0)
                    {
                        v81 = (char*)(v79 + 20);
                        if (*(_BYTE*)(v79 + 20))
                            break;
                    }
                }
            LABEL_171:
                ++v77;
                LODWORD(v109[0]) += 12;
            }
            if (!strstr(v81, aD))
            {
                v83 = sub_436DD0(*(_DWORD**)(dword_520970 + 224));
                sub_421110(v83, v81);
                goto LABEL_171;
            }
            v82 = sub_436DD0(*(_DWORD**)(dword_520970 + 224));
            sub_421190(v82, v81, v80);
            ++v77;
        }
    }
    return sub_428620((_DWORD*)a1, a3);
}
// 45B764: variable 'v104' is possibly undefined
// 4AD1B0: using guessed type int dword_4AD1B0;
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;
// 5216E4: using guessed type char byte_5216E4;
// 5216F8: using guessed type char byte_5216F8;

//----- (0045C640) --------------------------------------------------------
char __thiscall sub_45C640(int this, int a2)
{
    int v2; // edi
    int v3; // eax
    int v5; // ebx
    int v6; // edx
    int v7; // eax
    int v8; // edi
    int v9; // edx
    int v10; // edi

    v2 = *(_DWORD*)(a2 + 16);
    LOWORD(v3) = *(_WORD*)(a2 + 12) - 1281;
    switch (*(_WORD*)(a2 + 12))
    {
    case 0x501:
        v5 = *(_DWORD*)(v2 + 6);
        sub_45ABF0(this);
        *(_DWORD*)(this + 20) = *(_DWORD*)(v2 + 18);
        sub_45A920((_DWORD*)this, v5, *(_DWORD*)(v2 + 10), *(_DWORD*)(v2 + 14));
        *(_BYTE*)(dword_520970 + 20) = 1;
        LOBYTE(v3) = dword_520970;
        if (!*(_BYTE*)(dword_520970 + 296))
            *(_BYTE*)(dword_520970 + 296) = 1;
        break;
    case 0x502:
        v3 = sub_45E6F0(*(_DWORD**)(dword_520970 + 280), *(_DWORD*)(a2 + 4));
        if (v3 > -1)
        {
            v6 = 11 * v3;
            LOBYTE(v3) = dword_520970;
            *(_BYTE*)(*(_DWORD*)(dword_520970 + 280) + 32 * v6 + 897) = 1;
        }
        break;
    case 0x503:
        *(_DWORD*)(this + 100) = 5;
        break;
    case 0x504:
        LOBYTE(v3) = sub_45B2B0(this, (const char*)(v2 + 6));
        break;
    case 0x505:
        *(_BYTE*)(this + 80) = 1;
        v7 = sub_450BF0((_DWORD*)dword_520970, 1, 0);
        sub_421110(v7, aMissionComplet_0);
        LOBYTE(v3) = sub_41CD90(*(_DWORD*)(this + 232));
        break;
    case 0x506:
        LOBYTE(v3) = sub_45B200((int*)this, v2);
        break;
    case 0x507:
        sub_41CD90(*(_DWORD*)(this + 236));
        *(_BYTE*)(this + 81) = 1;
        *(_BYTE*)(*(_DWORD*)(dword_520970 + 280) + 11796) = 1;
        LOBYTE(v3) = sub_4261C0(*(_DWORD**)(dword_520970 + 232), aMissionfailed, 0);
        break;
    case 0x508:
        v8 = *(_DWORD*)(v2 + 6);
        v9 = *(_DWORD*)(this + 76);
        *(_DWORD*)(this + 104) = v8;
        v10 = *(_DWORD*)(*(_DWORD*)(v9 + 408) + 4 * v8);
        v3 = *(_DWORD*)(v10 + 12);
        if (v3 > -1)
            LOBYTE(v3) = sub_4030B0(*(_DWORD**)(this + 92), *(_DWORD*)(v10 + 16), aCommanderspeci, *(_DWORD*)(v10 + 12));
        break;
    default:
        return v3;
    }
    return v3;
}
// 520970: using guessed type int dword_520970;

//----- (0045C7E0) --------------------------------------------------------
void __thiscall sub_45C7E0(int this)
{
    int i; // ebp
    void* v3; // edi
    void* v4; // eax

    if (*(_BYTE*)(this + 12))
    {
        for (i = 0; i < *(_DWORD*)(this + 4); ++i)
        {
            v3 = *(void**)(*(_DWORD*)this + 4 * i);
            if (v3)
            {
                sub_45CCA0(*(_DWORD*)(*(_DWORD*)this + 4 * i));
                sub_4885A6(v3);
            }
        }
    }
    memset(*(void**)this, 0, 4 * *(_DWORD*)(this + 4));
    v4 = *(void**)this;
    *(_DWORD*)(this + 4) = 0;
    sub_488CEE(v4);
    *(_DWORD*)(this + 8) = 0;
    *(_DWORD*)this = 0;
}

//----- (0045C860) --------------------------------------------------------
_DWORD* __thiscall sub_45C860(_DWORD* this, char a2)
{
    _DWORD* result; // eax

    result = this;
    *this = 0;
    this[1] = 0;
    this[2] = 0;
    *((_BYTE*)this + 12) = a2;
    return result;
}

//----- (0045C880) --------------------------------------------------------
void __thiscall sub_45C880(_DWORD* this)
{
    int i; // ebp
    void* v3; // edi
    void* v4; // eax

    if (*((_BYTE*)this + 12))
    {
        for (i = 0; i < this[1]; ++i)
        {
            v3 = *(void**)(*this + 4 * i);
            if (v3)
            {
                sub_45CD60(*(_DWORD*)(*this + 4 * i));
                sub_4885A6(v3);
            }
        }
    }
    memset((void*)*this, 0, 4 * this[1]);
    v4 = (void*)*this;
    this[1] = 0;
    sub_488CEE(v4);
    this[2] = 0;
    *this = 0;
}

//----- (0045C900) --------------------------------------------------------
int __thiscall sub_45C900(_DWORD* this)
{
    int result; // eax

    result = this[1];
    if (result)
        return (this[2] - result) / 12;
    return result;
}

//----- (0045C920) --------------------------------------------------------
unsigned int __thiscall sub_45C920(_DWORD* this, char* a2, unsigned int a3, _DWORD* a4)
{
    _DWORD* v4; // ebx
    char* v5; // ecx
    unsigned int v6; // esi
    int v7; // edi
    unsigned int v8; // ebp
    int v9; // edx
    unsigned int v10; // eax
    _DWORD* v12; // edx
    char* k; // eax
    _DWORD* v14; // eax
    char* v15; // ebx
    _DWORD* v16; // edi
    char* v17; // eax
    unsigned int result; // eax
    int v19; // ecx
    int v20; // kr00_4
    int v22; // ebp
    char* v23; // edx
    char* v24; // eax
    char* v25; // ebx
    unsigned int j; // esi
    char* v27; // eax
    char* v28; // ecx
    char* v29; // edi
    int v30; // esi
    char* v31; // eax
    char* i; // edx
    _DWORD* v33; // ecx
    char* v34; // eax
    _DWORD* v35; // ebx
    _DWORD* v36; // [esp+10h] [ebp-8h]
    _DWORD* v37; // [esp+14h] [ebp-4h]
    unsigned int v38; // [esp+1Ch] [ebp+4h]
    int v39; // [esp+1Ch] [ebp+4h]
    unsigned int v40; // [esp+20h] [ebp+8h]
    char* v41; // [esp+20h] [ebp+8h]

    v4 = this;
    v5 = (char*)this[2];
    v6 = a3;
    v36 = v4;
    if ((v4[3] - (int)v5) / 12 >= a3)
    {
        result = (unsigned int)((unsigned __int64)(715827883LL * (v5 - a2)) >> 32) >> 31;
        if ((v5 - a2) / 12 >= a3)
        {
            if (a3)
            {
                v30 = 12 * a3;
                v31 = &v5[-12 * a3];
                for (i = v5; v31 != v5; i += 12)
                {
                    if (i)
                    {
                        *(_DWORD*)i = *(_DWORD*)v31;
                        *((_DWORD*)i + 1) = *((_DWORD*)v31 + 1);
                        *((_DWORD*)i + 2) = *((_DWORD*)v31 + 2);
                        v30 = 12 * a3;
                        v4 = v36;
                    }
                    v31 += 12;
                }
                v33 = (_DWORD*)v4[2];
                v34 = (char*)&v33[v30 / 0xFFFFFFFC];
                if (a2 != (char*)&v33[v30 / 0xFFFFFFFC])
                {
                    do
                    {
                        v34 -= 12;
                        v33 -= 3;
                        *v33 = *(_DWORD*)v34;
                        v33[1] = *((_DWORD*)v34 + 1);
                        v33[2] = *((_DWORD*)v34 + 2);
                    } while (v34 != a2);
                    v4 = v36;
                }
                result = (unsigned int)a2;
                if (a2 != &a2[v30])
                {
                    do
                    {
                        v35 = (_DWORD*)result;
                        result += 12;
                        *v35 = *a4;
                        v35[1] = a4[1];
                        v35[2] = a4[2];
                    } while ((char*)result != &a2[v30]);
                    v4 = v36;
                }
                v4[2] += v30;
            }
        }
        else
        {
            v22 = 12 * a3;
            v39 = 12 * a3;
            v23 = &a2[12 * a3];
            v41 = v23;
            if (a2 != v5)
            {
                v24 = &v23[-v22];
                do
                {
                    if (v23)
                    {
                        *(_DWORD*)v23 = *(_DWORD*)v24;
                        *((_DWORD*)v23 + 1) = *((_DWORD*)v24 + 1);
                        v22 = v39;
                        *((_DWORD*)v23 + 2) = *((_DWORD*)v24 + 2);
                        v23 = v41;
                        v4 = v36;
                    }
                    v24 += 12;
                    v23 += 12;
                    v41 = v23;
                } while (v24 != v5);
            }
            v25 = (char*)v4[2];
            for (j = v6 - (v25 - a2) / 12; j; --j)
            {
                if (v25)
                {
                    *(_DWORD*)v25 = *a4;
                    *((_DWORD*)v25 + 1) = a4[1];
                    *((_DWORD*)v25 + 2) = a4[2];
                }
                v25 += 12;
            }
            v27 = a2;
            v28 = (char*)v36[2];
            if (a2 != v28)
            {
                do
                {
                    v29 = v27;
                    v27 += 12;
                    *(_DWORD*)v29 = *a4;
                    *((_DWORD*)v29 + 1) = a4[1];
                    *((_DWORD*)v29 + 2) = a4[2];
                } while (v27 != v28);
            }
            result = v22 + v36[2];
            v36[2] = result;
        }
    }
    else
    {
        v7 = v4[1];
        if (!v7 || (v8 = (int)&v5[-v7] / 12, a3 >= v8))
            v8 = a3;
        if (v7)
            v9 = (int)&v5[-v7] / 12;
        else
            v9 = 0;
        v10 = v9 + v8;
        v40 = v9 + v8;
        if ((int)(v9 + v8) < 0)
            v10 = 0;
        v37 = operator new(12 * v10);
        v12 = v37;
        for (k = (char*)v4[1]; k != a2; v12 += 3)
        {
            if (v12)
            {
                *v12 = *(_DWORD*)k;
                v12[1] = *((_DWORD*)k + 1);
                v12[2] = *((_DWORD*)k + 2);
            }
            k += 12;
        }
        v14 = v12;
        if (v6)
        {
            v38 = v6;
            do
            {
                if (v14)
                {
                    *v14 = *a4;
                    v14[1] = a4[1];
                    v14[2] = a4[2];
                }
                v14 += 3;
                --v38;
            } while (v38);
        }
        v15 = (char*)v4[2];
        v16 = &v12[3 * v6];
        if (a2 != v15)
        {
            v17 = a2;
            do
            {
                if (v16)
                {
                    *v16 = *(_DWORD*)v17;
                    v16[1] = *((_DWORD*)v17 + 1);
                    v16[2] = *((_DWORD*)v17 + 2);
                }
                v17 += 12;
                v16 += 3;
            } while (v17 != v15);
        }
        sub_4885A6((LPVOID)v36[1]);
        result = v36[1];
        v36[3] = &v37[3 * v40];
        if (result)
        {
            v19 = v36[2];
            v36[1] = v37;
            v20 = v19 - result;
            result = (unsigned int)((unsigned __int64)(715827883LL * (int)(v19 - result)) >> 32) >> 31;
            v6 += v20 / 12;
        }
        else
        {
            v36[1] = v37;
        }
        v36[2] = &v37[3 * v6];
    }
    return result;
}

//----- (0045CC50) --------------------------------------------------------
_DWORD* __thiscall sub_45CC50(_DWORD* this, _DWORD* a2, _DWORD* a3)
{
    _DWORD* v3; // edx
    _DWORD* v4; // esi
    _DWORD* v5; // edi
    _DWORD* v6; // eax
    _DWORD* v7; // ebx
    _DWORD* result; // eax

    v3 = a3;
    v4 = a2;
    v5 = (_DWORD*)this[2];
    if (a3 != v5)
    {
        do
        {
            v6 = v3;
            v7 = v4;
            v3 += 3;
            v4 += 3;
            *v7 = *v6;
            v7[1] = v6[1];
            v7[2] = v6[2];
        } while (v3 != v5);
    }
    result = a2;
    this[2] = v4;
    return result;
}

//----- (0045CCA0) --------------------------------------------------------
void __thiscall sub_45CCA0(int this)
{
    int i; // edi
    void* v3; // eax
    int j; // edi
    void* v5; // eax

    if (*(_BYTE*)(this + 48))
    {
        for (i = 0; i < *(_DWORD*)(this + 40); ++i)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 36) + 4 * i));
    }
    memset(*(void**)(this + 36), 0, 4 * *(_DWORD*)(this + 40));
    v3 = *(void**)(this + 36);
    *(_DWORD*)(this + 40) = 0;
    sub_488CEE(v3);
    *(_DWORD*)(this + 44) = 0;
    *(_DWORD*)(this + 36) = 0;
    if (*(_BYTE*)(this + 32))
    {
        for (j = 0; j < *(_DWORD*)(this + 24); ++j)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 20) + 4 * j));
    }
    memset(*(void**)(this + 20), 0, 4 * *(_DWORD*)(this + 24));
    v5 = *(void**)(this + 20);
    *(_DWORD*)(this + 24) = 0;
    sub_488CEE(v5);
    *(_DWORD*)(this + 28) = 0;
    *(_DWORD*)(this + 20) = 0;
}

//----- (0045CD60) --------------------------------------------------------
void __thiscall sub_45CD60(int this)
{
    int i; // edi
    void* v3; // eax
    int j; // edi
    void* v5; // eax
    int k; // ebp
    void* v7; // edi
    void* v8; // eax

    if (*(_BYTE*)(this + 456))
    {
        for (i = 0; i < *(_DWORD*)(this + 448); ++i)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 444) + 4 * i));
    }
    memset(*(void**)(this + 444), 0, 4 * *(_DWORD*)(this + 448));
    v3 = *(void**)(this + 444);
    *(_DWORD*)(this + 448) = 0;
    sub_488CEE(v3);
    *(_DWORD*)(this + 452) = 0;
    *(_DWORD*)(this + 444) = 0;
    if (*(_BYTE*)(this + 436))
    {
        for (j = 0; j < *(_DWORD*)(this + 428); ++j)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 424) + 4 * j));
    }
    memset(*(void**)(this + 424), 0, 4 * *(_DWORD*)(this + 428));
    v5 = *(void**)(this + 424);
    *(_DWORD*)(this + 428) = 0;
    sub_488CEE(v5);
    *(_DWORD*)(this + 432) = 0;
    *(_DWORD*)(this + 424) = 0;
    if (*(_BYTE*)(this + 420))
    {
        for (k = 0; k < *(_DWORD*)(this + 412); ++k)
        {
            v7 = *(void**)(*(_DWORD*)(this + 408) + 4 * k);
            if (v7)
            {
                sub_45CF30((int)v7 + 36, 1);
                sub_45CF30((int)v7 + 20, 1);
                sub_4885A6(v7);
            }
        }
    }
    memset(*(void**)(this + 408), 0, 4 * *(_DWORD*)(this + 412));
    v8 = *(void**)(this + 408);
    *(_DWORD*)(this + 412) = 0;
    sub_488CEE(v8);
    *(_DWORD*)(this + 416) = 0;
    *(_DWORD*)(this + 408) = 0;
    sub_4885A6(*(LPVOID*)(this + 304));
    *(_DWORD*)(this + 304) = 0;
    *(_DWORD*)(this + 308) = 0;
    *(_DWORD*)(this + 312) = 0;
}

//----- (0045CF30) --------------------------------------------------------
void __thiscall sub_45CF30(int this, char a2)
{
    int i; // edi

    if (*(_BYTE*)(this + 12))
    {
        for (i = 0; i < *(_DWORD*)(this + 4); ++i)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)this + 4 * i));
    }
    memset(*(void**)this, 0, 4 * *(_DWORD*)(this + 4));
    *(_DWORD*)(this + 4) = 0;
    if (a2)
    {
        sub_488CEE(*(LPVOID*)this);
        *(_DWORD*)(this + 8) = 0;
        *(_DWORD*)this = 0;
    }
}

//----- (0045CFA0) --------------------------------------------------------
int __usercall sub_45CFA0@<eax>(int a1@<ecx>, int a2@<ebp>)
{
    int v3; // ebx
    int* v4; // edi
    int v5; // eax

    sub_45D070(a1, a2);
    v3 = 0;
    if (*(int*)(a1 + 656) > 0)
    {
        v4 = (int*)(a1 + 668);
        do
        {
            v5 = *(v4 - 1);
            if (v5 != -1)
                sub_403C80(*(_DWORD**)(a1 + 648), v5, 1);
            if (*v4 != -1)
                sub_403C80(*(_DWORD**)(a1 + 648), *v4, 1);
            ++v3;
            v4 += 3;
        } while (v3 < *(_DWORD*)(a1 + 656));
    }
    if (!*(_DWORD*)(a1 + 292) && *(_BYTE*)(a1 + 805))
    {
        sub_4282E0(*(_DWORD*)(a1 + 808) > -1, aDeleteExtradat);
        sub_408640(*(_DWORD**)(a1 + 652), *(_DWORD*)(a1 + 808), 0);
    }
    return sub_4690E0((_DWORD*)a1);
}

//----- (0045D050) --------------------------------------------------------
int __thiscall sub_45D050(_DWORD* this)
{
    sub_45D130(this);
    return sub_469120(this);
}

//----- (0045D070) --------------------------------------------------------
void __usercall sub_45D070(int a1@<ecx>, int a2@<ebp>)
{
    char* v3; // eax
    _DWORD* v4; // eax
    _DWORD* v5; // eax

    if (*(_DWORD*)(a1 + 292) != 3 && !*(_DWORD*)(a1 + 648))
    {
        v3 = sub_4069C0(*(_DWORD*)(dword_520970 + 128), a2, (char*)(a1 + 388));
        *(_DWORD*)(a1 + 648) = v3;
        sub_4282E0(v3 != 0, "failed to load model %s, see file %s", (const char*)(a1 + 388), (const char*)(a1 + 16));
        v4 = operator new(0x34u);
        if (v4)
            v5 = sub_406B00(v4, *(_DWORD*)(a1 + 648), 1);
        else
            v5 = 0;
        *(_DWORD*)(a1 + 652) = v5;
        v5[9] = 0;
        *(_BYTE*)(*(_DWORD*)(a1 + 652) + 48) = 1;
    }
}
// 520970: using guessed type int dword_520970;

//----- (0045D130) --------------------------------------------------------
void __thiscall sub_45D130(_DWORD* this)
{
    _DWORD* v2; // ecx
    void(__thiscall * **v3)(_DWORD, int); // ecx

    if (this[73] != 3)
    {
        v2 = (_DWORD*)this[162];
        if (v2)
        {
            sub_403B70(v2);
            v3 = (void(__thiscall***)(_DWORD, int))this[163];
            this[162] = 0;
            if (v3)
                (**v3)(v3, 1);
            this[163] = 0;
        }
    }
}

//----- (0045D180) --------------------------------------------------------
_DWORD* __thiscall sub_45D180(_DWORD* this, int a2)
{
    int v3; // esi
    const char* v4; // eax
    double v5; // st7
    double v6; // st7
    int v7; // eax
    int v8; // edi
    _DWORD* v9; // esi
    _DWORD* v10; // eax
    int* v11; // eax
    int v12; // eax
    char* v13; // edx
    int* v14; // eax
    int v15; // eax
    char* v16; // edx
    int v17; // eax
    _DWORD* v18; // eax
    _DWORD* v19; // eax
    int v20; // eax
    int v21; // ecx
    _DWORD* v22; // eax
    int v23; // edi
    float* v24; // eax
    int v25; // esi
    float* v26; // eax
    int v27; // esi
    int* v28; // eax
    int v29; // eax
    float* v30; // eax
    float* v31; // eax
    int v32; // ecx
    char* v33; // eax
    _DWORD* v34; // eax
    char* String1; // [esp+10h] [ebp-118h] BYREF
    float v37; // [esp+14h] [ebp-114h] BYREF
    _DWORD* v38; // [esp+18h] [ebp-110h]
    char Buffer[256]; // [esp+1Ch] [ebp-10Ch] BYREF
    int v40; // [esp+124h] [ebp-4h]

    v38 = this;
    sub_468FF0(this, (char*)a2);
    v40 = 0;
    *this = &off_499B78;
    sub_4229D0(aStartedLoading_2);
    sub_40AFC0((void*)a2, aType_0, &String1);
    if (_strcmpi(String1, aMachineGun))
    {
        if (_strcmpi(String1, aBazooka_0))
        {
            if (_strcmpi(String1, aArtillery))
            {
                if (_strcmpi(String1, aGrenade_0))
                    sub_4281B0("invalid gun type, see file %s", (const char*)(a2 + 16));
                this[73] = 3;
            }
            else
            {
                this[73] = 2;
            }
        }
        else
        {
            this[73] = 1;
        }
    }
    else
    {
        this[73] = 0;
    }
    sub_40AFC0((void*)a2, aAmmotype, &String1);
    v3 = 0;
    while (1)
    {
        if (v3)
        {
            switch (v3)
            {
            case 1:
                v4 = a45cal;
                break;
            case 2:
                v4 = a50cal;
                break;
            case 3:
                v4 = a40mm;
                break;
            case 4:
                v4 = a105mm;
                break;
            case 5:
                v4 = a155mm;
                break;
            case 6:
                v4 = a203mm;
                break;
            case 7:
                v4 = aBazooka;
                break;
            default:
                v4 = v3 == 8 ? aSuperbazooka : v3 != 9 ? 0 : aGrenade;
                break;
            }
        }
        else
        {
            v4 = a30cal;
        }
        if (!_strcmpi(String1, v4))
            break;
        if (++v3 >= 10)
            goto LABEL_34;
    }
    this[74] = v3;
LABEL_34:
    sub_40A120(v3 < 10, "invalid ammo type, see %s : %s", (const char*)this[1], (const char*)(a2 + 16));
    sub_40AF00((const char*)a2, aCrosshair_0, (char**)this + 75);
    sub_40AFC0((void*)a2, aBullettype, &String1);
    sub_469160((int)this, this + 76, String1, aBullet);
    sub_40AF60((const char*)a2, aRof, (float*)this + 77);
    v5 = *((float*)this + 77);
    if (v5 == 0.0)
        v6 = 0.0;
    else
        v6 = 60.0 / v5;
    *((float*)this + 77) = v6;
    sub_40AF60((const char*)a2, aMousemovementx, (float*)this + 78);
    this[79] = this[78];
    this[80] = 0;
    this[81] = 1120403456;
    this[82] = 0x40000000;
    if (sub_40ABC0((_DWORD*)a2, aMousemovementx_0, 0))
        sub_40AF60((const char*)a2, aMousemovementx_0, (float*)this + 79);
    if (sub_40ABC0((_DWORD*)a2, aMousemovementx_1, 0))
        sub_40AF60((const char*)a2, aMousemovementx_1, (float*)this + 80);
    if (sub_40ABC0((_DWORD*)a2, aMousemovementx_2, 0))
        sub_40AF60((const char*)a2, aMousemovementx_2, (float*)this + 81);
    if (sub_40ABC0((_DWORD*)a2, aMousemovementx_3, 0))
        sub_40AF60((const char*)a2, aMousemovementx_3, (float*)this + 82);
    sub_40AF60((const char*)a2, aMousemovementy, (float*)this + 83);
    this[84] = this[83];
    this[85] = 0;
    this[86] = 1120403456;
    this[87] = 0x40000000;
    if (sub_40ABC0((_DWORD*)a2, aMousemovementy_0, 0))
        sub_40AF60((const char*)a2, aMousemovementy_0, (float*)this + 84);
    if (sub_40ABC0((_DWORD*)a2, aMousemovementy_1, 0))
        sub_40AF60((const char*)a2, aMousemovementy_1, (float*)this + 85);
    if (sub_40ABC0((_DWORD*)a2, aMousemovementy_2, 0))
        sub_40AF60((const char*)a2, aMousemovementy_2, (float*)this + 86);
    if (sub_40ABC0((_DWORD*)a2, aMousemovementy_3, 0))
        sub_40AF60((const char*)a2, aMousemovementy_3, (float*)this + 87);
    if (this[73] != 2)
        sub_40B1B0((const char*)a2, aPitch, (float*)this + 88);
    sub_40B030((char*)a2, aGunoffset, (float*)this + 90);
    this[93] = 0;
    if (sub_40ABC0((_DWORD*)a2, aFiresoundeffec, 0))
    {
        sub_40AFC0((void*)a2, aFiresoundeffec, &String1);
        sub_469160((int)this, this + 93, String1, aSoundEffect);
    }
    this[94] = 0;
    if (sub_40ABC0((_DWORD*)a2, aShellsoundeffe, 0))
    {
        sub_40AFC0((void*)a2, aShellsoundeffe, &String1);
        sub_469160((int)this, this + 94, String1, aSoundEffect);
    }
    this[95] = 0;
    if (sub_40ABC0((_DWORD*)a2, aBeltsoundeffec, 0))
    {
        sub_40AFC0((void*)a2, aBeltsoundeffec, &String1);
        sub_469160((int)this, this + 95, String1, aSoundEffect);
    }
    this[96] = 0;
    if (sub_40ABC0((_DWORD*)a2, aOutofammosound, 0))
    {
        sub_40AFC0((void*)a2, aOutofammosound, &String1);
        sub_469160((int)this, this + 96, String1, aSoundEffect);
    }
    v7 = this[73];
    this[162] = 0;
    this[163] = 0;
    this[164] = 0;
    if (v7 != 3)
    {
        sub_40AFC0((void*)a2, aModelfile, &String1);
        strcpy((char*)this + 388, String1);
        this[162] = 0;
        this[163] = 0;
        if (!sub_46A3A0(*(_BYTE**)(dword_520970 + 200), (LPCSTR)this + 388))
            sub_45D070((int)this, (int)this);
        sub_40AF00((const char*)a2, aNumbarrels, (char**)this + 164);
        if ((int)this[164] > 0)
        {
            v8 = 1;
            v9 = this + 166;
            do
            {
                sprintf(Buffer, "endOfBarrelNodeName%d", v8);
                sub_40AFC0((void*)a2, Buffer, &String1);
                if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
                {
                    v10 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
                }
                else
                {
                    v37 = COERCE_FLOAT(sub_405A30(*(_DWORD**)(this[163] + 28), String1, -1, 1));
                    v10 = (_DWORD*)sub_46A4C0(*(_DWORD*)(dword_520970 + 200), &v37, 4u);
                }
                *(v9 - 1) = *v10;
                *v9 = -1;
                sprintf(Buffer, "flashNodeName%d", v8);
                if (sub_40ABC0((_DWORD*)a2, Buffer, 0))
                {
                    sub_40AFC0((void*)a2, Buffer, &String1);
                    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
                    {
                        v11 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
                    }
                    else
                    {
                        v37 = COERCE_FLOAT(sub_405A30(*(_DWORD**)(this[163] + 28), String1, -1, 1));
                        v11 = (int*)sub_46A4C0(*(_DWORD*)(dword_520970 + 200), &v37, 4u);
                    }
                    v12 = *v11;
                    v13 = String1;
                    *v9 = v12;
                    sub_40A120(
                        v12 != -1,
                        "failed to find muzzle flash node %s, see %s : %s",
                        v13,
                        (const char*)this[1],
                        (const char*)(a2 + 16));
                }
                v9[1] = -1;
                sprintf(Buffer, "subFlashNodeName%d", v8);
                if (sub_40ABC0((_DWORD*)a2, Buffer, 0))
                {
                    sub_40AFC0((void*)a2, Buffer, &String1);
                    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
                    {
                        v14 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
                    }
                    else
                    {
                        v37 = COERCE_FLOAT(sub_405A30(*(_DWORD**)(this[163] + 28), String1, -1, 1));
                        v14 = (int*)sub_46A4C0(*(_DWORD*)(dword_520970 + 200), &v37, 4u);
                    }
                    v15 = *v14;
                    v16 = String1;
                    v9[1] = v15;
                    sub_40A120(
                        v15 != -1,
                        "failed to find muzzle subFlash node %s, see %s : %s",
                        v16,
                        (const char*)this[1],
                        (const char*)(a2 + 16));
                }
                ++v8;
                v9 += 3;
            } while (v8 - 1 < this[164]);
        }
        this[198] = 0;
        if (sub_40ABC0((_DWORD*)a2, aFlashtime, 0))
            sub_40AF60((const char*)a2, aFlashtime, (float*)this + 198);
        sub_40AF60((const char*)a2, aVelocity, (float*)this + 199);
    }
    v17 = this[73];
    if (v17)
    {
        if (v17 == 2)
        {
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v23 = (int)v38;
            }
            else
            {
                v23 = sub_4059F0((_DWORD*)this[162], 0, 0);
                if (!v23)
                    sub_4281B0(aCouldNotFindAN);
            }
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v24 = (float*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v25 = *(_DWORD*)(dword_520970 + 200);
                v37 = atof((const char*)*(_DWORD*)v23);
                v24 = (float*)sub_46A4C0(v25, &v37, 4u);
            }
            *((float*)this + 88) = *v24;
            if (!sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v23 = sub_4059F0((_DWORD*)this[162], 0, 1);
                if (!v23)
                    sub_4281B0(aCouldNotFindAN);
            }
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v26 = (float*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v27 = *(_DWORD*)(dword_520970 + 200);
                v37 = atof((const char*)*(_DWORD*)v23);
                v26 = (float*)sub_46A4C0(v27, &v37, 4u);
            }
            *((float*)this + 89) = *v26;
            sub_40AFC0((void*)a2, aRecoilnodename, &String1);
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v28 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v37 = COERCE_FLOAT(sub_405A30(*(_DWORD**)(this[163] + 28), String1, -1, 1));
                v28 = (int*)sub_46A4C0(*(_DWORD*)(dword_520970 + 200), &v37, 4u);
            }
            v29 = *v28;
            this[208] = v29;
            if (v29 == -1)
                sub_4281B0(aCouldNotFindTh);
            if (!sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v23 = sub_4059F0((_DWORD*)this[162], this[208], 0);
                if (!v23)
                    sub_4281B0(aCouldNotFindAN);
            }
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v30 = (float*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v37 = *(float*)(v23 + 4);
                v30 = (float*)sub_46A4C0(*(_DWORD*)(dword_520970 + 200), &v37, 4u);
            }
            *((float*)this + 209) = *v30;
            if (!sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v23 = sub_4059F0((_DWORD*)this[162], this[208], 1);
                if (!v23)
                    sub_4281B0(aCouldNotFindAN);
            }
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v31 = (float*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v32 = *(_DWORD*)(dword_520970 + 200);
                v37 = *(float*)(v23 + 4);
                v31 = (float*)sub_46A4C0(v32, &v37, 4u);
            }
            *((float*)this + 210) = *v31;
        }
        else if (v17 == 3)
        {
            sub_40AFC0((void*)a2, aAiminglightmod, &String1);
            v33 = sub_4069C0(*(_DWORD*)(dword_520970 + 128), (int)this, String1);
            v34 = sub_406A90((int)v33, 1);
            this[212] = v34;
            v34[9] = 1065353216;
            *(_BYTE*)(this[212] + 48) = 80;
            sub_428680(*(_DWORD**)(dword_520970 + 280), this[212]);
            this[211] = 0;
            sub_40B1B0((const char*)a2, aAimingrange, (float*)this + 213);
            sub_40B1B0((const char*)a2, aAimingpitch, (float*)this + 215);
            sub_40B1B0((const char*)a2, aTimeinair, (float*)this + 217);
        }
    }
    else
    {
        if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
        {
            v18 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
        }
        else
        {
            v37 = COERCE_FLOAT(sub_405A30(*(_DWORD**)(this[163] + 28), aBase, -1, 1));
            v18 = (_DWORD*)sub_46A4C0(*(_DWORD*)(dword_520970 + 200), &v37, 4u);
        }
        this[200] = *v18;
        sub_40B130((const char*)a2, aAlternatebarre, (_BYTE*)this + 804);
        *((_BYTE*)this + 805) = 0;
        this[202] = -1;
        this[203] = -1;
        if (sub_40ABC0((_DWORD*)a2, aShellnodename, 0))
        {
            *((_BYTE*)this + 805) = 1;
            sub_40AFC0((void*)a2, aShellnodename, &String1);
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v19 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v20 = sub_405A30(*(_DWORD**)(this[163] + 28), String1, -1, 1);
                v21 = *(_DWORD*)(dword_520970 + 200);
                v37 = *(float*)&v20;
                v19 = (_DWORD*)sub_46A4C0(v21, &v37, 4u);
            }
            this[202] = *v19;
            sub_40AFC0((void*)a2, aShellexpendern, &String1);
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v22 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v37 = COERCE_FLOAT(sub_405A30(*(_DWORD**)(this[163] + 28), String1, -1, 1));
                v22 = (_DWORD*)sub_46A4C0(*(_DWORD*)(dword_520970 + 200), &v37, 4u);
            }
            this[203] = *v22;
        }
        sub_40AF60((const char*)a2, aMaxpitchshake, (float*)this + 204);
        sub_40AF60((const char*)a2, aShakevariance, (float*)this + 205);
    }
    sub_45D130(this);
    sub_4229D0(aFinishedLoadin_4);
    return this;
}
// 499B78: using guessed type _UNKNOWN *off_499B78;
// 520970: using guessed type int dword_520970;

//----- (0045DF90) --------------------------------------------------------
_DWORD* __thiscall sub_45DF90(_DWORD* this)
{
    char v3; // [esp+Bh] [ebp-11h]

    sub_401270((int)this);
    this[98] = 0;
    this[99] = 0;
    this[100] = 0;
    *((_BYTE*)this + 404) = 1;
    this[102] = 0;
    this[103] = 0;
    this[104] = 0;
    *((_BYTE*)this + 420) = 1;
    this[642] = 0;
    *((_BYTE*)this + 2564) = v3;
    this[643] = 0;
    this[644] = 0;
    this[2945] = 0;
    this[2946] = 0;
    this[2947] = 0;
    *((_BYTE*)this + 11792) = 1;
    *this = &off_499B84;
    *((_BYTE*)this + 2584) = 0;
    this[647] = 0;
    *((_BYTE*)this + 2552) = 0;
    this[639] = 0;
    *((_BYTE*)this + 11796) = 0;
    memset(this + 132, 0xFDu, 0x160u);
    memset(this + 572, 0xFDu, 0x34u);
    *((_BYTE*)this + 472) = 0;
    sub_462240((int)this);
    return this;
}
// 45DFF7: variable 'v3' is possibly undefined
// 499B84: using guessed type _UNKNOWN *off_499B84;

//----- (0045E0B0) --------------------------------------------------------
int __thiscall sub_45E0B0(int this)
{
    int i; // edi
    void* v3; // eax
    int j; // edi
    void* v5; // eax
    int k; // edi
    void* v7; // eax

    *(_DWORD*)this = &off_499B84;
    sub_403B70(*(_DWORD**)(this + 436));
    sub_403B70(*(_DWORD**)(this + 444));
    sub_411430((_DWORD*)dword_4F5CC4, this);
    if (*(_BYTE*)(this + 11792))
    {
        for (i = 0; i < *(_DWORD*)(this + 11784); ++i)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 11780) + 4 * i));
    }
    memset(*(void**)(this + 11780), 0, 4 * *(_DWORD*)(this + 11784));
    v3 = *(void**)(this + 11780);
    *(_DWORD*)(this + 11784) = 0;
    sub_488CEE(v3);
    *(_DWORD*)(this + 11788) = 0;
    *(_DWORD*)(this + 11780) = 0;
    sub_4885A6(*(LPVOID*)(this + 2568));
    *(_DWORD*)(this + 2568) = 0;
    *(_DWORD*)(this + 2572) = 0;
    *(_DWORD*)(this + 2576) = 0;
    if (*(_BYTE*)(this + 420))
    {
        for (j = 0; j < *(_DWORD*)(this + 412); ++j)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 408) + 4 * j));
    }
    memset(*(void**)(this + 408), 0, 4 * *(_DWORD*)(this + 412));
    v5 = *(void**)(this + 408);
    *(_DWORD*)(this + 412) = 0;
    sub_488CEE(v5);
    *(_DWORD*)(this + 416) = 0;
    *(_DWORD*)(this + 408) = 0;
    if (*(_BYTE*)(this + 404))
    {
        for (k = 0; k < *(_DWORD*)(this + 396); ++k)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 392) + 4 * k));
    }
    memset(*(void**)(this + 392), 0, 4 * *(_DWORD*)(this + 396));
    v7 = *(void**)(this + 392);
    *(_DWORD*)(this + 396) = 0;
    sub_488CEE(v7);
    *(_DWORD*)(this + 400) = 0;
    *(_DWORD*)(this + 392) = 0;
    return sub_4013F0((_DWORD*)this);
}
// 499B84: using guessed type _UNKNOWN *off_499B84;
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (0045E2A0) --------------------------------------------------------
char __userpurge sub_45E2A0@<al>(int a1@<ecx>, int a2@<ebp>, int a3, int a4, int a5, int a6)
{
    char* v7; // eax
    int v8; // eax
    char* v9; // eax
    int v10; // eax
    int v11; // eax
    _BYTE* v12; // eax
    int* v13; // edi
    int v14; // ebp
    _DWORD* v15; // eax
    int* v16; // eax
    int v17; // edx
    _DWORD* v18; // eax
    _DWORD* v19; // eax
    _BYTE* v20; // eax
    int v21; // ecx
    int v23; // [esp-4h] [ebp-150h]
    char* String1; // [esp+1Ch] [ebp-130h] BYREF
    char v25[288]; // [esp+20h] [ebp-12Ch] BYREF
    int v26; // [esp+148h] [ebp-4h]
    _UNKNOWN* retaddr; // [esp+14Ch] [ebp+0h]

    sub_4229D0(aStartedLoading_0);
    *(float*)(a1 + 2592) = fabs((double)rand() * 0.000030518509) * 10.0 + 15.0;
    *(_DWORD*)(a1 + 2596) = sub_403620((_DWORD*)dword_4B5AB0, aChatter);
    *(_DWORD*)(a1 + 508) = 0;
    sub_45E960((_DWORD*)a1, 1);
    nullsub_1(a1);
    sub_40A1D0((int)v25, aPlayerIni);
    v26 = 0;
    sub_40AA40((int)v25, Default);
    sub_40AF60(v25, aPlayerradius, (float*)(a1 + 424));
    sub_40AF60(v25, aHeight, (float*)(a1 + 428));
    sub_40AF60(v25, aMpradius, (float*)(a1 + 432));
    sub_40AFC0(v25, aFpturretmodelf, &String1);
    v7 = sub_4069C0(*(_DWORD*)(dword_520970 + 128), a2, String1);
    *(_DWORD*)(a1 + 436) = v7;
    v8 = sub_405A30(v7, aTurret, -1, 1);
    *(_DWORD*)(a1 + 440) = v8;
    if (v8 == -1)
        sub_4281B0(aCouldnTFindTur);
    sub_40AFC0(v25, aMpturretmodelf, &String1);
    v9 = sub_4069C0(*(_DWORD*)(dword_520970 + 128), a2, String1);
    *(_DWORD*)(a1 + 444) = v9;
    v10 = sub_405A30(v9, aTurret, -1, 1);
    *(_DWORD*)(a1 + 448) = v10;
    if (v10 == -1)
        sub_4281B0(aCouldnTFindTur_0);
    v11 = sub_405A30(*(_DWORD**)(a1 + 444), aBarrel, -1, 1);
    *(_DWORD*)(a1 + 452) = v11;
    if (v11 == -1)
        sub_4281B0(aCouldnTFindBar);
    sub_40AF60(v25, aMaxdamageangle, (float*)(a1 + 460));
    sub_40AF60(v25, aMindamageangle, (float*)(a1 + 464));
    sub_40AF60(v25, aMindamageperce, (float*)(a1 + 468));
    if (sub_422BA0(AppName, aAdjustgunposit, 0))
    {
        v12 = sub_409AD0((int*)dword_520970, 1, 0x400u);
        dword_5216FC = (int)v12;
        *((_DWORD*)v12 + 3) = 1120403456;
        *((_DWORD*)v12 + 4) = 1120403456;
        v12[32] = 0;
    }
    *(_DWORD*)(a1 + 2604) = 0;
    *(_DWORD*)(a1 + 2608) = 0;
    *(_DWORD*)(a1 + 2600) = 0;
    *(_DWORD*)(a1 + 2612) = 0;
    *(_DWORD*)(a1 + 2616) = 1092616192;
    *(_DWORD*)(a1 + 2632) = 0x40000000;
    *(_DWORD*)(a1 + 2620) = 1092616192;
    *(_DWORD*)(a1 + 2628) = 0;
    v23 = a2;
    *(_DWORD*)(a1 + 2624) = 1092616192;
    *(_DWORD*)(a1 + 2636) = sub_469650(*(_DWORD**)(dword_520970 + 200), aGrenade, aGun_0, 1);
    *(_DWORD*)(a1 + 2640) = 0;
    *(_BYTE*)(a1 + 2644) = 0;
    *(_BYTE*)(a1 + 2645) = 0;
    *(_BYTE*)(a1 + 2646) = 0;
    v13 = (int*)(a1 + 2348);
    v14 = 4;
    do
    {
        v15 = operator new(0x34u);
        LOBYTE(v26) = 1;
        if (v15)
            v16 = sub_406B00(v15, *(_DWORD*)(a1 + 436), 1);
        else
            v16 = 0;
        *(v13 - 1) = (int)v16;
        v17 = *v16;
        LOBYTE(v26) = 0;
        (*(void(__thiscall**)(int*, _DWORD, int))(v17 + 24))(v16, 0, v23);
        sub_428680((_DWORD*)a1, *(v13 - 1));
        v18 = operator new(0x34u);
        LOBYTE(retaddr) = 2;
        if (v18)
            v19 = sub_406B00(v18, *(_DWORD*)(a1 + 444), 1);
        else
            v19 = 0;
        *v13 = (int)v19;
        v23 = 0;
        LOBYTE(retaddr) = 0;
        (*(void(__thiscall**)(_DWORD*))(*v19 + 24))(v19);
        sub_428680((_DWORD*)a1, *v13);
        v13 += 13;
        --v14;
    } while (v14);
    sub_463020((_DWORD*)a1);
    sub_462F90((_DWORD*)a1);
    *(_DWORD*)(a1 + 2580) = 0;
    *(_DWORD*)(a1 + 2560) = a3;
    *(_BYTE*)(a1 + 2668) = 0;
    *(_DWORD*)(a1 + 2672) = 0;
    v20 = (_BYTE*)(a1 + 2720);
    v21 = 100;
    do
    {
        *v20 = 0;
        v20 += 88;
        --v21;
    } while (v21);
    *(_DWORD*)(a1 + 520) = 0;
    *(_DWORD*)(a1 + 524) = 0;
    *(_DWORD*)(a1 + 512) = -1;
    *(_DWORD*)(a1 + 516) = -1;
    *(_BYTE*)(a1 + 456) = 0;
    sub_4113F0((_DWORD*)dword_4F5CC4, a1, 65280, 1536, 1);
    sub_4229D0(aFinishedLoadin_1);
    v26 = -1;
    sub_40A830((int)v25);
    return 1;
}
// 415760: using guessed type int __thiscall nullsub_1(_DWORD);
// 4B5AB0: using guessed type int dword_4B5AB0;
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (0045E6F0) --------------------------------------------------------
int __thiscall sub_45E6F0(_DWORD* this, int a2)
{
    int v2; // edx
    int result; // eax
    _DWORD* i; // ecx

    v2 = this[130];
    result = 0;
    if (v2 <= 0)
        return -1;
    for (i = this + 222; *i != a2; i += 88)
    {
        if (++result >= v2)
            return -1;
    }
    return result;
}

//----- (0045E720) --------------------------------------------------------
int __thiscall sub_45E720(int this, const char* a2, int a3)
{
    strcpy((char*)(this + 472), a2);
    return sub_45E960((_DWORD*)this, a3);
}

//----- (0045E760) --------------------------------------------------------
char __thiscall sub_45E760(int this)
{
    FILE* v2; // eax
    FILE* v3; // esi
    void* v5; // eax
    size_t v6; // ecx
    char ArgList[4]; // [esp+8h] [ebp-108h] BYREF
    char Buffer[260]; // [esp+Ch] [ebp-104h] BYREF

    sub_45E960((_DWORD*)this, 1);
    sprintf(Buffer, "Saved\\%s.sps", (const char*)(this + 472));
    v2 = fopen(Buffer, Mode);
    v3 = v2;
    if (v2)
    {
        sub_4898CA(ArgList, 4u, 1u, v2);
        if (*(_DWORD*)ArgList == 305397761)
        {
            sub_4898CA((void*)(this + 496), 4u, 1u, v3);
            sub_4898CA((void*)(this + 500), 4u, 1u, v3);
            sub_4898CA((void*)(this + 504), 4u, 1u, v3);
            v5 = malloc(4 * *(_DWORD*)(this + 496) + 4);
            v6 = *(_DWORD*)(this + 496) + 1;
            *(_DWORD*)(this + 508) = v5;
            sub_4898CA(v5, 4u, v6, v3);
            fclose(v3);
            *(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 20) = *(_DWORD*)(this + 500);
            return 1;
        }
        else
        {
            sub_4229D0("Bad saved game version 0x%04x, need 0x%04x", *(_DWORD*)ArgList, 305397761);
            return 0;
        }
    }
    else
    {
        sub_4229D0("Unable to open saved game file %s", Buffer);
        return 0;
    }
}
// 520970: using guessed type int dword_520970;

//----- (0045E880) --------------------------------------------------------
char __thiscall sub_45E880(int this)
{
    FILE* v2; // eax
    FILE* v3; // esi
    int v5; // [esp+8h] [ebp-108h] BYREF
    char Buffer[260]; // [esp+Ch] [ebp-104h] BYREF

    sub_422EF0(aSaved);
    sprintf(Buffer, "Saved\\%s.sps", (const char*)(this + 472));
    v2 = fopen(Buffer, aWb);
    v3 = v2;
    if (v2)
    {
        v5 = 305397761;
        sub_48A21D(&v5, 4u, 1u, v2);
        sub_48A21D((void*)(this + 496), 4u, 1u, v3);
        sub_48A21D((void*)(this + 500), 4u, 1u, v3);
        sub_48A21D((void*)(this + 504), 4u, 1u, v3);
        sub_48A21D(*(void**)(this + 508), 4u, *(_DWORD*)(this + 496) + 1, v3);
        fclose(v3);
        return 1;
    }
    else
    {
        sub_4229D0("Unable to create saved game file %s", Buffer);
        return 0;
    }
}

//----- (0045E960) --------------------------------------------------------
int __thiscall sub_45E960(_DWORD* this, int a2)
{
    void* v3; // eax
    int result; // eax

    v3 = (void*)this[127];
    this[126] = 0;
    this[125] = a2;
    this[124] = -1;
    sub_488CEE(v3);
    this[127] = 0;
    *(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 20) = a2;
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (0045E9B0) --------------------------------------------------------
int __thiscall sub_45E9B0(_DWORD* this, int a2, int a3)
{
    int v4; // eax
    int v5; // edx
    _DWORD* v6; // eax

    v4 = this[127];
    v5 = *(_DWORD*)(v4 + 4 * a2);
    v6 = (_DWORD*)(v4 + 4 * a2);
    if (a3 > v5)
    {
        *v6 = a3;
        sub_45E880((int)this);
    }
    return *(_DWORD*)(this[127] + 4 * a2);
}

//----- (0045EA00) --------------------------------------------------------
char __thiscall sub_45EA00(_DWORD* this, int a2)
{
    int v3; // ebx
    int i; // eax
    void* v6; // [esp-8h] [ebp-14h]

    v3 = this[124];
    if (a2 > v3)
    {
        v6 = (void*)this[127];
        this[124] = a2;
        this[127] = sub_488DD7(v6, 4 * a2 + 4);
        for (i = v3 + 1; i <= a2; *(_DWORD*)(this[127] + 4 * i - 4) = 0)
            ++i;
    }
    return sub_45E880((int)this);
}

//----- (0045EA60) --------------------------------------------------------
int __thiscall sub_45EA60(_DWORD* this)
{
    int v1; // edx
    int result; // eax
    int* v3; // ecx
    int v4; // edx
    int v5; // esi

    v1 = this[124];
    result = 0;
    if (v1 >= 0)
    {
        v3 = (int*)this[127];
        v4 = v1 + 1;
        do
        {
            v5 = *v3++;
            result += v5;
            --v4;
        } while (v4);
    }
    return result;
}

//----- (0045EA80) --------------------------------------------------------
int __thiscall sub_45EA80(int this, int a2)
{
    int result; // eax
    int v4; // ebp
    int* v5; // esi
    double v6; // st7
    float v7; // ecx
    double v8; // st7
    float v9; // [esp+18h] [ebp-94h]
    float v10[3]; // [esp+1Ch] [ebp-90h]
    float v11; // [esp+28h] [ebp-84h]
    int v12; // [esp+2Ch] [ebp-80h]
    int v13; // [esp+30h] [ebp-7Ch]
    int v14; // [esp+34h] [ebp-78h]
    int v15; // [esp+38h] [ebp-74h]
    int v16; // [esp+3Ch] [ebp-70h]
    int v17; // [esp+40h] [ebp-6Ch]
    int v18; // [esp+44h] [ebp-68h]
    int v19; // [esp+48h] [ebp-64h]
    int v20; // [esp+4Ch] [ebp-60h]
    int v21; // [esp+50h] [ebp-5Ch]
    int v22; // [esp+54h] [ebp-58h]
    int v23; // [esp+58h] [ebp-54h]
    int v24; // [esp+5Ch] [ebp-50h]
    int v25; // [esp+60h] [ebp-4Ch]
    int v26; // [esp+64h] [ebp-48h]
    int v27; // [esp+68h] [ebp-44h]
    int v28[16]; // [esp+6Ch] [ebp-40h] BYREF

    sub_462F90((_DWORD*)this);
    result = a2;
    v4 = 0;
    v12 = -1082130432;
    v13 = -1082130432;
    v14 = -1082130432;
    v15 = -1082130432;
    v16 = 1070141403;
    v17 = -1077342245;
    v18 = -1082130432;
    v19 = -1082130432;
    v20 = 0;
    v21 = 1074137746;
    v22 = -1073345902;
    v23 = -1082130432;
    v24 = 1061752795;
    v25 = -1085730853;
    v26 = 1075235812;
    v27 = -1072247836;
    *(_DWORD*)(this + 524) = a2;
    if (a2 > 0)
    {
        v5 = (int*)(this + 2356);
        do
        {
            if (*(_DWORD*)(this + 524) == 1)
            {
                v6 = *(float*)(this + 428);
                v10[1] = 0.0;
                v10[2] = 0.0;
                *(v5 - 1) = 0;
                v11 = v6;
                v7 = v11;
                *v5 = 0;
                *((float*)v5 + 1) = v7;
            }
            else if (*(int*)(this + 520) > 1)
            {
                v9 = *(float*)(this + 432);
                v8 = *(float*)(this + 428);
                *(v5 - 1) = 0;
                v10[0] = v8;
                *(float*)v5 = v9;
                v5[1] = LODWORD(v10[0]);
                sub_401000((float*)v5 - 1, v10[4 * *(_DWORD*)(this + 520) + v4]);
            }
            sub_4074B0((_DWORD*)*(v5 - 3), 0);
            sub_407600((_DWORD*)*(v5 - 3), 0, *(v5 - 1), *v5, v5[1]);
            sub_4074B0((_DWORD*)*(v5 - 2), 0);
            sub_407600((_DWORD*)*(v5 - 2), 0, *(v5 - 1), *v5, v5[1]);
            v5[3] = 0;
            v5[4] = 0;
            v5[5] = 0;
            v5[7] = 0;
            v5[6] = 0;
            v5[8] = 0;
            v5[2] = *(_DWORD*)(this + 424);
            sub_407690(*(v5 - 3), *(_DWORD*)(this + 440), v28);
            sub_4010D0(v5 - 1, (int)v28);
            result = *(_DWORD*)(this + 524);
            ++v4;
            v5 += 13;
        } while (v4 < result);
    }
    return result;
}

//----- (0045EC70) --------------------------------------------------------
int __thiscall sub_45EC70(_DWORD* this)
{
    int result; // eax

    sub_463020(this);
    sub_45EA80((int)this, 1);
    result = 0;
    this[130] = 1;
    this[128] = 0;
    this[129] = 0;
    this[585] = 0;
    this[220] = 0;
    return result;
}

//----- (0045ECB0) --------------------------------------------------------
_DWORD* __thiscall sub_45ECB0(_DWORD* this)
{
    sub_462F90(this);
    return sub_463020(this);
}

//----- (0045ECD0) --------------------------------------------------------
int __thiscall sub_45ECD0(int this)
{
    int result; // eax
    int v3; // eax
    int* v4; // ecx
    int* v5; // edx

    result = dword_4F5CC4;
    if (*(_BYTE*)(dword_4F5CC4 + 936))
    {
        if (*(_DWORD*)(this + 524) != *(_DWORD*)(this + 520))
            sub_45EA80(this, *(_DWORD*)(this + 520));
        v3 = 0;
        v4 = (int*)(this + 2340);
        v5 = (int*)(this + 880);
        do
        {
            if (v3 >= *(_DWORD*)(this + 520))
            {
                *v5 = -1;
                *v4 = -1;
            }
            else
            {
                *v5 = v3;
                *v4 = v3;
            }
            ++v3;
            v4 += 13;
            v5 += 88;
        } while (v3 < 4);
        *(_DWORD*)(this + 512) = 0;
        *(_DWORD*)(this + 516) = *(_DWORD*)(this + 880);
        return sub_463180((_BYTE*)this);
    }
    return result;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (0045ED50) --------------------------------------------------------
void __userpurge sub_45ED50(int a1@<ecx>, int a2@<edi>, _DWORD* a3, _DWORD* a4)
{
    _DWORD* v4; // ebp
    int v6; // eax
    int v7; // esi
    int v8; // eax
    unsigned int v9; // edi
    unsigned int v10; // edx
    int v11; // edx
    int v12; // ecx
    int v13; // [esp+Ch] [ebp-4h] BYREF

    v4 = a3;
    if (a3[73] != 3)
    {
        (*(void(__thiscall**)(_DWORD*, int))(*a3 + 4))(a3, a2);
        v6 = *(_DWORD*)(a1 + 2568);
        if (v6)
            v7 = (*(_DWORD*)(a1 + 2572) - v6) >> 3;
        else
            v7 = 0;
        v8 = *(_DWORD*)(a1 + 2568);
        v9 = v7 + 1;
        if (v8)
            v10 = (*(_DWORD*)(a1 + 2572) - v8) >> 3;
        else
            v10 = 0;
        if (v10 >= v9)
        {
            if (v8)
            {
                if (v9 < (*(_DWORD*)(a1 + 2572) - v8) >> 3)
                    sub_463AF0((_DWORD*)(a1 + 2564), (_DWORD*)(v8 + 8 * v9), *(int**)(a1 + 2572));
                v4 = a4;
            }
        }
        else
        {
            if (v8)
                v11 = (*(_DWORD*)(a1 + 2572) - v8) >> 3;
            else
                v11 = 0;
            sub_4638A0(a1 + 2564, *(char**)(a1 + 2572), v9 - v11, &v13);
        }
        *(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * v7) = v4;
        sub_428680((_DWORD*)a1, *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * v7) + 652));
        v12 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * v7) + 652);
        (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)v12 + 24))(v12, 0);
        *(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * v7 + 4) = 0;
        if (!v7)
            sub_45EE50(a1, 0);
    }
}

//----- (0045EE50) --------------------------------------------------------
int __thiscall sub_45EE50(int this, int a2)
{
    int result; // eax
    unsigned int i; // edi
    int v5; // eax
    int v6; // ecx
    int v7; // eax
    int v8; // edi
    int v9; // ebp
    int v10; // edx

    *(_BYTE*)(this + 2645) = 0;
    result = *(_DWORD*)(this + 2568);
    if (result
        && a2 < (unsigned int)((*(_DWORD*)(this + 2572) - result) >> 3)
        && a2 >= 0
        && (*(_DWORD*)(this + 2572) - result) >> 3)
    {
        *(_DWORD*)(this + 2580) = a2;
        for (i = 0; ; *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 2568) + 8 * i - 8) + 652) + 36) = 0)
        {
            v5 = *(_DWORD*)(this + 2568);
            if (!v5 || i >= (*(_DWORD*)(this + 2572) - v5) >> 3)
                break;
            v6 = *(_DWORD*)(*(_DWORD*)(v5 + 8 * i) + 652);
            v7 = *(_DWORD*)(this + 2580);
            LOBYTE(v7) = i == v7;
            (*(void(__thiscall**)(int, int))(*(_DWORD*)v6 + 24))(v6, v7);
            ++i;
            *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 2568) + 8 * i - 8) + 652) + 32) = 0;
        }
        v8 = this + 2720;
        v9 = 100;
        do
        {
            if (*(_BYTE*)v8)
            {
                sub_409A00(dword_520970, *(void**)(v8 + 84));
                *(_DWORD*)(v8 + 84) = 0;
            }
            *(_BYTE*)v8 = 0;
            v8 += 88;
            --v9;
        } while (v9);
        *(_DWORD*)(this + 2660) = 0;
        *(_DWORD*)(this + 2664) = 0;
        *(_BYTE*)(this + 2668) = 0;
        *(_DWORD*)(this + 2672) = 0;
        memset((void*)(this + 2676), 0, 0x2Cu);
        v10 = *(_DWORD*)(this + 2580);
        *(_BYTE*)(this + 2647) = 0;
        *(_DWORD*)(this + 2648) = 0;
        *(_DWORD*)(this + 2656) = 0;
        *(_DWORD*)(this + 2652) = 0;
        return sub_436A40(
            *(_DWORD*)(dword_520970 + 224),
            *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 2568) + 8 * v10) + 300) - 1);
    }
    return result;
}
// 45EE8B: conditional instruction was optimized away because eax.4!=0
// 520970: using guessed type int dword_520970;

//----- (0045EFA0) --------------------------------------------------------
int __thiscall sub_45EFA0(_DWORD* this)
{
    unsigned int v2; // edi
    int v3; // eax
    int result; // eax

    v2 = this[645];
    while (1)
    {
        v3 = this[642];
        ++v2;
        if (!v3 || v2 >= (this[643] - v3) >> 3)
            v2 = 0;
        result = sub_4629B0((int)this, *(_DWORD*)(*(_DWORD*)(this[642] + 8 * v2) + 296));
        if (result > 0)
            break;
        if (v2 == this[645])
            return result;
    }
    return sub_45EE50((int)this, v2);
}

//----- (0045F000) --------------------------------------------------------
int __thiscall sub_45F000(_DWORD* this)
{
    int v1; // edx
    int v2; // eax
    unsigned int v3; // edx
    int v4; // edx

    v1 = this[642];
    if (v1)
        v2 = (this[643] - v1) >> 3;
    else
        v2 = 0;
    v3 = this[645] + 1;
    if (v3 >= v2 - 1)
    {
        v4 = this[642];
        if (!v4)
            return sub_45EE50((int)this, -1);
        v3 = ((this[643] - v4) >> 3) - 1;
    }
    return sub_45EE50((int)this, v3);
}

//----- (0045F050) --------------------------------------------------------
int __thiscall sub_45F050(_DWORD* this)
{
    int v1; // eax
    int v2; // edx

    v1 = this[645] - 1;
    if (v1 < 0)
    {
        v2 = this[642];
        if (!v2)
            return sub_45EE50((int)this, 0);
        v1 = (this[643] - v2) >> 3;
    }
    return sub_45EE50((int)this, v1);
}

//----- (0045F080) --------------------------------------------------------
int __thiscall sub_45F080(_DWORD* this)
{
    int v2; // eax
    int v3; // ebp
    int i; // edi
    int v5; // ecx
    int v6; // ecx
    int result; // eax
    _DWORD* v8; // edi
    int v9; // ebp

    v2 = this[642];
    if (v2)
        v3 = (this[643] - v2) >> 3;
    else
        v3 = 0;
    for (i = 0; i < v3; ++i)
    {
        sub_4286C0(this, *(_DWORD*)(*(_DWORD*)(this[642] + 8 * i) + 652));
        v5 = *(_DWORD*)(*(_DWORD*)(this[642] + 8 * i) + 652);
        (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)v5 + 24))(v5, 0);
        v6 = *(_DWORD*)(this[642] + 8 * i);
        (*(void(__thiscall**)(int))(*(_DWORD*)v6 + 8))(v6);
    }
    result = this[643];
    this[643] = this[642];
    v8 = this + 680;
    v9 = 100;
    do
    {
        if (*(_BYTE*)v8)
        {
            result = sub_409A00(dword_520970, (void*)v8[21]);
            v8[21] = 0;
        }
        *(_BYTE*)v8 = 0;
        v8 += 22;
        --v9;
    } while (v9);
    this[645] = 0;
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (0045F160) --------------------------------------------------------
void __thiscall sub_45F160(float* this, float* a2)
{
    int v3; // eax
    int v4; // ecx
    int v5; // ebx
    float* v6; // edx
    int v7; // edi
    int v8; // edx
    int v9; // eax
    int v10; // edi
    int v11; // eax
    int v12; // edx
    float* v13; // eax

    v3 = *((_DWORD*)this + 131);
    if (v3)
    {
        if (v3 == 1)
        {
            *a2 = this[588];
            a2[1] = this[589];
            a2[2] = this[590];
        }
        else
        {
            v4 = *((_DWORD*)this + 130);
            v5 = 0;
            if (v4 <= 0)
                goto LABEL_11;
            v6 = this + 231;
            v7 = *((_DWORD*)this + 130);
            do
            {
                if (*v6 > 0.0)
                    ++v5;
                v6 += 88;
                --v7;
            } while (v7);
            if (v5)
            {
                do
                {
                    v10 = 10 * v4 - 1;
                    v11 = rand();
                    v4 = *((_DWORD*)this + 130);
                    v12 = v11 % (v10 + 1) / 10;
                    if (v12 >= v4)
                        v12 = 0;
                } while (this[88 * v12 + 231] <= 0.0);
                v13 = &this[13 * LODWORD(this[88 * v12 + 220]) + 588];
                *a2 = *v13;
                a2[1] = v13[1];
                a2[2] = v13[2];
            }
            else
            {
            LABEL_11:
                v8 = rand() % (10 * v4) / 10;
                if (v8 >= *((_DWORD*)this + 130))
                    v8 = 0;
                v9 = 13 * LODWORD(this[88 * v8 + 220]);
                *a2 = this[13 * LODWORD(this[88 * v8 + 220]) + 588];
                a2[1] = this[v9 + 589];
                a2[2] = this[v9 + 590];
            }
        }
    }
    else
    {
        *a2 = 0.0;
        a2[1] = 0.0;
        a2[2] = sub_468BE0((int*)*(_DWORD*)(dword_520970 + 260), 0, 0, 0) + 72.0;
    }
}
// 520970: using guessed type int dword_520970;

//----- (0045F2E0) --------------------------------------------------------
float* __thiscall sub_45F2E0(float* this, int a2, int a3, int a4, int a5, float a6)
{
    float* result; // eax

    result = &this[7 * a2];
    *((_DWORD*)result + 2880) = a3;
    if (a3)
    {
        *((_DWORD*)result + 2881) = a4;
        result[2882] = 0.0;
        *((_DWORD*)result + 2883) = a5;
        this[7 * a2 + 2884] = a6;
        result[2885] = 0.0;
        result[2886] = 0.0;
    }
    return result;
}

//----- (0045F350) --------------------------------------------------------
_DWORD* __thiscall sub_45F350(_DWORD* this, int a2, char a3)
{
    _DWORD* result; // eax

    if (!a3)
        ++this[7 * a2 + 2881];
    result = &this[7 * a2 + 2882];
    --*result;
    return result;
}

//----- (0045F3A0) --------------------------------------------------------
int __thiscall sub_45F3A0(char* this, int a2, bool* a3, bool* a4, _DWORD* a5)
{
    char* v5; // edx
    int v6; // eax
    bool v7; // cc
    bool v8; // al
    bool v9; // al
    __int64 v10; // rax

    v5 = &this[28 * a2];
    if (!*((_DWORD*)v5 + 2880))
        goto LABEL_19;
    v6 = *((_DWORD*)v5 + 2881);
    v7 = v6 <= 0;
    if (!v6)
    {
        if (*((_DWORD*)v5 + 2882))
        {
            v7 = 1;
            goto LABEL_5;
        }
    LABEL_19:
        LODWORD(v10) = a4;
        *a4 = 0;
        *a3 = 0;
        *a5 = 0;
        return v10;
    }
LABEL_5:
    v8 = !v7 && *((float*)v5 + 2885) <= 0.0;
    *a3 = v8;
    v9 = *((_DWORD*)v5 + 2882) > 0;
    *a4 = v9;
    if (!*a3 && !v9)
        *a5 = *((_DWORD*)v5 + 2885);
    v10 = (unsigned int)(this + 11528);
    while (!*(_DWORD*)(v10 - 8) || *(int*)v10 <= 0)
    {
        ++HIDWORD(v10);
        LODWORD(v10) = v10 + 28;
        if (SHIDWORD(v10) >= 3)
            return v10;
    }
    if (*a3)
    {
        *a3 = 0;
        *a4 = 1;
    }
    return v10;
}

//----- (0045F480) --------------------------------------------------------
double __thiscall sub_45F480(int this)
{
    if (*(_DWORD*)(this + 11520))
        return *(float*)(this + 11544);
    else
        return 0.0;
}

//----- (0045F4A0) --------------------------------------------------------
double __thiscall sub_45F4A0(_DWORD* this)
{
    int v1; // eax
    int v2; // edx
    int v4; // edx
    int v5; // edx
    unsigned int v6; // eax
    unsigned int v7; // edx

    v1 = this[659];
    if (!v1)
        goto LABEL_8;
    v2 = *(_DWORD*)(v1 + 844);
    if (v2 && *(_BYTE*)(v2 + 32))
        return *(float*)(v1 + 308);
    v4 = *(_DWORD*)(v1 + 848);
    if (v4)
    {
        if (*(_BYTE*)(v4 + 16))
            return *(float*)(v1 + 308);
    }
LABEL_8:
    v5 = this[642];
    if (v5)
        v6 = (this[643] - v5) >> 3;
    else
        v6 = 0;
    v7 = this[645];
    if (v7 < v6)
        return *(float*)(*(_DWORD*)(this[642] + 8 * v7) + 308);
    else
        return 0.0;
}

//----- (0045F520) --------------------------------------------------------
double __thiscall sub_45F520(int this)
{
    int v1; // eax
    int v2; // esi
    char v3; // dl
    double v4; // st7
    double v5; // st6
    int v6; // edx
    unsigned int v7; // eax
    unsigned int v8; // edx
    int v9; // eax

    v1 = *(_DWORD*)(this + 2636);
    v2 = *(_DWORD*)(v1 + 844);
    if (v2)
        v3 = *(_BYTE*)(v2 + 32);
    else
        v3 = *(_BYTE*)(*(_DWORD*)(v1 + 848) + 16);
    if (v1 && v3)
    {
        v4 = *(float*)(v1 + 308);
        v5 = *(float*)(this + 2640);
    }
    else
    {
        v6 = *(_DWORD*)(this + 2568);
        if (v6)
            v7 = (*(_DWORD*)(this + 2572) - v6) >> 3;
        else
            v7 = 0;
        v8 = *(_DWORD*)(this + 2580);
        if (v8 >= v7)
            return 1.0;
        v9 = *(_DWORD*)(this + 2568);
        v4 = *(float*)(*(_DWORD*)(v9 + 8 * v8) + 308);
        v5 = *(float*)(v9 + 8 * v8 + 4);
    }
    if (v4 == 0.0)
        return 0.0;
    else
        return v5 / v4;
}

//----- (0045F5C0) --------------------------------------------------------
char __thiscall sub_45F5C0(int this, int a2, int a3)
{
    bool v4; // zf

    if (a2 == 2)
    {
        if ((_BYTE)a3)
        {
            if (*(_DWORD*)(this + 2636))
            {
                *(_BYTE*)(this + 2644) = 1;
                return sub_4285F0((_DWORD*)this, 2, a3);
            }
        }
        else
        {
            v4 = *(_BYTE*)(this + 2645) == 0;
            *(_BYTE*)(this + 2644) = 0;
            if (!v4)
            {
                *(_BYTE*)(this + 2646) = 1;
                *(_BYTE*)(this + 2645) = 0;
            }
        }
    }
    return sub_4285F0((_DWORD*)this, a2, a3);
}

//----- (0045F620) --------------------------------------------------------
void __thiscall sub_45F620(int this, int a2, char a3)
{
    char v4; // al
    char v5; // dl
    int v6; // ecx
    int* v7; // eax
    char* v8; // eax
    int v9; // eax
    char* v10; // eax
    int v11; // eax
    char* v12; // eax
    float v13; // [esp+0h] [ebp-20h]
    float v14; // [esp+0h] [ebp-20h]
    float v15; // [esp+14h] [ebp-Ch] BYREF
    int v16; // [esp+18h] [ebp-8h]
    int v17; // [esp+1Ch] [ebp-4h]

    if (*(_BYTE*)(dword_520970 + 296) || sub_408F30((_DWORD*)dword_520970) != this)
        return;
    if (a2 == 59)
    {
        sub_4261C0(*(_DWORD**)(dword_520970 + 232), aHelpscreen, 0);
        return;
    }
    if (a2 == 34)
    {
        if (!a3)
        {
            v4 = *(_BYTE*)(this + 2645);
            *(_BYTE*)(this + 2644) = 0;
            if (v4)
            {
                *(_BYTE*)(this + 2646) = 1;
                *(_BYTE*)(this + 2645) = 0;
            }
            return;
        }
        *(_BYTE*)(this + 2644) = 1;
    }
    if (a3)
    {
        switch (a2)
        {
        case 15:
            sub_45EFA0((_DWORD*)this);
            break;
        case 2:
            sub_45EE50(this, 0);
            break;
        case 3:
            sub_45EE50(this, 1);
            break;
        case 4:
            sub_45EE50(this, 2);
            break;
        case 5:
            sub_45EE50(this, 3);
            break;
        case 6:
            sub_45EE50(this, 4);
            break;
        case 7:
            sub_45EE50(this, 5);
            break;
        case 26:
            sub_45F050((_DWORD*)this);
            break;
        case 27:
            sub_45F000((_DWORD*)this);
            break;
        }
        v5 = 0;
        v6 = 0;
        v7 = (int*)(this + 11528);
        while (!*(v7 - 2) || *v7 <= 0)
        {
            ++v6;
            v7 += 7;
            if (v6 >= 3)
                goto LABEL_35;
        }
        v5 = 1;
    LABEL_35:
        if (!*(_BYTE*)(dword_4F5CC4 + 936) && !*(_BYTE*)(dword_4F5CC4 + 937) && !v5)
        {
            if (*(_DWORD*)(this + 11520) && (a2 == 16 || a2 == 30) && *(float*)(this + 11540) <= 0.0)
            {
                sub_42F620(*(_DWORD**)(dword_520970 + 208), *(_DWORD*)(this + 11524), *(_DWORD*)(this + 11520));
                *(_DWORD*)(this + 11528) = *(_DWORD*)(this + 11524);
                *(_DWORD*)(this + 11524) = 0;
                *(_DWORD*)(this + 11540) = *(_DWORD*)(this + 11532);
                *(_DWORD*)(this + 11544) = *(_DWORD*)(this + 11536);
                v8 = sub_403620((_DWORD*)dword_4B5AB0, aSpecialAttack);
                sub_4030B0(v8, 0, aAirstrikefight, -1);
            }
            else if (*(_DWORD*)(this + 11548) && (a2 == 17 || a2 == 20) && *(float*)(this + 11568) <= 0.0)
            {
                v9 = *(_DWORD*)(this + 516);
                v15 = 0.0;
                v16 = 1065353216;
                v17 = 0;
                v13 = *(float*)(this + 52 * v9 + 2368) * 0.017453292;
                sub_401000(&v15, v13);
                sub_42EF80(*(_DWORD**)(dword_520970 + 208), *(_DWORD*)(this + 11552), *(_DWORD*)(this + 11548), &v15);
                *(_DWORD*)(this + 11556) = *(_DWORD*)(this + 11552);
                *(_DWORD*)(this + 11552) = 0;
                *(_DWORD*)(this + 11568) = *(_DWORD*)(this + 11560);
                v10 = sub_403620((_DWORD*)dword_4B5AB0, aSpecialAttack);
                sub_4030B0(v10, 0, aAirstriketorpe, -1);
            }
            else if (*(_DWORD*)(this + 11576) && (a2 == 18 || a2 == 48) && *(float*)(this + 11596) <= 0.0)
            {
                v11 = *(_DWORD*)(this + 516);
                v15 = 0.0;
                v16 = 1065353216;
                v17 = 0;
                v14 = *(float*)(this + 52 * v11 + 2368) * 0.017453292;
                sub_401000(&v15, v14);
                sub_42E480(*(_DWORD**)(dword_520970 + 208), *(_DWORD*)(this + 11580), *(_DWORD*)(this + 11576), &v15);
                *(_DWORD*)(this + 11584) = *(_DWORD*)(this + 11580);
                *(_DWORD*)(this + 11580) = 0;
                *(_DWORD*)(this + 11596) = *(_DWORD*)(this + 11588);
                v12 = sub_403620((_DWORD*)dword_4B5AB0, aSpecialAttack);
                sub_4030B0(v12, 0, aAirstrikebombe, -1);
            }
        }
    }
}
// 4B5AB0: using guessed type int dword_4B5AB0;
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (0045F9E0) --------------------------------------------------------
char __userpurge sub_45F9E0@<al>(int a1@<ecx>, int a2@<edi>, int a3)
{
    double v4; // st7
    double v5; // st7
    int v7; // eax
    int v8; // ecx
    int v9; // eax
    bool v10; // zf
    int v11; // eax
    int v12; // eax
    int v13; // ecx
    int v14; // ecx
    int v15; // eax
    double v16; // st7
    double v17; // st7
    float* v18; // ecx
    int v19; // edx
    bool v20; // zf
    bool v21; // cc
    double v22; // st7
    double v23; // st7
    char v24; // al
    void** v25; // ecx
    float* v26; // eax
    double v27; // st7
    int* v28; // ecx
    float* v29; // eax
    int* v30; // eax
    void** v31; // ecx
    int v32; // edi
    int v33; // ebp
    double v34; // st7
    double v35; // st7
    int v36; // ecx
    int v37; // edx
    double v38; // st7
    bool v39; // al
    BOOL v40; // eax
    int v41; // ecx
    int v42; // eax
    float v43; // edx
    float* v44; // edi
    long double v45; // st7
    long double v46; // st7
    int v47; // eax
    double v48; // st7
    double v49; // st6
    int v50; // eax
    bool v51; // dl
    int v52; // eax
    int v53; // eax
    int* v54; // eax
    int v55; // ebp
    int v56; // ebx
    double v57; // st7
    float* v58; // edi
    double v59; // st7
    double v60; // st7
    long double v61; // st7
    double v62; // st7
    long double v63; // st7
    double v64; // st7
    long double v65; // st7
    double v66; // st7
    double v67; // st7
    double v68; // st7
    int v69; // ecx
    unsigned int i; // edi
    int v71; // eax
    int v72; // ecx
    double v73; // st7
    float* v74; // eax
    int v75; // eax
    int v76; // ecx
    char v77; // bl
    int v78; // edx
    int v79; // ecx
    int* v80; // eax
    int v81; // ecx
    int v82; // eax
    int v83; // eax
    int v84; // eax
    double v85; // st7
    double v86; // st6
    double v87; // st7
    int v88; // edx
    int v89; // ecx
    int v90; // edi
    int v91; // eax
    double v92; // st7
    int v93; // ebx
    int v94; // edi
    float* v95; // ebp
    int v96; // eax
    int v97; // ecx
    int v98; // eax
    int v99; // ecx
    int v100; // edx
    int v101; // ecx
    int v102; // ecx
    int v103; // eax
    int v104; // eax
    int v105; // edi
    int v106; // ebp
    int v107; // eax
    int v108; // ecx
    int v109; // ecx
    int v110; // edx
    int* v111; // eax
    int v112; // ecx
    double v113; // st7
    int v114; // eax
    int v115; // eax
    int v116; // ecx
    double v117; // st7
    int v118; // eax
    int v119; // eax
    int v120; // ecx
    double v121; // st7
    int v122; // eax
    int v123; // ecx
    int v124; // ebx
    int v125; // eax
    int v126; // ecx
    int v127; // edx
    int v128; // ecx
    int v129; // edx
    int v130; // edx
    int v131; // eax
    int v132; // ecx
    long double v133; // st7
    long double v134; // st7
    int v135; // edx
    int v136; // ecx
    long double v137; // st7
    long double v138; // st7
    int v139; // ecx
    double v140; // st7
    double v141; // st7
    double v142; // st7
    char v143; // al
    int v144; // eax
    int v145; // ecx
    int v146; // ecx
    float* v147; // ecx
    double v148; // st7
    double v149; // st7
    int v150; // eax
    double v151; // st7
    int v152; // eax
    double v153; // st7
    int v154; // ecx
    float* v155; // eax
    int v156; // ecx
    int* v157; // ecx
    long double v158; // st7
    char* v159; // edi
    float* v160; // eax
    int v161; // eax
    int v162; // edi
    _BYTE* v163; // ebp
    int v164; // ebp
    float* v165; // edi
    int v166; // eax
    _DWORD* v167; // ecx
    int v168; // eax
    int v169; // edx
    int v170; // ecx
    double v171; // st7
    int v172; // ecx
    int v173; // eax
    double v174; // st7
    int v175; // ecx
    int v176; // edi
    int v177; // eax
    double v178; // st7
    double v179; // st6
    float ArgList_4; // [esp+4h] [ebp-344h]
    float v181; // [esp+14h] [ebp-334h]
    float v182; // [esp+14h] [ebp-334h]
    float v183; // [esp+14h] [ebp-334h]
    float v184; // [esp+14h] [ebp-334h]
    float v185; // [esp+14h] [ebp-334h]
    float v186; // [esp+14h] [ebp-334h]
    float v187; // [esp+14h] [ebp-334h]
    float v188; // [esp+18h] [ebp-330h]
    float v190; // [esp+1Ch] [ebp-32Ch]
    char v191; // [esp+2Bh] [ebp-31Dh]
    char v192; // [esp+2Bh] [ebp-31Dh]
    float v193; // [esp+2Ch] [ebp-31Ch]
    float v194; // [esp+2Ch] [ebp-31Ch]
    float v195; // [esp+2Ch] [ebp-31Ch]
    float v196; // [esp+2Ch] [ebp-31Ch]
    float v197; // [esp+2Ch] [ebp-31Ch]
    float v198; // [esp+2Ch] [ebp-31Ch]
    float v199; // [esp+2Ch] [ebp-31Ch]
    float v200; // [esp+30h] [ebp-318h]
    float v201; // [esp+30h] [ebp-318h]
    float v202; // [esp+30h] [ebp-318h]
    float v203; // [esp+30h] [ebp-318h]
    float v204; // [esp+30h] [ebp-318h]
    float v205; // [esp+30h] [ebp-318h]
    float v206; // [esp+34h] [ebp-314h]
    float v207; // [esp+34h] [ebp-314h]
    float v208; // [esp+34h] [ebp-314h]
    float v209; // [esp+34h] [ebp-314h]
    float v210; // [esp+34h] [ebp-314h]
    int v211; // [esp+34h] [ebp-314h]
    int v212; // [esp+34h] [ebp-314h]
    float v213; // [esp+34h] [ebp-314h]
    float v214; // [esp+34h] [ebp-314h]
    float v215; // [esp+34h] [ebp-314h]
    float v216; // [esp+34h] [ebp-314h]
    float v217; // [esp+34h] [ebp-314h]
    float v218; // [esp+38h] [ebp-310h]
    float v219; // [esp+38h] [ebp-310h]
    float v220; // [esp+38h] [ebp-310h]
    float v221; // [esp+38h] [ebp-310h]
    int v222; // [esp+3Ch] [ebp-30Ch]
    float v223; // [esp+3Ch] [ebp-30Ch]
    int v224; // [esp+3Ch] [ebp-30Ch]
    int v225; // [esp+3Ch] [ebp-30Ch]
    bool v226; // [esp+43h] [ebp-305h]
    int v227; // [esp+44h] [ebp-304h] BYREF
    float v228; // [esp+48h] [ebp-300h]
    float v229; // [esp+4Ch] [ebp-2FCh]
    float v230; // [esp+50h] [ebp-2F8h]
    float v231; // [esp+54h] [ebp-2F4h]
    float v232; // [esp+58h] [ebp-2F0h]
    float v233; // [esp+5Ch] [ebp-2ECh]
    int v234; // [esp+60h] [ebp-2E8h] BYREF
    float v235; // [esp+64h] [ebp-2E4h]
    float v236; // [esp+68h] [ebp-2E0h]
    float v237; // [esp+6Ch] [ebp-2DCh] BYREF
    int v238; // [esp+70h] [ebp-2D8h]
    int v239; // [esp+74h] [ebp-2D4h]
    float v240; // [esp+78h] [ebp-2D0h]
    int v241; // [esp+7Ch] [ebp-2CCh] BYREF
    float v242; // [esp+80h] [ebp-2C8h]
    float v243; // [esp+84h] [ebp-2C4h]
    int v244[16]; // [esp+88h] [ebp-2C0h] BYREF
    _BYTE v245[16]; // [esp+C8h] [ebp-280h] BYREF
    int v246; // [esp+D8h] [ebp-270h]
    int v247; // [esp+DCh] [ebp-26Ch]
    int v248; // [esp+E0h] [ebp-268h]
    int v249; // [esp+E8h] [ebp-260h]
    int v250; // [esp+ECh] [ebp-25Ch]
    int v251; // [esp+F0h] [ebp-258h]
    float v252; // [esp+F8h] [ebp-250h]
    float v253; // [esp+FCh] [ebp-24Ch]
    float v254[2]; // [esp+100h] [ebp-248h]
    int v255[16]; // [esp+108h] [ebp-240h] BYREF
    int v256[16]; // [esp+148h] [ebp-200h] BYREF
    _BYTE v257[64]; // [esp+188h] [ebp-1C0h] BYREF
    int v258[16]; // [esp+1C8h] [ebp-180h] BYREF
    int v259[16]; // [esp+208h] [ebp-140h] BYREF
    int v260[16]; // [esp+248h] [ebp-100h] BYREF
    int v261[16]; // [esp+288h] [ebp-C0h] BYREF
    _BYTE v262[64]; // [esp+2C8h] [ebp-80h] BYREF
    int v263[16]; // [esp+308h] [ebp-40h] BYREF

    sub_401450((_DWORD*)a1);
    if (*(int*)(a1 + 516) < 0)
    {
        v4 = *(float*)(dword_520970 + 68) * 4.0 + *(float*)(a1 + 2556);
        *(float*)(a1 + 2556) = v4;
        if (v4 > 360.0)
        {
            do
            {
                v5 = *(float*)(a1 + 2556) - 360.0;
                *(float*)(a1 + 2556) = v5;
            } while (v5 > 360.0);
        }
        v188 = *(float*)(a1 + 2556) * 0.017453292;
        sub_4014C0((float*)a1, 0.0, v188, 0.0);
        v190 = sub_468BE0((int*)*(_DWORD*)(dword_520970 + 260), 0, 0, 0) + 72.0;
        sub_401480((float*)a1, 0.0, 0.0, v190);
        return sub_428620((_DWORD*)a1, a3);
    }
    if (!sub_408F30((_DWORD*)dword_520970))
        sub_408EF0(dword_520970, a1);
    if (*(_BYTE*)(dword_520970 + 296)
        || (v7 = *(_DWORD*)(a1 + 512), v7 < 0)
        || (v191 = 0, *(float*)(352 * v7 + a1 + 924) == 0.0))
    {
        v191 = 1;
    }
    v8 = *(_DWORD*)(a1 + 2568);
    if (v8)
        v9 = (*(_DWORD*)(a1 + 2572) - v8) >> 3;
    else
        v9 = 0;
    v10 = v9 == 0;
    v11 = *(_DWORD*)(a1 + 516);
    v226 = !v10;
    v240 = 0.0;
    *(float*)&v222 = 0.0;
    if (v11 > -1)
    {
        v12 = 13 * v11;
        v240 = *(float*)(a1 + 4 * v12 + 2368);
        v222 = *(int*)(a1 + 4 * v12 + 2372);
    }
    if (*(_BYTE*)(a1 + 2644))
    {
        if (!v10 && !v191)
        {
            v13 = *(_DWORD*)(a1 + 2636);
            if (v13)
            {
                if (*(float*)(a1 + 2640) <= 0.0 && sub_4629B0(a1, *(_DWORD*)(v13 + 296)))
                {
                    *(_BYTE*)(a1 + 2645) = 1;
                    *(_BYTE*)(a1 + 2644) = 0;
                }
            }
        }
    }
    v14 = *(_DWORD*)(a1 + 512);
    if (v14 > -1)
    {
        v15 = *(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 76);
        if (v15)
            v16 = *(float*)(v15 + 256);
        else
            v16 = 100.0;
        if (v16 == 0.0)
            v17 = 0.0;
        else
            v17 = *(float*)(352 * v14 + a1 + 924) / v16;
        *(float*)(352 * v14 + a1 + 928) = v17;
    }
    v18 = (float*)(a1 + 11540);
    v19 = 3;
    do
    {
        if (!*((_DWORD*)v18 - 5))
            goto LABEL_51;
        if (*((int*)v18 - 4) <= 0)
            goto LABEL_40;
        v20 = *((_DWORD*)v18 - 3) == 0;
        v21 = *((_DWORD*)v18 - 3) <= 0;
        if (!*((_DWORD*)v18 - 3))
        {
            if (*v18 > 0.0)
            {
                v230 = *v18 - *(float*)&a3;
                *v18 = v230;
                if (v230 >= 0.0)
                    v22 = v230;
                else
                    v22 = 0.0;
                *v18 = v22;
            }
        LABEL_40:
            v20 = *((_DWORD*)v18 - 3) == 0;
            v21 = *((_DWORD*)v18 - 3) <= 0;
        }
        if (!v21)
        {
            if (v18[1] > 0.0)
            {
                v230 = v18[1] - *(float*)&a3;
                v18[1] = v230;
                if (v230 >= 0.0)
                    v23 = v230;
                else
                    v23 = 0.0;
                v18[1] = v23;
            }
            v20 = *((_DWORD*)v18 - 3) == 0;
        }
        if (v20 && v18[1] > 0.0)
            v18[1] = 0.0;
    LABEL_51:
        v18 += 7;
        --v19;
    } while (v19);
    if (dword_5216FC && *(int*)(a1 + 516) > -1)
    {
        *(float*)&v227 = 0.0;
        v24 = *(_BYTE*)(dword_520970 + 296);
        v228 = 0.0;
        v229 = 0.0;
        v200 = *(float*)&a3 * 15.0;
        if (!v24 && a1 == sub_408F30((_DWORD*)dword_520970))
        {
            if (sub_408F40(17))
                v228 = *(float*)&a3 * 15.0;
            if (sub_408F40(31))
                v228 = v228 - v200;
            if (sub_408F40(30))
                *(float*)&v227 = -v200;
            if (sub_408F40(32))
                *(float*)&v227 = *(float*)&v227 + v200;
            if (sub_408F40(19))
                v229 = *(float*)&a3 * 15.0;
            if (sub_408F40(33))
                v229 = v229 - v200;
        }
        v25 = (void**)dword_5216FC;
        *(_BYTE*)(dword_5216FC + 33) = 1;
        sub_421540(v25);
        if (*(_BYTE*)(a1 + 2645))
        {
            v26 = *(float**)(a1 + 2636);
            v27 = *(float*)&v227 + v26[90];
            v26 += 90;
            *v26 = v27;
            v26[1] = v228 + v26[1];
            v26[2] = v229 + v26[2];
            v28 = (int*)(*(_DWORD*)(a1 + 2636) + 360);
            v227 = *v28;
            v228 = *((float*)v28 + 1);
            v229 = *((float*)v28 + 2);
        }
        else if (v226)
        {
            v29 = (float*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580)) + 360);
            *v29 = *(float*)&v227 + *v29;
            v29[1] = v228 + v29[1];
            v29[2] = v229 + v29[2];
            v30 = (int*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580)) + 360);
            v227 = *v30;
            v228 = *((float*)v30 + 1);
            v229 = *((float*)v30 + 2);
        }
        else
        {
            v31 = (void**)dword_5216FC;
            *(_BYTE*)(dword_5216FC + 33) = 0;
            sub_421540(v31);
        }
        sub_421190(
            dword_5216FC,
            "gunOffset = (%f, %f, %f)\npitch = %f",
            *(float*)&v227,
            v228,
            v229,
            *(float*)(a1 + 52 * *(_DWORD*)(a1 + 516) + 2372));
    }
    v32 = a1 + 2720;
    v33 = 100;
    do
    {
        if (*(_BYTE*)v32)
        {
            v34 = *(float*)(v32 + 80) - *(float*)&a3;
            *(float*)(v32 + 80) = v34;
            if (v34 > 0.0)
            {
                *(_DWORD*)(*(_DWORD*)(v32 + 84) + 40) = v32;
                v35 = *(float*)(v32 + 60);
                *(float*)(v32 + 76) = *(float*)(v32 + 76) - *(float*)&a3 * 300.0;
                *(float*)(v32 + 52) = *(float*)&a3 * *(float*)(v32 + 68) + *(float*)(v32 + 52);
                *(float*)(v32 + 56) = *(float*)&a3 * *(float*)(v32 + 72) + *(float*)(v32 + 56);
                v232 = *(float*)&a3 * *(float*)(v32 + 76) + *(float*)(v32 + 60);
                *(float*)(v32 + 60) = v232;
                if (v35 > *(float*)(a1 + 428) && v232 < (double)*(float*)(a1 + 428))
                {
                    v36 = *(_DWORD*)(a1 + 2580);
                    v37 = *(_DWORD*)(a1 + 2568);
                    v237 = 0.0;
                    v238 = 0;
                    v239 = 0;
                    sub_44DAD0(*(int**)(*(_DWORD*)(v37 + 8 * v36) + 376), &v237, 0, 0);
                }
                v38 = *(float*)&a3 * 4.712389;
                v201 = v38;
                v232 = -v38;
                v233 = v232;
                if (v201 == v232)
                    v230 = v233;
                else
                    v230 = fabs((double)rand() * 0.000030518509) * (v201 - v233) + v233;
                if (v232 == v201)
                    v231 = v232;
                else
                    v231 = fabs((double)rand() * 0.000030518509) * (v201 - v232) + v232;
                if (v232 == v201)
                {
                    sub_46C69B((float*)v255, v232, v231, v230);
                }
                else
                {
                    v206 = fabs((double)rand() * 0.000030518509) * (v201 - v232) + v232;
                    sub_46C69B((float*)v255, v206, v231, v230);
                }
                sub_46B97C((_BYTE*)(v32 + 4), v255, (_BYTE*)(v32 + 4));
            }
            else
            {
                sub_409A00(dword_520970, *(void**)(v32 + 84));
                *(_DWORD*)(v32 + 84) = 0;
                *(_BYTE*)v32 = 0;
            }
        }
        v32 += 88;
        --v33;
    } while (v33);
    v39 = !v191 && sub_408F60(1);
    *(_BYTE*)(a1 + 2584) = v39;
    if (v226)
    {
        v40 = sub_408F30((_DWORD*)dword_520970) == a1 && !*(_BYTE*)(a1 + 2584);
        v41 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580)) + 652);
        (*(void(__thiscall**)(int, BOOL))(*(_DWORD*)v41 + 24))(v41, v40);
    }
    if (*(_BYTE*)(a1 + 2584))
    {
        *(_DWORD*)(a1 + 20) = 1123024896;
    }
    else if (*(float*)&dword_4A4DB4 > 0.0)
    {
        *(float*)(a1 + 20) = *(float*)&dword_4A4DB4;
    }
    v233 = 0.0;
    v230 = 0.0;
    v193 = 0.0;
    if (!v191)
    {
        v233 = sub_408F80((float*)dword_520970, 0);
        v230 = sub_408F80((float*)dword_520970, 1);
        v193 = sub_408F80((float*)dword_520970, 2);
    }
    if (*(_BYTE*)(a1 + 2584))
    {
        v218 = 0.050000001;
        v232 = 0.050000001;
    }
    else if (*(_BYTE*)(a1 + 2645) && v193 == 0.0)
    {
        v42 = *(_DWORD*)(a1 + 2636);
        v43 = *(float*)(v42 + 332);
        v232 = *(float*)(v42 + 312);
        v218 = v43;
    }
    else if (v226)
    {
        v44 = *(float**)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580));
        v45 = (fabs(v233) - v44[80]) / (v44[81] - v44[80]);
        v219 = v45;
        if (v45 > 0.0)
        {
            if (v219 >= 1.0)
                v219 = 1.0;
        }
        else
        {
            v219 = 0.0;
        }
        v232 = pow(v219, v44[82]) * (v44[79] - v44[78]) + v44[78];
        v46 = (fabs(v230) - v44[85]) / (v44[86] - v44[85]);
        v220 = v46;
        if (v46 > 0.0)
        {
            if (v220 >= 1.0)
                v220 = 1.0;
        }
        else
        {
            v220 = 0.0;
        }
        v218 = pow(v220, v44[87]) * (v44[84] - v44[83]) + v44[83];
        if (v193 <= 0.0)
        {
            if (v193 < 0.0)
                sub_45F050((_DWORD*)a1);
        }
        else
        {
            sub_45F000((_DWORD*)a1);
        }
    }
    else
    {
        v218 = 0.25;
        v232 = 0.25;
    }
    v47 = *(_DWORD*)(a1 + 516);
    if (v47 > -1)
    {
        v48 = -30.0;
        v202 = 80.0;
        *(float*)(a1 + 52 * v47 + 2368) = *(float*)(a1 + 52 * v47 + 2368) - v232 * v233;
        if (byte_520884)
            v49 = 1.0;
        else
            v49 = -1.0;
        *(float*)(a1 + 52 * *(_DWORD*)(a1 + 516) + 2372) = v49 * v218 * v230
            + *(float*)(a1 + 52 * *(_DWORD*)(a1 + 516) + 2372);
        if (*(_BYTE*)(a1 + 2645))
        {
            v50 = *(_DWORD*)(a1 + 2636);
            v51 = v226;
            v48 = *(float*)(v50 + 352);
            v202 = *(float*)(v50 + 356);
        }
        else
        {
            v51 = v226;
            if (v226 && !*(_BYTE*)(a1 + 2584))
            {
                v52 = *(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580));
                v48 = *(float*)(v52 + 352);
                v202 = *(float*)(v52 + 356);
            }
        }
        if (v48 > *(float*)(a1 + 52 * *(_DWORD*)(a1 + 516) + 2372))
            *(float*)(a1 + 52 * *(_DWORD*)(a1 + 516) + 2372) = v48;
        if (*(float*)(a1 + 52 * *(_DWORD*)(a1 + 516) + 2372) > (double)v202)
            *(float*)(a1 + 52 * *(_DWORD*)(a1 + 516) + 2372) = v202;
        if (!v51
            || *(_BYTE*)(a1 + 2645)
            || *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580)) + 292))
        {
            *(_DWORD*)(a1 + 2652) = 0;
            *(_DWORD*)(a1 + 2656) = 0;
        }
        v53 = a1 + 52 * *(_DWORD*)(a1 + 516);
        v207 = *(float*)(v53 + 2368) + *(float*)(a1 + 2652);
        v221 = *(float*)(v53 + 2372) + *(float*)(a1 + 2656);
        if (v51
            && !*(_BYTE*)(a1 + 2584)
            && !*(_BYTE*)(a1 + 2645)
            && *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580)) + 292) == 2)
        {
            v221 = 0.0;
        }
        v54 = (int*)(v53 + 2352);
        v55 = *v54;
        v56 = v54[1];
        v238 = v56;
        v239 = v54[2];
        sub_46BE02((int)v262, v55, v56, v239);
        v233 = v207 * 0.017453292;
        sub_46BF69((float*)v260, v233);
        v232 = v221 * 0.017453292;
        sub_46BE62((float*)v263, v232);
        sub_46B97C(v245, v263, v260);
        sub_46B97C(v245, v245, v262);
        sub_401450((_DWORD*)a1);
        v57 = *(float*)(a1 + 2600);
        v58 = (float*)(a1 + 2604);
        *(float*)&v234 = 0.0;
        v235 = 0.0;
        *(_DWORD*)(a1 + 2604) = 0;
        v236 = 0.0;
        *(_DWORD*)(a1 + 2608) = 0;
        *(_DWORD*)(a1 + 2612) = 0;
        if (v57 > 0.0)
        {
            v59 = *(float*)(a1 + 2600) - *(float*)&a3;
            *(float*)&v234 = 1.0;
            v235 = 1.0;
            v236 = 1.0;
            *(float*)(a1 + 2600) = v59;
            *(_DWORD*)(a1 + 2616) = 1065353216;
            *(float*)(a1 + 2620) = v235;
            *(float*)(a1 + 2624) = v236;
            v60 = -*(float*)(a1 + 2616);
            v194 = v60;
            v208 = *(float*)(a1 + 2616);
            if (v60 == v208)
            {
                v61 = v194;
            }
            else
            {
                v231 = COERCE_FLOAT(rand());
                v61 = fabs((double)SLODWORD(v231) * 0.000030518509) * (v208 - v194) + v194;
            }
            *v58 = v61;
            v62 = -*(float*)(a1 + 2620);
            v195 = v62;
            v209 = *(float*)(a1 + 2620);
            if (v62 == v209)
            {
                v63 = v195;
            }
            else
            {
                v231 = COERCE_FLOAT(rand());
                v63 = fabs((double)SLODWORD(v231) * 0.000030518509) * (v209 - v195) + v195;
            }
            *(float*)(a1 + 2608) = v63;
            v64 = -*(float*)(a1 + 2624);
            v196 = v64;
            v210 = *(float*)(a1 + 2624);
            if (v64 == v210)
            {
                v65 = v196;
            }
            else
            {
                v231 = COERCE_FLOAT(rand());
                v65 = fabs((double)SLODWORD(v231) * 0.000030518509) * (v210 - v196) + v196;
            }
            *(float*)(a1 + 2612) = v65;
        }
        v66 = v252;
        *(_DWORD*)(a1 + 44) = v246;
        *(_DWORD*)(a1 + 48) = v247;
        *(_DWORD*)(a1 + 52) = v248;
        *(_DWORD*)(a1 + 56) = v249;
        *(_DWORD*)(a1 + 60) = v250;
        *(_DWORD*)(a1 + 64) = v251;
        *(float*)&v234 = v66 + *v58;
        v235 = v253 + *(float*)(a1 + 2608);
        v67 = v254[0] + *(float*)(a1 + 2612);
        *(float*)(a1 + 32) = *(float*)&v234;
        v236 = v67;
        *(float*)(a1 + 36) = v235;
        *(float*)(a1 + 40) = v236;
        *(float*)(a1 + 44) = *(float*)(a1 + 44) + *(float*)(a1 + 32);
        *(float*)(a1 + 48) = *(float*)(a1 + 36) + *(float*)(a1 + 48);
        *(float*)(a1 + 52) = *(float*)(a1 + 40) + *(float*)(a1 + 52);
        if (*(_BYTE*)(a1 + 2584))
            v68 = 8.0;
        else
            v68 = 45.0;
        v69 = *(_DWORD*)(a1 + 2636);
        *(float*)(a1 + 28) = v68 * 0.017453292;
        if (v69 && *(float*)(a1 + 2640) > 0.0 && sub_4629B0(a1, *(_DWORD*)(v69 + 296)))
            *(float*)(a1 + 2640) = *(float*)(a1 + 2640) - *(float*)&a3;
        for (i = 0; ; ++i)
        {
        LABEL_168:
            v71 = *(_DWORD*)(a1 + 2568);
            if (!v71 || i >= (*(_DWORD*)(a1 + 2572) - v71) >> 3)
            {
                v75 = *(_DWORD*)(a1 + 2636);
                if (v75)
                {
                    v76 = *(_DWORD*)(v75 + 844);
                    if (v76)
                        *(_BYTE*)(v76 + 32) = 0;
                    else
                        (*(void(__thiscall**)(_DWORD, _DWORD))(**(_DWORD**)(v75 + 848) + 24))(*(_DWORD*)(v75 + 848), 0);
                }
                if (*(_BYTE*)(a1 + 2645) || *(_BYTE*)(a1 + 2646))
                {
                    v216 = *(float*)(a1 + 52 * *(_DWORD*)(a1 + 516) + 2372);
                    v143 = *(_BYTE*)(a1 + 2646);
                    v231 = *(float*)(a1 + 52 * *(_DWORD*)(a1 + 516) + 2368);
                    if (v143)
                    {
                        v231 = v240;
                        v216 = *(float*)&v222;
                    }
                    v144 = *(_DWORD*)(a1 + 2636);
                    v145 = *(_DWORD*)(v144 + 844);
                    if (v145)
                        *(_BYTE*)(v145 + 32) = 1;
                    else
                        (*(void(__thiscall**)(_DWORD, int))(**(_DWORD**)(v144 + 848) + 24))(*(_DWORD*)(v144 + 848), 1);
                    v146 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580)) + 652);
                    (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)v146 + 24))(v146, 0);
                    v147 = *(float**)(a1 + 2636);
                    v148 = v147[216] - v147[215];
                    if (v148 == 0.0)
                    {
                        v205 = 0.0;
                    }
                    else
                    {
                        v205 = (v216 - v147[215]) / v148;
                        if (v205 > 0.0)
                        {
                            if (v205 >= 1.0)
                                v205 = 1.0;
                        }
                        else
                        {
                            v205 = 0.0;
                        }
                    }
                    v149 = (v147[214] - v147[213]) * v205 + v147[213];
                    *(float*)&v234 = 0.0;
                    v235 = 1.0;
                    v236 = 0.0;
                    v230 = v149;
                    v223 = v231 * 0.017453292;
                    sub_401000((float*)&v234, v223);
                    v150 = *(_DWORD*)(a1 + 516);
                    *(float*)&v227 = v230 * *(float*)&v234;
                    v228 = v235 * v230;
                    v229 = v236 * v230;
                    v151 = *(float*)&v227 + *(float*)(a1 + 52 * v150 + 2352);
                    v152 = a1 + 52 * v150 + 2352;
                    *(float*)&v227 = v151;
                    v228 = v228 + *(float*)(v152 + 4);
                    v153 = v229 + *(float*)(v152 + 8);
                    v229 = v153;
                    sub_450AA0((int**)dword_520970, v227, SLODWORD(v228));
                    v154 = *(_DWORD*)(a1 + 2636);
                    v229 = v153 + 90.0;
                    v155 = *(float**)(v154 + 844);
                    if (v155)
                    {
                        v155[1] = *(float*)&v227;
                        v155[2] = v228;
                        v155[3] = v229;
                        *(float*)(*(_DWORD*)(*(_DWORD*)(a1 + 2636) + 844) + 20) = v223;
                    }
                    else
                    {
                        sub_4074B0(*(_DWORD**)(v154 + 848), 0);
                        sub_407600(*(_DWORD**)(*(_DWORD*)(a1 + 2636) + 848), 0, v227, SLODWORD(v228), SLODWORD(v229));
                    }
                    if (*(_BYTE*)(a1 + 2646))
                    {
                        *(_BYTE*)(a1 + 2645) = 0;
                        v156 = *(_DWORD*)(a1 + 2636);
                        *(_BYTE*)(a1 + 2646) = 0;
                        *(_DWORD*)(a1 + 2640) = *(_DWORD*)(v156 + 308);
                        v157 = *(int**)(dword_520970 + 260);
                        v231 = (*(float*)(*(_DWORD*)(a1 + 2636) + 872) - *(float*)(*(_DWORD*)(a1 + 2636) + 868)) * v205
                            + *(float*)(*(_DWORD*)(a1 + 2636) + 868);
                        v229 = sub_468BE0(v157, v227, SLODWORD(v228), 0);
                        sub_46BE02((int)v257, v55, v56, v239);
                        sub_46BF69((float*)v258, v233);
                        sub_46BE62((float*)v259, v232);
                        sub_46BE02(
                            (int)v256,
                            *(_DWORD*)(*(_DWORD*)(a1 + 2636) + 360),
                            *(_DWORD*)(*(_DWORD*)(a1 + 2636) + 364),
                            *(_DWORD*)(*(_DWORD*)(a1 + 2636) + 368));
                        sub_46B97C(v244, v259, v258);
                        sub_46B97C(v244, v244, v257);
                        sub_46B97C(v244, v256, v244);
                        v217 = fabs((double)rand() * 0.000030518509);
                        v240 = fabs((double)rand() * 0.000030518509);
                        v158 = fabs((double)rand() * 0.000030518509);
                        *(float*)&v241 = v158 + v158 - 1.0;
                        v242 = v240 + v240 - 1.0;
                        v243 = v217 + v217 - 1.0;
                        sub_46B970(&v241, &v241);
                        v159 = *(char**)(dword_520970 + 276);
                        ArgList_4 = v231;
                        v160 = (float*)sub_4010C0((int)v244);
                        sub_44A1D0(
                            v159,
                            *(_DWORD*)(*(_DWORD*)(a1 + 2636) + 304),
                            v160,
                            (float*)&v227,
                            ArgList_4,
                            1,
                            0,
                            6.2831855,
                            (int)&v241);
                        v161 = *(_DWORD*)(a1 + 2636);
                        v237 = 0.0;
                        v238 = 0;
                        v239 = 0;
                        sub_44DAD0(*(int**)(v161 + 372), &v237, 0, 0);
                        sub_4629F0(a1, *(_DWORD*)(*(_DWORD*)(a1 + 2636) + 296));
                    }
                }
                else if (v226)
                {
                    if (!v191 && (sub_408F60(0) || sub_408F40(57)))
                    {
                        v77 = 1;
                        v192 = 1;
                    }
                    else
                    {
                        v192 = 0;
                        *(_BYTE*)(a1 + 2647) = 0;
                        v77 = 0;
                    }
                    if (*(float*)(a1 + 2648) > 0.0)
                        *(float*)(a1 + 2648) = *(float*)(a1 + 2648) - *(float*)&a3;
                    if (v77
                        && !*(_BYTE*)(a1 + 2647)
                        && *(float*)(a1 + 2648) <= 0.0
                        && !sub_4629B0(a1, *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580)) + 296)))
                    {
                        v78 = *(_DWORD*)(a1 + 2580);
                        *(_BYTE*)(a1 + 2647) = 1;
                        *(float*)&v241 = 0.0;
                        v242 = 0.0;
                        v243 = 0.0;
                        sub_44DAD0(*(int**)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * v78) + 384), (float*)&v241, 0, 0);
                    }
                    v79 = *(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580));
                    v197 = *(float*)(v79 + 352);
                    v203 = *(float*)(v79 + 356);
                    if (v221 < (double)v197)
                        v221 = *(float*)(v79 + 352);
                    if (v221 > (double)v203)
                        v221 = *(float*)(v79 + 356);
                    if (*(_DWORD*)(v79 + 292) == 2)
                        v221 = 0.0;
                    sub_46BE02((int)v257, v55, v238, v239);
                    sub_46BF69((float*)v261, v233);
                    v181 = v221 * 0.017453292;
                    sub_46BE62((float*)v256, v181);
                    sub_46B97C(v255, v256, v261);
                    sub_46B97C(v255, v255, v257);
                    v80 = *(int**)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580));
                    sub_46BE02((int)v259, v80[90], v80[91], v80[92]);
                    sub_46B97C(v258, v259, v255);
                    sub_4074B0(*(_DWORD**)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580)) + 652), 0);
                    sub_4073F0(*(_DWORD**)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580)) + 652), 0, v258);
                    v81 = *(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580));
                    v82 = *(_DWORD*)(v81 + 292);
                    if (v82)
                    {
                        if (v82 == 2)
                        {
                            v85 = *(float*)(a1 + 52 * *(_DWORD*)(a1 + 516) + 2372);
                            if (v85 <= v197)
                                v85 = v197;
                            if (v85 >= v203)
                                v85 = v203;
                            v86 = *(float*)(v81 + 356) - *(float*)(v81 + 352);
                            if (v86 == 0.0)
                                v87 = 0.0;
                            else
                                v87 = (v85 - *(float*)(v81 + 352)) / v86;
                            *(float*)(*(_DWORD*)(v81 + 652) + 32) = *(float*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v81 + 652) + 28)
                                + 48)
                                + 4 * *(_DWORD*)(*(_DWORD*)(v81 + 652) + 44))
                                * v87;
                        }
                    }
                    else
                    {
                        v83 = *(_DWORD*)(v81 + 800);
                        if (v83 != -1)
                        {
                            sub_4074B0(*(_DWORD**)(v81 + 652), v83);
                            v84 = *(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580));
                            v182 = -v221 * 0.017453292;
                            sub_407510(*(_DWORD**)(v84 + 652), *(_DWORD*)(v84 + 800), v182);
                        }
                    }
                    v88 = *(_DWORD*)(a1 + 2568);
                    v89 = 8 * *(_DWORD*)(a1 + 2580);
                    v90 = *(_DWORD*)(v88 + v89);
                    v91 = *(_DWORD*)(v90 + 292);
                    if (v91 == 1)
                    {
                        if (v77 && *(float*)(v88 + v89 + 4) <= 0.0)
                        {
                            *(_DWORD*)(*(_DWORD*)(v90 + 652) + 36) = 1065353216;
                        }
                        else if (sub_4088A0(*(_DWORD*)(*(_DWORD*)(v88 + v89) + 652)))
                        {
                            *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580)) + 652) + 36) = 0;
                        }
                    }
                    else if (v91)
                    {
                        if (v91 == 2)
                        {
                            if (!*(_BYTE*)(a1 + 2668))
                                goto LABEL_228;
                            v92 = sub_407320(
                                (_DWORD*)*(_DWORD*)(*(_DWORD*)(v88 + v89) + 652),
                                *(_DWORD*)(*(_DWORD*)(v88 + v89) + 832))
                                + *(float*)&a3;
                            v89 = 8 * *(_DWORD*)(a1 + 2580);
                            *(float*)&v211 = v92;
                            if (v92 > *(float*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + v89) + 840))
                                *(_BYTE*)(a1 + 2668) = 0;
                            if (!*(_BYTE*)(a1 + 2668))
                                LABEL_228:
                            v211 = *(int*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + v89) + 836);
                            sub_4072A0(
                                *(_DWORD**)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + v89) + 652),
                                *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + v89) + 832),
                                v211,
                                0);
                        }
                    }
                    else if (v77 && sub_4629B0(a1, *(_DWORD*)(*(_DWORD*)(v88 + v89) + 296)))
                    {
                        *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580)) + 652) + 36) = 1065353216;
                    }
                    else
                    {
                        *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580)) + 652) + 36) = 0;
                        *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580)) + 652) + 32) = 0;
                    }
                    v93 = 0;
                    if (*(int*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580)) + 656) > 0)
                    {
                        v94 = 0;
                        v95 = (float*)(a1 + 2676);
                        do
                        {
                            if (*v95 > 0.0)
                                *v95 = *v95 - *(float*)&a3;
                            if (*v95 <= 0.0)
                            {
                                v96 = *(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580));
                                v97 = *(_DWORD*)(v96 + v94 + 664);
                                if (v97 != -1)
                                    sub_408640(*(_DWORD**)(v96 + 652), v97, 0);
                                v98 = *(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580));
                                v99 = *(_DWORD*)(v98 + v94 + 668);
                                if (v99 != -1)
                                    sub_408640(*(_DWORD**)(v98 + 652), v99, 0);
                            }
                            ++v93;
                            ++v95;
                            v94 += 12;
                        } while (v93 < *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580)) + 656));
                    }
                    if (v192)
                    {
                        v100 = *(_DWORD*)(a1 + 2568);
                        v101 = 8 * *(_DWORD*)(a1 + 2580);
                        if (*(float*)(v100 + v101 + 4) <= 0.0)
                        {
                            if (sub_4629B0(a1, *(_DWORD*)(*(_DWORD*)(v100 + v101) + 296)))
                            {
                                v102 = 8 * *(_DWORD*)(a1 + 2580);
                                v103 = *(_DWORD*)(*(_DWORD*)(a1 + 2568) + v102);
                                if (*(_BYTE*)(v103 + 804))
                                    v104 = 1;
                                else
                                    v104 = *(_DWORD*)(v103 + 656);
                                v105 = 0;
                                v212 = v104;
                                if (v104 > 0)
                                {
                                    v106 = a1 + 2676;
                                    do
                                    {
                                        if (!sub_4629B0(a1, *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + v102) + 296)))
                                            break;
                                        sub_4629F0(a1, *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580)) + 296));
                                        v107 = *(_DWORD*)(a1 + 2580);
                                        v108 = *(_DWORD*)(a1 + 2568);
                                        *(float*)&v241 = 0.0;
                                        v242 = 0.0;
                                        v243 = 0.0;
                                        *(float*)&v227 = 0.0;
                                        v228 = 1.0;
                                        v229 = 0.0;
                                        memset(&v244[11], 0, 16);
                                        memset(&v244[6], 0, 16);
                                        memset(&v244[1], 0, 16);
                                        v244[15] = 1065353216;
                                        v244[10] = 1065353216;
                                        v244[5] = 1065353216;
                                        v244[0] = 1065353216;
                                        sub_407690(
                                            *(_DWORD*)(*(_DWORD*)(v108 + 8 * v107) + 652),
                                            *(_DWORD*)(*(_DWORD*)(v108 + 8 * v107) + 12 * (*(_DWORD*)(a1 + 2672) + 55)),
                                            v244);
                                        sub_4010D0(&v241, (int)v244);
                                        sub_46B976((float*)&v227, (float*)&v227, (float*)v244);
                                        sub_46B970(&v227, &v227);
                                        v109 = *(_DWORD*)(a1 + 2580);
                                        v110 = *(_DWORD*)(a1 + 2568);
                                        v237 = 0.0;
                                        v238 = 0;
                                        v111 = (int*)(v110 + 8 * v109);
                                        v112 = *v111;
                                        v239 = 1065353216;
                                        v113 = *(float*)(v112 + 796);
                                        *(float*)&v227 = *(float*)&v227 * v113;
                                        v228 = v228 * v113;
                                        v229 = v229 * v113;
                                        sub_449C40(*(char**)(a1 + 2560), *(_DWORD*)(*v111 + 304), &v241, &v227, 1, 0, 0.0, (int)&v237);
                                        v114 = *(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580));
                                        if (!*(_DWORD*)(v114 + 292) && *(_BYTE*)(v114 + 805))
                                            sub_462B20((_DWORD*)a1);
                                        v115 = *(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580));
                                        v116 = *(_DWORD*)(v115 + 12 * *(_DWORD*)(a1 + 2672) + 664);
                                        if (v116 != -1)
                                        {
                                            sub_408640(*(_DWORD**)(v115 + 652), v116, 1);
                                            v117 = (double)rand();
                                            v118 = *(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580));
                                            v183 = fabs(v117 * 0.000030518509) * 6.2831855;
                                            sub_407560(*(_DWORD**)(v118 + 652), *(_DWORD*)(v118 + 12 * *(_DWORD*)(a1 + 2672) + 664), v183);
                                        }
                                        v119 = *(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580));
                                        v120 = *(_DWORD*)(v119 + 12 * *(_DWORD*)(a1 + 2672) + 668);
                                        if (v120 != -1)
                                        {
                                            sub_408640(*(_DWORD**)(v119 + 652), v120, 1);
                                            v121 = (double)rand();
                                            v122 = *(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580));
                                            v184 = fabs(v121 * 0.000030518509) * 6.2831855;
                                            sub_407560(*(_DWORD**)(v122 + 652), *(_DWORD*)(v122 + 12 * *(_DWORD*)(a1 + 2672) + 668), v184);
                                        }
                                        v106 += 4;
                                        *(_DWORD*)(v106 - 4) = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580))
                                            + 792);
                                        v123 = *(_DWORD*)(a1 + 2580);
                                        v124 = *(_DWORD*)(a1 + 2672) + 1;
                                        *(_DWORD*)(a1 + 2672) = v124;
                                        v102 = 8 * v123;
                                        ++v105;
                                        *(_DWORD*)(a1 + 2672) = v124 % *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + v102) + 656);
                                    } while (v105 < v212);
                                }
                                v125 = *(_DWORD*)(a1 + 2580);
                                *(_BYTE*)(a1 + 2668) = 1;
                                *(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * v125 + 4) = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568)
                                    + 8 * v125)
                                    + 308);
                                if (!sub_4629B0(
                                    a1,
                                    *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580)) + 296)))
                                    *(_DWORD*)(a1 + 2648) = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * *(_DWORD*)(a1 + 2580))
                                        + 308);
                                v126 = *(_DWORD*)(a1 + 2580);
                                v127 = *(_DWORD*)(a1 + 2568);
                                v237 = 0.0;
                                v238 = 0;
                                v239 = 0;
                                sub_44DAD0(*(int**)(*(_DWORD*)(v127 + 8 * v126) + 372), &v237, 0, 0);
                                v128 = *(_DWORD*)(a1 + 2580);
                                v129 = *(_DWORD*)(a1 + 2568);
                                v237 = 0.0;
                                v238 = 0;
                                v239 = 0;
                                sub_44DAD0(*(int**)(*(_DWORD*)(v129 + 8 * v128) + 380), &v237, 0, 0);
                            }
                        }
                    }
                    v130 = *(_DWORD*)(a1 + 2568);
                    v131 = 8 * *(_DWORD*)(a1 + 2580);
                    v132 = *(_DWORD*)(v130 + v131);
                    if (*(_DWORD*)(v132 + 292))
                    {
                        *(_DWORD*)(a1 + 2652) = 0;
                        *(_DWORD*)(a1 + 2656) = 0;
                    }
                    else
                    {
                        v204 = *(float*)&a3 * *(float*)(v132 + 820) * 50.0;
                        if (v192 && sub_4629B0(a1, *(_DWORD*)(*(_DWORD*)(v130 + v131) + 296)))
                        {
                            v198 = v204 * -0.40000001;
                            v213 = v204 * 0.60000002;
                            if (v198 == v213)
                                v133 = v198;
                            else
                                v133 = fabs((double)rand() * 0.000030518509) * (v213 - v198) + v198;
                            v134 = v133 + *(float*)(a1 + 2656);
                            v135 = *(_DWORD*)(a1 + 2580);
                            *(float*)(a1 + 2656) = v134;
                            v136 = *(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * v135);
                            if (v134 > *(float*)(v136 + 816))
                                *(_DWORD*)(a1 + 2656) = *(_DWORD*)(v136 + 816);
                            if (*(float*)(a1 + 2656) < 0.0)
                                *(_DWORD*)(a1 + 2656) = 0;
                            v199 = v204 * -0.5;
                            v214 = v204 * 0.5;
                            if (v199 == v214)
                                v137 = v199;
                            else
                                v137 = fabs((double)rand() * 0.000030518509) * (v214 - v199) + v199;
                            v138 = v137 + *(float*)(a1 + 2652);
                            v139 = 8 * *(_DWORD*)(a1 + 2580);
                            *(float*)(a1 + 2652) = v138;
                            v215 = *(float*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + v139) + 816) * 0.5;
                            if (v138 > v215)
                                *(float*)(a1 + 2652) = v215;
                            v140 = *(float*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + v139) + 816) * -0.5;
                            if (v140 > *(float*)(a1 + 2652))
                                *(float*)(a1 + 2652) = v140;
                        }
                        else
                        {
                            v141 = *(float*)(a1 + 2656) * 0.69999999;
                            *(float*)(a1 + 2656) = v141;
                            if ((double)(int)abs32((__int64)v141) < v204)
                                *(_DWORD*)(a1 + 2656) = 0;
                            v142 = *(float*)(a1 + 2652) * 0.69999999;
                            *(float*)(a1 + 2652) = v142;
                            if ((double)(int)abs32((__int64)v142) < v204)
                                *(_DWORD*)(a1 + 2652) = 0;
                        }
                    }
                }
                goto LABEL_298;
            }
            if (*(float*)(v71 + 8 * i + 4) <= 0.0)
                goto LABEL_174;
            if (!sub_4629B0(a1, *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * i) + 296)))
                break;
            v72 = *(_DWORD*)(a1 + 2568);
            v73 = *(float*)(v72 + 8 * i + 4) - *(float*)&a3;
            v74 = (float*)(v72 + 8 * i + 4);
            *v74 = v73;
        }
        *(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * i + 4) = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a1 + 2568) + 8 * i) + 308);
    LABEL_174:
        ++i;
        goto LABEL_168;
    }
LABEL_298:
    v162 = 0;
    v163 = (_BYTE*)(a1 + 2720);
    do
    {
        if (*v163)
            sub_462DD0((_DWORD*)a1, v162);
        ++v162;
        v163 += 88;
    } while (v162 < 100);
    v164 = 0;
    if (*(int*)(a1 + 524) > 0)
    {
        v165 = (float*)(a1 + 2344);
        do
        {
            sub_4074B0(*(_DWORD**)v165, *(_DWORD*)(a1 + 440));
            v185 = v165[6] * 0.017453292;
            sub_4075B0(*(_DWORD**)v165, *(_DWORD*)(a1 + 440), v185);
            v166 = *(_DWORD*)(a1 + 448);
            v224 = *((int*)v165 + 6);
            v167 = (_DWORD*)*((_DWORD*)v165 + 1);
            v240 = v165[7];
            sub_4074B0(v167, v166);
            v186 = (*(float*)&v224 + 180.0) * 0.017453292;
            sub_4075B0(*((_DWORD**)v165 + 1), *(_DWORD*)(a1 + 448), v186);
            sub_4074B0(*((_DWORD**)v165 + 1), *(_DWORD*)(a1 + 452));
            v187 = -(v240 * 0.017453292);
            sub_407510(*((_DWORD**)v165 + 1), *(_DWORD*)(a1 + 452), v187);
            if (v164 == *(_DWORD*)(a1 + 516) && (v168 = sub_408F30((_DWORD*)dword_520970), v168 == a1))
            {
                LOBYTE(v168) = *(_BYTE*)(a1 + 2584) == 0;
                (*(void(__thiscall**)(_DWORD, int, int))(**(_DWORD**)v165 + 24))(*(_DWORD*)v165, v168, a2);
                a2 = 0;
                v169 = **((_DWORD**)v165 + 1);
            }
            else
            {
                (*(void(__thiscall**)(_DWORD, _DWORD, int))(**(_DWORD**)v165 + 24))(*(_DWORD*)v165, 0, a2);
                a2 = 1;
                v169 = **((_DWORD**)v165 + 1);
            }
            (*(void (**)(void))(v169 + 24))();
            ++v164;
            v165 += 13;
        } while (v164 < *(_DWORD*)(a1 + 524));
    }
    if ((*(_BYTE*)(dword_4F5CC4 + 936) || *(_BYTE*)(dword_4F5CC4 + 937))
        && (v170 = *(_DWORD*)(a1 + 512), v170 >= 0)
        && *(float*)(352 * v170 + a1 + 924) > 0.0)
    {
        v171 = *(float*)(a1 + 2548) - *(float*)&a3;
        *(float*)(a1 + 2548) = v171;
        if (v171 < 0.0)
        {
            *(_DWORD*)(a1 + 2548) = 0;
            if (*(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 100) == 6)
            {
                *(_DWORD*)(a1 + 2548) = 1041865114;
                if (*(int*)(a1 + 516) > -1)
                    sub_463780((_DWORD*)a1);
            }
        }
        v172 = 0;
        if (*(int*)(a1 + 524) > 0)
        {
            v173 = a1 + 2388;
            do
            {
                v174 = *(float*)&a3 + *(float*)(v173 - 12);
                ++v172;
                v173 += 52;
                *(float*)(v173 - 64) = v174;
                *(float*)(v173 - 52) = *(float*)&a3 + *(float*)(v173 - 52);
            } while (v172 < *(_DWORD*)(a1 + 524));
        }
    }
    else
    {
        v175 = *(_DWORD*)(a1 + 512);
        if (v175 >= 0)
            v176 = *(_DWORD*)(352 * v175 + a1 + 1228);
        else
            v176 = 0;
        v177 = *(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 76);
        if (v177)
            v178 = *(float*)(v177 + 256);
        else
            v178 = 100.0;
        if (v175 >= 0)
            v179 = *(float*)(352 * v175 + a1 + 924);
        else
            v179 = 0.0;
        if (v178 == 0.0)
        {
            sub_436EC0(*(_DWORD**)(dword_520970 + 224), *(_DWORD*)(352 * v175 + a1 + 884), 0, v176);
        }
        else
        {
            *(float*)&v225 = v179 / v178;
            sub_436EC0(*(_DWORD**)(dword_520970 + 224), *(_DWORD*)(352 * v175 + a1 + 884), v225, v176);
        }
    }
    return sub_428620((_DWORD*)a1, a3);
}
// 45F9E0: could not find valid save-restore pair for edi
// 45FBD6: conditional instruction was optimized away because ecx.4>=0
// 461C2F: conditional instruction was optimized away because ecx.4>=0
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);
// 4A4DB4: using guessed type int dword_4A4DB4;
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520884: using guessed type char byte_520884;
// 520970: using guessed type int dword_520970;

//----- (00461D40) --------------------------------------------------------
int __thiscall sub_461D40(int this, int* a2, int* a3, int a4, _DWORD* a5)
{
    int v5; // eax
    int v6; // ebp
    int v7; // eax
    int v8; // ecx
    int v9; // edx
    int v10; // eax
    int v11; // ecx
    int v12; // edx
    int v13; // eax
    double v14; // st7
    long double v15; // st6
    int v16; // eax
    double v17; // st7
    int v18; // eax
    int v19; // ecx
    long double v20; // st7
    double v21; // st7
    double v22; // st6
    double v23; // st7
    int v26[3]; // [esp+14h] [ebp-24h] BYREF
    int v27[3]; // [esp+20h] [ebp-18h] BYREF
    int v28[3]; // [esp+2Ch] [ebp-Ch] BYREF
    float v29; // [esp+3Ch] [ebp+4h]
    float v30; // [esp+3Ch] [ebp+4h]
    float v31; // [esp+3Ch] [ebp+4h]
    float v32; // [esp+40h] [ebp+8h]
    float v33; // [esp+40h] [ebp+8h]
    float v34; // [esp+40h] [ebp+8h]
    float v35; // [esp+40h] [ebp+8h]
    float v36; // [esp+40h] [ebp+8h]

    v5 = *(_DWORD*)(this + 516);
    if (v5 < 0)
        return 0;
    v6 = this + 4 * (v5 + 4 * (3 * v5 + 135) + 45);
    v7 = *(_DWORD*)(v6 + 20);
    v26[0] = *(_DWORD*)(v6 + 12);
    v8 = *a3;
    v26[1] = *(_DWORD*)(v6 + 16);
    v9 = a3[1];
    v26[2] = v7;
    v10 = a3[2];
    v27[0] = v8;
    v11 = *a2;
    v27[1] = v9;
    v12 = a2[1];
    v27[2] = v10;
    v13 = a2[2];
    v28[0] = v11;
    v28[1] = v12;
    v28[2] = v13;
    if (!sub_40C6F0((float*)v28, (float*)v27, (float*)v26))
        return 0;
    v14 = *(float*)a3 - *(float*)a2;
    v15 = *((float*)a3 + 1) - *((float*)a2 + 1);
    if (v14 == 0.0 && v15 == 0.0)
        v32 = *(float*)(v6 + 28) - 180.0;
    else
        v32 = atan2(-v14, v15) * 57.295776;
    v29 = *(float*)(v6 + 28) - 180.0;
    v30 = sub_422830(v29, v32);
    v16 = *(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 76);
    if (!v16)
    {
        v17 = 100.0;
    LABEL_10:
        v33 = *(float*)(*(_DWORD*)(a4 + 4) + 300) / v17;
        goto LABEL_12;
    }
    v17 = *(float*)(v16 + 256);
    if (v17 != 0.0)
        goto LABEL_10;
    v33 = 0.0;
LABEL_12:
    sub_437020(*(float**)(dword_520970 + 224), v30, v33);
    *a5 = *(_DWORD*)(v6 + 12);
    a5[1] = *(_DWORD*)(v6 + 16);
    a5[2] = *(_DWORD*)(v6 + 20);
    v18 = *(_DWORD*)(a4 + 4);
    v34 = *(float*)(v18 + 300);
    if (*(_BYTE*)(v18 + 312))
    {
        v19 = this;
        goto LABEL_21;
    }
    v19 = this;
    v20 = fabs(v30);
    v31 = v20;
    if (v20 <= *(float*)(this + 460))
    {
    LABEL_21:
        sub_462090(v19, v34);
        return 4;
    }
    if (v31 >= (double)*(float*)(this + 464))
    {
        v36 = *(float*)(this + 468) * 0.0099999998 * v34;
        sub_462090(this, v36);
        return 4;
    }
    else
    {
        v21 = *(float*)(this + 460);
        v22 = *(float*)(this + 464) - v21;
        if (v22 == 0.0)
            v23 = 0.0;
        else
            v23 = (v31 - v21) / v22;
        v35 = (v23 * *(float*)(this + 468) + (1.0 - v23) * 100.0) * 0.0099999998 * v34;
        sub_462090(this, v35);
        return 4;
    }
}
// 520970: using guessed type int dword_520970;

//----- (00461FD0) --------------------------------------------------------
void __thiscall sub_461FD0(_DWORD* this, float* a2, float a3, float a4, int a5, int a6)
{
    int v6; // eax
    float* v7; // edx
    double v8; // st4
    double v9; // st3
    double v10; // st4
    double v11; // st3
    double v12; // st4
    double v13; // st7
    double v14; // st7
    float v15; // [esp+0h] [ebp-4h]

    v6 = this[129];
    if (v6 >= 0)
    {
        v7 = (float*)&this[12 * v6 + 585 + v6];
        v8 = a2[2] - v7[5];
        v9 = a2[1] - v7[4];
        v10 = v8 * v8 + v9 * v9;
        v11 = *a2 - v7[3];
        v12 = sqrt(v10 + v11 * v11);
        if (v12 <= a3 + v7[6])
        {
            v13 = v12 - v7[6];
            if (v13 <= 0.0)
                v13 = 0.0;
            if (a3 == 0.0)
                v14 = 0.0;
            else
                v14 = v13 / a3;
            v15 = (1.0 - v14) * a4;
            sub_462090((int)this, v15);
        }
    }
}

//----- (00462090) --------------------------------------------------------
void __thiscall sub_462090(int this, float a2)
{
    int v3; // edx
    double v4; // st7
    int v5; // ecx
    char v6; // al
    double v7; // st7
    double v8; // st7

    if (*(_BYTE*)(this + 11796))
        return;
    v3 = 352 * *(_DWORD*)(this + 512);
    v4 = *(float*)(v3 + this + 924) - a2;
    v5 = v3 + this + 880;
    *(float*)(v3 + this + 924) = v4;
    if (*(float*)(this + 11608) < v4)
        v4 = *(float*)(this + 11608);
    *(float*)(this + 11608) = v4;
    v6 = *(_BYTE*)(this + 2552);
    *(float*)(this + 11616) = a2 + *(float*)(this + 11616);
    v7 = *(float*)(v5 + 44);
    if (!v6)
    {
        if (v7 < 0.0)
        {
            v8 = 0.0;
            goto LABEL_10;
        }
    LABEL_9:
        v8 = *(float*)(v5 + 44);
        goto LABEL_10;
    }
    if (v7 >= 1.0)
        goto LABEL_9;
    v8 = 1.0;
LABEL_10:
    *(float*)(v5 + 44) = v8;
    if (*(float*)(v5 + 44) <= 0.0 && !*(_DWORD*)(*(_DWORD*)(dword_520970 + 232) + 52))
    {
        *(_BYTE*)(this + 11796) = 1;
        sub_4261C0(*(_DWORD**)(dword_520970 + 232), aTelegram, 1);
        if (*(_BYTE*)(dword_4F5CC4 + 936) || *(_BYTE*)(dword_4F5CC4 + 937))
            sub_463110((_DWORD*)this);
        else
            ++ * (_DWORD*)(this + 504);
    }
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (004621B0) --------------------------------------------------------
void __thiscall sub_4621B0(int* this)
{
    int v1; // ebx
    int* v2; // edi
    int v3; // ebp
    int v4; // esi
    int v5; // edx
    int* v6; // eax
    int v7; // esi
    _DWORD* v8; // edx
    int v9; // eax
    int v10; // [esp+8h] [ebp-4h]

    v1 = this[130];
    v10 = 0;
    if (v1 > 0)
    {
        v2 = this + 223;
        v3 = v1;
        do
        {
            v4 = *v2;
            v5 = 0;
            v6 = dword_499B68;
            do
            {
                if (v4 == *v6)
                    *((_BYTE*)&v10 + v5) = 1;
                ++v6;
                ++v5;
            } while ((int)v6 < (int)&off_499B78);
            v2 += 88;
            --v3;
        } while (v3);
    }
    v7 = 0;
    if (v1 > 0)
    {
        v8 = this + 223;
        do
        {
            if (!*v8)
            {
                v9 = 0;
                while (*((_BYTE*)&v10 + v9))
                {
                    if (++v9 >= 4)
                        goto LABEL_16;
                }
                *((_BYTE*)&v10 + v9) = 1;
                *v8 = dword_499B68[v9];
            }
        LABEL_16:
            ++v7;
            v8 += 88;
        } while (v7 < this[130]);
    }
}
// 499B68: using guessed type int dword_499B68[4];
// 499B78: using guessed type _UNKNOWN *off_499B78;

//----- (00462240) --------------------------------------------------------
int __thiscall sub_462240(int this)
{
    int i; // esi
    void* v3; // eax
    void* v4; // ebx
    int v5; // eax
    int v6; // ecx
    void* v7; // edx
    int v8; // eax
    char* v9; // eax
    int v10; // esi
    int v11; // ecx
    int v13; // [esp+10h] [ebp-134h] BYREF
    int v14; // [esp+14h] [ebp-130h] BYREF
    _DWORD v15[72]; // [esp+18h] [ebp-12Ch] BYREF
    int v16; // [esp+140h] [ebp-4h]

    if (*(_BYTE*)(this + 11792))
    {
        for (i = 0; i < *(_DWORD*)(this + 11784); ++i)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 11780) + 4 * i));
    }
    memset(*(void**)(this + 11780), 0, 4 * *(_DWORD*)(this + 11784));
    v3 = *(void**)(this + 11780);
    *(_DWORD*)(this + 11784) = 0;
    sub_488CEE(v3);
    *(_DWORD*)(this + 11788) = 0;
    *(_DWORD*)(this + 11780) = 0;
    sub_40A1D0((int)v15, aScoringIni);
    v16 = 0;
    while (sub_40AAF0(v15, aScoringgroup_0, 0))
    {
        v4 = operator new(0x12Cu);
        v5 = *(_DWORD*)(this + 11788);
        v6 = *(_DWORD*)(this + 11784) + 1;
        *(_DWORD*)(this + 11784) = v6;
        if (v6 > v5)
        {
            v7 = *(void**)(this + 11780);
            v8 = v5 + 8;
            *(_DWORD*)(this + 11788) = v8;
            v9 = (char*)sub_488DD7(v7, 4 * v8);
            if (v9)
            {
                v10 = *(_DWORD*)(this + 11784);
                v11 = *(_DWORD*)(this + 11788) - v10;
                *(_DWORD*)(this + 11780) = v9;
                memset(&v9[4 * v10], 0, 4 * v11);
            }
        }
        *(_DWORD*)(*(_DWORD*)(this + 11780) + 4 * *(_DWORD*)(this + 11784) - 4) = v4;
        sub_40AA40((int)v15, aScoringgroup_0);
        sub_40AFC0(v15, aName_0, &v13);
        strcpy((char*)v4, (const char*)v13);
        sub_40AFC0(v15, aIcon, &v13);
        strcpy((char*)v4 + 33, (const char*)v13);
        sub_40AF00((const char*)v15, aPosition, (char**)&v14);
        sub_40AF00((const char*)v15, aPoints, (char**)v4 + 74);
    }
    v16 = -1;
    return sub_40A830((int)v15);
}

//----- (00462480) --------------------------------------------------------
const char* __thiscall sub_462480(_DWORD* this, char* String1)
{
    int v3; // ebp
    int v4; // esi
    const char* v5; // edi

    v3 = this[2946];
    v4 = 0;
    if (v3 <= 0)
        return 0;
    while (1)
    {
        v5 = *(const char**)(this[2945] + 4 * v4);
        if (!_strcmpi(String1, v5))
            break;
        if (++v4 >= v3)
            return 0;
    }
    return v5;
}

//----- (004624D0) --------------------------------------------------------
unsigned int __thiscall sub_4624D0(_DWORD* this, int a2)
{
    int v2; // eax
    unsigned int result; // eax

    if (&this[88 * this[128]] != (_DWORD*)-880)
    {
        v2 = (int)&this[88 * this[128] + 220];
        *(_DWORD*)(v2 + 348) += a2;
    }
    result = dword_4F5CC4;
    if (*(_BYTE*)(dword_4F5CC4 + 936) || *(_BYTE*)(dword_4F5CC4 + 937))
        return sub_463780(this);
    return result;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (00462520) --------------------------------------------------------
char __thiscall sub_462520(_DWORD* this, int a2, int a3)
{
    int v3; // eax
    int v5; // ebx
    int v6; // ecx
    _DWORD* v7; // edx
    int v8; // edi
    int v9; // ecx
    int v10; // eax
    _DWORD* v11; // edx
    int v12; // eax
    _WORD v14[3]; // [esp+10h] [ebp-8h] BYREF
    char v15; // [esp+16h] [ebp-2h]

    v3 = 0;
    v5 = -1;
    v6 = this[2946];
    if (v6 > 0)
    {
        v7 = (_DWORD*)this[2945];
        while (*v7 != a2)
        {
            ++v3;
            ++v7;
            if (v3 >= v6)
                goto LABEL_7;
        }
        v5 = v3;
    }
LABEL_7:
    v8 = (int)&this[88 * this[128] + 220];
    if (a3)
    {
        v9 = this[130];
        v8 = 0;
        v10 = 0;
        if (v9 > 0)
        {
            v11 = this + 222;
            while (*v11 != a3)
            {
                ++v10;
                v11 += 88;
                if (v10 >= v9)
                    goto LABEL_14;
            }
            v8 = (int)&this[88 * v10 + 220];
        }
    }
LABEL_14:
    LOBYTE(v12) = *(_BYTE*)(dword_4F5CC4 + 936);
    if ((_BYTE)v12 && a3)
    {
        v15 = v5;
        LOBYTE(v12) = sub_411480((_DWORD*)dword_4F5CC4, (int**)0x605, a3, v14, 7, 11, 5000);
    }
    if (v8)
    {
        ++*(_DWORD*)(v8 + 4 * v5 + 92);
        *(_DWORD*)(v8 + 348) += *(_DWORD*)(a2 + 296);
        v12 = this[129];
        if (v12 > -1)
        {
            v12 = 352 * this[128];
            if ((_DWORD*)v8 == (_DWORD*)((char*)this + v12 + 880) && *(int*)(a2 + 296) > 200)
            {
                sub_402FC0(this[649]);
                LOBYTE(v12) = sub_4030B0((_DWORD*)this[649], 0, aChatterenemyki, -1);
            }
        }
    }
    return v12;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (00462660) --------------------------------------------------------
_DWORD* __thiscall sub_462660(_DWORD* this)
{
    int v1; // eax
    int v2; // edx
    int v3; // eax
    _DWORD* result; // eax
    int v5; // esi

    v1 = 88 * this[128];
    this[2901] = this[v1 + 231];
    v2 = 0;
    v3 = this[v1 + 231];
    this[2903] = 0;
    this[2902] = v3;
    this[2904] = 0;
    result = this + 2906;
    do
    {
        result += 4;
        *(result - 5) = this[88 * this[128] + 233 + v2];
        v5 = v2 + 88 * this[128];
        ++v2;
        *(result - 4) = this[v5 + 233];
        *(result - 3) = 0;
        *(result - 2) = 0;
    } while (v2 < 10);
    return result;
}

//----- (004626F0) --------------------------------------------------------
INT __usercall sub_4626F0@<eax>(int a1@<ecx>, int a2@<edi>)
{
    INT result; // eax
    FILE* v4; // esi
    int v5; // eax
    int v6; // eax
    CHAR* v7; // ecx
    int v8; // ecx
    int v9; // eax
    double v10; // st7
    int i; // edi
    int* v12; // ebx
    char* v13; // eax
    int v14; // eax
    int v15; // [esp+8h] [ebp-10h]
    int v16; // [esp+8h] [ebp-10h]

    result = sub_422BA0(AppName, aWritemissionst, 0);
    if (result == 1)
    {
        v4 = fopen(aMissionTxt, aA);
        v5 = sub_45A870(*(_DWORD**)(dword_520970 + 236), *(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 72));
        sub_48B1FD(v4, (int)aMissionS, v5);
        v6 = *(_DWORD*)(dword_520970 + 280);
        v7 = (CHAR*)(v6 + 472);
        if (!*(_BYTE*)(v6 + 472))
        {
            v8 = *(_DWORD*)(v6 + 512);
            if (v8 <= -1)
                v7 = AppName;
            else
                v7 = (CHAR*)(352 * v8 + v6 + 899);
        }
        sub_48B1FD(v4, (int)aPlayerS, (int)v7);
        sub_48B1FD(v4, (int)aDifficultyD, *(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 20) + 1);
        sub_48B1FD(v4, (int)asc_4A1F30, a2);
        sub_48B1FD(v4, (int)aHealthStarting, COERCE_UNSIGNED_INT64(*(float*)(a1 + 11604)));
        v9 = *(_DWORD*)(a1 + 512);
        if (v9 >= 0)
            v10 = *(float*)(352 * v9 + a1 + 924);
        else
            v10 = 0.0;
        sub_48B1FD(v4, (int)aHealthEnding02, SLODWORD(v10));
        sub_48B1FD(v4, (int)aHealthLow02f, COERCE_UNSIGNED_INT64(*(float*)(a1 + 11608)));
        sub_48B1FD(v4, (int)aHealthResuppli, COERCE_UNSIGNED_INT64(*(float*)(a1 + 11612)));
        sub_48B1FD(v4, (int)aHealthLost02f, COERCE_UNSIGNED_INT64(*(float*)(a1 + 11616)));
        sub_48B1FD(v4, (int)asc_4A1F30, v15);
        for (i = 0; i < 10; ++i)
        {
            v12 = (int*)(16 * i + a1);
            if (v12[2905])
            {
                if (i)
                {
                    switch (i)
                    {
                    case 1:
                        v13 = a45cal;
                        break;
                    case 2:
                        v13 = a50cal;
                        break;
                    case 3:
                        v13 = a40mm;
                        break;
                    case 4:
                        v13 = a105mm;
                        break;
                    case 5:
                        v13 = a155mm;
                        break;
                    case 6:
                        v13 = a203mm;
                        break;
                    case 7:
                        v13 = aBazooka;
                        break;
                    case 8:
                        v13 = aSuperbazooka;
                        break;
                    default:
                        v13 = i != 9 ? 0 : aGrenade;
                        break;
                    }
                }
                else
                {
                    v13 = a30cal;
                }
                sub_48B1FD(v4, (int)aAmmoNameS, (int)v13);
                sub_48B1FD(v4, (int)aAmmoStartingD, v12[2905]);
                v14 = sub_4629B0(a1, i);
                sub_48B1FD(v4, (int)aAmmoEndingD, v14);
                sub_48B1FD(v4, (int)aAmmoLowD, v12[2906]);
                sub_48B1FD(v4, (int)aAmmoResupplied, v12[2907]);
                sub_48B1FD(v4, (int)aAmmoUsedD, *(_DWORD*)(16 * (i + 727) + a1));
                sub_48B1FD(v4, (int)asc_4A1F30, v16);
            }
        }
        sub_48B1FD(v4, (int)asc_4AE234, v16);
        return fclose(v4);
    }
    return result;
}
// 4626F0: could not find valid save-restore pair for edi
// 462859: variable 'v15' is possibly undefined
// 462979: variable 'v16' is possibly undefined
// 520970: using guessed type int dword_520970;

//----- (004629B0) --------------------------------------------------------
int __thiscall sub_4629B0(int this, int a2)
{
    int result; // eax

    result = *(_DWORD*)(this + 4 * (a2 + 88 * *(_DWORD*)(this + 512)) + 932);
    if (*(_BYTE*)(this + 2552))
    {
        if (result <= 1)
            return 1;
    }
    return result;
}

//----- (004629F0) --------------------------------------------------------
int __thiscall sub_4629F0(int this, int a2)
{
    int v2; // edx
    int result; // eax
    int v4; // esi
    int v5; // edi
    int v6; // ecx

    v2 = 352 * *(_DWORD*)(this + 512) + this + 880;
    result = a2;
    v4 = *(_DWORD*)(v2 + 4 * a2 + 52) - 1;
    *(_DWORD*)(v2 + 4 * a2 + 52) = v4;
    v5 = v4;
    if (*(_DWORD*)(16 * a2 + this + 11624) < v4)
        v5 = *(_DWORD*)(16 * a2 + this + 11624);
    *(_DWORD*)(16 * a2 + this + 11624) = v5;
    ++*(_DWORD*)(this + 16 * (a2 + 727));
    if (*(_BYTE*)(this + 2552))
    {
        v6 = *(_DWORD*)(v2 + 4 * a2 + 52);
        if (v6 < 1)
        {
            *(_DWORD*)(v2 + 4 * a2 + 52) = 1;
            return result;
        }
    }
    else
    {
        v6 = *(int*)(v2 + 4 * a2 + 52) < 0 ? 0 : *(_DWORD*)(v2 + 4 * a2 + 52);
    }
    *(_DWORD*)(v2 + 4 * a2 + 52) = v6;
    return result;
}

//----- (00462A80) --------------------------------------------------------
int __thiscall sub_462A80(_DWORD* this, _BYTE* a2, _BYTE* a3)
{
    int i; // esi
    int result; // eax
    int v6; // edx
    int v7; // edx

    *a2 = 0;
    *a3 = 0;
    for (i = 0; ; ++i)
    {
        result = this[642];
        if (!result || i >= (unsigned int)((this[643] - result) >> 3))
            break;
        v6 = *(_DWORD*)(result + 8 * i);
        if (*(_DWORD*)(v6 + 292) == 2 && sub_4629B0((int)this, *(_DWORD*)(v6 + 296)))
            *a2 = 1;
        if (i > 0)
        {
            v7 = *(_DWORD*)(this[642] + 8 * i);
            if (*(_DWORD*)(v7 + 292) != 2)
            {
                if (sub_4629B0((int)this, *(_DWORD*)(v7 + 296)))
                    *a3 = 1;
            }
        }
    }
    return result;
}

//----- (00462B20) --------------------------------------------------------
_DWORD* __thiscall sub_462B20(_DWORD* this)
{
    _DWORD* result; // eax
    int v3; // ebp
    _DWORD* v4; // esi
    int v5; // eax
    double v6; // st7
    double v7; // st7
    int v8; // eax
    int v9; // ecx
    _DWORD* v10; // eax
    _DWORD* v11; // edx
    float v12; // [esp+8h] [ebp-B8h]
    float v13; // [esp+Ch] [ebp-B4h] BYREF
    float v14; // [esp+10h] [ebp-B0h]
    float v15; // [esp+14h] [ebp-ACh]
    _DWORD* v16; // [esp+18h] [ebp-A8h]
    int v17; // [esp+1Ch] [ebp-A4h] BYREF
    int v18; // [esp+20h] [ebp-A0h]
    int v19; // [esp+24h] [ebp-9Ch]
    _DWORD* v20; // [esp+28h] [ebp-98h]
    float v21; // [esp+2Ch] [ebp-94h]
    float v22; // [esp+30h] [ebp-90h]
    float v23; // [esp+34h] [ebp-8Ch]
    float v24; // [esp+38h] [ebp-88h]
    float v25; // [esp+3Ch] [ebp-84h]
    int v26[16]; // [esp+40h] [ebp-80h] BYREF
    int v27[16]; // [esp+80h] [ebp-40h] BYREF

    result = *(_DWORD**)(this[642] + 8 * this[645]);
    if ((int)result[202] >= 0 && (int)result[203] >= 0)
    {
        v3 = 0;
        result = this + 680;
        while (*(_BYTE*)result)
        {
            ++v3;
            result += 22;
            if (v3 >= 100)
                return result;
        }
        v17 = 0;
        v18 = 0;
        v4 = &this[22 * v3];
        v19 = 0;
        v16 = v4;
        v13 = 0.0;
        v4[700] = 1065353216;
        v20 = v4 + 680;
        v14 = 1.0;
        *((_BYTE*)v4 + 2720) = 1;
        v15 = 0.0;
        sub_406BE0(v27);
        v5 = *(_DWORD*)(this[642] + 8 * this[645]);
        sub_407690(*(_DWORD*)(v5 + 652), *(_DWORD*)(v5 + 812), v27);
        sub_46C5C5((float*)&v17, (float*)&v17, (float*)v27);
        sub_46B976(&v13, &v13, (float*)v27);
        v25 = fabs((double)rand() * 0.000030518509) * 0.73919827 - 0.36959913;
        v24 = fabs((double)rand() * 0.000030518509) * 0.73919827 - 0.36959913;
        v12 = fabs((double)rand() * 0.000030518509) * 0.73919827 - 0.36959913;
        sub_46C69B((float*)v26, v12, v24, v25);
        sub_46B976(&v13, &v13, (float*)v26);
        sub_46B970(&v13, &v13);
        v4 += 697;
        v21 = v13 * 50.0;
        v6 = v14 * 50.0;
        *(float*)v4 = v21;
        v22 = v6;
        v7 = v15 * 50.0;
        *((float*)v4 + 1) = v22;
        v23 = v7;
        *((float*)v4 + 2) = v23;
        v8 = *(_DWORD*)(this[642] + 8 * this[645]);
        v9 = *(_DWORD*)(v8 + 808);
        if (v9 >= 0)
            sub_407690(*(_DWORD*)(v8 + 652), v9, v27);
        qmemcpy(v26, v27, sizeof(v26));
        v26[12] = v17;
        v26[13] = v18;
        v26[14] = v19;
        qmemcpy(v16 + 681, v26, 0x40u);
        v10 = sub_409960((_DWORD*)dword_520970, (int)this);
        v11 = v20;
        v16[701] = v10;
        v10[10] = v11;
        return sub_462DD0(this, v3);
    }
    return result;
}
// 462B77: conditional instruction was optimized away because ebp.4<64
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);
// 520970: using guessed type int dword_520970;

//----- (00462DD0) --------------------------------------------------------
_DWORD* __thiscall sub_462DD0(_DWORD* this, int a2)
{
    int v3; // eax
    int v4; // ecx
    _DWORD* v5; // esi
    int v6; // eax
    _DWORD* v7; // ebx
    int v8; // ecx
    _DWORD* result; // eax
    int v10; // ecx
    int v11[16]; // [esp+Ch] [ebp-40h] BYREF

    memset(&v11[11], 0, 16);
    v3 = this[645];
    v4 = this[642];
    v5 = (_DWORD*)this[22 * a2 + 701];
    memset(&v11[6], 0, 16);
    memset(&v11[1], 0, 16);
    v11[15] = 1065353216;
    v11[10] = 1065353216;
    v11[5] = 1065353216;
    v11[0] = 1065353216;
    v6 = *(_DWORD*)(v4 + 8 * v3);
    v7 = &this[22 * a2];
    v8 = *(_DWORD*)(v6 + 808);
    if (v8 >= 0)
        sub_407690(*(_DWORD*)(v6 + 652), v8, v11);
    v5[7] = 1;
    v5[4] = v7[693];
    v5[5] = v7[694];
    v5[6] = v7[695];
    result = *(_DWORD**)(this[642] + 8 * this[645]);
    v10 = result[202];
    if (v10 >= 0)
        result = sub_4085F0(result[163], v10, v5 + 8, 0);
    v5[9] = 0;
    v5[3] = 2;
    return result;
}

//----- (00462F00) --------------------------------------------------------
int __thiscall sub_462F00(int this, int a2)
{
    int v3; // eax
    char v5; // [esp+0h] [ebp-4h]

    if (sub_408F30((_DWORD*)dword_520970) != this
        || *(_BYTE*)(this + 2584)
        || *(int*)(*(_DWORD*)(*(_DWORD*)(this + 2568) + 8 * *(_DWORD*)(this + 2580)) + 808) < 0)
    {
        return 0;
    }
    (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**)ArgList + 148))(
        *(_DWORD*)ArgList,
        256,
        *(_DWORD*)(a2 + 40) + 4);
    v3 = *(_DWORD*)(8 * *(_DWORD*)(this + 2580) + *(_DWORD*)(this + 2568));
    return sub_406110(*(_DWORD**)(v3 + 648), this, *(_DWORD*)(v3 + 808), 0, 0, v5);
}
// 462F79: variable 'v5' is possibly undefined
// 520970: using guessed type int dword_520970;

//----- (00462F90) --------------------------------------------------------
_DWORD* __thiscall sub_462F90(_DWORD* this)
{
    _DWORD* v1; // esi
    int v2; // ebp
    int v3; // edx
    int v4; // ebx
    int v5; // edx
    _DWORD* result; // eax
    _DWORD* v7; // ecx

    v1 = this + 586;
    v2 = 4;
    do
    {
        v3 = *v1;
        v4 = v1[1];
        memset(v1 - 1, 0, 0x34u);
        *v1 = v3;
        v1[1] = v4;
        (*(void(__thiscall**)(_DWORD, _DWORD))(*(_DWORD*)*v1 + 24))(*v1, 0);
        (*(void(__thiscall**)(_DWORD, _DWORD))(*(_DWORD*)v1[1] + 24))(v1[1], 0);
        v1 += 13;
        --v2;
    } while (v2);
    v5 = 4;
    this[131] = 0;
    result = this + 585;
    v7 = this + 220;
    do
    {
        *v7 = -1;
        *result = -1;
        result += 13;
        v7 += 88;
        --v5;
    } while (v5);
    this[129] = -1;
    return result;
}

//----- (00463020) --------------------------------------------------------
_DWORD* __thiscall sub_463020(_DWORD* this)
{
    _DWORD* v2; // ecx
    _DWORD* result; // eax
    int v4; // esi

    memset(this + 220, 0, 0x580u);
    this[130] = 0;
    v2 = this + 220;
    result = this + 585;
    v4 = 4;
    do
    {
        *v2 = -1;
        *result = -1;
        result += 13;
        v2 += 88;
        --v4;
    } while (v4);
    this[129] = -1;
    return result;
}

//----- (00463070) --------------------------------------------------------
int __thiscall sub_463070(_DWORD* this)
{
    _DWORD* v1; // edx
    int v2; // esi
    int result; // eax
    void* v4; // edi

    v1 = this + 231;
    v2 = 4;
    do
    {
        v1[1] = 0;
        result = 0;
        *v1 = 0;
        memset(v1 + 2, 0, 0x28u);
        v4 = v1 + 12;
        v1 += 88;
        --v2;
        memset(v4, 0, 0x100u);
    } while (v2);
    return result;
}

//----- (004630B0) --------------------------------------------------------
_DWORD* __thiscall sub_4630B0(_DWORD* this)
{
    _DWORD* result; // eax
    int v2; // ecx

    result = this + 231;
    v2 = 4;
    do
    {
        result[1] = 0;
        *result = 0;
        result += 88;
        --v2;
    } while (v2);
    return result;
}

//----- (004630D0) --------------------------------------------------------
int __thiscall sub_4630D0(char* this)
{
    int v1; // edx
    int result; // eax
    char* v3; // esi

    v1 = 0;
    result = *((_DWORD*)this + 130);
    if (result > 0)
    {
        v3 = this + 972;
        do
        {
            ++v1;
            memset(v3, 0, 0x100u);
            result = *((_DWORD*)this + 130);
            v3 += 352;
        } while (v1 < result);
    }
    return result;
}

//----- (00463110) --------------------------------------------------------
int __thiscall sub_463110(_DWORD* this)
{
    int result; // eax
    int v2; // edx

    result = 88 * this[128];
    v2 = (int)&this[result + 220];
    if (&this[result] != (_DWORD*)-880)
    {
        result = 0;
        *(_DWORD*)(v2 + 348) = 0;
        memset((void*)(v2 + 92), 0, 0x100u);
    }
    return result * 4;
}

//----- (00463150) --------------------------------------------------------
int __thiscall sub_463150(_DWORD* this)
{
    int result; // eax
    _DWORD* v2; // edx

    result = 0;
    if ((int)this[130] > 0)
    {
        v2 = this + 307;
        do
        {
            *v2 = 0;
            ++result;
            v2 += 88;
        } while (result < this[130]);
    }
    return result;
}

//----- (00463180) --------------------------------------------------------
int __thiscall sub_463180(_BYTE* this)
{
    char v2; // al
    char v3; // cl
    char* v4; // ebp
    _BYTE* v5; // ebx
    char v6; // cl
    char v7; // dl
    int v8; // eax
    char v9; // cl
    char* v10; // edx
    int result; // eax
    int v12; // edi
    _BYTE* v13; // esi
    char ArgList[4]; // [esp+10h] [ebp-9Ch]
    _BYTE* v15; // [esp+14h] [ebp-98h]
    __int16 v16[3]; // [esp+18h] [ebp-94h] BYREF
    char v17; // [esp+1Eh] [ebp-8Eh]
    char v18; // [esp+1Fh] [ebp-8Dh]
    char v19; // [esp+3Ch] [ebp-70h] BYREF

    v2 = this[520];
    v3 = this[524];
    v15 = this;
    v17 = v2;
    v18 = v3;
    sub_4229D0(aHostSendingLis);
    *(_DWORD*)ArgList = 0;
    v4 = &v19;
    v5 = this + 896;
    do
    {
        sub_4229D0("%d: %s", *(_DWORD*)ArgList, v5 + 3);
        v6 = *v5;
        v7 = v5[2];
        *((_DWORD*)v4 - 7) = *((_DWORD*)v5 - 2);
        v8 = *((_DWORD*)v5 - 1);
        *v4 = v6;
        v9 = *(v5 - 16);
        v4[1] = v7;
        *(_DWORD*)(v4 + 3) = v8;
        v4[2] = v9;
        v10 = v4 - 24;
        v5 += 352;
        v4 += 35;
        strcpy(v10, v5 + 3);
        ++*(_DWORD*)ArgList;
    } while (*(int*)ArgList < 4);
    v15[472] = 0;
    sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x601, v16, 148, 15, 0);
    sub_436E20(*(char**)(dword_520970 + 224));
    result = *((_DWORD*)v15 + 130);
    v12 = 0;
    if (result > 0)
    {
        v13 = v15 + 884;
        do
        {
            *(_DWORD*)v13 = sub_436E40(*(char**)(dword_520970 + 224), v13 + 15);
            result = *((_DWORD*)v15 + 130);
            ++v12;
            v13 += 352;
        } while (v12 < result);
    }
    return result;
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (004632B0) --------------------------------------------------------
char __thiscall sub_4632B0(int this, int ArgList)
{
    int v3; // eax
    int v4; // esi
    int v5; // eax
    int v6; // eax
    int v7; // eax
    int v8; // eax
    int v9; // edi
    unsigned int v10; // eax
    int v11; // ecx
    int v12; // edx
    int v13; // edx
    int v14; // eax
    int v15; // eax
    _BYTE* v16; // ebx
    int v17; // ecx
    int v18; // ecx
    int v19; // eax
    int v20; // edi
    int v21; // esi
    int v22; // eax
    int v23; // ecx
    int v24; // edi
    int v25; // esi
    int v26; // ebx
    char* v27; // edx
    int v28; // eax
    int v30; // [esp-8h] [ebp-20h]
    int v31; // [esp-4h] [ebp-1Ch]
    int i; // [esp+10h] [ebp-8h]
    int ArgListb; // [esp+1Ch] [ebp+4h]
    int ArgLista; // [esp+1Ch] [ebp+4h]

    v3 = *(unsigned __int16*)(ArgList + 12);
    v4 = *(_DWORD*)(ArgList + 16);
    if ((unsigned __int16)v3 > 0x605u)
    {
        v22 = v3 - 65281;
        if (v22)
        {
            v7 = v22 - 1;
            if (!v7)
            {
                v23 = *(_DWORD*)(this + 520);
                v24 = 0;
                if (v23 > 0)
                {
                    v7 = this + 888;
                    while (*(_DWORD*)v7 != *(_DWORD*)(*(_DWORD*)(v4 + 6) + 8))
                    {
                        ++v24;
                        v7 += 352;
                        if (v24 >= v23)
                            return v7;
                    }
                    if (v24 > -1)
                    {
                        v25 = 352 * v24 + this;
                        *(_BYTE*)(v25 + 898) = 0;
                        LOBYTE(v7) = *(_BYTE*)(dword_4F5CC4 + 936);
                        if ((_BYTE)v7)
                        {
                            sub_4229D0("Deleting player '%s'", (const char*)(v25 + 899));
                            v26 = v24;
                            if (v24 < *(_DWORD*)(this + 520) - 1)
                            {
                                v27 = (char*)(v25 + 1232);
                                do
                                {
                                    qmemcpy(v27 - 352, v27, 0x160u);
                                    memset(v27, 0, 0x160u);
                                    ++v26;
                                    v27 += 352;
                                } while (v26 < *(_DWORD*)(this + 520) - 1);
                            }
                            -- * (_DWORD*)(this + 520);
                            LOBYTE(v7) = sub_463180((_BYTE*)this);
                        }
                    }
                }
            }
        }
        else
        {
            LOBYTE(v7) = *(_BYTE*)(dword_4F5CC4 + 936);
            if ((_BYTE)v7)
            {
                v28 = *(_DWORD*)(this + 520);
                *(_DWORD*)(this + 520) = v28 + 1;
                *(_DWORD*)(352 * v28 + this + 888) = *(_DWORD*)(*(_DWORD*)(v4 + 6) + 8);
                strcpy((char*)(352 * v28 + this + 899), (const char*)(*(_DWORD*)(v4 + 6) + 12));
                *(_DWORD*)(352 * v28 + this + 924) = 0;
                *(_DWORD*)(352 * v28 + this + 928) = 0;
                *(_DWORD*)(352 * v28 + this + 1228) = 0;
                sub_4621B0((int*)this);
                LOBYTE(v7) = sub_463180((_BYTE*)this);
            }
        }
    }
    else if ((unsigned __int16)v3 == 1541)
    {
        LOBYTE(v7) = *(_BYTE*)(dword_4F5CC4 + 937);
        if ((_BYTE)v7)
            LOBYTE(v7) = sub_462520(
                (_DWORD*)this,
                *(_DWORD*)(*(_DWORD*)(this + 11780) + 4 * *(unsigned __int8*)(v4 + 6)),
                0);
    }
    else
    {
        v5 = v3 - 1537;
        if (v5)
        {
            v6 = v5 - 2;
            if (v6)
            {
                v7 = v6 - 1;
                if (!v7)
                {
                    v7 = sub_45E6F0((_DWORD*)this, *(_DWORD*)(ArgList + 4));
                    if (v7 > -1)
                    {
                        v30 = 352 * v7 + this + 899;
                        v8 = sub_436A90(*(_DWORD*)(dword_520970 + 224));
                        LOBYTE(v7) = sub_421190(v8, (char*)&dword_4A0090 + 32, v30, v4 + 6);
                    }
                }
            }
            else
            {
                v7 = *(_DWORD*)(v4 + 6);
                if (v7 >= 0)
                {
                    v9 = 352 * v7 + this + 880;
                    v31 = *(_DWORD*)(v4 + 14);
                    *(_DWORD*)(v9 + 348) = v31;
                    v10 = *(_DWORD*)(352 * v7 + this + 884);
                    ArgListb = *(int*)(v4 + 10);
                    *(float*)(v9 + 48) = *(float*)&ArgListb;
                    LOBYTE(v7) = sub_436EC0(*(_DWORD**)(dword_520970 + 224), v10, ArgListb, v31);
                    v11 = *(_DWORD*)v9;
                    if (*(int*)v9 > -1)
                    {
                        v7 = this + 4 * (v11 + 4 * (3 * v11 + 135) + 45);
                        if (v7)
                        {
                            *(_DWORD*)(v7 + 40) = *(_DWORD*)(this + 52 * v11 + 2372);
                            v12 = *(_DWORD*)(v7 + 36);
                            *(_DWORD*)(v7 + 44) = *(_DWORD*)(this + 52 * *(_DWORD*)v9 + 2368);
                            *(_DWORD*)(v7 + 48) = v12;
                            *(_DWORD*)(v7 + 32) = *(_DWORD*)(v4 + 18);
                            *(_DWORD*)(v7 + 28) = *(_DWORD*)(v4 + 22);
                            *(_DWORD*)(v7 + 36) = 0;
                        }
                    }
                }
            }
        }
        else
        {
            v13 = *(_DWORD*)(this + 524);
            *(_DWORD*)(this + 512) = -1;
            *(_DWORD*)(this + 516) = -1;
            *(_DWORD*)(this + 520) = *(char*)(v4 + 6);
            *(_BYTE*)(this + 472) = 0;
            v14 = *(unsigned __int8*)(v4 + 7);
            if (v13 != (char)v14)
            {
                if ((_BYTE)v14)
                    sub_45EA80(this, (char)v14);
                else
                    sub_462F90((_DWORD*)this);
            }
            ArgLista = 0;
            if (*(char*)(v4 + 6) > 0)
            {
                v15 = v4 + 36;
                v16 = (_BYTE*)(this + 896);
                for (i = v4 + 36; ; v15 = i)
                {
                    v17 = *(_DWORD*)(v15 - 28);
                    *((_DWORD*)v16 - 2) = v17;
                    if (v17 == *(_DWORD*)(dword_4F5CC4 + 84))
                    {
                        *(_DWORD*)(this + 512) = ArgLista;
                        *(_DWORD*)(this + 516) = *(char*)(v15 + 2);
                    }
                    *v16 = *(_BYTE*)v15;
                    v16[2] = *(_BYTE*)(v15 + 1);
                    *((_DWORD*)v16 - 1) = *(_DWORD*)(v15 + 3);
                    strcpy(v16 + 3, (const char*)(v15 - 24));
                    sub_4229D0("%d: %s", ArgLista, v16 + 3);
                    v18 = ArgLista;
                    *((_DWORD*)v16 - 3) = ArgLista;
                    v19 = *(char*)(i + 2);
                    *((_DWORD*)v16 - 4) = v19;
                    if (v19 > -1)
                        *(_DWORD*)(this + 4 * (v19 + 4 * (3 * v19 + 135) + 45)) = ArgLista;
                    v16 += 352;
                    ++ArgLista;
                    i += 35;
                    if (v18 + 1 >= *(char*)(v4 + 6))
                        break;
                }
            }
            sub_436E20(*(char**)(dword_520970 + 224));
            v7 = *(_DWORD*)(this + 520);
            v20 = 0;
            if (v7 > 0)
            {
                v21 = this + 884;
                do
                {
                    *(_DWORD*)v21 = sub_436E40(*(char**)(dword_520970 + 224), (const char*)(v21 + 15));
                    v7 = *(_DWORD*)(this + 520);
                    ++v20;
                    v21 += 352;
                } while (v20 < v7);
            }
        }
    }
    return v7;
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (00463710) --------------------------------------------------------
char __stdcall sub_463710(const char* a1)
{
    _DWORD* v1; // edx
    char result; // al
    _WORD v3[3]; // [esp+0h] [ebp-48h] BYREF
    char v4[66]; // [esp+6h] [ebp-42h] BYREF

    v1 = (_DWORD*)dword_4F5CC4;
    if (*(_BYTE*)(dword_4F5CC4 + 936) || (result = *(_BYTE*)(dword_4F5CC4 + 937)) != 0)
    {
        strcpy(v4, a1);
        return sub_4117A0(v1, (int**)0x604, v3, 70, 5, 10000);
    }
    return result;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (00463780) --------------------------------------------------------
unsigned int __thiscall sub_463780(_DWORD* this)
{
    int v2; // eax
    double v3; // st7
    int v4; // ecx
    double v5; // st6
    int v6; // eax
    int v7; // eax
    _WORD v9[3]; // [esp+4h] [ebp-1Ch] BYREF
    int v10; // [esp+Ah] [ebp-16h]
    int v11; // [esp+Eh] [ebp-12h]
    char ArgList[4]; // [esp+12h] [ebp-Eh]
    int v13; // [esp+16h] [ebp-Ah]
    int v14; // [esp+1Ah] [ebp-6h]

    v2 = *(_DWORD*)(*(_DWORD*)(dword_520970 + 236) + 76);
    if (v2)
        v3 = *(float*)(v2 + 256);
    else
        v3 = 100.0;
    v4 = this[128];
    if (v4 >= 0)
        v5 = *(float*)&this[88 * v4 + 231];
    else
        v5 = 0.0;
    if (v3 == 0.0)
        *(float*)&v11 = 0.0;
    else
        *(float*)&v11 = v5 / v3;
    if (v4 >= 0)
        v6 = this[88 * v4 + 307];
    else
        v6 = 0;
    *(_DWORD*)ArgList = v6;
    v7 = this[129];
    v10 = v4;
    if (v7 <= -1)
    {
        v13 = 0;
        v14 = 0;
    }
    else
    {
        v13 = this[13 * v7 + 593];
        v14 = this[13 * v7 + 592];
    }
    sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x603, v9, 26, 8, 1000);
    return sub_436EC0(*(_DWORD**)(dword_520970 + 224), this[88 * this[128] + 221], v11, *(int*)ArgList);
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (004638A0) --------------------------------------------------------
char* __thiscall sub_4638A0(int this, char* a2, unsigned int a3, _DWORD* a4)
{
    int v5; // edi
    char* result; // eax
    int v7; // edx
    unsigned int v8; // ecx
    int v9; // eax
    int v10; // eax
    _DWORD* v11; // ecx
    char* m; // eax
    _DWORD* v13; // eax
    unsigned int v14; // edx
    char* v15; // edi
    _DWORD* v16; // edx
    char* v17; // eax
    int v18; // ecx
    int v19; // eax
    int v20; // ebx
    char* v21; // edx
    char* v22; // ecx
    char* v23; // eax
    unsigned int j; // ebp
    char* v25; // ecx
    char* k; // eax
    int v27; // ebp
    _DWORD* v28; // edx
    char* i; // ecx
    _DWORD* v30; // ecx
    char* v31; // eax
    int v32; // edx
    int v34; // [esp+14h] [ebp-4h]
    _DWORD* v35; // [esp+20h] [ebp+8h]

    v5 = this;
    result = *(char**)(this + 8);
    if ((*(_DWORD*)(this + 12) - (int)result) >> 3 >= a3)
    {
        if ((result - a2) >> 3 >= a3)
        {
            if (a3)
            {
                v27 = 8 * a3;
                v28 = *(_DWORD**)(this + 8);
                for (i = &result[-8 * a3]; i != result; v28 += 2)
                {
                    if (v28)
                    {
                        *v28 = *(_DWORD*)i;
                        v28[1] = *((_DWORD*)i + 1);
                    }
                    i += 8;
                }
                v30 = *(_DWORD**)(v5 + 8);
                v31 = (char*)&v30[v27 / 0xFFFFFFFC];
                if (a2 != (char*)&v30[v27 / 0xFFFFFFFC])
                {
                    do
                    {
                        v32 = *((_DWORD*)v31 - 2);
                        v31 -= 8;
                        v30 -= 2;
                        *v30 = v32;
                        v30[1] = *((_DWORD*)v31 + 1);
                    } while (v31 != a2);
                }
                for (result = a2; result != &a2[v27]; result += 8)
                {
                    *(_DWORD*)result = *a4;
                    *((_DWORD*)result + 1) = a4[1];
                }
                *(_DWORD*)(v5 + 8) += v27;
            }
        }
        else
        {
            v20 = 8 * a3;
            v21 = &a2[8 * a3];
            if (a2 != result)
            {
                v22 = &v21[-v20];
                do
                {
                    if (v21)
                    {
                        *(_DWORD*)v21 = *(_DWORD*)v22;
                        *((_DWORD*)v21 + 1) = *((_DWORD*)v22 + 1);
                        v5 = this;
                    }
                    v22 += 8;
                    v21 += 8;
                } while (v22 != result);
            }
            v23 = *(char**)(v5 + 8);
            for (j = a3 - ((v23 - a2) >> 3); j; --j)
            {
                if (v23)
                {
                    *(_DWORD*)v23 = *a4;
                    *((_DWORD*)v23 + 1) = a4[1];
                }
                v23 += 8;
            }
            v25 = *(char**)(v5 + 8);
            for (k = a2; k != v25; k += 8)
            {
                *(_DWORD*)k = *a4;
                *((_DWORD*)k + 1) = a4[1];
            }
            result = (char*)(v20 + *(_DWORD*)(v5 + 8));
            *(_DWORD*)(v5 + 8) = result;
        }
    }
    else
    {
        v7 = *(_DWORD*)(this + 4);
        if (!v7 || (v8 = (int)&result[-v7] >> 3, a3 >= v8))
            v8 = a3;
        if (v7)
            v9 = (int)&result[-v7] >> 3;
        else
            v9 = 0;
        v10 = v8 + v9;
        v34 = v10;
        if (v10 < 0)
            v10 = 0;
        v35 = operator new(8 * v10);
        v11 = v35;
        for (m = *(char**)(v5 + 4); m != a2; v11 += 2)
        {
            if (v11)
            {
                *v11 = *(_DWORD*)m;
                v11[1] = *((_DWORD*)m + 1);
            }
            m += 8;
        }
        v13 = v11;
        if (a3)
        {
            v14 = a3;
            do
            {
                if (v13)
                {
                    *v13 = *a4;
                    v13[1] = a4[1];
                    v5 = this;
                }
                v13 += 2;
                --v14;
            } while (v14);
        }
        v15 = *(char**)(v5 + 8);
        v16 = &v11[2 * a3];
        if (a2 != v15)
        {
            v17 = a2;
            do
            {
                if (v16)
                {
                    *v16 = *(_DWORD*)v17;
                    v16[1] = *((_DWORD*)v17 + 1);
                }
                v17 += 8;
                v16 += 2;
            } while (v17 != v15);
        }
        sub_4885A6(*(LPVOID*)(this + 4));
        *(_DWORD*)(this + 12) = &v35[2 * v34];
        v18 = *(_DWORD*)(this + 4);
        if (v18)
        {
            v19 = *(_DWORD*)(this + 8);
            *(_DWORD*)(this + 4) = v35;
            result = (char*)&v35[2 * a3 + 2 * ((v19 - v18) >> 3)];
        }
        else
        {
            *(_DWORD*)(this + 4) = v35;
            result = (char*)&v35[2 * a3];
        }
        *(_DWORD*)(this + 8) = result;
    }
    return result;
}

//----- (00463AF0) --------------------------------------------------------
_DWORD* __thiscall sub_463AF0(_DWORD* this, _DWORD* a2, int* a3)
{
    int* v3; // edx
    _DWORD* result; // eax
    int* v5; // edi
    _DWORD* v6; // esi
    int v7; // ebx

    v3 = a3;
    result = a2;
    v5 = (int*)this[2];
    v6 = a2;
    if (a3 != v5)
    {
        do
        {
            v7 = *v3;
            v3 += 2;
            *v6 = v7;
            v6[1] = *(v3 - 1);
            v6 += 2;
        } while (v3 != v5);
    }
    this[2] = v6;
    return result;
}

//----- (00463B30) --------------------------------------------------------
_DWORD* __thiscall sub_463B30(
    _DWORD* this,
    _DWORD* a2,
    int a3,
    int a4,
    int a5,
    float a6,
    float a7,
    int a8,
    int a9,
    char* a10,
    int a11,
    int a12)
{
    char v13; // al
    char v14; // dl
    int v15; // ecx
    double v16; // st7
    char v18; // c3
    double v19; // st7
    int v20; // edi
    char* v21; // eax
    _DWORD* v22; // ecx
    int v23; // edx
    double v24; // st7
    double v25; // st7
    int v26; // ebp
    int i; // edi
    bool v28; // cl
    int v29; // eax
    int v30; // ecx
    int v31; // eax
    __int16 v32; // di
    __int16 v33; // dx
    __int16 v34; // bx

    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
    *((_BYTE*)this + 16) = 1;
    this[21] = 0;
    this[22] = 0;
    this[23] = 0;
    this[7] = a3;
    this[10] = a8;
    v13 = a11;
    this[8] = a4;
    *((_BYTE*)this + 49) = v13;
    this[9] = a5;
    v14 = (char)a10;
    this[11] = a9;
    v15 = a12;
    *this = &off_499BDC;
    *((_BYTE*)this + 48) = v14;
    this[13] = v15;
    this[5] = a2;
    if (a2)
        ++*a2;
    v16 = a7 * 0.25;
    *((float*)this + 20) = a6;
    *((float*)this + 18) = a7;
    *((float*)this + 15) = v16;
    *((float*)this + 14) = v16;
    this[19] = 0;
    this[16] = 0;
    if (v18)
        v19 = 1.0;
    else
        v19 = a6 / v16;
    v20 = (__int64)v19 + 1;
    this[17] = v20;
    v21 = (char*)operator new(16 * v20);
    if (v21)
    {
        if ((int)(__int64)v19 >= 0)
        {
            v22 = v21 + 8;
            v23 = (__int64)v19 + 1;
            do
            {
                *(v22 - 2) = 0;
                *(v22 - 1) = 0;
                *v22 = 0;
                v22 += 4;
                --v23;
            } while (v23);
        }
    }
    else
    {
        v21 = 0;
    }
    v24 = *((float*)this + 18);
    this[6] = v21;
    if (v24 == 0.0)
        v25 = 1.0;
    else
        v25 = *((float*)this + 20) / v24;
    v26 = 2 * (__int64)v25 + 4;
    a11 = v26 / 2;
    this[30] = v26 / 2;
    this[24] = operator new(4 * (v26 / 2));
    for (i = 0; i < this[30]; ++i)
    {
        *(_DWORD*)(this[24] + 4 * i) = sub_409960((_DWORD*)dword_520970, (int)this);
        if (*((_BYTE*)this + 48))
            *(_DWORD*)(*(_DWORD*)(this[24] + 4 * i) + 12) = 4;
        else
            *(_DWORD*)(*(_DWORD*)(this[24] + 4 * i) + 12) = 3;
        *(_DWORD*)(*(_DWORD*)(this[24] + 4 * i) + 28) = 0;
        *(_DWORD*)(*(_DWORD*)(this[24] + 4 * i) + 36) = this[5];
        *(_DWORD*)(*(_DWORD*)(this[24] + 4 * i) + 40) = i;
    }
    this[28] = 3 * v26;
    v28 = (*(int(__stdcall**)(_DWORD, int, int, int, int, _DWORD*))(**(_DWORD**)ArgList + 96))(
        *(_DWORD*)ArgList,
        6 * v26,
        8,
        101,
        1,
        this + 27) == 0;
    v29 = 2 * v26 + 2;
    this[26] = v29;
    if (v28)
        (*(void(__stdcall**)(_DWORD, int, int, int, int, _DWORD*))(**(_DWORD**)ArgList + 92))(
            *(_DWORD*)ArgList,
            24 * v29,
            8,
            322,
            1,
            this + 25);
    (*(void(__stdcall**)(_DWORD, _DWORD, int, char**, _DWORD))(*(_DWORD*)this[27] + 44))(
        this[27],
        0,
        2 * this[28],
        &a10,
        0);
    memset(a10, 0, 2 * this[28]);
    v30 = 0;
    if (a11 > 0)
    {
        v31 = 0;
        do
        {
            *(_WORD*)&a10[v31] = 2 * v30;
            v32 = 2 * v30 + 1;
            v33 = 2 * v30 + 3;
            *(_WORD*)&a10[v31 + 2] = v32;
            v34 = 2 * v30++ + 2;
            *(_WORD*)&a10[v31 + 4] = v34;
            *(_WORD*)&a10[v31 + 6] = v33;
            *(_WORD*)&a10[v31 + 8] = v34;
            *(_WORD*)&a10[v31 + 10] = v32;
            v31 += 12;
        } while (v30 < a11);
    }
    (*(void(__stdcall**)(_DWORD))(*(_DWORD*)this[27] + 48))(this[27]);
    return this;
}
// 463BE6: variable 'v18' is possibly undefined
// 499BDC: using guessed type _UNKNOWN *off_499BDC;
// 520970: using guessed type int dword_520970;

//----- (00463E00) --------------------------------------------------------
int __thiscall sub_463E00(void* this)
{
    int i; // edi
    int* v3; // ecx
    int v4; // eax
    int result; // eax

    *(_DWORD*)this = &off_499BDC;
    for (i = 0; i < *((_DWORD*)this + 30); ++i)
        sub_409A00(dword_520970, *(void**)(*((_DWORD*)this + 24) + 4 * i));
    v3 = (int*)*((_DWORD*)this + 5);
    if (v3)
    {
        sub_422230(v3);
        *((_DWORD*)this + 5) = 0;
    }
    sub_4885A6(*((LPVOID*)this + 6));
    sub_4885A6(*((LPVOID*)this + 24));
    v4 = *((_DWORD*)this + 25);
    if (v4)
    {
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)v4 + 8))(*((_DWORD*)this + 25));
        *((_DWORD*)this + 25) = 0;
    }
    result = *((_DWORD*)this + 27);
    if (result)
    {
        result = (*(int(__stdcall**)(_DWORD))(*(_DWORD*)result + 8))(*((_DWORD*)this + 27));
        *((_DWORD*)this + 27) = 0;
    }
    *(_DWORD*)this = &off_499040;
    return result;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 499BDC: using guessed type _UNKNOWN *off_499BDC;
// 520970: using guessed type int dword_520970;

//----- (00463EB0) --------------------------------------------------------
_DWORD* __thiscall sub_463EB0(_DWORD* this, float a2, _DWORD* a3)
{
    int v3; // edi
    _DWORD* v4; // eax
    _DWORD* result; // eax
    float* v6; // edx
    int v7; // esi
    float* v8; // ecx
    int v9; // edi
    double v10; // st7
    double v11; // st7
    double v12; // st7

    v3 = this[16];
    if (v3 == 1)
    {
        v4 = (_DWORD*)this[6];
        *a3 = *v4;
        a3[1] = v4[1];
        result = (_DWORD*)v4[2];
        a3[2] = result;
    }
    else
    {
        v6 = (float*)this[6];
        v7 = 0;
        v8 = v6 + 4;
        if (v6[7] < (double)a2)
        {
            v9 = v3 - 2;
            do
            {
                if (v7 == v9)
                    break;
                v10 = v8[7];
                v8 += 4;
                ++v7;
                v6 = v8 - 4;
            } while (v10 < a2);
        }
        v11 = v8[3] - v6[3];
        if (v11 == 0.0)
            v12 = 0.0;
        else
            v12 = (a2 - v6[3]) / v11;
        result = a3;
        *(float*)a3 = (*v8 - *v6) * v12 + *v6;
        *((float*)a3 + 1) = (v8[1] - v6[1]) * v12 + v6[1];
        *((float*)a3 + 2) = (v8[2] - v6[2]) * v12 + v6[2];
    }
    return result;
}

//----- (00463F60) --------------------------------------------------------
void __userpurge sub_463F60(int a1@<ecx>, int a2@<edi>, float a3)
{
    double v4; // st7
    int v5; // ecx
    int v6; // edx
    int v7; // eax
    double v8; // st7
    int v9; // eax
    double v10; // st7
    int v11; // ecx
    int v12; // eax
    _DWORD* v13; // ecx
    int v14; // eax
    int v15; // eax
    int v16; // eax
    float v17; // edx
    double v18; // st7
    double v19; // st7
    double v20; // st7
    double v21; // st6
    long double v22; // st6
    double v23; // st7
    double v24; // st6
    double v25; // st5
    double v26; // st4
    double v27; // st4
    double v28; // st3
    long double v29; // st2
    long double v30; // st2
    long double v31; // st4
    double v32; // st7
    long double v33; // st6
    long double v34; // st6
    bool v35; // zf
    long double v36; // st7
    double v37; // st6
    long double v38; // st7
    double v39; // st6
    unsigned int v40; // ecx
    double v41; // st6
    float* v42; // edx
    double v43; // st5
    float* v44; // eax
    float* v45; // eax
    float* v46; // eax
    int v47; // ecx
    int v48; // kr00_4
    int v49; // edx
    float* v50; // eax
    double v51; // st7
    double v52; // st7
    bool v53; // c3
    int v54; // eax
    double v55; // st7
    int v56; // [esp+14h] [ebp-64h] BYREF
    float* v57; // [esp+18h] [ebp-60h]
    float v58; // [esp+1Ch] [ebp-5Ch]
    float v59; // [esp+20h] [ebp-58h]
    float v60; // [esp+24h] [ebp-54h]
    int v61; // [esp+28h] [ebp-50h] BYREF
    float v62; // [esp+2Ch] [ebp-4Ch]
    float v63; // [esp+30h] [ebp-48h]
    float v64; // [esp+34h] [ebp-44h]
    float v65; // [esp+38h] [ebp-40h]
    int v66; // [esp+40h] [ebp-38h]
    float v67; // [esp+44h] [ebp-34h]
    float v68; // [esp+48h] [ebp-30h]
    float v69; // [esp+4Ch] [ebp-2Ch]
    float v70; // [esp+50h] [ebp-28h]
    float v71; // [esp+54h] [ebp-24h]
    int v72; // [esp+58h] [ebp-20h]
    float v73; // [esp+5Ch] [ebp-1Ch]
    float v74; // [esp+60h] [ebp-18h]
    int v75; // [esp+64h] [ebp-14h] BYREF
    float v76; // [esp+68h] [ebp-10h]
    float v77; // [esp+6Ch] [ebp-Ch]
    float v78; // [esp+70h] [ebp-8h]
    float v79; // [esp+74h] [ebp-4h]
    float retaddr; // [esp+78h] [ebp+0h]
    float v81; // [esp+80h] [ebp+8h]

    if ((a3 >= 0.0000099999997 || a3 <= -0.0000099999997) && sub_408F30((_DWORD*)dword_520970))
    {
        v4 = a3 + *(float*)(a1 + 76);
        *(float*)(a1 + 76) = v4;
        if (v4 > *(float*)(a1 + 80))
            *(_DWORD*)(a1 + 76) = *(_DWORD*)(a1 + 80);
        v5 = 0;
        if (*(int*)(a1 + 64) > 0)
        {
            v6 = 0;
            do
            {
                v7 = *(_DWORD*)(a1 + 24);
                v8 = a3 + *(float*)(v7 + v6 + 12);
                v9 = v6 + v7;
                ++v5;
                v6 += 16;
                *(float*)(v9 + 12) = v8;
            } while (v5 < *(_DWORD*)(a1 + 64));
        }
        v10 = a3 + *(float*)(a1 + 56);
        v11 = *(_DWORD*)(a1 + 64);
        *(float*)(a1 + 56) = v10;
        if (!v11 || v10 > *(float*)(a1 + 60))
        {
            v12 = *(_DWORD*)(a1 + 68);
            *(_DWORD*)(a1 + 56) = 0;
            if (v11 < v12)
                *(_DWORD*)(a1 + 64) = v11 + 1;
            memcpy((void*)(*(_DWORD*)(a1 + 24) + 16), *(const void**)(a1 + 24), 16 * (*(_DWORD*)(a1 + 64) + 0xFFFFFFF));
        }
        *(_DWORD*)(*(_DWORD*)(a1 + 24) + 12) = 0;
        v13 = *(_DWORD**)(a1 + 24);
        *v13 = *(_DWORD*)(a1 + 84);
        v13[1] = *(_DWORD*)(a1 + 88);
        v13[2] = *(_DWORD*)(a1 + 92);
        v14 = *(_DWORD*)(a1 + 100);
        v56 = 0;
        (*(void(__stdcall**)(int, _DWORD, int, int*, _DWORD, int))(*(_DWORD*)v14 + 44))(
            v14,
            0,
            24 * *(_DWORD*)(a1 + 104),
            &v56,
            0,
            a2);
        v15 = *(_DWORD*)(a1 + 104);
        v78 = 0.0;
        v79 = 0.0;
        retaddr = 0.0;
        memset(v57, 0, 4 * ((unsigned int)(24 * v15) >> 2));
        if (sub_408F30((_DWORD*)dword_520970))
        {
            v16 = sub_408F30((_DWORD*)dword_520970);
            v17 = *(float*)(v16 + 36);
            v78 = *(float*)(v16 + 32);
            v79 = v17;
            retaddr = *(float*)(v16 + 40);
        }
        *(_DWORD*)(a1 + 116) = 0;
        v81 = 0.0;
        while (1)
        {
            v18 = *(float*)(a1 + 80);
            if (v18 == 0.0)
                v58 = 0.0;
            else
                v58 = (*(float*)(a1 + 80) - *(float*)(a1 + 76) + v81) / v18;
            *(float*)&v61 = 0.0;
            v62 = 0.0;
            v63 = 0.0;
            *(float*)&v75 = 0.0;
            v76 = 0.0;
            v77 = 0.0;
            sub_463EB0((_DWORD*)a1, v81, &v61);
            v19 = v81 + *(float*)(a1 + 72);
            if (v19 <= *(float*)(a1 + 80))
                v19 = *(float*)(a1 + 80);
            v60 = v19;
            sub_463EB0((_DWORD*)a1, v60, &v75);
            if (*(_BYTE*)(a1 + 48))
            {
                v20 = *(float*)&v61 - v78;
                v72 = v61;
                v73 = v62 - v79;
                v21 = v63 - retaddr;
                v74 = v21;
                v22 = sqrt(v21 * v74 + v73 * v73 + v20 * v20);
                if (v22 >= 0.0000099999997 || v22 <= -0.0000099999997)
                    v59 = v22 == 0.0 ? 0.0 : 1.0 / v22;
                else
                    v59 = 1.0 / 1.0;
                v23 = v20 * v59;
                v24 = v73 * v59;
                v25 = v74 * v59;
            }
            else
            {
                v23 = 0.0;
                v24 = 0.0;
                v25 = 1.0;
            }
            v26 = *(float*)(a1 + 44) - *(float*)(a1 + 40);
            v67 = v76;
            v68 = v77;
            v66 = v75;
            v60 = v26 * v58 + *(float*)(a1 + 40);
            v27 = *(float*)&v75 - *(float*)&v61;
            v67 = v76 - v62;
            v28 = v77 - v63;
            v29 = sqrt(v67 * v67 + v28 * v28 + v27 * v27);
            if (v29 >= 0.0000099999997 || v29 <= -0.0000099999997)
                v30 = v29 == 0.0 ? 0.0 : 1.0 / v29;
            else
                v30 = 1.0 / 1.0;
            *(float*)&v66 = v30 * v27;
            v67 = v67 * v30;
            v31 = v28 * v30;
            v64 = v31 * v24 - v67 * v25;
            v65 = v25 * *(float*)&v66 - v31 * v23;
            v32 = v23 * v67 - v24 * *(float*)&v66;
            v33 = sqrt(v32 * v32 + v65 * v65 + v64 * v64);
            if (v33 >= 0.0000099999997 || v33 <= -0.0000099999997)
                v34 = v33 == 0.0 ? 0.0 : 1.0 / v33;
            else
                v34 = 1.0 / 1.0;
            v35 = *(_BYTE*)(a1 + 49) == 0;
            v64 = v34 * v64;
            v65 = v65 * v34;
            v36 = v32 * v34;
            v37 = v60 * 0.5;
            v64 = v37 * v64;
            v65 = v65 * v37;
            v38 = v36 * v37;
            v39 = 1.0;
            if (!v35)
                v39 = 1.0 - v58;
            v40 = (unsigned __int8)*(_DWORD*)(a1 + 36)
                | (((unsigned __int8)*(_DWORD*)(a1 + 32)
                    | (((unsigned __int8)*(_DWORD*)(a1 + 28) | ((unsigned int)(__int64)(v39 * 255.0) << 8)) << 8)) << 8);
            v41 = *(float*)(a1 + 52) == 0.0 ? v58 : v58 - *(float*)(dword_520970 + 72) * *(float*)(a1 + 52);
            v42 = v57;
            v43 = v64;
            *v57 = *(float*)&v61;
            v42[1] = v62;
            v42[2] = v63;
            v44 = v57;
            *v57 = v43 + *v57;
            v44[1] = v65 + v44[1];
            v44[2] = v38 + v44[2];
            v57[4] = 0.0;
            v57[5] = v41;
            *((_DWORD*)v57 + 3) = v40;
            v45 = v57 + 6;
            v57 = v45;
            *v45 = *(float*)&v61;
            v45[1] = v62;
            v45[2] = v63;
            v46 = v57;
            *v57 = *v57 - v64;
            v46[1] = v46[1] - v65;
            v46[2] = v46[2] - v38;
            v57[4] = 1.0;
            v57[5] = v41;
            *((_DWORD*)v57 + 3) = v40;
            v47 = *(_DWORD*)(a1 + 120);
            v57 += 6;
            v48 = *(_DWORD*)(a1 + 116);
            if (v48 / 2 < v47)
            {
                v70 = v62;
                v69 = *(float*)&v61;
                v49 = *(_DWORD*)(a1 + 96);
                v71 = v63;
                v50 = *(float**)(v49 + 4 * (v48 / 2));
                v70 = v62 + v76;
                v50 += 4;
                v71 = v63 + v77;
                v69 = (*(float*)&v75 + *(float*)&v61) * 0.5;
                v51 = v70 * 0.5;
                *v50 = v69;
                v70 = v51;
                v52 = v71 * 0.5;
                v50[1] = v70;
                v71 = v52;
                v50[2] = v71;
            }
            v53 = v81 == *(float*)(a1 + 76);
            v54 = *(_DWORD*)(a1 + 116) + 2;
            *(_DWORD*)(a1 + 116) = v54;
            if (v53)
                break;
            v55 = v81 + *(float*)(a1 + 72);
            v81 = v55;
            if (v55 > *(float*)(a1 + 76))
                v81 = *(float*)(a1 + 76);
        }
        *(_DWORD*)(a1 + 116) = v54 - 2;
        (*(void(__cdecl**)(_DWORD))(**(_DWORD**)(a1 + 100) + 48))(*(_DWORD*)(a1 + 100));
    }
}
// 463F60: could not find valid save-restore pair for edi
// 520970: using guessed type int dword_520970;

//----- (004645D0) --------------------------------------------------------
int __thiscall sub_4645D0(int* this, int a2)
{
    int v2; // edi
    int v4; // ecx
    _DWORD v6[16]; // [esp+8h] [ebp-40h] BYREF

    v2 = *(_DWORD*)(a2 + 40);
    v4 = 0;
    if (v2 < 0 || v2 >= this[29] / 2)
        return 0;
    if (this[27])
    {
        if (this[25])
        {
            memset(&v6[11], 0, 16);
            memset(&v6[6], 0, 16);
            memset(&v6[1], 0, 16);
            v6[15] = 1065353216;
            v6[10] = 1065353216;
            v6[5] = 1065353216;
            v6[0] = 1065353216;
            (*(void(__stdcall**)(_DWORD, int, _DWORD*))(**(_DWORD**)ArgList + 148))(*(_DWORD*)ArgList, 256, v6);
            sub_41BEF0((_DWORD*)dword_520A50, 0, this[5], 1, 0);
            sub_41BC00((_DWORD*)dword_520A50, 1, 1, 1, 1, 2, -1, 0);
            (*(void(__stdcall**)(_DWORD, int))(**(_DWORD**)ArgList + 304))(*(_DWORD*)ArgList, 322);
            (*(void(__stdcall**)(_DWORD, _DWORD, int, int))(**(_DWORD**)ArgList + 332))(
                *(_DWORD*)ArgList,
                0,
                this[25],
                24);
            (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**)ArgList + 340))(*(_DWORD*)ArgList, this[27], 0);
            (*(void(__stdcall**)(_DWORD, int, int, int, int, int))(**(_DWORD**)ArgList + 284))(
                *(_DWORD*)ArgList,
                4,
                2 * v2,
                4,
                6 * v2,
                2);
            v4 = 2;
            *(float*)dword_520A20 = *(float*)dword_520A20 + 1.0;
        }
    }
    return v4;
}
// 520A20: using guessed type int dword_520A20;
// 520A50: using guessed type int dword_520A50;

//----- (00464730) --------------------------------------------------------
_DWORD* __thiscall sub_464730(_DWORD* this)
{
    _DWORD* result; // eax

    result = this;
    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
    *((_BYTE*)this + 16) = 1;
    this[5] = 0;
    this[6] = 0;
    this[8] = 0;
    *this = &off_499C4C;
    this[7] = 0;
    return result;
}
// 499C4C: using guessed type _UNKNOWN *off_499C4C;

//----- (00464780) --------------------------------------------------------
void __thiscall sub_464780(_DWORD* this)
{
    _DWORD* v2; // ecx

    *this = &off_499C4C;
    v2 = (_DWORD*)this[7];
    if (v2)
    {
        sub_403B70(v2);
        this[7] = 0;
    }
    *this = &off_499040;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 499C4C: using guessed type _UNKNOWN *off_499C4C;

//----- (004647E0) --------------------------------------------------------
BOOL __thiscall sub_4647E0(_DWORD* this)
{
    return this[5] < 8;
}

//----- (004647F0) --------------------------------------------------------
int sub_4647F0()
{
    return 10;
}

//----- (00464800) --------------------------------------------------------
char* __stdcall sub_464800(int a1)
{
    return off_4AE3F8[a1];
}
// 4AE3F8: using guessed type char *off_4AE3F8[10];

//----- (00464810) --------------------------------------------------------
char __userpurge sub_464810@<al>(_DWORD* a1@<ecx>, int a2@<ebp>, int a3, int a4)
{
    void(__thiscall * **v6)(_DWORD, int); // ecx
    int v7; // ebp
    _DWORD* v8; // eax
    int v9; // eax
    char String1[32]; // [esp+4h] [ebp-A0h] BYREF
    char Buffer[128]; // [esp+24h] [ebp-80h] BYREF

    if (!sub_422BA0(AppName, aLoadsky, 1))
        return 1;
    if (a1[8])
    {
        sub_4286C0(a1, a1[8]);
        v6 = (void(__thiscall***)(_DWORD, int))a1[8];
        if (v6)
            (**v6)(v6, 1);
        a1[8] = 0;
    }
    sprintf(Buffer, "Sky%02d.pf3", a3);
    a1[7] = sub_4069C0(*(_DWORD*)(dword_520970 + 128), a2, Buffer);
    sprintf(String1, "cloud%02d", a3);
    v7 = sub_405A30((_DWORD*)a1[7], String1, -1, 1);
    a1[9] = sub_405A30((_DWORD*)a1[7], aClouddummy, -1, 1);
    if (a4 > 0)
    {
        sprintf(Buffer, "Clouds%d.tga", a4);
        sub_403BB0((_DWORD*)a1[7], v7, Buffer);
    }
    v8 = sub_406A90(a1[7], 0);
    a1[8] = v8;
    sub_408540(v8, 1);
    sub_428680(a1, a1[8]);
    v9 = sub_405A30((_DWORD*)a1[7], aSun, -1, 1);
    if (v9 > -1)
        sub_403C80((_DWORD*)a1[7], v9, 1);
    if (!a4)
        sub_408640((_DWORD*)a1[8], v7, 0);
    a1[5] = a3;
    a1[6] = a4;
    dword_4A4DD0 = dword_499BFC[a3];
    dword_4A4DD4 = dword_499C24[a1[5]];
    dword_4A4DD8 = SLODWORD(flt_4AE420[2 * a1[5]]);
    dword_4A4DDC = SLODWORD(flt_4AE424[2 * a1[5]]);
    sub_468E90(*(_DWORD***)(dword_520970 + 260), a1[5]);
    return 1;
}
// 499BFC: using guessed type int dword_499BFC[10];
// 499C24: using guessed type int dword_499C24[10];
// 4A4DD0: using guessed type int dword_4A4DD0;
// 4A4DD4: using guessed type int dword_4A4DD4;
// 4A4DD8: using guessed type int dword_4A4DD8;
// 4A4DDC: using guessed type int dword_4A4DDC;
// 4AE420: using guessed type float flt_4AE420[];
// 4AE424: using guessed type float flt_4AE424[19];
// 520970: using guessed type int dword_520970;

//----- (004649C0) --------------------------------------------------------
char __thiscall sub_4649C0(int this, int a2)
{
    int v3; // eax
    int* v4; // eax
    int v5; // edi
    int v6; // ebx
    int v7; // ebp
    int v8; // eax
    float v10; // [esp+0h] [ebp-8h]

    if (*(_DWORD*)(this + 32))
    {
        v3 = sub_408F30((_DWORD*)dword_520970);
        if (v3)
        {
            v4 = (int*)(v3 + 32);
            v5 = *v4;
            v6 = v4[1];
            v7 = v4[2];
            sub_4074B0(*(_DWORD**)(this + 32), 0);
            sub_407600(*(_DWORD**)(this + 32), 0, v5, v6, v7);
            v8 = *(_DWORD*)(this + 36);
            if (v8 > -1)
            {
                v10 = *(float*)&a2 * 0.5 * 0.017453292;
                sub_407560(*(_DWORD**)(this + 32), v8, v10);
            }
        }
    }
    return sub_428620((_DWORD*)this, a2);
}
// 520970: using guessed type int dword_520970;

//----- (00464A40) --------------------------------------------------------
int __thiscall sub_464A40(int this, int a2)
{
    if ((_BYTE)a2)
    {
        dword_4A4DD0 = dword_499BFC[*(_DWORD*)(this + 20)];
        dword_4A4DD4 = dword_499C24[*(_DWORD*)(this + 20)];
        dword_4A4DD8 = SLODWORD(flt_4AE420[2 * *(_DWORD*)(this + 20)]);
        dword_4A4DDC = SLODWORD(flt_4AE424[2 * *(_DWORD*)(this + 20)]);
    }
    return (*(int(__thiscall**)(_DWORD, int))(**(_DWORD**)(this + 32) + 24))(*(_DWORD*)(this + 32), a2);
}
// 499BFC: using guessed type int dword_499BFC[10];
// 499C24: using guessed type int dword_499C24[10];
// 4A4DD0: using guessed type int dword_4A4DD0;
// 4A4DD4: using guessed type int dword_4A4DD4;
// 4A4DD8: using guessed type int dword_4A4DD8;
// 4A4DDC: using guessed type int dword_4A4DDC;
// 4AE420: using guessed type float flt_4AE420[];
// 4AE424: using guessed type float flt_4AE424[19];

//----- (00464AA0) --------------------------------------------------------
int __usercall sub_464AA0@<eax>(_DWORD* a1@<ecx>, int a2@<ebp>)
{
    sub_464AE0((int)a1, a2);
    return sub_4690E0(a1);
}

//----- (00464AC0) --------------------------------------------------------
int __thiscall sub_464AC0(_DWORD* this)
{
    sub_464BB0(this);
    return sub_469120(this);
}

//----- (00464AE0) --------------------------------------------------------
char __usercall sub_464AE0@<al>(int a1@<ecx>, int a2@<ebp>)
{
    int v3; // eax
    char* v4; // eax
    _DWORD* v5; // eax
    _DWORD* v6; // eax

    v3 = *(_DWORD*)(a1 + 560);
    if (!v3)
    {
        v4 = sub_4069C0(*(_DWORD*)(dword_520970 + 128), a2, (char*)(a1 + 300));
        *(_DWORD*)(a1 + 560) = v4;
        sub_4282E0(v4 != 0, "failed to load model %s, see file %s", (const char*)(a1 + 300), (const char*)(a1 + 16));
        if (*(_BYTE*)(a1 + 564))
        {
            v5 = sub_422400(*(_DWORD**)(dword_520970 + 124), (char*)(a1 + 564), 0);
            *(_DWORD*)(a1 + 1084) = v5;
            sub_4282E0(v5 != 0, "failed to find texture %s, see file %s", (const char*)(a1 + 564), (const char*)(a1 + 16));
        }
        LOBYTE(v3) = *(_BYTE*)(a1 + 824);
        if ((_BYTE)v3)
        {
            v6 = sub_422400(*(_DWORD**)(dword_520970 + 124), (char*)(a1 + 824), 0);
            *(_DWORD*)(a1 + 1088) = v6;
            LOBYTE(v3) = sub_4282E0(
                v6 != 0,
                "failed to load texture %s, see file %s",
                (const char*)(a1 + 824),
                (const char*)(a1 + 16));
        }
    }
    return v3;
}
// 520970: using guessed type int dword_520970;

//----- (00464BB0) --------------------------------------------------------
void __thiscall sub_464BB0(_DWORD* this)
{
    _DWORD* v2; // ecx
    int* v3; // ecx
    int* v4; // ecx

    v2 = (_DWORD*)this[140];
    if (v2)
    {
        sub_403B70(v2);
        v3 = (int*)this[271];
        this[140] = 0;
        if (v3)
        {
            sub_422230(v3);
            this[271] = 0;
        }
        v4 = (int*)this[272];
        if (v4)
        {
            sub_422230(v4);
            this[272] = 0;
        }
    }
}

//----- (00464C00) --------------------------------------------------------
int __thiscall sub_464C00(_DWORD* this)
{
    *this = &off_499C6C;
    sub_464BB0(this);
    nullsub_1(this + 318);
    nullsub_1(this + 315);
    return sub_4690A0(this);
}
// 415760: using guessed type int __thiscall nullsub_1(_DWORD);
// 499C6C: using guessed type _UNKNOWN *off_499C6C;

//----- (00464C90) --------------------------------------------------------
_DWORD* __thiscall sub_464C90(_DWORD* this, int a2)
{
    const char* v3; // eax
    const char* v4; // eax
    char* v5; // ecx
    int v6; // esi
    _DWORD* v7; // ecx
    int v8; // eax
    int v9; // edi
    _DWORD* v10; // esi
    int* v11; // eax
    char* v12; // eax
    int v13; // esi
    unsigned int* v14; // eax
    unsigned int v15; // kr20_4
    char* v16; // esi
    unsigned int v17; // ecx
    int v18; // esi
    int* v19; // eax
    int v20; // esi
    int* v21; // eax
    int v22; // esi
    int* v23; // eax
    int v24; // esi
    int* v25; // eax
    int v26; // esi
    int* v27; // eax
    int v28; // esi
    int* v29; // eax
    int v30; // esi
    int v31; // eax
    int v32; // esi
    _DWORD* v33; // eax
    int v34; // esi
    _DWORD* v35; // eax
    int v36; // esi
    const char* v37; // esi
    const char* v38; // edx
    int v39; // eax
    int v40; // edi
    int v41; // eax
    int v42; // edi
    int v43; // eax
    int v44; // edi
    const char* v45; // edx
    int v46; // edx
    int v47; // ecx
    int v48; // esi
    _DWORD* v49; // eax
    int v50; // edi
    _BYTE* v51; // eax
    int v52; // edi
    _BYTE* v53; // eax
    int v54; // edi
    int* v55; // ecx
    int v56; // eax
    _DWORD* v57; // eax
    _DWORD* v58; // esi
    _DWORD* v59; // eax
    const char* v60; // edi
    _DWORD* v61; // ebx
    char* v62; // edx
    double v63; // st7
    double v64; // st7
    int* v66; // [esp+Ch] [ebp-130h] BYREF
    char* String1; // [esp+10h] [ebp-12Ch] BYREF
    int v68; // [esp+14h] [ebp-128h]
    char v69; // [esp+1Bh] [ebp-121h] BYREF
    const char* v70; // [esp+1Ch] [ebp-120h]
    int v71; // [esp+20h] [ebp-11Ch] BYREF
    int v72; // [esp+24h] [ebp-118h] BYREF
    int v73; // [esp+28h] [ebp-114h]
    _DWORD* v74; // [esp+2Ch] [ebp-110h]
    char Str[256]; // [esp+30h] [ebp-10Ch] BYREF
    int v76; // [esp+138h] [ebp-4h]

    v74 = this;
    sub_468FF0(this, (char*)a2);
    v76 = 1;
    Iostream_init::Iostream_init((Iostream_init*)(this + 315));
    Iostream_init::Iostream_init((Iostream_init*)(this + 318));
    *this = &off_499C6C;
    v70 = (const char*)(a2 + 16);
    v3 = (const char*)this[1];
    LOBYTE(v76) = 2;
    sub_4229D0("Started to load %s in %s", v3, (const char*)(a2 + 16));
    this[73] = 1065353216;
    if (sub_40ABC0((_DWORD*)a2, aUnitvalue, 0))
        sub_40AF60((const char*)a2, aUnitvalue, (float*)this + 73);
    sub_40AFC0((void*)a2, aScoringgroup, &String1);
    v4 = sub_462480(*(_DWORD**)(dword_520970 + 280), String1);
    v5 = String1;
    this[74] = v4;
    sub_4282E0(v4 != 0, "Tank type %s: couldn't find scoring groups %s", (const char*)this[1], v5);
    sub_40AFC0((void*)a2, aModelfile, &String1);
    strcpy((char*)this + 300, String1);
    this[140] = 0;
    strcpy((char*)this + 564, AppName);
    strcpy((char*)this + 824, AppName);
    this[271] = 0;
    this[272] = 0;
    if (!sub_46A3A0(*(_BYTE**)(dword_520970 + 200), (LPCSTR)this + 300))
        sub_464AE0((int)this, (int)this);
    v6 = 0;
    String1 = 0;
    if (!sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v7 = (_DWORD*)this[140];
        if ((int)v7[2] > 0)
        {
            while (1)
            {
                v8 = sub_403CB0(v7, v6);
                v9 = v8;
                if (v8)
                {
                    if (strstr(*(const char**)(v8 + 12), a512))
                        break;
                }
                v7 = (_DWORD*)this[140];
                if (++v6 >= v7[2])
                    goto LABEL_12;
            }
            String1 = *(char**)(v9 + 12);
        }
    }
LABEL_12:
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v10 = *(_DWORD**)(dword_520970 + 200);
        v11 = (int*)sub_46A4A0(v10, 4);
        v12 = (char*)sub_46A4A0(v10, *v11);
    }
    else
    {
        v13 = *(_DWORD*)(dword_520970 + 200);
        v66 = (int*)(strlen(String1) + 1);
        v14 = (unsigned int*)sub_46A4C0(v13, &v66, 4u);
        v12 = (char*)sub_46A4C0(v13, String1, *v14);
    }
    String1 = v12;
    strcpy((char*)this + 564, v12);
    strcpy(Str, v12);
    *strchr(Str, 95) = 0;
    strcat(Str, aCharred512Tga);
    v15 = strlen(Str) + 1;
    qmemcpy(this + 206, Str, 4 * (v15 >> 2));
    v16 = &Str[4 * (v15 >> 2)];
    v17 = v15 & 3;
    qmemcpy(&this[(v15 >> 2) + 206], v16, v17);
    v18 = (int)&v16[v17];
    if (!sub_46A490(*(_BYTE**)(dword_520970 + 200)))
        sub_4066C0(
            (_DWORD*)this[140],
            v18,
            this + 276,
            (float*)this + 273,
            (float*)this + 277,
            (float*)this + 274,
            (float*)this + 278,
            (float*)this + 275);
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v19 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v20 = *(_DWORD*)(dword_520970 + 200);
        v66 = (int*)(__int64)*((float*)this + 276);
        v19 = (int*)sub_46A4C0(v20, &v66, 4u);
    }
    v68 = *v19;
    *((float*)this + 276) = (float)v68;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v21 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v22 = *(_DWORD*)(dword_520970 + 200);
        v66 = (int*)(__int64)*((float*)this + 277);
        v21 = (int*)sub_46A4C0(v22, &v66, 4u);
    }
    v68 = *v21;
    *((float*)this + 277) = (float)v68;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v23 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v24 = *(_DWORD*)(dword_520970 + 200);
        v66 = (int*)(__int64)*((float*)this + 278);
        v23 = (int*)sub_46A4C0(v24, &v66, 4u);
    }
    v68 = *v23;
    *((float*)this + 278) = (float)v68;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v25 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v26 = *(_DWORD*)(dword_520970 + 200);
        v66 = (int*)(__int64)*((float*)this + 273);
        v25 = (int*)sub_46A4C0(v26, &v66, 4u);
    }
    v68 = *v25;
    *((float*)this + 273) = (float)v68;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v27 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v28 = *(_DWORD*)(dword_520970 + 200);
        v66 = (int*)(__int64)*((float*)this + 274);
        v27 = (int*)sub_46A4C0(v28, &v66, 4u);
    }
    v68 = *v27;
    *((float*)this + 274) = (float)v68;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v29 = (int*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v30 = *(_DWORD*)(dword_520970 + 200);
        v66 = (int*)(__int64)*((float*)this + 275);
        v29 = (int*)sub_46A4C0(v30, &v66, 4u);
    }
    v68 = *v29;
    *((float*)this + 275) = (float)v68;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v31 = *(_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v32 = *(_DWORD*)(dword_520970 + 200);
        v66 = (int*)sub_405A30((_DWORD*)this[140], aBase, -1, 1);
        v31 = *(_DWORD*)sub_46A4C0(v32, &v66, 4u);
    }
    this[279] = v31;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v33 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v34 = *(_DWORD*)(dword_520970 + 200);
        v66 = (int*)sub_405A30((_DWORD*)this[140], aTurret, -1, 1);
        v33 = (_DWORD*)sub_46A4C0(v34, &v66, 4u);
    }
    this[282] = *v33;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v35 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v36 = *(_DWORD*)(dword_520970 + 200);
        v66 = (int*)sub_405A30((_DWORD*)this[140], aBarrel, -1, 1);
        v35 = (_DWORD*)sub_46A4C0(v36, &v66, 4u);
    }
    v37 = v70;
    v38 = (const char*)this[1];
    this[285] = *v35;
    sub_40A120(this[279] != -1, "%s, see %s : %s", aCouldNotFindBa, v38, v37);
    sub_40A120(this[282] != -1, "%s, see %s : %s", aCouldNotFindTu, (const char*)this[1], v37);
    sub_40A120(this[285] != -1, "%s, see %s : %s", aCouldNotFindBa_0, (const char*)this[1], v37);
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v39 = *(_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v40 = *(_DWORD*)(dword_520970 + 200);
        v66 = (int*)sub_405A30((_DWORD*)this[140], asc_4A6264, this[279], 0);
        v39 = *(_DWORD*)sub_46A4C0(v40, &v66, 4u);
    }
    this[280] = v39;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v41 = *(_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v42 = *(_DWORD*)(dword_520970 + 200);
        v66 = (int*)sub_405A30((_DWORD*)this[140], asc_4A6264, this[282], 0);
        v41 = *(_DWORD*)sub_46A4C0(v42, &v66, 4u);
    }
    this[283] = v41;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v43 = *(_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v44 = *(_DWORD*)(dword_520970 + 200);
        v66 = (int*)sub_405A30((_DWORD*)this[140], asc_4A6264, this[285], 0);
        v43 = *(_DWORD*)sub_46A4C0(v44, &v66, 4u);
    }
    v45 = (const char*)this[1];
    this[286] = v43;
    sub_40A120(this[280] != -1, "%s, see %s : %s", aCouldNotFindBa_1, v45, v37);
    sub_40A120(this[283] != -1, "%s, see %s : %s", aCouldNotFindTu_0, (const char*)this[1], v37);
    sub_40A120(this[286] != -1, "%s, see %s : %s", aCouldNotFindBa_2, (const char*)this[1], v37);
    sub_40AF60((const char*)a2, aHealth, (float*)&v71);
    v46 = v71;
    this[281] = v71;
    this[284] = v46;
    this[287] = v46;
    this[288] = -1;
    this[289] = -1;
    v73 = 0;
    if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
    {
        v68 = *(_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
    }
    else
    {
        v47 = *(_DWORD*)(dword_520970 + 200);
        v66 = *(int**)(this[140] + 8);
        v68 = *(_DWORD*)sub_46A4C0(v47, &v66, 4u);
    }
    v48 = this[285] + 1;
    if (v48 < v68)
    {
        v66 = this + 288;
        do
        {
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v49 = (_DWORD*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v50 = *(_DWORD*)(dword_520970 + 200);
                v72 = sub_405BB0((_DWORD*)this[140], v48);
                v49 = (_DWORD*)sub_46A4C0(v50, &v72, 4u);
            }
            if (*v49 < this[285])
                break;
            if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
            {
                v51 = (_BYTE*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
            }
            else
            {
                v52 = *(_DWORD*)(dword_520970 + 200);
                v69 = sub_405BE0((_DWORD*)this[140], v48);
                v51 = (_BYTE*)sub_46A4C0(v52, &v69, 4u);
            }
            if (!*v51)
            {
                if (sub_46A490(*(_BYTE**)(dword_520970 + 200)))
                {
                    v53 = (_BYTE*)sub_46A4A0(*(_DWORD**)(dword_520970 + 200), 4);
                }
                else
                {
                    v54 = *(_DWORD*)(dword_520970 + 200);
                    v69 = sub_405C00((_DWORD*)this[140], v48);
                    v53 = (_BYTE*)sub_46A4C0(v54, &v69, 4u);
                }
                if (!*v53)
                {
                    v55 = v66;
                    v56 = v73 + 1;
                    *v66 = v48;
                    v73 = v56;
                    v66 = v55 + 1;
                    if (v56 >= 2)
                        break;
                }
            }
            ++v48;
        } while (v48 < v68);
    }
    sub_40AF60((const char*)a2, aLifetime, (float*)this + 290);
    sub_40AF60((const char*)a2, aFadetime, (float*)this + 291);
    sub_40AF60((const char*)a2, aSpeed, (float*)this + 293);
    sub_40B1B0((const char*)a2, aRange, (float*)this + 294);
    sub_40AF60((const char*)a2, aPathsegmenttim, (float*)this + 298);
    sub_40AF60((const char*)a2, aPathsegmentvar, (float*)this + 299);
    *((float*)this + 299) = *((float*)this + 299) * 0.017453292;
    sub_40B1B0((const char*)a2, aTimetillpause, (float*)this + 300);
    sub_40B1B0((const char*)a2, aPausetime, (float*)this + 302);
    sub_40AF60((const char*)a2, aPausespeed, (float*)this + 304);
    *((float*)this + 292) = *((float*)this + 298) * 5.0;
    if (sub_40ABC0((_DWORD*)a2, aTimebetweenlau, 0))
        sub_40AF60((const char*)a2, aTimebetweenlau, (float*)this + 292);
    v57 = operator new(0x148u);
    v58 = v57;
    v72 = (int)v57;
    LOBYTE(v76) = 3;
    if (v57)
    {
        sub_468FA0((int)v57);
        *v58 = &off_499224;
        v59 = v58;
    }
    else
    {
        v59 = 0;
    }
    v60 = v70;
    v61 = this + 305;
    this[305] = v59;
    v59[3] = aPath;
    v62 = (char*)(this[305] + 16);
    LOBYTE(v76) = 2;
    strcpy(v62, v60);
    *(_DWORD*)(*v61 + 292) = this[293];
    *(_DWORD*)(*v61 + 296) = this[298];
    *(_DWORD*)(*v61 + 300) = this[299];
    *(_DWORD*)(*v61 + 304) = 0;
    *(_DWORD*)(*v61 + 308) = this[294];
    *(_DWORD*)(*v61 + 312) = this[295];
    *(_DWORD*)(*v61 + 316) = 0;
    *(_DWORD*)(*v61 + 320) = 0;
    *(_BYTE*)(*v61 + 324) = 1;
    sub_469700(*(_DWORD**)(dword_520970 + 200), this[305], aCustomPath);
    sub_469160((int)this, this + 305, 0, 0);
    this[306] = 0;
    if (sub_40ABC0((_DWORD*)a2, aTurretexplodee, 0))
    {
        sub_40AFC0((void*)a2, aTurretexplodee, &String1);
        sub_469160((int)this, this + 306, String1, aEffect);
    }
    this[307] = 0;
    if (sub_40ABC0((_DWORD*)a2, aBaseexplodeeff, 0))
    {
        sub_40AFC0((void*)a2, aBaseexplodeeff, &String1);
        sub_469160((int)this, this + 307, String1, aEffect);
    }
    this[308] = 0;
    if (sub_40ABC0((_DWORD*)a2, aTotallyexplode, 0))
    {
        sub_40AFC0((void*)a2, aTotallyexplode, &String1);
        sub_469160((int)this, this + 308, String1, aEffect);
    }
    this[309] = 0;
    if (sub_40ABC0((_DWORD*)a2, aEnginesound, 0))
    {
        sub_40AFC0((void*)a2, aEnginesound, &String1);
        sub_469160((int)this, this + 309, String1, aSoundEffect);
    }
    this[310] = 0;
    if (sub_40ABC0((_DWORD*)a2, aIdlesound, 0))
    {
        sub_40AFC0((void*)a2, aIdlesound, &String1);
        sub_469160((int)this, this + 310, String1, aSoundEffect);
    }
    this[311] = 0;
    if (sub_40ABC0((_DWORD*)a2, aEnginedying, 0))
    {
        sub_40AFC0((void*)a2, aEnginedying, &String1);
        sub_469160((int)this, this + 311, String1, aEffect);
    }
    sub_40AFC0((void*)a2, aBullettype, &String1);
    sub_469160((int)this, this + 312, String1, aBullet);
    sub_40AF60((const char*)a2, aRof, (float*)this + 313);
    v63 = *((float*)this + 313);
    if (v63 == 0.0)
        v64 = 0.0;
    else
        v64 = 60.0 / v63;
    *((float*)this + 313) = v64;
    sub_40AF60((const char*)a2, aVelocity, (float*)this + 314);
    sub_40AF60((const char*)a2, aTurnrate, (float*)this + 321);
    *((float*)this + 321) = 6.2831855 / *((float*)this + 321);
    sub_41C310((int)(this + 315), 0.0, 6.2831855);
    sub_41C310((int)(this + 318), 0.0, 6.2831855);
    this[322] = 0;
    if (sub_40ABC0((_DWORD*)a2, aFireeffect, 0))
    {
        sub_40AFC0((void*)a2, aFireeffect, &String1);
        sub_469160((int)this, this + 322, String1, aEffect);
    }
    sub_464BB0(this);
    sub_4229D0("Finished loading %s in %s", (const char*)this[1], v70);
    return this;
}
// 499224: using guessed type _UNKNOWN *off_499224;
// 499C6C: using guessed type _UNKNOWN *off_499C6C;
// 520970: using guessed type int dword_520970;

//----- (00465C10) --------------------------------------------------------
int __fastcall sub_465C10(int a1)
{
    int result; // eax

    result = a1;
    *(_DWORD*)(a1 + 4) = 0;
    *(_DWORD*)(a1 + 8) = 0;
    *(_DWORD*)(a1 + 12) = 0;
    *(_BYTE*)(a1 + 16) = 1;
    *(_BYTE*)(a1 + 20) = HIBYTE(a1);
    *(_DWORD*)(a1 + 24) = 0;
    *(_DWORD*)(a1 + 28) = 0;
    *(_DWORD*)(a1 + 32) = 0;
    *(_DWORD*)a1 = &off_499C78;
    return result;
}
// 499C78: using guessed type _UNKNOWN *off_499C78;

//----- (00465C60) --------------------------------------------------------
int __thiscall sub_465C60(LPVOID* this)
{
    int result; // eax

    *this = &off_499C78;
    sub_411430((_DWORD*)dword_4F5CC4, (int)this);
    sub_4885A6(this[6]);
    result = 0;
    this[6] = 0;
    this[7] = 0;
    this[8] = 0;
    *this = &off_499040;
    return result;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 499C78: using guessed type _UNKNOWN *off_499C78;
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (00465CD0) --------------------------------------------------------
char __thiscall sub_465CD0(void* this)
{
    sub_4113F0((_DWORD*)dword_4F5CC4, (int)this, 65280, 2048, 0);
    return 1;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (00465CF0) --------------------------------------------------------
int __thiscall sub_465CF0(_DWORD* this, int* a2, int* a3, int a4, float* a5)
{
    int result; // eax
    unsigned int i; // esi
    int v8; // ecx

    result = 0;
    for (i = 0; ; ++i)
    {
        v8 = this[6];
        if (!v8)
            break;
        if (i >= (this[7] - v8) >> 2)
            break;
        if (*(_BYTE*)(*(_DWORD*)(v8 + 4 * i) + 16))
        {
            result = sub_466410(*(_DWORD*)(v8 + 4 * i), a2, a3, a4, a5);
            if (result)
                break;
        }
    }
    return result;
}

//----- (00465D40) --------------------------------------------------------
int __thiscall sub_465D40(_DWORD* this, int* a2, float a3, float a4, char a5, int a6)
{
    unsigned int i; // edi
    int result; // eax
    int v9; // ecx

    for (i = 0; ; ++i)
    {
        result = this[6];
        if (!result || i >= (this[7] - result) >> 2)
            break;
        v9 = *(_DWORD*)(result + 4 * i);
        if (*(_BYTE*)(v9 + 16))
            sub_4665E0(v9, a2, a3, a4, a5, a6);
    }
    return result;
}

//----- (00465D90) --------------------------------------------------------
int __thiscall sub_465D90(_DWORD* this, int a2)
{
    int result; // eax
    int v3; // edx

    if (*(_WORD*)(a2 + 12) == 2049)
        return sub_465E00(
            this,
            *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(dword_520970 + 200) + 20) + 4 * *(_DWORD*)(*(_DWORD*)(a2 + 16) + 6)),
            *(_DWORD*)(*(_DWORD*)(a2 + 16) + 10));
    result = *(__int16*)(*(_DWORD*)(a2 + 16) + 6);
    if (result >= 0)
    {
        v3 = this[6];
        if (v3)
        {
            if (result < (unsigned int)((this[7] - v3) >> 2))
                return (*(int(__thiscall**)(_DWORD, int))(**(_DWORD**)(v3 + 4 * result) + 28))(
                    *(_DWORD*)(v3 + 4 * result),
                    a2);
        }
    }
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (00465E00) --------------------------------------------------------
int __thiscall sub_465E00(_DWORD* this, int a2, int a3)
{
    _DWORD* v4; // eax
    int v5; // edi
    _DWORD* v6; // eax
    _DWORD* v7; // edx
    int v9[2]; // [esp+8h] [ebp-24h] BYREF
    _WORD v10[3]; // [esp+10h] [ebp-1Ch] BYREF
    int v11; // [esp+16h] [ebp-16h]
    int v12; // [esp+1Ah] [ebp-12h]
    int v13; // [esp+28h] [ebp-4h]

    v4 = operator new(0x550u);
    v9[1] = (int)v4;
    v13 = 0;
    if (v4)
    {
        v5 = this[6];
        if (v5)
            v6 = sub_465FF0(v4, a2, (this[7] - v5) >> 2);
        else
            v6 = sub_465FF0(v4, a2, 0);
    }
    else
    {
        v6 = 0;
    }
    v7 = (_DWORD*)this[7];
    v9[0] = (int)v6;
    v13 = -1;
    sub_44F190((int)(this + 5), v7, 1u, v9);
    sub_466AA0(v9[0]);
    sub_428680(this, v9[0]);
    if (a3 <= -1)
    {
        *(_BYTE*)(v9[0] + 436) = 1;
    }
    else
    {
        *(_BYTE*)(v9[0] + 436) = 0;
        sub_4431F0(*(_DWORD**)(dword_520970 + 212), a3, v9[0]);
    }
    if (*(_BYTE*)(dword_4F5CC4 + 936))
    {
        v11 = *(_DWORD*)(a2 + 8);
        v12 = a3;
        sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x801, v10, 14, 15, 0);
    }
    return v9[0];
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (00465F20) --------------------------------------------------------
int __thiscall sub_465F20(_DWORD* this)
{
    int v2; // eax
    int v3; // ebx
    int i; // edi
    void(__thiscall * **v5)(_DWORD, int); // ecx
    int result; // eax

    v2 = this[6];
    if (v2)
        v3 = (this[7] - v2) >> 2;
    else
        v3 = 0;
    for (i = 0; i < v3; ++i)
    {
        sub_428720(*(_DWORD**)(this[6] + 4 * i));
        sub_4286C0(this, *(_DWORD*)(this[6] + 4 * i));
        v5 = *(void(__thiscall****)(_DWORD, int))(this[6] + 4 * i);
        if (v5)
            (**v5)(v5, 1);
    }
    result = this[7];
    this[7] = this[6];
    return result;
}

//----- (00465FB0) --------------------------------------------------------
char __thiscall sub_465FB0(_DWORD* this)
{
    int v1; // edx
    int v2; // eax
    int v3; // edx
    int i; // ecx

    v1 = this[6];
    if (v1)
        v2 = (this[7] - v1) >> 2;
    else
        v2 = 0;
    v3 = 0;
    if (v2 <= 0)
        return 1;
    for (i = this[6]; !*(_BYTE*)(*(_DWORD*)i + 396); i += 4)
    {
        if (++v3 >= v2)
            return 1;
    }
    return 0;
}

//----- (00465FF0) --------------------------------------------------------
_DWORD* __thiscall sub_465FF0(_DWORD* this, int a2, int a3)
{
    _DWORD* v4; // eax
    _DWORD* v5; // eax
    int v6; // eax
    int v7; // ecx
    int v8; // edx
    _BYTE* v9; // eax
    int v10; // ecx
    int* v11; // eax
    int v12; // eax
    int v13; // ecx
    int v14; // edx
    _BYTE* v15; // eax
    int v16; // ecx
    int* v17; // eax
    _DWORD* v19; // [esp+8h] [ebp-24h] BYREF
    int v20[2]; // [esp+Ch] [ebp-20h] BYREF
    int v21; // [esp+14h] [ebp-18h] BYREF
    int v22; // [esp+18h] [ebp-14h]
    int v23; // [esp+1Ch] [ebp-10h]
    int v24; // [esp+28h] [ebp-4h]

    v20[1] = (int)this;
    sub_401270((int)this);
    v24 = 0;
    Iostream_init::Iostream_init((Iostream_init*)(this + 129));
    *this = &off_499C98;
    this[98] = a3;
    this[103] = a2;
    sub_4282E0(
        *(_DWORD*)(a2 + 560) != 0,
        "model for %s not loaded, try deleting ExtraData.dat",
        *(const char**)(a2 + 4));
    v4 = operator new(0x34u);
    LOBYTE(v24) = 2;
    if (v4)
        v5 = sub_406B00(v4, *(_DWORD*)(a2 + 560), 0);
    else
        v5 = 0;
    LOBYTE(v24) = 1;
    this[104] = v5;
    sub_428680(this, (int)v5);
    this[113] = sub_415270(*(_DWORD*)(dword_520970 + 244), *(_DWORD*)(a2 + 1220));
    v6 = this[103];
    this[338] = 0;
    v7 = *(_DWORD*)(v6 + 1236);
    if (v7)
    {
        sub_4282E0(
            *(_BYTE*)(v7 + 301),
            "engine sound did not set 'engine = true', see %s : %s",
            *(const char**)(v6 + 4),
            (const char*)(v6 + 16));
        v8 = this[103];
        v21 = 0;
        v22 = 0;
        v23 = 0;
        sub_44D850(*(_DWORD*)(v8 + 1236), (float*)&v21, &v19, v20);
        if (v19)
        {
            v9 = (_BYTE*)sub_41E2D0(*(_DWORD**)(dword_520970 + 120), v19, 0, 1);
            this[338] = v9;
            if (v9)
            {
                sub_41D8A0(v9, *(_BYTE*)(*(_DWORD*)(this[103] + 1236) + 330));
                sub_41D8B0(
                    (_DWORD*)this[338],
                    *(_DWORD*)v20[0],
                    *(_DWORD*)(v20[0] + 12),
                    *(_DWORD*)(v20[0] + 20),
                    *(_DWORD*)(v20[0] + 4),
                    *(_DWORD*)(v20[0] + 8),
                    *(_DWORD*)(v20[0] + 16));
                v10 = this[103];
                v11 = *(int**)(v10 + 1236);
                sub_41D900((_DWORD*)this[338], *(_DWORD*)(v10 + 1172), v11[76], v11[77], v11[78], v11[79], v11[80], v11[81]);
            }
        }
    }
    v12 = this[103];
    this[339] = 0;
    v13 = *(_DWORD*)(v12 + 1240);
    if (v13)
    {
        sub_4282E0(
            *(_BYTE*)(v13 + 301),
            "idle sound did not set 'engine = true', see %s : %s",
            *(const char**)(v12 + 4),
            (const char*)(v12 + 16));
        v14 = this[103];
        v21 = 0;
        v22 = 0;
        v23 = 0;
        sub_44D850(*(_DWORD*)(v14 + 1240), (float*)&v21, &v19, v20);
        if (v19)
        {
            v15 = (_BYTE*)sub_41E2D0(*(_DWORD**)(dword_520970 + 120), v19, 0, 1);
            this[339] = v15;
            if (v15)
            {
                sub_41D8A0(v15, *(_BYTE*)(*(_DWORD*)(this[103] + 1240) + 330));
                sub_41D8B0(
                    (_DWORD*)this[339],
                    *(_DWORD*)v20[0],
                    *(_DWORD*)(v20[0] + 12),
                    *(_DWORD*)(v20[0] + 20),
                    *(_DWORD*)(v20[0] + 4),
                    *(_DWORD*)(v20[0] + 8),
                    *(_DWORD*)(v20[0] + 16));
                v16 = this[103];
                v17 = *(int**)(v16 + 1240);
                sub_41D900((_DWORD*)this[339], *(_DWORD*)(v16 + 1172), v17[76], v17[77], v17[78], v17[79], v17[80], v17[81]);
            }
        }
    }
    sub_466AA0((int)this);
    return this;
}
// 499C98: using guessed type _UNKNOWN *off_499C98;
// 520970: using guessed type int dword_520970;

//----- (00466370) --------------------------------------------------------
int __thiscall sub_466370(_DWORD* this)
{
    void* v2; // ecx
    int v3; // ecx
    int v4; // ecx

    *this = &off_499C98;
    v2 = (void*)this[113];
    if (v2)
    {
        sub_415910(v2);
        this[113] = 0;
    }
    v3 = this[338];
    if (v3)
    {
        sub_41D9A0(v3);
        this[338] = 0;
    }
    v4 = this[339];
    if (v4)
    {
        sub_41D9A0(v4);
        this[339] = 0;
    }
    nullsub_1(this + 129);
    return sub_4013F0(this);
}
// 415760: using guessed type int __thiscall nullsub_1(_DWORD);
// 499C98: using guessed type _UNKNOWN *off_499C98;

//----- (00466410) --------------------------------------------------------
int __thiscall sub_466410(int this, int* a2, int* a3, int a4, float* a5)
{
    int v6; // edi
    int v7; // eax
    float** v8; // ecx
    __int16 v9; // bx
    int v10; // eax
    int v11; // ecx
    _WORD v13[4]; // [esp+8h] [ebp-60h] BYREF
    int v14; // [esp+10h] [ebp-58h]
    float v15; // [esp+14h] [ebp-54h]
    int v16; // [esp+18h] [ebp-50h]
    int v17; // [esp+1Ch] [ebp-4Ch]
    int v18; // [esp+20h] [ebp-48h]
    char v19; // [esp+24h] [ebp-44h]
    int v20[16]; // [esp+28h] [ebp-40h] BYREF

    if (!*(_BYTE*)(this + 16))
        return 0;
    v6 = (int)a5;
    if (!sub_407710(*(float**)(this + 416), *a2, a2[1], a2[2], *a3, a3[1], a3[2], (int*)&a5, a5))
        return 0;
    v7 = 0;
    v8 = (float**)(*(_DWORD*)(this + 412) + 1120);
    do
    {
        if (a5 == *v8)
            break;
        ++v7;
        v8 += 3;
    } while (v7 < 3);
    if (*(_BYTE*)(dword_4F5CC4 + 936) || *(_BYTE*)(dword_4F5CC4 + 937))
    {
        if (!*(_BYTE*)(a4 + 124))
        {
            v9 = *(_WORD*)(this + 392);
            v14 = v7;
            v13[3] = v9;
            v15 = *(float*)v6;
            v16 = *(_DWORD*)(v6 + 4);
            v17 = *(_DWORD*)(v6 + 8);
            v10 = *(_DWORD*)(a4 + 4);
            v18 = *(_DWORD*)(v10 + 300);
            v19 = *(_BYTE*)(v10 + 312);
            sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x803, v13, 29, 2, 10000);
        }
    }
    else
    {
        sub_4666E0((char*)this, v7, v6, *(float*)(*(_DWORD*)(a4 + 4) + 300), *(_BYTE*)(*(_DWORD*)(a4 + 4) + 312));
    }
    v11 = *(_DWORD*)(this + 416);
    memset(&v20[11], 0, 16);
    memset(&v20[6], 0, 16);
    memset(&v20[1], 0, 16);
    v20[15] = 1065353216;
    v20[10] = 1065353216;
    v20[5] = 1065353216;
    v20[0] = 1065353216;
    sub_407690(v11, (int)a5, v20);
    sub_46C5C5((float*)v6, (float*)v6, (float*)v20);
    return 8;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (004665E0) --------------------------------------------------------
bool __thiscall sub_4665E0(int this, int* a2, float a3, float a4, char a5, int a6)
{
    int v7; // edi
    int i; // ebp
    bool result; // al
    float v10; // [esp+0h] [ebp-44h]
    int v11; // [esp+14h] [ebp-30h] BYREF
    int v12; // [esp+18h] [ebp-2Ch] BYREF
    int v13; // [esp+1Ch] [ebp-28h]
    int v14; // [esp+20h] [ebp-24h]
    _WORD v15[4]; // [esp+24h] [ebp-20h] BYREF
    int v16; // [esp+2Ch] [ebp-18h]
    int v17; // [esp+30h] [ebp-14h]
    int v18; // [esp+34h] [ebp-10h]
    int v19; // [esp+38h] [ebp-Ch]
    float v20; // [esp+3Ch] [ebp-8h]
    char v21; // [esp+40h] [ebp-4h]

    v12 = 0;
    v13 = 0;
    v14 = 0;
    v7 = 0;
    for (i = 1116; i < 1152; i += 12)
    {
        result = sub_407F00(*(_DWORD*)(this + 416), *(_DWORD*)(*(_DWORD*)(this + 412) + i), a2, a3, &v12, (float*)&v11);
        if (result)
        {
            if (*(_BYTE*)(dword_4F5CC4 + 936) || *(_BYTE*)(dword_4F5CC4 + 937))
            {
                v15[3] = *(_WORD*)(this + 392);
                v18 = v13;
                v20 = *(float*)&v11 * a4;
                v17 = v12;
                v16 = v7;
                v19 = v14;
                v21 = 1;
                result = sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x803, v15, 29, 2, 10000);
            }
            else
            {
                v10 = *(float*)&v11 * a4;
                result = sub_4666E0((char*)this, v7, (int)&v12, v10, a5);
            }
        }
        ++v7;
    }
    return result;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (004666E0) --------------------------------------------------------
bool __thiscall sub_4666E0(char* this, int a2, int a3, float a4, char a5)
{
    double v6; // st7
    double v7; // st7
    int v8; // edx
    int v9; // ecx
    int v10; // edi
    int v11; // eax
    unsigned __int8 v13; // c0
    unsigned __int8 v14; // c3
    float v15; // eax
    _DWORD* v16; // ecx
    int v17; // eax
    _DWORD* v18; // ecx
    int v19; // ecx
    int v20; // eax
    char v22; // [esp+Ah] [ebp-Eh]
    bool v23; // [esp+Bh] [ebp-Dh]
    int v24; // [esp+Ch] [ebp-Ch] BYREF
    int v25; // [esp+10h] [ebp-8h]
    int v26; // [esp+14h] [ebp-4h]
    char v27; // [esp+28h] [ebp+10h]

    v23 = this[396] == 0;
    if (!a5)
        a4 = 0.0;
    v27 = 0;
    v22 = 0;
    if (a2)
    {
        if (a2 != 1 && a2 != 2)
            return !this[396] && !v23;
        if (*((float*)this + 107) <= 0.0)
            return !this[396] && !v23;
        v7 = *((float*)this + 107) - a4;
        *((float*)this + 107) = v7;
        if (v7 > 0.0)
            return !this[396] && !v23;
        v22 = 1;
    }
    else
    {
        if (*((float*)this + 106) <= 0.0)
            return !this[396] && !v23;
        v6 = *((float*)this + 106) - a4;
        *((float*)this + 106) = v6;
        if (v6 > 0.0)
            return !this[396] && !v23;
        v27 = 1;
    }
    if (this[436])
    {
        v8 = 0;
        v9 = *(_DWORD*)(dword_520970 + 212);
        v10 = *(_DWORD*)(v9 + 24);
        while (1)
        {
            v11 = v10 ? (*(_DWORD*)(v9 + 28) - v10) >> 2 : 0;
            if (v8 >= v11)
                break;
            if (*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v9 + 24) + 4 * v8) + 408) + 292) == 3 && v13 | v14)
                goto LABEL_22;
            ++v8;
        }
        if (v27)
        {
            sub_467A50((int)this, 1);
            this[420] = 0;
            if (!*(_BYTE*)(dword_4F5CC4 + 937))
            {
                sub_4164A0(*((_DWORD*)this + 113), 6);
                v16 = (_DWORD*)*((_DWORD*)this + 113);
                *((_DWORD*)this + 112) = 2;
                sub_416F80(v16, 1);
            }
            v17 = *((_DWORD*)this + 103);
            this[421] = 0;
            if (*(_DWORD*)(v17 + 1228))
            {
                v24 = 0;
                v25 = 0;
                v26 = 0;
                sub_44E040(
                    *(char**)(dword_520970 + 240),
                    *(_DWORD*)(v17 + 1228),
                    (int)(this + 488),
                    *((_DWORD*)this + 104),
                    *(float*)(v17 + 1116),
                    &v24);
            }
        }
        else
        {
            if (!v22)
                return !this[396] && !v23;
            sub_467A50((int)this, 1);
            this[420] = 0;
            if (!*(_BYTE*)(dword_4F5CC4 + 937))
            {
                sub_4164A0(*((_DWORD*)this + 113), 6);
                v18 = (_DWORD*)*((_DWORD*)this + 113);
                *((_DWORD*)this + 112) = 2;
                sub_416F80(v18, 1);
            }
            v19 = *((_DWORD*)this + 103);
            this[421] = 0;
            sub_408640(*((_DWORD**)this + 104), *(_DWORD*)(v19 + 1128), 0);
            sub_408640(*((_DWORD**)this + 104), *(_DWORD*)(*((_DWORD*)this + 103) + 1140), 0);
            sub_407670(*((_DWORD**)this + 104), *(_DWORD*)(*((_DWORD*)this + 103) + 1132), 0);
            sub_407670(*((_DWORD**)this + 104), *(_DWORD*)(*((_DWORD*)this + 103) + 1144), 0);
            v20 = *((_DWORD*)this + 103);
            if (*(_DWORD*)(v20 + 1224))
            {
                v24 = 0;
                v25 = 0;
                v26 = 0;
                sub_44E040(
                    *(char**)(dword_520970 + 240),
                    *(_DWORD*)(v20 + 1224),
                    (int)(this + 488),
                    *((_DWORD*)this + 104),
                    *(float*)(v20 + 1128),
                    &v24);
            }
        }
        sub_4089D0(
            *((_DWORD**)this + 104),
            *(_DWORD*)(*((_DWORD*)this + 103) + 1084),
            *(_DWORD*)(*((_DWORD*)this + 103) + 1088));
        return !this[396] && !v23;
    }
    this[436] = 1;
LABEL_22:
    sub_467A50((int)this, 1);
    (*(void(__thiscall**)(char*, _DWORD))(*(_DWORD*)this + 24))(this, 0);
    v15 = *(float*)(*((_DWORD*)this + 103) + 1232);
    if (v15 != 0.0)
        sub_44DF20(*(char**)(dword_520970 + 240), v15, COERCE_FLOAT(this + 460), (float*)this + 122);
    return !this[396] && !v23;
}
// 46682C: variable 'v13' is possibly undefined
// 46682C: variable 'v14' is possibly undefined
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (00466AA0) --------------------------------------------------------
int __thiscall sub_466AA0(int this)
{
    _DWORD* v2; // ecx
    int v3; // eax
    long double v4; // st7
    int v5; // eax
    int result; // eax
    float v7; // [esp+8h] [ebp-8Ch]
    float v8; // [esp+Ch] [ebp-88h]
    int v9[16]; // [esp+14h] [ebp-80h] BYREF
    int v10[16]; // [esp+54h] [ebp-40h] BYREF

    v2 = *(_DWORD**)(this + 416);
    *(_BYTE*)(this + 396) = 1;
    sub_407250(v2);
    sub_4074B0(*(_DWORD**)(this + 416), 0);
    sub_408860(*(_DWORD**)(this + 416), 0);
    *(_BYTE*)(*(_DWORD*)(this + 416) + 48) = 0;
    *(_DWORD*)(*(_DWORD*)(this + 416) + 36) = 0;
    *(_DWORD*)(*(_DWORD*)(this + 416) + 32) = 0;
    sub_408640(*(_DWORD**)(this + 416), *(_DWORD*)(*(_DWORD*)(this + 412) + 1116), 1);
    sub_408640(*(_DWORD**)(this + 416), *(_DWORD*)(*(_DWORD*)(this + 412) + 1128), 1);
    sub_408640(*(_DWORD**)(this + 416), *(_DWORD*)(*(_DWORD*)(this + 412) + 1140), 1);
    sub_407670(*(_DWORD**)(this + 416), *(_DWORD*)(*(_DWORD*)(this + 412) + 1128), 1);
    sub_407670(*(_DWORD**)(this + 416), *(_DWORD*)(*(_DWORD*)(this + 412) + 1140), 1);
    sub_46BF69((float*)v9, 0.0);
    sub_46BE62((float*)v10, 0.0);
    sub_4073F0(*(_DWORD**)(this + 416), *(_DWORD*)(*(_DWORD*)(this + 412) + 1128), v9);
    sub_4073C0(*(_DWORD**)(this + 416), *(_DWORD*)(*(_DWORD*)(this + 412) + 1128), 1);
    sub_4073F0(*(_DWORD**)(this + 416), *(_DWORD*)(*(_DWORD*)(this + 412) + 1140), v10);
    sub_4073C0(*(_DWORD**)(this + 416), *(_DWORD*)(*(_DWORD*)(this + 412) + 1140), 1);
    v3 = *(_DWORD*)(this + 412);
    *(_BYTE*)(this + 420) = 1;
    *(_BYTE*)(this + 421) = 1;
    *(_DWORD*)(this + 424) = *(_DWORD*)(v3 + 1124);
    *(_DWORD*)(this + 428) = *(_DWORD*)(v3 + 1136);
    *(_DWORD*)(this + 432) = *(_DWORD*)(v3 + 1160);
    *(_BYTE*)(this + 436) = 1;
    *(_DWORD*)(this + 448) = 0;
    v8 = *(float*)(v3 + 1204);
    v7 = *(float*)(v3 + 1200);
    if (v7 == v8)
        v4 = v7;
    else
        v4 = fabs((double)rand() * 0.000030518509) * (v8 - v7) + v7;
    *(float*)(this + 456) = v4;
    v5 = *(_DWORD*)(this + 412);
    if (*(_BYTE*)(dword_4F5CC4 + 937))
        result = sub_415770(*(_DWORD*)(this + 452), (float*)(v5 + 1092), (float*)(v5 + 1104), this, 0);
    else
        result = sub_415770(*(_DWORD*)(this + 452), (float*)(v5 + 1092), (float*)(v5 + 1104), this, (int)sub_467E30);
    *(_DWORD*)(*(_DWORD*)(this + 452) + 4144) = 2;
    *(_BYTE*)(this + 504) = 0;
    *(_DWORD*)(this + 508) = 0;
    return result;
}
// 4F5CC4: using guessed type int dword_4F5CC4;

//----- (00466D00) --------------------------------------------------------
char __thiscall sub_466D00(int this, int a2)
{
    double v4; // st7
    int v5; // ecx
    double v6; // st6
    double v7; // st7
    float v8; // ecx
    float v9; // eax
    int v10; // edx
    int v11; // eax
    double v12; // st7
    int v13; // eax
    long double v14; // st7
    char v15; // cl
    bool v16; // al
    int v17; // ecx
    int v18; // edx
    float* v19; // edi
    double v20; // st7
    unsigned int v21; // eax
    int v22; // eax
    double v23; // st7
    int v24; // ebx
    long double v25; // st7
    double v26; // st7
    double v27; // st7
    double v28; // st7
    int v29; // eax
    int v30; // eax
    int v31; // ecx
    int v32; // eax
    int v33; // eax
    int v34; // edx
    int v35; // eax
    _DWORD* v36; // ecx
    int v37; // eax
    int v38; // edx
    int v39; // eax
    float v40; // edx
    float v41; // eax
    _DWORD* v42; // ecx
    int v43; // eax
    int v44; // edx
    int v45; // eax
    float v46; // edx
    float v47; // eax
    float v48; // ecx
    double v49; // st7
    float v50; // eax
    float v51; // eax
    float v52; // edx
    float v53; // edx
    float v54; // ecx
    int v55; // eax
    double v56; // st7
    int v57; // edi
    float v58; // [esp+0h] [ebp-198h]
    float v59; // [esp+0h] [ebp-198h]
    float v60; // [esp+4h] [ebp-194h]
    float v61; // [esp+4h] [ebp-194h]
    int v62; // [esp+4h] [ebp-194h]
    int v63; // [esp+4h] [ebp-194h]
    float v64; // [esp+18h] [ebp-180h]
    float v65; // [esp+18h] [ebp-180h]
    float v66; // [esp+18h] [ebp-180h]
    float v67; // [esp+18h] [ebp-180h]
    float v68; // [esp+1Ch] [ebp-17Ch]
    float v69; // [esp+1Ch] [ebp-17Ch]
    float v70; // [esp+1Ch] [ebp-17Ch]
    float v71; // [esp+1Ch] [ebp-17Ch]
    char v72; // [esp+23h] [ebp-175h] BYREF
    float v73; // [esp+24h] [ebp-174h] BYREF
    float v74; // [esp+28h] [ebp-170h]
    float v75; // [esp+2Ch] [ebp-16Ch]
    int v76; // [esp+30h] [ebp-168h] BYREF
    float v77; // [esp+34h] [ebp-164h]
    float v78; // [esp+38h] [ebp-160h]
    float v79; // [esp+3Ch] [ebp-15Ch] BYREF
    int v80; // [esp+40h] [ebp-158h] BYREF
    float v81; // [esp+44h] [ebp-154h]
    float v82; // [esp+48h] [ebp-150h]
    int v83; // [esp+4Ch] [ebp-14Ch] BYREF
    float v84; // [esp+50h] [ebp-148h]
    float v85; // [esp+54h] [ebp-144h]
    int v86; // [esp+58h] [ebp-140h] BYREF
    int v87; // [esp+5Ch] [ebp-13Ch]
    int v88; // [esp+60h] [ebp-138h]
    float v89; // [esp+64h] [ebp-134h]
    int v90; // [esp+68h] [ebp-130h] BYREF
    float v91; // [esp+6Ch] [ebp-12Ch]
    float v92; // [esp+70h] [ebp-128h]
    float v93; // [esp+74h] [ebp-124h] BYREF
    __int16 v94; // [esp+7Ah] [ebp-11Eh]
    __int16 v95; // [esp+7Ch] [ebp-11Ch]
    char v96; // [esp+7Eh] [ebp-11Ah]
    __int16 v97; // [esp+7Fh] [ebp-119h]
    __int16 v98; // [esp+81h] [ebp-117h]
    __int16 v99; // [esp+83h] [ebp-115h]
    __int16 v100; // [esp+85h] [ebp-113h]
    char v101; // [esp+87h] [ebp-111h]
    int v102; // [esp+88h] [ebp-110h] BYREF
    float v103; // [esp+8Ch] [ebp-10Ch]
    float v104; // [esp+90h] [ebp-108h]
    int v105; // [esp+94h] [ebp-104h]
    float v106; // [esp+98h] [ebp-100h]
    float v107; // [esp+9Ch] [ebp-FCh]
    float v108; // [esp+A0h] [ebp-F8h]
    int v109; // [esp+A4h] [ebp-F4h]
    float v110; // [esp+A8h] [ebp-F0h]
    float v111; // [esp+ACh] [ebp-ECh]
    float v112; // [esp+B0h] [ebp-E8h]
    int v113; // [esp+B4h] [ebp-E4h]
    int v114; // [esp+B8h] [ebp-E0h]
    int v115; // [esp+BCh] [ebp-DCh]
    float v116; // [esp+C0h] [ebp-D8h]
    int v117; // [esp+C4h] [ebp-D4h]
    float v118; // [esp+C8h] [ebp-D0h]
    int v119[3]; // [esp+CCh] [ebp-CCh] BYREF
    int v120[16]; // [esp+D8h] [ebp-C0h] BYREF
    int v121[16]; // [esp+118h] [ebp-80h] BYREF
    int v122[16]; // [esp+158h] [ebp-40h] BYREF

    if (!*(_BYTE*)(dword_4F5CC4 + 937))
        goto LABEL_6;
    if (*(_BYTE*)(this + 396))
    {
        if (*(_BYTE*)(this + 436)
            && sqrt(
                *(float*)(this + 460) * *(float*)(this + 460)
                + *(float*)(this + 464) * *(float*)(this + 464)
                + *(float*)(this + 468) * *(float*)(this + 468)) > 7000.0)
        {
            sub_467A50(this, 0);
            (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)this + 24))(this, 0);
            return sub_428620((_DWORD*)this, a2);
        }
    LABEL_6:
        if (*(_BYTE*)(this + 396))
            goto LABEL_13;
    }
    v4 = *(float*)(this + 432) - *(float*)&a2;
    v5 = *(_DWORD*)(this + 412);
    *(float*)(this + 432) = v4;
    v6 = *(float*)(v5 + 1164);
    if (v6 == 0.0)
    {
        v64 = 0.0;
        sub_408960(*(_DWORD**)(this + 416), 0.0);
    }
    else
    {
        v64 = v4 / v6;
        if (v64 < 1.0)
            sub_408960(*(_DWORD**)(this + 416), v64);
    }
    if (v64 <= 0.0)
    {
        (*(void(__thiscall**)(int, _DWORD))(*(_DWORD*)this + 24))(this, 0);
        return sub_428620((_DWORD*)this, a2);
    }
LABEL_13:
    if (*(_BYTE*)(this + 436))
    {
        sub_4159B0(
            *(_DWORD*)(this + 452),
            *(float*)&a2,
            (_DWORD*)(this + 460),
            (_DWORD*)(this + 472),
            (float*)(this + 484),
            this + 488,
            (float*)(this + 500));
        v7 = sub_468BE0((int*)*(_DWORD*)(dword_520970 + 260), *(_DWORD*)(this + 460), *(_DWORD*)(this + 464), 0);
        if (*(_BYTE*)(this + 444))
        {
            if (v7 <= *(float*)(this + 468))
                v7 = *(float*)(this + 468);
            else
                *(_BYTE*)(this + 444) = 0;
        }
        *(float*)(this + 468) = v7;
        *(_DWORD*)(this + 484) = 0;
        sub_46BEE6((float*)v120, 0.0);
        v8 = *(float*)(this + 472);
        v74 = *(float*)(this + 476);
        v73 = v8;
        v9 = *(float*)(this + 480);
        v82 = 0.0;
        v75 = v9;
        v78 = 0.0;
        *(float*)&v80 = v74 - 0.0;
        v76 = v80;
        v81 = 0.0 - v8;
        v77 = v81;
        sub_46B970(&v76, &v76);
        v102 = v76;
        v103 = v77;
        v104 = v78;
        v106 = v73;
        v107 = v74;
        v108 = v75;
        v81 = v73 * v78 - v75 * *(float*)&v76;
        v10 = *(_DWORD*)(this + 460);
        v111 = v81;
        v11 = *(_DWORD*)(this + 464);
        v114 = v10;
        v115 = v11;
        v82 = v74 * *(float*)&v76 - v73 * v77;
        v110 = v75 * v77 - v74 * v78;
        v112 = v82;
        v116 = *(float*)(this + 468);
        v105 = 0;
        v109 = 0;
        v113 = 0;
        v117 = 1065353216;
        sub_46B97C(&v102, v120, &v102);
        sub_4073F0(*(_DWORD**)(this + 416), 0, &v102);
    }
    if (*(float*)(this + 440) > 0.0)
        *(float*)(this + 440) = *(float*)(this + 440) - *(float*)&a2;
    if (*(_BYTE*)(this + 436) && *(float*)(this + 440) <= 0.0)
    {
        if (*(_BYTE*)(this + 420))
        {
            if (!*(_DWORD*)(this + 448))
            {
                v12 = *(float*)(this + 456) - *(float*)&a2;
                *(float*)(this + 456) = v12;
                if (v12 <= 0.0)
                {
                    v13 = *(_DWORD*)(this + 412);
                    *(_DWORD*)(this + 448) = 1;
                    v65 = *(float*)(v13 + 1200);
                    v68 = *(float*)(v13 + 1204);
                    if (v65 == v68)
                    {
                        v14 = v65;
                    }
                    else
                    {
                        v79 = COERCE_FLOAT(rand());
                        v14 = fabs((double)SLODWORD(v79) * 0.000030518509) * (v68 - v65) + v65;
                    }
                    *(float*)(this + 456) = v14;
                }
            }
        }
        if (*(_BYTE*)(this + 421))
        {
            v15 = *(_BYTE*)(this + 504);
            v16 = *(float*)(*(_DWORD*)(this + 412) + 1172) * 0.5 > *(float*)(this + 500);
            *(_BYTE*)(this + 504) = v16;
            if (!v15 && v16)
            {
                sub_45F160(*(float**)(dword_520970 + 280), (float*)(this + 400));
                *(_DWORD*)(this + 512) = 0;
            }
            if (*(_BYTE*)(this + 504))
            {
                memset(v119, 0, sizeof(v119));
                v80 = *(int*)(this + 400);
                v17 = *(_DWORD*)(this + 416);
                v81 = *(float*)(this + 404);
                v18 = *(_DWORD*)(this + 412);
                v82 = *(float*)(this + 408);
                sub_4085B0(v17, *(_DWORD*)(v18 + 1128), (int)&v93);
                v19 = (float*)(this + 488);
                v58 = sub_44A3E0(&v93, (float*)&v80, *(float*)(*(_DWORD*)(this + 412) + 1256), 1.0);
                sub_44A250(
                    *(_DWORD*)(*(_DWORD*)(this + 412) + 1248),
                    &v93,
                    (float*)(this + 488),
                    (float*)&v80,
                    (float*)v119,
                    v58,
                    (float*)&v76);
                sub_407690(*(_DWORD*)(this + 416), 0, v120);
                sub_46B982((int)v120, (int)v120);
                v73 = *(float*)&v76;
                v74 = v77;
                v75 = v78;
                sub_46B970(&v73, &v73);
                sub_46B976(&v73, &v73, (float*)v120);
                v79 = v75;
                v60 = atan2(-v73, v74);
                v89 = sub_41C2F0((float*)(*(_DWORD*)(this + 412) + 1260), v60);
                v61 = asin(v79);
                v20 = sub_41C2F0((float*)(*(_DWORD*)(this + 412) + 1272), v61);
                v21 = *(_DWORD*)(this + 512);
                v79 = v20;
                v69 = v20;
                v66 = v89;
                if (v21 <= 1)
                {
                    sub_407430(*(_DWORD**)(this + 416), *(_DWORD*)(*(_DWORD*)(this + 412) + 1128), (char*)&v102);
                    v70 = 1.0;
                    if (v103 <= 0.0)
                        v70 = -1.0;
                    v67 = acos(*(float*)&v102) * v70;
                    sub_407430(*(_DWORD**)(this + 416), *(_DWORD*)(*(_DWORD*)(this + 412) + 1140), (char*)&v102);
                    v71 = 1.0;
                    if (v108 <= 0.0)
                        v71 = -1.0;
                    v118 = v112;
                    v22 = *(_DWORD*)(this + 412);
                    v23 = *(float*)&a2 * *(float*)(v22 + 1284);
                    *(float*)&v62 = v23;
                    sub_41C3C0(v22 + 1260, v89, v67, v62);
                    v66 = v23;
                    v24 = *(_DWORD*)(this + 412);
                    *(float*)&v63 = *(float*)&a2 * *(float*)(v24 + 1284);
                    v25 = acos(v118) * v71;
                    v59 = v25;
                    sub_41C3C0(v24 + 1272, v79, v59, v63);
                    v69 = v25;
                    v26 = v66 - v89;
                    if (v26 < 0.0000099999997 && v26 > -0.0000099999997)
                    {
                        v27 = v69 - v79;
                        if (v27 < 0.0000099999997 && v27 > -0.0000099999997)
                            *(_DWORD*)(this + 512) = 2;
                    }
                }
                sub_46BF69((float*)v121, v66);
                sub_46BE62((float*)v122, v69);
                sub_4073F0(*(_DWORD**)(this + 416), *(_DWORD*)(*(_DWORD*)(this + 412) + 1128), v121);
                sub_4073F0(*(_DWORD**)(this + 416), *(_DWORD*)(*(_DWORD*)(this + 412) + 1140), v122);
                if (*(_DWORD*)(this + 512) == 2)
                {
                    v28 = *(float*)(this + 508) - *(float*)&a2;
                    *(float*)(this + 508) = v28;
                    if (v28 <= 0.0)
                    {
                        v29 = *(_DWORD*)(this + 412);
                        *(_DWORD*)(this + 508) = *(_DWORD*)(v29 + 1252);
                        v30 = *(_DWORD*)(v29 + 1152);
                        if (v30 != -1)
                        {
                            sub_407690(*(_DWORD*)(this + 416), v30, &v102);
                            sub_4010D0(&v86, (int)&v102);
                            *(float*)&v83 = *(float*)&v76 + *v19;
                            v31 = *(_DWORD*)(this + 412);
                            v84 = v77 + *(float*)(this + 492);
                            v85 = v78 + *(float*)(this + 496);
                            *(float*)&v90 = 0.0;
                            v91 = 0.0;
                            v92 = 1.0;
                            sub_449C40(*(char**)(dword_520970 + 276), *(_DWORD*)(v31 + 1248), &v86, &v83, 0, 0, 0.0, (int)&v90);
                            v32 = *(_DWORD*)(this + 412);
                            *(float*)&v83 = 0.0;
                            v84 = 0.0;
                            v85 = 0.0;
                            sub_44E040(
                                *(char**)(dword_520970 + 240),
                                *(_DWORD*)(v32 + 1288),
                                this + 488,
                                *(_DWORD*)(this + 416),
                                *(float*)(v32 + 1152),
                                &v83);
                        }
                        v33 = *(_DWORD*)(*(_DWORD*)(this + 412) + 1156);
                        if (v33 != -1)
                        {
                            sub_407690(*(_DWORD*)(this + 416), v33, &v102);
                            sub_4010D0(&v86, (int)&v102);
                            *(float*)&v90 = *(float*)&v76 + *v19;
                            v34 = *(_DWORD*)(this + 412);
                            v91 = v77 + *(float*)(this + 492);
                            v92 = v78 + *(float*)(this + 496);
                            *(float*)&v83 = 0.0;
                            v84 = 0.0;
                            v85 = 1.0;
                            sub_449C40(*(char**)(dword_520970 + 276), *(_DWORD*)(v34 + 1248), &v86, &v90, 0, 0, 0.0, (int)&v83);
                            v35 = *(_DWORD*)(this + 412);
                            *(float*)&v83 = 0.0;
                            v84 = 0.0;
                            v85 = 0.0;
                            sub_44E040(
                                *(char**)(dword_520970 + 240),
                                *(_DWORD*)(v35 + 1288),
                                this + 488,
                                *(_DWORD*)(this + 416),
                                *(float*)(v35 + 1156),
                                &v83);
                        }
                    }
                }
            }
        }
    }
    v36 = *(_DWORD**)(this + 1352);
    if (v36)
    {
        v37 = *(_DWORD*)(this + 492);
        v86 = *(_DWORD*)(this + 488);
        v38 = *(_DWORD*)(this + 496);
        v87 = v37;
        v39 = *(int*)(this + 460);
        v88 = v38;
        v40 = *(float*)(this + 464);
        v83 = v39;
        v41 = *(float*)(this + 468);
        v84 = v40;
        v85 = v41;
        sub_41D960(v36, &v83, &v86);
    }
    v42 = *(_DWORD**)(this + 1356);
    if (v42)
    {
        v43 = *(_DWORD*)(this + 492);
        v86 = *(_DWORD*)(this + 488);
        v44 = *(_DWORD*)(this + 496);
        v87 = v43;
        v45 = *(int*)(this + 460);
        v88 = v44;
        v46 = *(float*)(this + 464);
        v83 = v45;
        v47 = *(float*)(this + 468);
        v84 = v46;
        v85 = v47;
        sub_41D960(v42, &v83, &v86);
    }
    if (sub_408F30((_DWORD*)dword_520970) == this)
    {
        sub_407430(*(_DWORD**)(this + 416), 0, (char*)&v102);
        sub_401450((_DWORD*)this);
        v73 = 0.0;
        v74 = -4000.0;
        v75 = 0.0;
        *(float*)&v76 = 0.0;
        v77 = 0.0;
        v78 = 0.0;
        *(float*)&v80 = 0.0;
        v81 = 0.0;
        v82 = 1.0;
        sub_46C5C5(&v73, &v73, (float*)&v102);
        v75 = v116 + 2000.0;
        sub_46C5C5((float*)&v76, (float*)&v76, (float*)&v102);
        v48 = v74;
        v49 = v116 + 1000.0;
        *(float*)(this + 32) = v73;
        v50 = v75;
        *(float*)(this + 36) = v48;
        v78 = v49;
        *(float*)(this + 40) = v50;
        v51 = v77;
        *(float*)(this + 44) = *(float*)&v76;
        v52 = v78;
        *(float*)(this + 48) = v51;
        *(float*)(this + 52) = v52;
        v53 = v81;
        *(float*)(this + 56) = *(float*)&v80;
        v54 = v82;
        *(float*)(this + 60) = v53;
        *(float*)(this + 64) = v54;
    }
    if (*(_BYTE*)(dword_4F5CC4 + 936))
    {
        if (*(_BYTE*)(this + 436))
        {
            v94 = *(_WORD*)(this + 392);
            while (sub_4176E0(*(_DWORD**)(this + 452), &v79, &v80, &v72, 8))
            {
                v55 = *(_DWORD*)(this + 452);
                v56 = *(float*)(v55 + 16);
                v57 = *(_DWORD*)(v55 + 4136);
                v95 = LOWORD(v79);
                v97 = (__int64)*(float*)&v80;
                v98 = (__int64)v81;
                v99 = (__int64)v82;
                v96 = v72;
                v100 = v57;
                v101 = (__int64)(v56 * 255.0);
                sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x802, &v93, 20, 8, 5000);
            }
        }
    }
    return sub_428620((_DWORD*)this, a2);
}
// 466D00: too many cbuild loops
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;

//----- (00467A00) --------------------------------------------------------
int __thiscall sub_467A00(int this, int a2)
{
    int* v3; // ecx
    int result; // eax

    if (!(_BYTE)a2)
    {
        v3 = *(int**)(this + 452);
        if (v3)
        {
            if (v3[1033] > 0)
            {
                sub_415910(v3);
                *(_DWORD*)(this + 452) = 0;
            }
        }
    }
    result = (*(int(__thiscall**)(_DWORD, int))(**(_DWORD**)(this + 416) + 24))(*(_DWORD*)(this + 416), a2);
    *(_BYTE*)(this + 16) = a2;
    return result;
}

//----- (00467A50) --------------------------------------------------------
char __thiscall sub_467A50(int this, char a2)
{
    int v3; // ecx
    int v4; // edx
    int v5; // ecx
    int v7; // [esp-Ch] [ebp-1Ch]
    int v8[3]; // [esp+4h] [ebp-Ch] BYREF

    if (!*(_BYTE*)(this + 396))
        return 0;
    if (!*(_BYTE*)(dword_4F5CC4 + 937) && a2)
        sub_462520(*(_DWORD**)(dword_520970 + 280), *(_DWORD*)(*(_DWORD*)(this + 412) + 296), dword_5216E8);
    v3 = *(_DWORD*)(this + 1352);
    *(_BYTE*)(this + 396) = 0;
    if (v3)
    {
        sub_41D9A0(v3);
        v4 = *(_DWORD*)(this + 412);
        v7 = *(_DWORD*)(this + 416);
        *(_DWORD*)(this + 1352) = 0;
        memset(v8, 0, sizeof(v8));
        sub_44E040(*(char**)(dword_520970 + 240), *(_DWORD*)(v4 + 1244), this + 488, v7, 0.0, v8);
    }
    v5 = *(_DWORD*)(this + 1356);
    if (v5)
    {
        sub_41D9A0(v5);
        *(_DWORD*)(this + 1356) = 0;
    }
    if (a2)
        sub_45A420(*(float**)(dword_520970 + 236), *(_DWORD*)(this + 412), 1, 0, 1);
    return 1;
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;
// 5216E8: using guessed type int dword_5216E8;

//----- (00467B60) --------------------------------------------------------
char __thiscall sub_467B60(int this, int a2)
{
    char result; // al
    int v4; // ecx
    int v5; // ecx

    result = 1;
    *(_DWORD*)(this + 440) = a2;
    v4 = *(_DWORD*)(this + 1352);
    *(_BYTE*)(this + 436) = 1;
    *(_BYTE*)(this + 444) = 1;
    if (v4)
        result = sub_41D840(v4);
    v5 = *(_DWORD*)(this + 1356);
    if (v5)
        return sub_41D840(v5);
    return result;
}

//----- (00467BA0) --------------------------------------------------------
void __thiscall sub_467BA0(int this, float a2)
{
    int v3; // esi
    int v4; // ecx
    int v5; // edx
    char v6; // al
    float v7; // ecx
    _DWORD* v8; // eax
    int v9; // eax
    int v10; // ecx
    int v11; // edx
    char v12; // al
    float v13; // ecx
    bool v14; // bl
    _DWORD* v15; // eax
    int v16; // eax
    int v17; // edx
    int v18; // eax
    int v19; // ecx
    int v20; // edx
    int v21; // ecx
    int v22; // ecx
    double v23; // st7
    unsigned __int8 v24; // dl
    int v25; // edx
    int v26; // ebp
    char v27; // bl
    const char* v28; // [esp-8h] [ebp-64h]
    const char* v29; // [esp-8h] [ebp-64h]
    const char* v30; // [esp-4h] [ebp-60h]
    const char* v31; // [esp-4h] [ebp-60h]
    unsigned __int8 v32; // [esp+10h] [ebp-4Ch]
    _DWORD v33[3]; // [esp+14h] [ebp-48h] BYREF
    _DWORD v34[3]; // [esp+20h] [ebp-3Ch] BYREF
    float v35[3]; // [esp+2Ch] [ebp-30h] BYREF
    _WORD v36[4]; // [esp+38h] [ebp-24h] BYREF
    int v37; // [esp+40h] [ebp-1Ch]
    int v38; // [esp+44h] [ebp-18h]
    int v39; // [esp+48h] [ebp-14h]
    int v40; // [esp+4Ch] [ebp-10h]
    int v41; // [esp+50h] [ebp-Ch]
    char v42; // [esp+54h] [ebp-8h]
    int v43; // [esp+55h] [ebp-7h]
    int v44; // [esp+60h] [ebp+4h]
    int v45; // [esp+60h] [ebp+4h]
    float v46; // [esp+60h] [ebp+4h]

    v3 = *(_DWORD*)(LODWORD(a2) + 16);
    switch (*(_WORD*)(LODWORD(a2) + 12))
    {
    case 0x802:
        if (*(_BYTE*)(dword_4F5CC4 + 937))
        {
            v22 = *(_DWORD*)(this + 452);
            if (v22)
            {
                v44 = *(__int16*)(v3 + 13);
                v35[0] = (float)*(__int16*)(v3 + 11);
                v23 = (double)v44;
                v45 = *(__int16*)(v3 + 15);
                v24 = *(_BYTE*)(v3 + 10);
                v35[1] = v23;
                v32 = v24;
                v25 = *(unsigned __int8*)(v3 + 19);
                v35[2] = (float)v45;
                v26 = *(__int16*)(v3 + 17);
                v46 = (double)v25 * 0.0039215689;
                v27 = sub_417190(v22, *(__int16*)(v3 + 8), v35, v32);
                sub_415930(*(_DWORD*)(this + 452), v26, v46);
                if (v27)
                    *(_BYTE*)(this + 436) = 1;
            }
        }
        break;
    case 0x803:
        if (*(_BYTE*)(dword_4F5CC4 + 936))
        {
            dword_5216E8 = *(_DWORD*)(LODWORD(a2) + 4);
            v10 = *(_DWORD*)(v3 + 16);
            v11 = *(_DWORD*)(v3 + 20);
            v34[0] = *(_DWORD*)(v3 + 12);
            v12 = *(_BYTE*)(v3 + 28);
            v34[1] = v10;
            v13 = *(float*)(v3 + 24);
            v34[2] = v11;
            v14 = sub_4666E0((char*)this, *(_DWORD*)(v3 + 8), (int)v34, v13, v12);
            if (v14)
            {
                v15 = sub_411B60(dword_4F5CC4, *(_DWORD*)(LODWORD(a2) + 4));
                if (v15)
                {
                    v31 = *(const char**)(*(_DWORD*)(this + 412) + 4);
                    v29 = (const char*)(v15 + 3);
                    v16 = sub_436A90(*(_DWORD*)(dword_520970 + 224));
                    sub_421190(v16, "%s destroyed a %s", v29, v31);
                }
                sub_411BB0(dword_4F5CC4, *(_DWORD*)(LODWORD(a2) + 4));
            }
            v17 = *(_DWORD*)(v3 + 12);
            v18 = *(_DWORD*)(v3 + 16);
            v36[3] = *(_WORD*)(this + 392);
            v19 = *(_DWORD*)(v3 + 20);
            v38 = v17;
            v20 = *(_DWORD*)(v3 + 24);
            v39 = v18;
            LOBYTE(v18) = *(_BYTE*)(v3 + 28);
            v40 = v19;
            v21 = *(_DWORD*)(v3 + 8);
            v41 = v20;
            v42 = v18;
            v37 = v21;
            if (v14)
                v43 = *(_DWORD*)(LODWORD(a2) + 4);
            else
                v43 = 0;
            sub_4117A0((_DWORD*)dword_4F5CC4, (int**)0x804, v36, 33, 11, 10000);
            dword_5216E8 = 0;
        }
        break;
    case 0x804:
        v4 = *(_DWORD*)(v3 + 16);
        v5 = *(_DWORD*)(v3 + 20);
        v33[0] = *(_DWORD*)(v3 + 12);
        v6 = *(_BYTE*)(v3 + 28);
        v33[1] = v4;
        v7 = *(float*)(v3 + 24);
        v33[2] = v5;
        sub_4666E0((char*)this, *(_DWORD*)(v3 + 8), (int)v33, v7, v6);
        if (*(_DWORD*)(v3 + 29))
        {
            v8 = sub_411B60(dword_4F5CC4, *(_DWORD*)(v3 + 29));
            if (v8)
            {
                v30 = *(const char**)(*(_DWORD*)(this + 412) + 4);
                v28 = (const char*)(v8 + 3);
                v9 = sub_436A90(*(_DWORD*)(dword_520970 + 224));
                sub_421190(v9, "%s destroyed a %s", v28, v30);
            }
            sub_411BB0(dword_4F5CC4, *(_DWORD*)(v3 + 29));
        }
        break;
    }
}
// 4F5CC4: using guessed type int dword_4F5CC4;
// 520970: using guessed type int dword_520970;
// 5216E8: using guessed type int dword_5216E8;

//----- (00467E30) --------------------------------------------------------
char __cdecl sub_467E30(int a1)
{
    int v1; // eax
    int v2; // edi
    int v3; // eax
    int v4; // eax
    char v5; // bl
    double v6; // st7
    char result; // al
    double v8; // st7
    _DWORD* v9; // eax
    float v10; // [esp+0h] [ebp-Ch]
    float v11; // [esp+0h] [ebp-Ch]
    float v12; // [esp+4h] [ebp-8h]
    float v13; // [esp+4h] [ebp-8h]
    int v14; // [esp+8h] [ebp-4h]

    if (!*(_DWORD*)(a1 + 448) || sub_417160(*(_DWORD**)(a1 + 452)) > 0)
        return sub_418E50(*(_DWORD*)(a1 + 452), 1, COERCE_FLOAT(1));
    v1 = *(_DWORD*)(a1 + 448);
    if (v1 == 1)
    {
        v2 = *(_DWORD*)(*(_DWORD*)(a1 + 452) + 4132);
        v3 = *(_DWORD*)(a1 + 412);
        v10 = *(float*)(v3 + 1208);
        v12 = *(float*)(v3 + 1212);
        if (v10 == v12)
            v11 = *(float*)(v3 + 1208);
        else
            v11 = fabs((double)rand() * 0.000030518509) * (v12 - v10) + v10;
        v4 = *(_DWORD*)(a1 + 452);
        v14 = *(_DWORD*)(v4 + 4284);
        *(_DWORD*)(v4 + 4284) = *(_DWORD*)(*(_DWORD*)(a1 + 412) + 1216);
        v5 = 1;
        v13 = 0.0;
        if (v11 > 0.0)
        {
            while (sub_419910(*(_DWORD*)(a1 + 452), 0.0, 0.0, COERCE_FLOAT(1), 1, 0))
            {
                v6 = v13 + *(float*)(*(_DWORD*)(a1 + 412) + 1192);
                v13 = v6;
                if (v6 >= v11)
                    goto LABEL_12;
            }
            v5 = 0;
        }
    LABEL_12:
        *(_DWORD*)(*(_DWORD*)(a1 + 452) + 4284) = v14;
        if (!v5 || !sub_419910(*(_DWORD*)(a1 + 452), 0.0, 0.0, COERCE_FLOAT(1), 1, 0))
        {
            sub_4164A0(*(_DWORD*)(a1 + 452), v2);
            return 0;
        }
        v8 = v11 + *(float*)(a1 + 456);
        *(_DWORD*)(a1 + 448) = 0;
        result = 1;
        *(float*)(a1 + 456) = v8;
    }
    else
    {
        if (v1 != 2)
            return 0;
        v9 = (_DWORD*)sub_417140(*(_DWORD**)(a1 + 452), 0);
        return sub_416350(*(_DWORD*)(a1 + 452), v9, 0);
    }
    return result;
}

//----- (00468000) --------------------------------------------------------
int __usercall sub_468000@<eax>(int a1@<ecx>, int a2@<ebp>)
{
    int v3; // edi
    int v4; // eax
    int v5; // ebx
    _BYTE* v6; // ebp
    int v7; // eax
    int v8; // edi
    void* v9; // ecx
    int v10; // eax
    char* v11; // edx
    int v12; // eax
    int v13; // edi
    void* v14; // edx
    int v15; // eax
    int v18; // [esp+8h] [ebp-1Ch]
    int i; // [esp+Ch] [ebp-18h]
    int v20; // [esp+10h] [ebp-14h]
    int v21; // [esp+10h] [ebp-14h]

    sub_403B10((_DWORD*)a1);
    v3 = 0;
    *(_BYTE*)(a1 + 628) = 1;
    *(_DWORD*)(a1 + 616) = 0;
    *(_DWORD*)(a1 + 620) = 0;
    *(_DWORD*)(a1 + 624) = 0;
    *(_DWORD*)a1 = &off_499CD4;
    sub_403D90((char*)a1, aIslandPf3);
    sub_403E30(a1, a2);
    *(_DWORD*)(a1 + 588) = sub_422400(*(_DWORD**)(dword_520970 + 124), aWater1Tga, 0);
    *(_DWORD*)(a1 + 592) = sub_422400(*(_DWORD**)(dword_520970 + 124), aWater2Tga, 0);
    *(_DWORD*)(a1 + 596) = sub_422400(*(_DWORD**)(dword_520970 + 124), aWater3Tga, 0);
    *(_DWORD*)(a1 + 600) = sub_422400(*(_DWORD**)(dword_520970 + 124), aWater4Tga, 0);
    v4 = *(_DWORD*)(a1 + 8);
    *(_DWORD*)(a1 + 604) = 0;
    *(_DWORD*)(a1 + 608) = 1;
    *(_DWORD*)(a1 + 612) = 0x40000000;
    v18 = 0;
    if (v4 > 0)
    {
        for (i = 0; ; i += 172)
        {
            v5 = v3 + *(_DWORD*)(a1 + 4);
            if (*(_BYTE*)(v5 + 81))
                break;
        LABEL_15:
            v3 = i + 172;
            if (++v18 >= *(_DWORD*)(a1 + 8))
                return a1;
        }
        if (!_strnicmp(*(const char**)(v5 + 8), aWave, strlen(aWave)))
        {
            v6 = operator new(0x1Cu);
            v6[8] = 0;
            *((_DWORD*)v6 + 6) = 1065353216;
            *(_DWORD*)v6 = v5;
            *((_DWORD*)v6 + 1) = v18;
            *((float*)v6 + 3) = fabs((double)rand() * 0.000030518509) * 0.85000002 + 0.15000001;
            v20 = rand();
            *((_DWORD*)v6 + 5) = 0;
            *((float*)v6 + 4) = fabs((double)v20 * 0.000030518509) * 0.050000004 + 0.1;
            v7 = *(_DWORD*)(a1 + 624);
            v8 = *(_DWORD*)(a1 + 620) + 1;
            *(_DWORD*)(a1 + 620) = v8;
            if (v8 <= v7)
                goto LABEL_13;
            v9 = *(void**)(a1 + 616);
            v10 = v7 + 8;
            *(_DWORD*)(a1 + 624) = v10;
            v11 = (char*)sub_488DD7(v9, 4 * v10);
            if (!v11)
                goto LABEL_13;
        }
        else
        {
            if (!*(_BYTE*)(v5 + 81) || _strnicmp(*(const char**)(v5 + 8), aFoam, strlen(aFoam)))
                goto LABEL_15;
            v6 = operator new(0x1Cu);
            v6[8] = 1;
            *((_DWORD*)v6 + 6) = 1065353216;
            *(_DWORD*)v6 = v5;
            *((_DWORD*)v6 + 1) = v18;
            *((float*)v6 + 3) = fabs((double)rand() * 0.000030518509);
            v21 = rand();
            *((_DWORD*)v6 + 5) = 0;
            *((float*)v6 + 4) = fabs((double)v21 * 0.000030518509) * 0.0099999998 + 0.025;
            v12 = *(_DWORD*)(a1 + 624);
            v13 = *(_DWORD*)(a1 + 620) + 1;
            *(_DWORD*)(a1 + 620) = v13;
            if (v13 <= v12)
                goto LABEL_13;
            v14 = *(void**)(a1 + 616);
            v15 = v12 + 8;
            *(_DWORD*)(a1 + 624) = v15;
            v11 = (char*)sub_488DD7(v14, 4 * v15);
            if (!v11)
                goto LABEL_13;
        }
        *(_DWORD*)(a1 + 616) = v11;
        memset(&v11[4 * *(_DWORD*)(a1 + 620)], 0, 4 * (*(_DWORD*)(a1 + 624) - *(_DWORD*)(a1 + 620)));
    LABEL_13:
        *(_DWORD*)(*(_DWORD*)(a1 + 616) + 4 * *(_DWORD*)(a1 + 620) - 4) = v6;
        if (v6)
        {
            *(_BYTE*)(*(_DWORD*)v6 + 57) = 1;
            sub_4229D0("%s using %s", *(const char**)(v5 + 8), *(const char**)(*(_DWORD*)(v5 + 52) + 76));
        }
        goto LABEL_15;
    }
    return a1;
}
// 499CD4: using guessed type int (__stdcall *off_499CD4)(int, int, int);
// 520970: using guessed type int dword_520970;

//----- (00468370) --------------------------------------------------------
void __thiscall sub_468370(int this)
{
    int i; // edi
    void* v3; // eax

    *(_DWORD*)this = &off_499CD4;
    *(_DWORD*)(this + 56) = 0;
    if (*(_BYTE*)(this + 628))
    {
        for (i = 0; i < *(_DWORD*)(this + 620); ++i)
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 616) + 4 * i));
    }
    memset(*(void**)(this + 616), 0, 4 * *(_DWORD*)(this + 620));
    v3 = *(void**)(this + 616);
    *(_DWORD*)(this + 620) = 0;
    sub_488CEE(v3);
    *(_DWORD*)(this + 624) = 0;
    *(_DWORD*)(this + 616) = 0;
    sub_403B60((_DWORD*)this);
}
// 499CD4: using guessed type int (__stdcall *off_499CD4)(int, int, int);

//----- (00468400) --------------------------------------------------------
int __thiscall sub_468400(int this, float a2)
{
    double v3; // st7
    int v4; // edx
    int v5; // eax
    int result; // eax
    int i; // ebp
    float* v8; // esi
    double v9; // st7
    long double v10; // st7
    _DWORD* v11; // eax
    double v12; // st7
    double v13; // st7
    double v14; // st6
    double v15; // st7
    double v16; // st6
    _DWORD* v17; // ecx
    int v18; // [esp+0h] [ebp-1Ch]
    float v19; // [esp+4h] [ebp-18h]
    float v20; // [esp+Ch] [ebp-10h]
    float v21; // [esp+18h] [ebp-4h]

    *(_BYTE*)(*(_DWORD*)(this + 4) + 172 * sub_405A30((_DWORD*)this, aIsland, -1, 1) + 80) = 0;
    if (byte_520974)
    {
        v3 = *(float*)(this + 612) - a2;
        *(float*)(this + 612) = v3;
        if (v3 < 0.0)
        {
            v4 = *(_DWORD*)(this + 604);
            *(_DWORD*)(this + 612) = 0x40000000;
            *(_DWORD*)(this + 604) = v4 + 1;
            if (v4 == 3)
                *(_DWORD*)(this + 604) = 0;
            v5 = *(_DWORD*)(this + 608) + 1;
            *(_DWORD*)(this + 608) = v5;
            if (v5 == 4)
                *(_DWORD*)(this + 608) = 0;
        }
    }
    *(float*)&v18 = *(float*)(dword_520970 + 72) * 0.0026179941;
    sub_4685D0(this, this, aWater, v18, 0.059999999, 0.015, v20);
    result = *(_DWORD*)(this + 620);
    for (i = 0; i < result; ++i)
    {
        v8 = *(float**)(*(_DWORD*)(this + 616) + 4 * i);
        if (*((_BYTE*)v8 + 8))
        {
            v9 = a2 * v8[4] + v8[3];
            v8[3] = v9;
            v10 = v9 * 6.2831855;
        }
        else
        {
            v11 = (_DWORD*)*((_DWORD*)v8 + 5);
            if (v11)
            {
                if (v11 == (_DWORD*)1)
                {
                    v15 = a2 * v8[4];
                    v16 = v8[3] - v15 * 0.5;
                    v8[3] = v16;
                    v8[6] = v8[6] - (v15 + v15);
                    if (v16 < 0.75)
                    {
                        v8[6] = 0.0;
                        v8[3] = 0.15000001;
                        v8[5] = 0.0;
                        v17 = *(_DWORD**)(dword_520970 + 240);
                        if (v17)
                            sub_44CD90(v17, (float*)(*(_DWORD*)v8 + 60));
                    }
                }
            }
            else
            {
                v12 = a2 * v8[4];
                v21 = v12;
                v13 = v12 + v8[3];
                v8[3] = v13;
                v14 = v21 + v21 + v8[6];
                v8[6] = v14;
                if (v14 > 1.0)
                    v8[6] = 1.0;
                if (v13 > 1.0)
                {
                    v8[3] = 1.0;
                    *((_DWORD*)v8 + 5) = 1;
                }
            }
            v10 = v8[3] * 1.5707964;
        }
        v19 = sin(v10);
        sub_468750(*(_DWORD**)v8, v19);
        result = *(_DWORD*)(this + 620);
    }
    return result;
}
// 4684B4: variable 'v20' is possibly undefined
// 520970: using guessed type int dword_520970;
// 520974: using guessed type char byte_520974;

//----- (004685D0) --------------------------------------------------------
void __userpurge sub_4685D0(int a1@<ecx>, int a2@<edi>, char* String2, int a4, float a5, float a6, float a7)
{
    int v8; // ebx
    int v9; // esi
    int v10; // eax
    int v11; // edi
    char* v12; // ecx
    float v13; // edx
    float* v14; // eax
    long double v15; // st6
    long double v16; // st7
    long double v17; // st7
    float v19; // [esp+18h] [ebp-10h]
    float v20; // [esp+20h] [ebp-8h] BYREF
    char* v21; // [esp+24h] [ebp-4h]
    char* retaddr; // [esp+28h] [ebp+0h]

    v8 = 0;
    v19 = 0.0;
    if (*(int*)(a1 + 8) > 0)
    {
        do
        {
            v9 = *(_DWORD*)(a1 + 4) + v8;
            if (*(_BYTE*)(v9 + 81) && !_strnicmp(*(const char**)(v9 + 8), String2, strlen(String2)))
            {
                v10 = *(_DWORD*)(v9 + 36);
                v11 = 0;
                v21 = 0;
                (*(void(__stdcall**)(int, _DWORD, _DWORD, float*, _DWORD, int))(*(_DWORD*)v10 + 44))(v10, 0, 0, &v20, 0, a2);
                v12 = v21;
                retaddr = v21;
                if (*(int*)(v9 + 40) > 0)
                {
                    v13 = v20;
                    do
                    {
                        v14 = (float*)&v12[*(_DWORD*)(LODWORD(v13) + 24)];
                        v19 = v14[1];
                        if (a7 == 0.0)
                            v15 = 0.0;
                        else
                            v15 = (v19 * 3.1415927 + a5) / a7;
                        v16 = *v14 + (sin(v15) * 0.30000001 + 0.69999999) * a6;
                        *(float*)&v12[*(_DWORD*)(LODWORD(v13) + 20)] = v16;
                        if (a7 == 0.0)
                            v17 = 0.0;
                        else
                            v17 = (v16 * 3.1415927 + a5 * 1.23) / a7;
                        *(float*)&retaddr[*(_DWORD*)(LODWORD(v20) + 20) + 4] = (cos(v17 * 0.86) * 0.30000001 + 0.69999999) * a6
                            + v19;
                        v13 = v20;
                        v12 = &retaddr[*(_DWORD*)(LODWORD(v20) + 84)];
                        ++v11;
                        retaddr = v12;
                    } while (v11 < *(_DWORD*)(v9 + 40));
                }
                a2 = *(_DWORD*)(v9 + 36);
                (*(void (**)(void))(*(_DWORD*)a2 + 48))();
            }
            v8 += 172;
            ++LODWORD(v19);
        } while (SLODWORD(v19) < *(_DWORD*)(a1 + 8));
    }
}
// 4685D0: could not find valid save-restore pair for edi

//----- (00468750) --------------------------------------------------------
int __stdcall sub_468750(_DWORD* a1, float a2)
{
    int v2; // eax
    int v3; // ecx
    int v4; // eax
    int v5; // edx
    _DWORD* v6; // ecx
    int v7; // edi
    int v9; // [esp+18h] [ebp-8h] BYREF
    int v10; // [esp+1Ch] [ebp-4h]

    v2 = a1[9];
    v10 = 0;
    (*(void(__stdcall**)(int, _DWORD, _DWORD, int*, _DWORD))(*(_DWORD*)v2 + 44))(v2, 0, 0, &v9, 0);
    v3 = a1[10];
    v4 = v9;
    v5 = 0;
    v10 = v9;
    if (v3 > 0)
    {
        v6 = a1 + 21;
        do
        {
            *(float*)(v6[5] + v4 + 4) = *(float*)(v6[6] + v4 + 4) + a2;
            v6 = a1 + 21;
            v4 = a1[42] + v10;
            v7 = a1[10];
            ++v5;
            v10 = v4;
        } while (v5 < v7);
    }
    return (*(int(__stdcall**)(_DWORD))(*(_DWORD*)a1[9] + 48))(a1[9]);
}

//----- (004687D0) --------------------------------------------------------
int __thiscall sub_4687D0(int* this, int a2, int a3)
{
    int result; // eax
    double v6; // st7
    int v7; // ecx
    int v8; // eax
    _DWORD** v9; // edx
    float v10[17]; // [esp+18h] [ebp-44h] BYREF
    int v11; // [esp+60h] [ebp+4h]
    int v12; // [esp+60h] [ebp+4h]

    if (!_strnicmp(*(const char**)(a2 + 8), aWater, strlen(aWater)))
    {
        (*(void(__thiscall**)(int*, int, _DWORD, _DWORD)) * this)(this, a2, 0, 0);
        sub_41BEF0((_DWORD*)dword_520A50, 0, this[this[151] + 147], 1, 0);
        result = sub_406000((_DWORD*)a2, a3);
        v11 = result;
        if (byte_520974)
        {
            (*(void(__thiscall**)(int*, int, _DWORD, _DWORD)) * this)(this, a2, 0, 0);
            v6 = (2.0 - *((float*)this + 153)) * 0.5;
            qmemcpy(v10, (const void*)(*(_DWORD*)(a2 + 52) + 4), sizeof(v10));
            v10[3] = v6;
            v10[7] = v6;
            (*(void(__stdcall**)(_DWORD, float*))(**(_DWORD**)ArgList + 168))(*(_DWORD*)ArgList, v10);
            sub_41BEF0((_DWORD*)dword_520A50, 0, this[this[152] + 147], 1, 0);
            sub_41BC00((_DWORD*)dword_520A50, 0, 1, 0, 0, 1, -1, 1);
            return sub_406000((_DWORD*)a2, a3) + v11;
        }
    }
    else
    {
        if (!_strnicmp(*(const char**)(a2 + 8), aWave, strlen(aWave))
            || !_strnicmp(*(const char**)(a2 + 8), aFoam, strlen(aFoam)))
        {
            v7 = this[155];
            v8 = 0;
            v12 = 0;
            if (v7 > 0)
            {
                v9 = (_DWORD**)this[154];
                while (**v9 != a2)
                {
                    ++v8;
                    ++v9;
                    if (v8 >= v7)
                        goto LABEL_13;
                }
                v12 = *(_DWORD*)(this[154] + 4 * v8);
            }
        LABEL_13:
            (*(void(__thiscall**)(int*, int, _DWORD, _DWORD)) * this)(this, a2, 0, 0);
            if (v12)
            {
                qmemcpy(v10, (const void*)(*(_DWORD*)(a2 + 52) + 4), sizeof(v10));
                v10[7] = *(float*)(v12 + 24);
                v10[3] = v10[7];
                v10[15] = v10[7];
                v10[11] = v10[7];
                (*(void(__stdcall**)(_DWORD, float*))(**(_DWORD**)ArgList + 168))(*(_DWORD*)ArgList, v10);
                sub_41BC00((_DWORD*)dword_520A50, 0, 1, -1, -1, -1, -1, 1);
            }
        }
        else
        {
            (*(void(__thiscall**)(int*, int, _DWORD, _DWORD)) * this)(this, a2, 0, 0);
        }
        return sub_406000((_DWORD*)a2, a3);
    }
    return result;
}
// 520974: using guessed type char byte_520974;
// 520A50: using guessed type int dword_520A50;

//----- (00468A00) --------------------------------------------------------
int __usercall sub_468A00@<eax>(int a1@<ecx>, int a2@<ebp>)
{
    void* v3; // eax
    int v4; // eax
    _DWORD* v5; // eax
    void* v6; // edi
    int v7; // eax
    int i; // edi
    int* v9; // edi
    int v10; // eax
    int v11; // edi
    void* v12; // eax
    void* v13; // eax

    *(_DWORD*)(a1 + 4) = 0;
    *(_DWORD*)(a1 + 8) = 0;
    *(_DWORD*)(a1 + 12) = 0;
    *(_BYTE*)(a1 + 16) = 1;
    *(_DWORD*)a1 = &off_499CF8;
    *(_DWORD*)(a1 + 20) = 0;
    *(_DWORD*)(a1 + 24) = 0;
    *(_DWORD*)(a1 + 44) = 0;
    v3 = operator new(0x278u);
    if (v3)
        v4 = sub_468000((int)v3, a2);
    else
        v4 = 0;
    *(_DWORD*)(a1 + 20) = v4;
    v5 = sub_406A90(v4, 1);
    *(_DWORD*)(a1 + 24) = v5;
    if (v5)
    {
        sub_428680((_DWORD*)a1, (int)v5);
        v7 = *(_DWORD*)(a1 + 20);
        for (i = 0; i < *(_DWORD*)(v7 + 620); ++i)
        {
            sub_408580(*(_DWORD**)(a1 + 24), *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(v7 + 616) + 4 * i) + 4), 3);
            v7 = *(_DWORD*)(a1 + 20);
        }
    }
    else
    {
        v6 = *(void**)(a1 + 20);
        if (v6)
        {
            sub_468370(*(_DWORD*)(a1 + 20));
            sub_4885A6(v6);
        }
        *(_DWORD*)(a1 + 20) = 0;
    }
    if (*(_DWORD*)(a1 + 20) && dword_4AE740 != -1)
    {
        v9 = (int*)&unk_4AE748;
        do
        {
            *v9 = sub_405A30(*(_DWORD**)(a1 + 20), (char*)*(v9 - 1), -1, 1);
            v10 = v9[1];
            v9 += 3;
        } while (v10 != -1);
    }
    v11 = sub_405A30(*(_DWORD**)(a1 + 20), aIsland, -1, 1);
    v12 = operator new(0x28u);
    if (v12)
        v13 = sub_450FB0(v12, 64, *(_DWORD*)(a1 + 24), v11);
    else
        v13 = 0;
    *(_DWORD*)(a1 + 44) = v13;
    return a1;
}
// 499CF8: using guessed type _UNKNOWN *off_499CF8;
// 4AE740: using guessed type int dword_4AE740;

//----- (00468BE0) --------------------------------------------------------
double __thiscall sub_468BE0(int* this, int a2, int a3, int* a4)
{
    float* v6; // ecx
    int* v7; // esi
    int v8; // eax
    double v9; // st7
    int v10; // eax
    float v12; // [esp+14h] [ebp+8h]

    v6 = (float*)this[11];
    if (v6)
        v12 = sub_4510D0(v6, *(float*)&a2, *(float*)&a3);
    else
        v12 = -3.4028235e38;
    if (a4)
        *a4 = 2;
    if (this[6])
    {
        v7 = &dword_4AE740;
        if (dword_4AE740 != -1)
        {
            do
            {
                v8 = v7[2];
                if (v8 >= 0)
                {
                    v9 = sub_4081A0(this[6], v8, *(float*)&a2, *(float*)&a3);
                    if (v9 > v12)
                    {
                        v12 = v9;
                        if (a4)
                            *a4 = *v7;
                    }
                }
                v10 = v7[3];
                v7 += 3;
            } while (v10 != -1);
        }
    }
    if (v12 != -3.4028235e38)
        return v12;
    if (a4)
        *a4 = -1;
    return 0.0;
}
// 4AE740: using guessed type int dword_4AE740;

//----- (00468CA0) --------------------------------------------------------
char __thiscall sub_468CA0(int* this, float* a2, int* a3, float* a4, int* a5)
{
    int v6; // ecx
    int* v10; // eax
    int v11; // edx
    double v12; // st7
    double v13; // st6
    double v14; // st5
    int v15; // ebp
    float* v16; // ecx
    double v17; // st7
    char v19; // c0
    float v21; // [esp-20h] [ebp-84h]
    int v22; // [esp-1Ch] [ebp-80h]
    int v23; // [esp-18h] [ebp-7Ch]
    int v24; // [esp-14h] [ebp-78h]
    int v25; // [esp-10h] [ebp-74h]
    int v26; // [esp-Ch] [ebp-70h]
    int v27; // [esp+0h] [ebp-64h]
    float* v28; // [esp+4h] [ebp-60h]
    float v29; // [esp+10h] [ebp-54h]
    int v30; // [esp+14h] [ebp-50h] BYREF
    float v31; // [esp+18h] [ebp-4Ch]
    float v32; // [esp+1Ch] [ebp-48h]
    int* v33; // [esp+20h] [ebp-44h]
    int v34[16]; // [esp+24h] [ebp-40h] BYREF
    float v35; // [esp+68h] [ebp+4h]
    float v36; // [esp+6Ch] [ebp+8h]
    float v37; // [esp+70h] [ebp+Ch]

    v33 = this;
    v6 = this[6];
    if (!v6)
        return 0;
    v26 = a3[2];
    v25 = a3[1];
    v24 = *a3;
    v23 = *((_DWORD*)a2 + 2);
    v22 = *((_DWORD*)a2 + 1);
    v21 = *a2;
    v32 = 3.4028235e38;
    if (!sub_407A90(v6, (int)a4, (int)a2, SLODWORD(v21), v22, v23, v24, v25, v26, &v30, a4, v27, v28))
        goto LABEL_7;
    sub_407690(this[6], v30, v34);
    sub_46C5C5(a4, a4, (float*)v34);
    v10 = &dword_4AE740;
    if (dword_4AE740 == -1)
    {
    LABEL_6:
        v12 = *a2 - *a4;
        v13 = a2[1] - a4[1];
        v14 = a2[2] - a4[2];
        v32 = v14 * v14 + v13 * v13 + v12 * v12;
    LABEL_7:
        v36 = 0.0;
        v35 = 1.0;
        v15 = 0;
        while (1)
        {
            v37 = v35 * *a2 + v36 * *(float*)a3;
            v29 = v35 * a2[1] + v36 * *((float*)a3 + 1);
            v16 = (float*)v33[11];
            v31 = v35 * a2[2] + v36 * *((float*)a3 + 2);
            v17 = sub_4510D0(v16, v37, v29);
            if (v17 >= v31)
            {
                if (v19)
                    break;
            }
            ++v15;
            v36 = v36 + 0.1;
            v35 = v35 - 0.1;
            if (v15 > 10)
                return 0;
        }
        if (a5)
            *a5 = 2;
        a4[2] = v17;
        *a4 = v37;
        a4[1] = v29;
        return 1;
    }
    while (v10[2] != v30)
    {
        v11 = v10[3];
        v10 += 3;
        if (v11 == -1)
            goto LABEL_6;
    }
    if (a5)
        *a5 = *v10;
    return 1;
}
// 468CE8: variable 'v27' is possibly undefined
// 468CE8: variable 'v28' is possibly undefined
// 468E01: variable 'v19' is possibly undefined
// 4AE740: using guessed type int dword_4AE740;

//----- (00468E90) --------------------------------------------------------
_DWORD* __thiscall sub_468E90(_DWORD** this, int a2)
{
    int i; // esi
    int v4; // eax
    int v5; // ebp
    int j; // esi
    int* v7; // ecx
    _DWORD* result; // eax
    char Buffer[80]; // [esp+10h] [ebp-154h] BYREF
    char v10[260]; // [esp+60h] [ebp-104h] BYREF

    for (i = 1; i <= 9; ++i)
    {
        sprintf(Buffer, "island %d", i);
        sprintf(v10, "Sky%02d\\Island %d_Sky%02d.tga", a2, i, a2);
        v4 = sub_405A30(this[5], Buffer, -1, 1);
        sub_403BB0(this[5], v4, v10);
    }
    v5 = 0;
    for (j = 147; j < 151; this[5][j - 1] = result)
    {
        sprintf(v10, "Sky%02d\\Water%d_Sky%02d.tga", a2, ++v5, a2);
        v7 = (int*)this[5][j];
        if (v7)
        {
            sub_422230(v7);
            this[5][j] = 0;
        }
        result = sub_409AF0((_DWORD**)dword_520970, v10, 0);
        ++j;
    }
    return result;
}
// 520970: using guessed type int dword_520970;

//----- (00468F60) --------------------------------------------------------
char __thiscall sub_468F60(int this, int a2)
{
    (*(void(__thiscall**)(_DWORD, int))(**(_DWORD**)(this + 20) + 8))(*(_DWORD*)(this + 20), a2);
    return sub_428620((_DWORD*)this, a2);
}

//----- (00468F80) --------------------------------------------------------
int __thiscall sub_468F80(int this, int a2)
{
    int result; // eax

    result = (*(int(__thiscall**)(_DWORD, int))(**(_DWORD**)(this + 24) + 24))(*(_DWORD*)(this + 24), a2);
    *(_BYTE*)(this + 16) = a2;
    return result;
}

//----- (00468FA0) --------------------------------------------------------
int __fastcall sub_468FA0(int a1)
{
    int result; // eax

    result = a1;
    *(_BYTE*)(a1 + 276) = HIBYTE(a1);
    *(_DWORD*)(a1 + 280) = 0;
    *(_DWORD*)(a1 + 284) = 0;
    *(_DWORD*)(a1 + 288) = 0;
    *(_DWORD*)a1 = &off_499D18;
    return result;
}
// 499D18: using guessed type _UNKNOWN *off_499D18;

//----- (00468FF0) --------------------------------------------------------
void* __thiscall sub_468FF0(void* this, char* a2)
{
    *((_BYTE*)this + 276) = (_BYTE)a2;
    *((_DWORD*)this + 70) = 0;
    *((_DWORD*)this + 71) = 0;
    *((_DWORD*)this + 72) = 0;
    *(_DWORD*)this = &off_499D18;
    if (!sub_40AE70(a2, aName_0))
        sub_40AFE0(a2, aName_0, (char**)this + 1);
    strcpy((char*)this + 16, a2 + 16);
    return this;
}
// 499D18: using guessed type _UNKNOWN *off_499D18;

//----- (004690A0) --------------------------------------------------------
int __thiscall sub_4690A0(void* this)
{
    void* v2; // eax
    int result; // eax

    v2 = (void*)*((_DWORD*)this + 1);
    *(_DWORD*)this = &off_499D18;
    sub_4885A6(v2);
    sub_4885A6(*((LPVOID*)this + 70));
    result = 0;
    *((_DWORD*)this + 70) = 0;
    *((_DWORD*)this + 71) = 0;
    *((_DWORD*)this + 72) = 0;
    return result;
}
// 499D18: using guessed type _UNKNOWN *off_499D18;

//----- (004690E0) --------------------------------------------------------
int __thiscall sub_4690E0(_DWORD* this)
{
    unsigned int v1; // ebx
    int i; // edi
    int result; // eax

    v1 = 0;
    for (i = 0; ; i += 16)
    {
        result = this[70];
        if (!result || v1 >= (this[71] - result) >> 4)
            break;
        (*(void(__thiscall**)(_DWORD))(**(_DWORD**)(result + i + 4) + 4))(*(_DWORD*)(result + i + 4));
        ++v1;
    }
    return result;
}

//----- (00469120) --------------------------------------------------------
int __thiscall sub_469120(_DWORD* this)
{
    unsigned int v1; // ebx
    int i; // edi
    int result; // eax

    v1 = 0;
    for (i = 0; ; i += 16)
    {
        result = this[70];
        if (!result || v1 >= (this[71] - result) >> 4)
            break;
        (*(void(__thiscall**)(_DWORD))(**(_DWORD**)(result + i + 4) + 8))(*(_DWORD*)(result + i + 4));
        ++v1;
    }
    return result;
}

//----- (00469160) --------------------------------------------------------
unsigned int __thiscall sub_469160(int this, _DWORD* a2, const char* a3, const char* a4)
{
    int v5; // eax
    int v6; // ebx
    int v7; // ecx
    unsigned int v8; // edi
    unsigned int v9; // eax
    int v10; // eax
    int v11; // ebx
    unsigned int result; // eax
    int v13; // eax
    int v14; // ecx
    int v15; // esi
    int v16; // edx
    unsigned int v17; // eax
    unsigned int v18; // edi
    int v19; // edi
    char* v20; // [esp+10h] [ebp-14h]
    _DWORD v21[4]; // [esp+14h] [ebp-10h] BYREF

    if (a3 && a4)
    {
        v5 = *(_DWORD*)(this + 280);
        if (v5)
            v6 = (*(_DWORD*)(this + 284) - v5) >> 4;
        else
            v6 = 0;
        v7 = *(_DWORD*)(this + 280);
        v8 = v6 + 1;
        if (v7)
            v9 = (*(_DWORD*)(this + 284) - v7) >> 4;
        else
            v9 = 0;
        if (v9 >= v8)
        {
            if (v8 < sub_448730((_DWORD*)(this + 276)))
                sub_448750((_DWORD*)(this + 276), (_DWORD*)(*(_DWORD*)(this + 280) + 16 * v8), *(_DWORD**)(this + 284));
        }
        else
        {
            v20 = *(char**)(this + 284);
            v10 = sub_448730((_DWORD*)(this + 276));
            sub_419CF0((char*)(this + 276), v20, v8 - v10, v21);
        }
        v11 = 16 * v6;
        *(_DWORD*)(*(_DWORD*)(this + 280) + v11) = a2;
        **(_DWORD**)(*(_DWORD*)(this + 280) + v11) = 0;
        *(_DWORD*)(*(_DWORD*)(this + 280) + v11 + 4) = 0;
        *(_DWORD*)(*(_DWORD*)(this + 280) + v11 + 8) = operator new(0x80u);
        strcpy(*(char**)(*(_DWORD*)(this + 280) + v11 + 8), a3);
        *(_DWORD*)(*(_DWORD*)(this + 280) + v11 + 12) = operator new(0x80u);
        result = strlen(a4) + 1;
        qmemcpy(*(void**)(*(_DWORD*)(this + 280) + v11 + 12), a4, result);
    }
    else
    {
        v13 = *(_DWORD*)(this + 280);
        v14 = this + 276;
        if (v13)
            v15 = (*(_DWORD*)(this + 284) - v13) >> 4;
        else
            v15 = 0;
        v16 = *(_DWORD*)(this + 280);
        v17 = v15 + 1;
        if (v16)
            v18 = (*(_DWORD*)(this + 284) - v16) >> 4;
        else
            v18 = 0;
        if (v18 >= v17)
        {
            if (v16 && v17 < (*(_DWORD*)(this + 284) - v16) >> 4)
                sub_448750((_DWORD*)v14, (_DWORD*)(v16 + 16 * v17), *(_DWORD**)(v14 + 8));
        }
        else
        {
            if (v16)
                v19 = (*(_DWORD*)(this + 284) - v16) >> 4;
            else
                v19 = 0;
            sub_419CF0((char*)v14, *(char**)(this + 284), v17 - v19, v21);
        }
        result = 16 * v15;
        *(_DWORD*)(*(_DWORD*)(this + 280) + result) = 0;
        *(_DWORD*)(*(_DWORD*)(this + 280) + result + 4) = *a2;
        *(_DWORD*)(*(_DWORD*)(this + 280) + result + 8) = 0;
        *(_DWORD*)(*(_DWORD*)(this + 280) + result + 12) = 0;
    }
    return result;
}

//----- (00469370) --------------------------------------------------------
unsigned int __thiscall sub_469370(int this, _DWORD* a2)
{
    int v2; // esi
    unsigned int result; // eax
    int v5; // ecx
    int v6; // ebx
    int v7; // eax
    bool v8; // al
    char* v9; // [esp-10h] [ebp-24h]
    const char* v10; // [esp-Ch] [ebp-20h]
    const char* v11; // [esp-8h] [ebp-1Ch]
    unsigned int i; // [esp+10h] [ebp-4h]

    v2 = 0;
    for (i = 0; ; ++i)
    {
        result = *(_DWORD*)(this + 280);
        if (!result)
            break;
        v5 = *(_DWORD*)(this + 284) - result;
        result = i;
        if (i >= v5 >> 4)
            break;
        v6 = *(_DWORD*)(this + 280);
        if (!*(_DWORD*)(v2 + v6 + 4))
        {
            *(_DWORD*)(v2 + v6 + 4) = sub_469650(a2, *(char**)(v2 + v6 + 8), *(char**)(v2 + v6 + 12), 1);
            sub_40A120(
                *(_DWORD*)(*(_DWORD*)(this + 280) + v2 + 4) != 0,
                "could not find type info for %s, see %s",
                *(const char**)(*(_DWORD*)(this + 280) + v2 + 8),
                *(const char**)(this + 4));
            v7 = *(_DWORD*)(this + 280);
            if (**(_DWORD**)(v2 + v7))
            {
                v11 = *(const char**)(this + 4);
                v10 = *(const char**)(*(_DWORD*)(v2 + v7 + 4) + 12);
                v9 = *(char**)(v2 + v7 + 12);
                v8 = sub_4696E0(*(_DWORD*)(v2 + v7 + 4), v9);
                sub_40A120(
                    v8,
                    "linking mismatch, requested %s, received %s, see %s : %s",
                    v9,
                    v10,
                    v11,
                    (const char*)(this + 16));
            }
            **(_DWORD**)(v2 + *(_DWORD*)(this + 280)) = *(_DWORD*)(v2 + *(_DWORD*)(this + 280) + 4);
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 280) + v2 + 8));
            *(_DWORD*)(*(_DWORD*)(this + 280) + v2 + 8) = 0;
            sub_4885A6(*(LPVOID*)(*(_DWORD*)(this + 280) + v2 + 12));
            *(_DWORD*)(*(_DWORD*)(this + 280) + v2 + 12) = 0;
        }
        v2 += 16;
    }
    return result;
}

//----- (004694A0) --------------------------------------------------------
void* __thiscall sub_4694A0(void* this)
{
    int i; // edi
    void(__thiscall * **v3)(_DWORD, int); // ecx
    void* v4; // eax

    *((_DWORD*)this + 1) = 0;
    *((_DWORD*)this + 2) = 0;
    *((_DWORD*)this + 3) = 0;
    *((_BYTE*)this + 16) = 1;
    *((_DWORD*)this + 5) = 0;
    *((_DWORD*)this + 6) = 0;
    *((_DWORD*)this + 7) = 0;
    *((_BYTE*)this + 32) = 1;
    *(_DWORD*)this = &off_499D24;
    if (*((_BYTE*)this + 32))
    {
        for (i = 0; i < *((_DWORD*)this + 6); ++i)
        {
            v3 = *(void(__thiscall****)(_DWORD, int))(*((_DWORD*)this + 5) + 4 * i);
            if (v3)
                (**v3)(v3, 1);
        }
    }
    memset(*((void**)this + 5), 0, 4 * *((_DWORD*)this + 6));
    v4 = (void*)*((_DWORD*)this + 5);
    *((_DWORD*)this + 6) = 0;
    sub_488CEE(v4);
    *((_DWORD*)this + 7) = 0;
    *((_DWORD*)this + 5) = 0;
    *((_DWORD*)this + 9) = 0;
    return this;
}
// 499D24: using guessed type _UNKNOWN *off_499D24;

//----- (00469580) --------------------------------------------------------
void __thiscall sub_469580(void* this)
{
    int i; // edi
    int v3; // ecx
    int j; // edi
    void(__thiscall * **v5)(_DWORD, int); // ecx
    void* v6; // eax

    *(_DWORD*)this = &off_499D24;
    if (byte_520A10)
    {
        for (i = 0; i < *((_DWORD*)this + 6); ++i)
        {
            v3 = *(_DWORD*)(*((_DWORD*)this + 5) + 4 * i);
            (*(void(__thiscall**)(int))(*(_DWORD*)v3 + 8))(v3);
        }
    }
    if (*((_BYTE*)this + 32))
    {
        for (j = 0; j < *((_DWORD*)this + 6); ++j)
        {
            v5 = *(void(__thiscall****)(_DWORD, int))(*((_DWORD*)this + 5) + 4 * j);
            if (v5)
                (**v5)(v5, 1);
        }
    }
    memset(*((void**)this + 5), 0, 4 * *((_DWORD*)this + 6));
    v6 = (void*)*((_DWORD*)this + 5);
    *((_DWORD*)this + 6) = 0;
    sub_488CEE(v6);
    *((_DWORD*)this + 7) = 0;
    *((_DWORD*)this + 5) = 0;
    *(_DWORD*)this = &off_499040;
}
// 499040: using guessed type void *(__thiscall *off_499040)(std::locale::facet *__hidden this, unsigned int);
// 499D24: using guessed type _UNKNOWN *off_499D24;
// 520A10: using guessed type char byte_520A10;

//----- (00469650) --------------------------------------------------------
int __thiscall sub_469650(_DWORD* this, char* String2, char* a3, char a4)
{
    int v5; // edi

    v5 = 0;
    if ((int)this[6] > 0)
    {
        while (_strcmpi(*(const char**)(*(_DWORD*)(this[5] + 4 * v5) + 4), String2))
        {
            if (++v5 >= this[6])
                return 0;
        }
        if (sub_4696E0(*(_DWORD*)(this[5] + 4 * v5), a3))
            return *(_DWORD*)(this[5] + 4 * v5);
        if (a4)
            sub_40A120(
                0,
                "%s was linked as type %s, but is type %s",
                String2,
                a3,
                *(const char**)(*(_DWORD*)(this[5] + 4 * v5) + 12));
    }
    return 0;
}

//----- (004696E0) --------------------------------------------------------
BOOL __stdcall sub_4696E0(int a1, char* String2)
{
    return _strcmpi(*(const char**)(a1 + 12), String2) == 0;
}

//----- (00469700) --------------------------------------------------------
int __thiscall sub_469700(_DWORD* this, int a2, const char* a3)
{
    char* v4; // eax
    int v5; // eax
    int v6; // ecx
    void* v7; // ecx
    int v8; // eax
    char* v9; // eax
    int v10; // edi
    int v11; // ecx
    int result; // eax

    v4 = (char*)operator new(0x80u);
    *(_DWORD*)(a2 + 4) = v4;
    sprintf(v4, "%s %d", a3, this[9]);
    v5 = this[7];
    v6 = this[6] + 1;
    this[6] = v6;
    if (v6 > v5)
    {
        v7 = (void*)this[5];
        v8 = v5 + 8;
        this[7] = v8;
        v9 = (char*)sub_488DD7(v7, 4 * v8);
        if (v9)
        {
            v10 = this[6];
            v11 = this[7] - v10;
            this[5] = v9;
            memset(&v9[4 * v10], 0, 4 * v11);
        }
    }
    *(_DWORD*)(this[5] + 4 * this[6] - 4) = a2;
    result = this[9] + 1;
    this[9] = result;
    return result;
}

//----- (004697A0) --------------------------------------------------------
char __thiscall sub_4697A0(int this)
{
    void* v2; // ebp
    unsigned int v3; // ebx
    const char* v4; // ebp
    _DWORD* v5; // eax
    int v6; // edx
    _DWORD* v7; // ebp
    int v8; // eax
    int v9; // ecx
    _DWORD* v10; // eax
    void* v11; // eax
    _DWORD* v12; // eax
    float* v13; // eax
    void* v14; // eax
    float* v15; // eax
    _DWORD* v16; // eax
    _DWORD* v17; // eax
    _DWORD* v18; // eax
    _DWORD* v19; // eax
    float* v20; // eax
    _DWORD* v21; // eax
    _DWORD* v22; // eax
    _DWORD* v23; // eax
    float* v24; // eax
    int v25; // edi
    int v26; // eax
    char* v27; // edx
    float* v28; // eax
    int v29; // eax
    int v30; // ecx
    void* v31; // ecx
    int v32; // eax
    int v33; // ecx
    int j; // edi
    int k; // edi
    int m; // eax
    int n; // edi
    int v38; // ecx
    const char* v40; // [esp+10h] [ebp-264h]
    unsigned int i; // [esp+18h] [ebp-25Ch]
    char v42; // [esp+1Fh] [ebp-255h]
    int v43; // [esp+20h] [ebp-254h] BYREF
    char* v44; // [esp+24h] [ebp-250h]
    char* v45; // [esp+28h] [ebp-24Ch]
    int v46; // [esp+2Ch] [ebp-248h]
    char String1[16]; // [esp+30h] [ebp-244h] BYREF
    char v48[272]; // [esp+40h] [ebp-234h] BYREF
    int v49[5]; // [esp+150h] [ebp-124h] BYREF
    char v50[260]; // [esp+164h] [ebp-110h] BYREF
    int v51; // [esp+270h] [ebp-4h]

    sub_46A280(this, aExtradataDat);
    LOBYTE(v43) = v42;
    v44 = 0;
    v45 = 0;
    v46 = 0;
    v51 = 0;
    v2 = (void*)_findfirst(aIni, (int)v49);
    if (v2 != (void*)-1)
    {
        do
        {
            if (strcmp(v50, File))
            {
                sub_46A570(&v43, v45, 1u, v49);
                sub_46A3A0((_BYTE*)this, v50);
            }
        } while (_findnext(v2, (int)v49) != -1);
    }
    for (i = 0; v44 && i < (v45 - v44) / 280; ++i)
    {
        sub_40A1D0((int)String1, &v44[280 * i + 20]);
        LOBYTE(v51) = 1;
        v3 = 0;
        if (sub_40A980(String1) > 0)
        {
            while (1)
            {
                sub_40A9B0((int)String1, v3);
                v4 = (const char*)sub_40AA00(String1, v3);
                v40 = v4;
                if (!_strcmpi(v4, aChunk))
                    break;
                if (!_strcmpi(v4, aBullet))
                {
                    sub_40AA20(String1, v3);
                    v10 = operator new(0x1A4u);
                    LOBYTE(v51) = 3;
                    if (v10)
                    {
                        v7 = sub_448F70(v10, (int)String1, String1, 1);
                        LOBYTE(v51) = 1;
                        v7[3] = aBullet;
                    }
                    else
                    {
                        v7 = 0;
                        LOBYTE(v51) = 1;
                        MEMORY[0xC] = aBullet;
                    }
                LABEL_76:
                    v25 = *(_DWORD*)(this + 24) + 1;
                    *(_DWORD*)(this + 24) = v25;
                    v8 = *(_DWORD*)(this + 28);
                    if (v25 <= v8)
                        goto LABEL_86;
                LABEL_77:
                    v26 = v8 + 8;
                    *(_DWORD*)(this + 28) = v26;
                    v27 = (char*)sub_488DD7(*(LPVOID*)(this + 20), 4 * v26);
                    if (v27)
                        goto LABEL_85;
                    goto LABEL_86;
                }
                if (!_strcmpi(v4, aChunkExplosion))
                {
                    sub_40AA20(String1, v3);
                    v11 = operator new(0x140u);
                    LOBYTE(v51) = 4;
                    if (v11)
                    {
                        v7 = (_DWORD*)sub_4496E0(v11, String1);
                        LOBYTE(v51) = 1;
                        v7[3] = aChunkExplosion;
                    }
                    else
                    {
                        v7 = 0;
                        LOBYTE(v51) = 1;
                        MEMORY[0xC] = aChunkExplosion;
                    }
                    goto LABEL_76;
                }
                if (!_strcmpi(v4, aGun_0))
                {
                    sub_40AA20(String1, v3);
                    v12 = operator new(0x36Cu);
                    LOBYTE(v51) = 5;
                    if (v12)
                    {
                        v7 = sub_45D180(v12, (int)String1);
                        LOBYTE(v51) = 1;
                        v7[3] = aGun_0;
                    }
                    else
                    {
                        v7 = 0;
                        LOBYTE(v51) = 1;
                        MEMORY[0xC] = aGun_0;
                    }
                    goto LABEL_76;
                }
                if (!_strcmpi(v4, aAirplaneGun))
                {
                    sub_40AA20(String1, v3);
                    v13 = (float*)operator new(0x138u);
                    LOBYTE(v51) = 6;
                    if (v13)
                    {
                        v7 = sub_42A5F0(v13, String1);
                        LOBYTE(v51) = 1;
                        v7[3] = aAirplaneGun;
                    }
                    else
                    {
                        v7 = 0;
                        LOBYTE(v51) = 1;
                        MEMORY[0xC] = aAirplaneGun;
                    }
                    goto LABEL_76;
                }
                if (!_strcmpi(v4, aAirplane))
                {
                    sub_40AA20(String1, v3);
                    v14 = operator new(0x410u);
                    LOBYTE(v51) = 7;
                    if (v14)
                    {
                        v7 = (_DWORD*)sub_42AA30((int)v14, (int)String1, String1);
                        LOBYTE(v51) = 1;
                        v7[3] = aAirplane;
                    }
                    else
                    {
                        v7 = 0;
                        LOBYTE(v51) = 1;
                        MEMORY[0xC] = aAirplane;
                    }
                    goto LABEL_76;
                }
                if (!_strcmpi(v4, aBoatGun))
                {
                    sub_40AA20(String1, v3);
                    v15 = (float*)operator new(0x15Cu);
                    LOBYTE(v51) = 8;
                    if (v15)
                    {
                        v7 = sub_43F030(v15, String1);
                        LOBYTE(v51) = 1;
                        v7[3] = aBoatGun;
                    }
                    else
                    {
                        v7 = 0;
                        LOBYTE(v51) = 1;
                        MEMORY[0xC] = aBoatGun;
                    }
                    goto LABEL_76;
                }
                if (!_strcmpi(v4, aBoat))
                {
                    sub_40AA20(String1, v3);
                    v16 = operator new(0x3ACu);
                    LOBYTE(v51) = 9;
                    if (v16)
                    {
                        v7 = sub_43F560(v16, (int)String1);
                        LOBYTE(v51) = 1;
                        v7[3] = aBoat;
                    }
                    else
                    {
                        v7 = 0;
                        LOBYTE(v51) = 1;
                        MEMORY[0xC] = aBoat;
                    }
                    goto LABEL_76;
                }
                if (!_strcmpi(v4, aInfantry))
                {
                    sub_40AA20(String1, v3);
                    v17 = operator new(0x330u);
                    LOBYTE(v51) = 10;
                    if (v17)
                    {
                        v7 = sub_4519E0(v17, String1);
                        LOBYTE(v51) = 1;
                        v7[3] = aInfantry;
                    }
                    else
                    {
                        v7 = 0;
                        LOBYTE(v51) = 1;
                        MEMORY[0xC] = aInfantry;
                    }
                    goto LABEL_76;
                }
                if (!_strcmpi(v4, aTank))
                {
                    sub_40AA20(String1, v3);
                    v18 = operator new(0x50Cu);
                    LOBYTE(v51) = 11;
                    if (v18)
                    {
                        v7 = sub_464C90(v18, (int)String1);
                        LOBYTE(v51) = 1;
                        v7[3] = aTank;
                    }
                    else
                    {
                        v7 = 0;
                        LOBYTE(v51) = 1;
                        MEMORY[0xC] = aTank;
                    }
                    goto LABEL_76;
                }
                if (!_strcmpi(v4, aParticleEffect))
                {
                    sub_40AA20(String1, v3);
                    v19 = operator new(0x134u);
                    LOBYTE(v51) = 12;
                    if (v19)
                    {
                        v7 = sub_44B4B0(v19, String1);
                        LOBYTE(v51) = 1;
                        v7[3] = aParticleEffect;
                    }
                    else
                    {
                        v7 = 0;
                        LOBYTE(v51) = 1;
                        MEMORY[0xC] = aParticleEffect;
                    }
                    goto LABEL_76;
                }
                if (!_strcmpi(v4, aSoundEffect))
                {
                    sub_40AA20(String1, v3);
                    v20 = (float*)operator new(0x15Cu);
                    LOBYTE(v51) = 13;
                    if (v20)
                    {
                        v7 = sub_44B870(v20, String1);
                        LOBYTE(v51) = 1;
                        v7[3] = aSoundEffect;
                    }
                    else
                    {
                        v7 = 0;
                        LOBYTE(v51) = 1;
                        MEMORY[0xC] = aSoundEffect;
                    }
                    goto LABEL_76;
                }
                if (!_strcmpi(v4, aEffect))
                {
                    sub_40AA20(String1, v3);
                    v21 = operator new(0x140u);
                    LOBYTE(v51) = 14;
                    if (v21)
                    {
                        v7 = sub_44C720(v21, String1);
                        LOBYTE(v51) = 1;
                        v7[3] = aEffect;
                    }
                    else
                    {
                        v7 = 0;
                        LOBYTE(v51) = 1;
                        MEMORY[0xC] = aEffect;
                    }
                    goto LABEL_76;
                }
                if (!_strcmpi(v4, aAmbientSounds))
                {
                    sub_40AA20(String1, v3);
                    v22 = operator new(0x350u);
                    LOBYTE(v51) = 15;
                    if (v22)
                    {
                        v7 = sub_44C470(v22, String1);
                        LOBYTE(v51) = 1;
                        v7[3] = aAmbientSounds;
                    }
                    else
                    {
                        v7 = 0;
                        LOBYTE(v51) = 1;
                        MEMORY[0xC] = aAmbientSounds;
                    }
                    goto LABEL_76;
                }
                if (!_strcmpi(v4, aImpacts))
                {
                    sub_40AA20(String1, v3);
                    v23 = operator new(0x14Cu);
                    LOBYTE(v51) = 16;
                    if (v23)
                    {
                        v7 = sub_448C90(v23, String1);
                        LOBYTE(v51) = 1;
                        v7[3] = aImpacts;
                    }
                    else
                    {
                        v7 = 0;
                        LOBYTE(v51) = 1;
                        MEMORY[0xC] = aImpacts;
                    }
                    goto LABEL_76;
                }
                if (!_strcmpi(v4, aBubblySoundEff))
                {
                    sub_40AA20(String1, v3);
                    v24 = (float*)operator new(0x13Cu);
                    LOBYTE(v51) = 17;
                    if (v24)
                        v7 = sub_44C330(v24, String1);
                    else
                        v7 = 0;
                    LOBYTE(v51) = 1;
                    v7[3] = aBubblySoundEff;
                    goto LABEL_76;
                }
                if (!_strcmpi(v4, aRippleEffect))
                {
                    sub_40AA20(String1, v3);
                    v28 = (float*)operator new(0x148u);
                    LOBYTE(v51) = 18;
                    if (v28)
                        v7 = sub_44C620(v28, String1);
                    else
                        v7 = 0;
                    v7[3] = aRippleEffect;
                    v29 = *(_DWORD*)(this + 28);
                    v30 = *(_DWORD*)(this + 24) + 1;
                    LOBYTE(v51) = 1;
                    *(_DWORD*)(this + 24) = v30;
                    if (v30 > v29)
                    {
                        v31 = *(void**)(this + 20);
                        v32 = v29 + 8;
                        *(_DWORD*)(this + 28) = v32;
                        v27 = (char*)sub_488DD7(v31, 4 * v32);
                        if (v27)
                        {
                        LABEL_85:
                            *(_DWORD*)(this + 20) = v27;
                            memset(&v27[4 * *(_DWORD*)(this + 24)], 0, 4 * (*(_DWORD*)(this + 28) - *(_DWORD*)(this + 24)));
                        }
                    }
                LABEL_86:
                    *(_DWORD*)(*(_DWORD*)(this + 20) + 4 * *(_DWORD*)(this + 24) - 4) = v7;
                    v4 = v40;
                }
                v33 = *(_DWORD*)(this + 24);
                for (j = 0; j < v33 - 1; ++j)
                {
                    if (!_strcmpi(
                        *(const char**)(*(_DWORD*)(*(_DWORD*)(this + 20) + 4 * j) + 4),
                        *(const char**)(*(_DWORD*)(*(_DWORD*)(this + 20) + 4 * v33 - 4) + 4)))
                        sub_40A120(
                            0,
                            "duplicate type info %s, see %s : %s",
                            *(const char**)(*(_DWORD*)(*(_DWORD*)(this + 20) + 4 * j) + 4),
                            v4,
                            v48);
                    v33 = *(_DWORD*)(this + 24);
                }
                if ((int)++v3 >= sub_40A980(String1))
                    goto LABEL_92;
            }
            sub_40AA20(String1, v3);
            v5 = operator new(0x1A4u);
            LOBYTE(v51) = 2;
            if (v5)
                v7 = sub_448F70(v5, v6, String1, 1);
            else
                v7 = 0;
            v7[3] = aChunk;
            v8 = *(_DWORD*)(this + 28);
            v9 = *(_DWORD*)(this + 24) + 1;
            LOBYTE(v51) = 1;
            *(_DWORD*)(this + 24) = v9;
            if (v9 <= v8)
                goto LABEL_86;
            goto LABEL_77;
        }
    LABEL_92:
        LOBYTE(v51) = 0;
        sub_40A830((int)String1);
    }
    for (k = 0; k < *(_DWORD*)(this + 24); ++k)
        sub_469370(*(_DWORD*)(*(_DWORD*)(this + 20) + 4 * k), (_DWORD*)this);
    qsort(*(void**)(this + 20), *(_DWORD*)(this + 24), 4u, sub_46A230);
    for (m = 0; m < *(_DWORD*)(this + 24); ++m)
        *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(this + 20) + 4 * m) + 8) = m;
    sub_46A340(this);
    if (byte_520A10)
    {
        for (n = 0; n < *(_DWORD*)(this + 24); ++n)
        {
            v38 = *(_DWORD*)(*(_DWORD*)(this + 20) + 4 * n);
            (*(void(__thiscall**)(int))(*(_DWORD*)v38 + 4))(v38);
        }
    }
    sub_4885A6(v44);
    return 1;
}
// 4697D1: variable 'v42' is possibly undefined
// 469942: variable 'v6' is possibly undefined
// 520A10: using guessed type char byte_520A10;

//----- (0046A230) --------------------------------------------------------
int __cdecl sub_46A230(const void* a1, const void* a2)
{
    return strcmp(*(const char**)(*(_DWORD*)a1 + 4), *(const char**)(*(_DWORD*)a2 + 4));
}

//----- (0046A280) --------------------------------------------------------
int __thiscall sub_46A280(int this, const char* a2)
{
    FILE* v3; // eax
    FILE* v4; // esi
    unsigned int v5; // edi
    void* v6; // eax
    int result; // eax
    size_t v8; // [esp-28h] [ebp-38h]

    strcpy((char*)(this + 40), a2);
    *(_DWORD*)(this + 308) = 0;
    v3 = fopen((const char*)(this + 40), aAB);
    v4 = v3;
    if (!v3)
        sub_4281B0("Can't open file '%s'", (const char*)(this + 40));
    fseek(v3, 0, 2);
    v5 = ftell(v4);
    fseek(v4, 0, 0);
    *(_DWORD*)(this + 304) = v5;
    v6 = operator new(v5);
    v8 = *(_DWORD*)(this + 304);
    *(_DWORD*)(this + 308) = v6;
    sub_4898CA(v6, 1u, v8, v4);
    result = fclose(v4);
    *(_BYTE*)(this + 300) = 1;
    *(_DWORD*)(this + 312) = 0;
    return result;
}

//----- (0046A340) --------------------------------------------------------
char __thiscall sub_46A340(int this)
{
    char result; // al
    FILE* v3; // esi

    result = *(_BYTE*)(this + 300);
    if (!result)
    {
        v3 = fopen((const char*)(this + 40), aWb);
        if (!v3)
            sub_4281B0("Can't create file '%s'", (const char*)(this + 40));
        sub_48A21D(*(void**)(this + 308), 1u, *(_DWORD*)(this + 312), v3);
        return fclose(v3);
    }
    return result;
}

//----- (0046A3A0) --------------------------------------------------------
char __thiscall sub_46A3A0(_BYTE* this, LPCSTR lpFileName)
{
    int v4; // [esp+Ch] [ebp-118h] BYREF
    _BYTE v5[8]; // [esp+10h] [ebp-114h] BYREF
    _BYTE v6[4]; // [esp+18h] [ebp-10Ch] BYREF
    _BYTE v7[264]; // [esp+1Ch] [ebp-108h] BYREF

    sub_46A410((int)this, lpFileName, strlen(lpFileName) + 1);
    _findfirst(lpFileName, (int)&v4);
    sub_46A410((int)this, v5, 4u);
    sub_46A410((int)this, v6, 4u);
    sub_46A410((int)this, v7, 4u);
    return this[300];
}

//----- (0046A410) --------------------------------------------------------
int __thiscall sub_46A410(int this, const void* a2, unsigned int a3)
{
    int result; // eax
    int v4; // edx

    result = this;
    if (*(_BYTE*)(this + 300))
    {
        v4 = *(_DWORD*)(this + 312);
        *(_BYTE*)(this + 300) = (signed int)(v4 + a3 - 1) < *(_DWORD*)(this + 304)
            && memcmp((const void*)(v4 + *(_DWORD*)(this + 308)), a2, a3) == 0;
    }
    if (!*(_BYTE*)(result + 300))
        return sub_46A4C0(result, a2, a3);
    *(_DWORD*)(result + 312) += a3;
    return result;
}

//----- (0046A490) --------------------------------------------------------
char __thiscall sub_46A490(_BYTE* this)
{
    return this[300];
}

//----- (0046A4A0) --------------------------------------------------------
int __thiscall sub_46A4A0(_DWORD* this, int a2)
{
    int v2; // edx
    int result; // eax

    v2 = this[78];
    result = v2 + this[77];
    this[78] = a2 + v2;
    return result;
}

//----- (0046A4C0) --------------------------------------------------------
int __thiscall sub_46A4C0(int this, const void* a2, unsigned int a3)
{
    unsigned int v3; // edx
    int v5; // ebp
    unsigned int v6; // ebp
    void* v7; // eax
    int v8; // ecx
    int result; // eax
    void* v10; // [esp+10h] [ebp-4h]

    v3 = a3;
    v5 = *(_DWORD*)(this + 304);
    if ((int)(a3 + *(_DWORD*)(this + 312) - 1) >= v5)
    {
        v6 = v5 + 100;
        v7 = operator new(v6);
        qmemcpy(v7, *(const void**)(this + 308), *(_DWORD*)(this + 304));
        v10 = v7;
        sub_4885A6(*(LPVOID*)(this + 308));
        v3 = a3;
        *(_DWORD*)(this + 308) = v10;
        *(_DWORD*)(this + 304) = v6;
    }
    qmemcpy((void*)(*(_DWORD*)(this + 312) + *(_DWORD*)(this + 308)), a2, v3);
    v8 = *(_DWORD*)(this + 312);
    result = v8 + *(_DWORD*)(this + 308);
    *(_DWORD*)(this + 312) = v3 + v8;
    return result;
}

//----- (0046A570) --------------------------------------------------------
int __thiscall sub_46A570(_DWORD* this, char* a2, unsigned int a3, const void* a4)
{
    _DWORD* v4; // esi
    char* v6; // ebx
    int v7; // edi
    unsigned int v8; // ecx
    int v9; // edx
    int v10; // ecx
    char* v11; // edx
    char* k; // eax
    char* v13; // eax
    unsigned int v14; // ebx
    char* v15; // edi
    char* v16; // ebx
    char* v17; // eax
    int v18; // eax
    int v19; // edx
    int result; // eax
    char* v21; // edi
    int v22; // ecx
    char* v23; // edx
    char* v24; // eax
    char* v25; // ebx
    unsigned int j; // eax
    char* v27; // edx
    char* v28; // eax
    char* v29; // edi
    char* v30; // edx
    int v31; // ebp
    char* i; // eax
    char* v33; // edx
    char* v34; // eax
    char* v35; // edx
    void* v36; // edi
    char* v38; // [esp+14h] [ebp-4h]
    int v39; // [esp+20h] [ebp+8h]
    int v40; // [esp+20h] [ebp+8h]
    char* v41; // [esp+24h] [ebp+Ch]

    v4 = this;
    v6 = (char*)this[2];
    if ((this[3] - (int)v6) / 280 >= a3)
    {
        v21 = a2;
        result = -368140053 * (v6 - a2);
        if ((v6 - a2) / 280 >= a3)
        {
            if (a3)
            {
                v30 = (char*)this[2];
                v31 = 280 * a3;
                for (i = &v6[-280 * a3]; i != v6; v30 += 280)
                {
                    if (v30)
                    {
                        qmemcpy(v30, i, 0x118u);
                        v21 = a2;
                        v4 = this;
                    }
                    i += 280;
                }
                v33 = (char*)v4[2];
                v34 = &v33[-v31];
                if (v21 != &v33[-v31])
                {
                    do
                    {
                        v34 -= 280;
                        v33 -= 280;
                        qmemcpy(v33, v34, 0x118u);
                    } while (v34 != a2);
                    v4 = this;
                    v21 = a2;
                }
                v35 = &v21[v31];
                result = (int)v21;
                if (v21 != &v21[v31])
                {
                    do
                    {
                        v36 = (void*)result;
                        result += 280;
                        qmemcpy(v36, a4, 0x118u);
                    } while ((char*)result != v35);
                    v4 = this;
                }
                v4[2] += v31;
            }
        }
        else
        {
            v22 = 280 * a3;
            v40 = 280 * a3;
            v23 = &a2[280 * a3];
            if (a2 != v6)
            {
                v24 = &v23[-v22];
                do
                {
                    if (v23)
                    {
                        qmemcpy(v23, v24, 0x118u);
                        v21 = a2;
                        v4 = this;
                    }
                    v24 += 280;
                    v23 += 280;
                } while (v24 != v6);
            }
            v25 = (char*)v4[2];
            for (j = a3 - (v25 - v21) / 280; j; --j)
            {
                if (v25)
                {
                    qmemcpy(v25, a4, 0x118u);
                    v21 = a2;
                    v4 = this;
                }
                v25 += 280;
            }
            v27 = (char*)v4[2];
            v28 = v21;
            if (v21 != v27)
            {
                do
                {
                    v29 = v28;
                    v28 += 280;
                    qmemcpy(v29, a4, 0x118u);
                } while (v28 != v27);
                v4 = this;
            }
            result = v40 + v4[2];
            v4[2] = result;
        }
    }
    else
    {
        v7 = this[1];
        if (!v7 || (v8 = (int)&v6[-v7] / 280, a3 >= v8))
            v8 = a3;
        if (v7)
            v9 = (int)&v6[-v7] / 280;
        else
            v9 = 0;
        v10 = v9 + v8;
        v39 = v10;
        if (v10 < 0)
            v10 = 0;
        v38 = (char*)operator new(280 * v10);
        v11 = v38;
        for (k = (char*)v4[1]; k != a2; v11 += 280)
        {
            if (v11)
            {
                qmemcpy(v11, k, 0x118u);
                v4 = this;
            }
            k += 280;
        }
        v13 = v11;
        if (a3)
        {
            v14 = a3;
            do
            {
                if (v13)
                {
                    qmemcpy(v13, a4, 0x118u);
                    v4 = this;
                }
                v13 += 280;
                --v14;
            } while (v14);
        }
        v15 = (char*)v4[2];
        v41 = v15;
        v16 = &v11[280 * a3];
        if (a2 != v15)
        {
            v17 = a2;
            do
            {
                if (v16)
                {
                    qmemcpy(v16, v17, 0x118u);
                    v4 = this;
                    v15 = v41;
                }
                v17 += 280;
                v16 += 280;
            } while (v17 != v15);
        }
        sub_4885A6((LPVOID)v4[1]);
        v4[3] = &v38[280 * v39];
        v18 = v4[1];
        if (v18)
            v19 = (v4[2] - v18) / 280;
        else
            v19 = 0;
        v4[1] = v38;
        result = (int)&v38[280 * v19 + 280 * a3];
        v4[2] = result;
    }
    return result;
}

//----- (0046B940) --------------------------------------------------------
BOOL __cdecl sub_46B940(float a1, float a2)
{
    double v2; // st7

    v2 = a1 - a2;
    return v2 >= -0.0000099999997 && v2 <= 0.0000099999997;
}

//----- (0046B982) --------------------------------------------------------
int __stdcall sub_46B982(int a1, int a2)
{
    int result; // eax
    int v3; // edx
    int v4; // edx
    int v5; // edx
    int v6; // edx
    int v7; // edx
    int v8; // edx

    result = a1;
    if (!a1 || !a2)
        return 0;
    v3 = *(_DWORD*)(a2 + 16);
    *(float*)(a1 + 16) = *(float*)(a2 + 4);
    *(_DWORD*)(a1 + 4) = v3;
    v4 = *(_DWORD*)(a2 + 32);
    *(float*)(a1 + 32) = *(float*)(a2 + 8);
    *(_DWORD*)(a1 + 8) = v4;
    v5 = *(_DWORD*)(a2 + 48);
    *(float*)(a1 + 48) = *(float*)(a2 + 12);
    *(_DWORD*)(a1 + 12) = v5;
    v6 = *(_DWORD*)(a2 + 36);
    *(float*)(a1 + 36) = *(float*)(a2 + 24);
    *(_DWORD*)(a1 + 24) = v6;
    v7 = *(_DWORD*)(a2 + 52);
    *(float*)(a1 + 52) = *(float*)(a2 + 28);
    *(_DWORD*)(a1 + 28) = v7;
    v8 = *(_DWORD*)(a2 + 56);
    *(float*)(a1 + 56) = *(float*)(a2 + 44);
    *(_DWORD*)(a1 + 44) = v8;
    if (a1 != a2)
    {
        *(_DWORD*)a1 = *(_DWORD*)a2;
        *(_DWORD*)(a1 + 20) = *(_DWORD*)(a2 + 20);
        *(_DWORD*)(a1 + 40) = *(_DWORD*)(a2 + 40);
        *(_DWORD*)(a1 + 60) = *(_DWORD*)(a2 + 60);
    }
    return result;
}

//----- (0046B9FD) --------------------------------------------------------
float* __stdcall sub_46B9FD(float* a1, float* a2, float* a3)
{
    double v5; // st7
    double v6; // st6
    double v7; // st7
    double v8; // st7
    double v9; // st6
    double v10; // st5
    double v11; // st4
    double v12; // st3
    double v13; // st2
    double v14; // st7
    double v15; // st6
    double v16; // st5
    double v17; // st3
    double v18; // st4
    double v19; // st3
    double v20; // st2
    double v21; // st7
    float* result; // eax
    float v23; // [esp+Ch] [ebp-50h]
    float v24; // [esp+10h] [ebp-4Ch]
    float v25; // [esp+14h] [ebp-48h]
    float v26; // [esp+18h] [ebp-44h]
    float v27; // [esp+1Ch] [ebp-40h]
    float v28; // [esp+20h] [ebp-3Ch]
    float v29; // [esp+24h] [ebp-38h]
    float v30; // [esp+28h] [ebp-34h]
    float v31; // [esp+2Ch] [ebp-30h]
    float v32; // [esp+2Ch] [ebp-30h]
    float v33; // [esp+30h] [ebp-2Ch]
    float v34; // [esp+30h] [ebp-2Ch]
    float v35; // [esp+34h] [ebp-28h]
    float v36; // [esp+34h] [ebp-28h]
    float v37; // [esp+38h] [ebp-24h]
    float v38; // [esp+38h] [ebp-24h]
    float v39; // [esp+3Ch] [ebp-20h]
    float v40; // [esp+3Ch] [ebp-20h]
    float v41; // [esp+40h] [ebp-1Ch]
    float v42; // [esp+40h] [ebp-1Ch]
    float v43; // [esp+40h] [ebp-1Ch]
    float v44; // [esp+44h] [ebp-18h]
    float v45; // [esp+44h] [ebp-18h]
    float v46; // [esp+48h] [ebp-14h]
    float v47; // [esp+48h] [ebp-14h]
    float v48; // [esp+4Ch] [ebp-10h]
    float v49; // [esp+50h] [ebp-Ch]
    float v50; // [esp+50h] [ebp-Ch]
    float v51; // [esp+54h] [ebp-8h]
    float v52; // [esp+54h] [ebp-8h]
    float v53; // [esp+58h] [ebp-4h]
    float v54; // [esp+58h] [ebp-4h]
    float v55; // [esp+58h] [ebp-4h]
    float v56; // [esp+64h] [ebp+8h]
    float v57; // [esp+64h] [ebp+8h]
    float v58; // [esp+64h] [ebp+8h]
    float v59; // [esp+64h] [ebp+8h]
    float v60; // [esp+6Ch] [ebp+10h]
    float v61; // [esp+6Ch] [ebp+10h]
    float v62; // [esp+6Ch] [ebp+10h]
    float v63; // [esp+6Ch] [ebp+10h]

    if (!a1 || !a3)
        return 0;
    v5 = *a3;
    v6 = a3[1];
    v44 = a3[4];
    v41 = a3[5];
    v46 = a3[8];
    v60 = a3[9];
    v48 = a3[12];
    v56 = a3[13];
    v51 = v41 * v5 - v44 * v6;
    v49 = a3[14];
    v53 = v60 * v5 - v46 * v6;
    v35 = v56 * v5 - v48 * v6;
    v30 = v60 * v44 - v46 * v41;
    v31 = v56 * v44 - v48 * v41;
    v7 = v56;
    v57 = a3[15];
    v33 = v7 * v46 - v48 * v60;
    v8 = a3[2];
    v9 = a3[3];
    v10 = a3[6];
    v37 = a3[6];
    v11 = a3[7];
    v42 = a3[7];
    v12 = a3[10];
    v39 = a3[10];
    v13 = a3[11];
    v61 = a3[11];
    v23 = v8 * v30 - v10 * v53 + v12 * v51;
    v24 = v10 * v35 - v49 * v51 - v8 * v31;
    v25 = v8 * v33 - v12 * v35 + v49 * v53;
    v26 = v12 * v31 - v49 * v30 - v10 * v33;
    v27 = v53 * v11 - v51 * v13 - v30 * v9;
    v28 = v31 * v9 - v35 * v11 + v51 * v57;
    v29 = v35 * v13 - v53 * v57 - v33 * v9;
    v36 = v33 * v11 - v31 * v13 + v30 * v57;
    v52 = v8 * v11 - v10 * v9;
    v54 = v8 * v61 - v39 * v9;
    v14 = v8 * v57 - v49 * v9;
    v45 = a3[4];
    v15 = v37 * v61 - v39 * v42;
    v47 = a3[8];
    v16 = v37 * v57 - v49 * v42;
    v17 = v49 * v61;
    v62 = a3[9];
    v18 = v39 * v57 - v17;
    v19 = a3[1];
    v20 = a3[5];
    v58 = a3[13];
    v50 = v54 * v20 - v52 * v62 - v15 * v19;
    v40 = v16 * v19 - v14 * v20 + v52 * v58;
    v38 = v14 * v62 - v54 * v58 - v18 * v19;
    v32 = v18 * v20 - v16 * v62 + v15 * v58;
    v59 = v15 * *a3 - v54 * v45 + v52 * v47;
    v63 = v14 * v45 - v52 * v48 - v16 * *a3;
    v43 = *a3 * v18 - v14 * v47 + v54 * v48;
    v21 = v50 * v48 + v40 * v47 + v38 * v45 + v32 * *a3;
    if (a2)
        *a2 = v21;
    v55 = 1.0 / v21;
    if (!_finite(v55))
        return 0;
    result = a1;
    *a1 = v32 * v55;
    a1[1] = v38 * v55;
    a1[2] = v40 * v55;
    a1[3] = v50 * v55;
    v34 = v16 * v47 - v15 * v48 - v18 * v45;
    a1[4] = v34 * v55;
    a1[5] = v43 * v55;
    a1[6] = v63 * v55;
    a1[7] = v59 * v55;
    a1[8] = v36 * v55;
    a1[9] = v29 * v55;
    a1[10] = v28 * v55;
    a1[11] = v27 * v55;
    a1[12] = v26 * v55;
    a1[13] = v25 * v55;
    a1[14] = v24 * v55;
    a1[15] = v23 * v55;
    return result;
}

//----- (0046BDA2) --------------------------------------------------------
int __stdcall sub_46BDA2(int a1, int a2, int a3, int a4)
{
    int result; // eax

    result = a1;
    if (a1)
    {
        *(float*)(a1 + 56) = 0.0;
        *(_DWORD*)a1 = a2;
        *(float*)(a1 + 52) = 0.0;
        *(_DWORD*)(a1 + 20) = a3;
        *(_DWORD*)(a1 + 40) = a4;
        *(float*)(a1 + 48) = 0.0;
        *(float*)(a1 + 44) = 0.0;
        *(float*)(a1 + 36) = 0.0;
        *(float*)(a1 + 32) = 0.0;
        *(float*)(a1 + 28) = 0.0;
        *(float*)(a1 + 24) = 0.0;
        *(float*)(a1 + 16) = 0.0;
        *(float*)(a1 + 12) = 0.0;
        *(float*)(a1 + 8) = 0.0;
        *(float*)(a1 + 4) = 0.0;
        *(float*)(a1 + 60) = 1.0;
    }
    return result;
}

//----- (0046BE02) --------------------------------------------------------
int __stdcall sub_46BE02(int a1, int a2, int a3, int a4)
{
    int result; // eax

    result = a1;
    if (a1)
    {
        *(float*)(a1 + 44) = 0.0;
        *(_DWORD*)(a1 + 48) = a2;
        *(float*)(a1 + 36) = 0.0;
        *(_DWORD*)(a1 + 52) = a3;
        *(_DWORD*)(a1 + 56) = a4;
        *(float*)(a1 + 32) = 0.0;
        *(float*)(a1 + 28) = 0.0;
        *(float*)(a1 + 24) = 0.0;
        *(float*)(a1 + 16) = 0.0;
        *(float*)(a1 + 12) = 0.0;
        *(float*)(a1 + 8) = 0.0;
        *(float*)(a1 + 4) = 0.0;
        *(float*)(a1 + 60) = 1.0;
        *(float*)(a1 + 40) = 1.0;
        *(float*)(a1 + 20) = 1.0;
        *(float*)a1 = 1.0;
    }
    return result;
}

//----- (0046BE62) --------------------------------------------------------
float* __stdcall sub_46BE62(float* a1, float a2)
{
    float* result; // eax
    float v4; // [esp+8h] [ebp-4h]
    float v5; // [esp+14h] [ebp+8h]

    if (!a1)
        return 0;
    v4 = cos(a2);
    v5 = sin(a2);
    *a1 = 1.0;
    a1[6] = v5;
    a1[1] = 0.0;
    result = a1;
    a1[2] = 0.0;
    a1[3] = 0.0;
    a1[4] = 0.0;
    a1[5] = v4;
    a1[7] = 0.0;
    a1[8] = 0.0;
    a1[9] = -v5;
    a1[10] = v4;
    a1[11] = 0.0;
    a1[12] = 0.0;
    a1[13] = 0.0;
    a1[14] = 0.0;
    a1[15] = 1.0;
    return result;
}

//----- (0046BEE6) --------------------------------------------------------
float* __stdcall sub_46BEE6(float* a1, float a2)
{
    float* result; // eax
    float v4; // [esp+8h] [ebp-4h]
    float v5; // [esp+14h] [ebp+8h]

    if (!a1)
        return 0;
    v5 = cos(a2);
    v4 = sin(a2);
    *a1 = v5;
    result = a1;
    a1[1] = 0.0;
    a1[2] = -v4;
    a1[3] = 0.0;
    a1[4] = 0.0;
    a1[5] = 1.0;
    a1[6] = 0.0;
    a1[7] = 0.0;
    a1[8] = v4;
    a1[9] = 0.0;
    a1[10] = v5;
    a1[11] = 0.0;
    a1[12] = 0.0;
    a1[13] = 0.0;
    a1[14] = 0.0;
    a1[15] = 1.0;
    return result;
}

//----- (0046BF69) --------------------------------------------------------
float* __stdcall sub_46BF69(float* a1, float a2)
{
    float* result; // eax
    float v4; // [esp+8h] [ebp-4h]
    float v5; // [esp+14h] [ebp+8h]

    if (!a1)
        return 0;
    v4 = cos(a2);
    v5 = sin(a2);
    *a1 = v4;
    a1[1] = v5;
    a1[2] = 0.0;
    result = a1;
    a1[3] = 0.0;
    a1[4] = -v5;
    a1[5] = v4;
    a1[6] = 0.0;
    a1[7] = 0.0;
    a1[8] = 0.0;
    a1[9] = 0.0;
    a1[10] = 1.0;
    a1[11] = 0.0;
    a1[12] = 0.0;
    a1[13] = 0.0;
    a1[14] = 0.0;
    a1[15] = 1.0;
    return result;
}

//----- (0046BFED) --------------------------------------------------------
float* __stdcall sub_46BFED(int a1, int a2, float a3)
{
    float* v3; // ebx
    float* v4; // esi
    float* v5; // esi
    double v6; // st7
    double v7; // st6
    double v8; // st5
    double v9; // st4
    double v10; // st3
    double v11; // st2
    double v12; // st3
    float* result; // eax
    float v14; // [esp+8h] [ebp-14h] BYREF
    float v15; // [esp+Ch] [ebp-10h]
    float v16; // [esp+10h] [ebp-Ch]
    float v17; // [esp+14h] [ebp-8h]
    int* v18; // [esp+18h] [ebp-4h]

    v3 = (float*)a1;
    if (*(float*)&a1 == 0.0)
        return 0;
    v4 = (float*)a2;
    if (*(float*)&a2 == 0.0)
        return 0;
    v18 = &a1;
    v17 = COERCE_FLOAT(&a2);
    *(float*)&a1 = cos(a3);
    *(float*)&a2 = sin(a3);
    v14 = *v4;
    v5 = v4 + 1;
    v15 = *v5;
    a3 = 1.0 - *(float*)&a1;
    v16 = v5[1];
    sub_46B970(&v14, &v14);
    v6 = a3;
    a3 = v15 * v14 * a3;
    v7 = v16;
    v8 = v15 * v16 * v6;
    v9 = v16 * v14 * v6;
    *v3 = v14 * v14 * v6 + *(float*)&a1;
    v10 = v7 * *(float*)&a2;
    v3[1] = a3 + v10;
    v11 = v15 * *(float*)&a2;
    v17 = v11;
    v3[2] = v9 - v11;
    v3[3] = 0.0;
    v3[4] = a3 - v10;
    v3[5] = v15 * v15 * v6 + *(float*)&a1;
    v12 = v14 * *(float*)&a2;
    v3[6] = v12 + v8;
    v3[7] = 0.0;
    v3[8] = v17 + v9;
    v3[9] = v8 - v12;
    v3[10] = v7 * v7 * v6 + *(float*)&a1;
    result = v3;
    v3[11] = 0.0;
    v3[12] = 0.0;
    v3[13] = 0.0;
    v3[14] = 0.0;
    v3[15] = 1.0;
    return result;
}
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);

//----- (0046C107) --------------------------------------------------------
float* __stdcall sub_46C107(float* a1, float* a2)
{
    float* result; // eax
    double v4; // st7
    double v5; // st6
    double v6; // st5
    double v7; // st4
    double v8; // st3
    double v9; // st2
    float v10; // [esp+0h] [ebp-Ch]
    float v11; // [esp+4h] [ebp-8h]
    float v12; // [esp+8h] [ebp-4h]
    float v13; // [esp+14h] [ebp+8h]
    float v14; // [esp+14h] [ebp+8h]
    float v15; // [esp+18h] [ebp+Ch]
    float v16; // [esp+18h] [ebp+Ch]
    float v17; // [esp+18h] [ebp+Ch]

    result = a1;
    if (!a1 || !a2)
        return 0;
    v15 = *a2 * 2.0;
    v13 = a2[1] * 2.0;
    v4 = 2.0 * a2[2];
    v5 = v15 * a2[3];
    v6 = v13 * a2[3];
    v7 = v4 * a2[3];
    v10 = v15 * *a2;
    v16 = v13 * *a2;
    v12 = v4 * *a2;
    v11 = v13 * a2[1];
    v14 = v4 * a2[1];
    v8 = v4 * a2[2];
    *result = 1.0 - v11 - v8;
    result[1] = v16 + v7;
    result[2] = v12 - v6;
    result[3] = 0.0;
    result[4] = v16 - v7;
    v9 = 1.0 - v10;
    v17 = v9;
    result[5] = v9 - v8;
    result[6] = v14 + v5;
    result[7] = 0.0;
    result[8] = v12 + v6;
    result[9] = v14 - v5;
    result[10] = v17 - v11;
    result[11] = 0.0;
    result[12] = 0.0;
    result[13] = 0.0;
    result[14] = 0.0;
    result[15] = 1.0;
    return result;
}

//----- (0046C1FD) --------------------------------------------------------
int __stdcall sub_46C1FD(int a1, float a2, float a3, float a4, float a5)
{
    int result; // eax
    double v7; // st7
    double v8; // st7
    float v9; // [esp+8h] [ebp-4h]
    float v10; // [esp+14h] [ebp+8h]
    float v11; // [esp+18h] [ebp+Ch]

    if (!a1)
        return 0;
    v9 = a2 * 0.5;
    v10 = cos(v9);
    v11 = sin(v9);
    *(_DWORD*)(a1 + 44) = -1082130432;
    v7 = v10 / v11;
    result = a1;
    *(float*)a1 = v7 / a3;
    *(float*)(a1 + 4) = 0.0;
    *(float*)(a1 + 8) = 0.0;
    *(float*)(a1 + 12) = 0.0;
    *(float*)(a1 + 16) = 0.0;
    *(float*)(a1 + 20) = v7;
    *(float*)(a1 + 24) = 0.0;
    *(float*)(a1 + 28) = 0.0;
    *(float*)(a1 + 32) = 0.0;
    *(float*)(a1 + 36) = 0.0;
    v8 = a5 / (a4 - a5);
    *(float*)(a1 + 40) = v8;
    *(float*)(a1 + 48) = 0.0;
    *(float*)(a1 + 52) = 0.0;
    *(float*)(a1 + 56) = v8 * a4;
    *(float*)(a1 + 60) = 0.0;
    return result;
}

//----- (0046C29E) --------------------------------------------------------
double __cdecl sub_46C29E(float* a1)
{
    return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (0046C2C4) --------------------------------------------------------
float* __stdcall sub_46C2C4(float* a1, float a2, float a3, float a4)
{
    float* result; // eax
    double v6; // st7
    double v7; // st6
    double v8; // st7
    double v9; // st6
    float v10; // [esp+8h] [ebp-14h]
    float v11; // [esp+Ch] [ebp-10h]
    float v12; // [esp+10h] [ebp-Ch]
    float v13; // [esp+14h] [ebp-8h]
    float v14; // [esp+18h] [ebp-4h]
    float v15; // [esp+24h] [ebp+8h]
    float v16; // [esp+2Ch] [ebp+10h]
    float v17; // [esp+2Ch] [ebp+10h]
    float v18; // [esp+30h] [ebp+14h]

    if (!a1)
        return 0;
    v10 = a4 * 0.5;
    v18 = cos(v10);
    v15 = sin(v10);
    v16 = a3 * 0.5;
    v13 = cos(v16);
    v11 = sin(v16);
    v17 = a2 * 0.5;
    v14 = cos(v17);
    v12 = sin(v17);
    result = a1;
    v6 = v12 * v13;
    v7 = v14 * v11;
    *a1 = v18 * v7 + v6 * v15;
    a1[1] = v6 * v18 - v7 * v15;
    v8 = v14 * v13;
    v9 = v12 * v11;
    a1[2] = v8 * v15 - v9 * v18;
    a1[3] = v9 * v15 + v8 * v18;
    return result;
}

//----- (0046C3AA) --------------------------------------------------------
float* __stdcall sub_46C3AA(float* a1, float* a2, float* a3, float a4)
{
    double v7; // st7
    double v8; // st6
    double v9; // st5
    long double v10; // st6
    long double v11; // st6
    long double v12; // st6
    float* result; // eax
    float v14; // [esp+Ch] [ebp+8h]
    float v15; // [esp+10h] [ebp+Ch]
    float v16; // [esp+10h] [ebp+Ch]
    float v17; // [esp+14h] [ebp+10h]

    if (!a1 || !a2 || !a3)
        return 0;
    v7 = 1.0 - a4;
    v8 = *a2 * *a3 + a2[2] * a3[2] + a2[1] * a3[1] + a3[3] * a2[3];
    if (v8 < 0.0)
        v14 = -1.0;
    else
        v14 = 1.0;
    v9 = v14 * v8;
    if (1.0 - v9 <= 0.0000099999997)
    {
        v11 = a4;
    }
    else
    {
        v10 = sqrt(1.0 - v9 * v9);
        v15 = v9;
        v16 = atan2(v10, v15);
        v17 = 1.0 / v10;
        v7 = sin(v16 * v7) * v17;
        v11 = sin(v16 * a4) * v17;
    }
    v12 = v11 * v14;
    result = a1;
    *a1 = v7 * *a2 + v12 * *a3;
    a1[1] = v7 * a2[1] + v12 * a3[1];
    a1[2] = v7 * a2[2] + v12 * a3[2];
    a1[3] = v12 * a3[3] + v7 * a2[3];
    return result;
}

//----- (0046C4AC) --------------------------------------------------------
float* __stdcall sub_46C4AC(float* a1, float* a2, float* a3, float* a4)
{
    float* result; // eax
    float v5[3]; // [esp+8h] [ebp-18h] BYREF
    float v6[3]; // [esp+14h] [ebp-Ch] BYREF

    if (!a1 || !a2 || !a3 || !a4)
        return 0;
    v5[0] = *a2 - *a3;
    v5[1] = a2[1] - a3[1];
    v5[2] = a2[2] - a3[2];
    v6[0] = *a2 - *a4;
    v6[1] = a2[1] - a4[1];
    v6[2] = a2[2] - a4[2];
    sub_419690(a1, v5, v6);
    sub_46B970(a1, a1);
    result = a1;
    a1[3] = -(a1[2] * a2[2] + a1[1] * a2[1] + *a1 * *a2);
    return result;
}
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);

//----- (0046C53F) --------------------------------------------------------
float* __stdcall sub_46C53F(float* a1, float* a2)
{
    float* v3; // esi
    float* v4; // esi
    float v6; // [esp+4h] [ebp-1Ch]
    float v7[3]; // [esp+14h] [ebp-Ch] BYREF
    float v8; // [esp+28h] [ebp+8h]

    if (a1)
    {
        v3 = a2;
        if (a2)
        {
            v8 = sub_46C29E(a2);
            if (sub_46B940(v8, 1.0))
            {
                if (a1 == a2)
                    return a1;
            }
            else
            {
                if (v8 <= 9.9999994e-11)
                {
                    *a1 = 0.0;
                    a1[1] = 0.0;
                    a1[2] = 0.0;
                    return a1;
                }
                v6 = sqrt(v8);
                v3 = sub_416320(a2, v7, v6);
            }
            *a1 = *v3;
            v4 = v3 + 1;
            a1[1] = *v4;
            a1[2] = v4[1];
            return a1;
        }
    }
    return 0;
}

//----- (0046C5C5) --------------------------------------------------------
float* __stdcall sub_46C5C5(float* a1, float* a2, float* a3)
{
    double v3; // st5
    double v4; // st6
    double v5; // st7
    float v7; // [esp+8h] [ebp-4h]

    if (!a1 || !a2 || !a3)
        return 0;
    v3 = *a2 * a3[1] + a2[1] * a3[5] + a2[2] * a3[9] + a3[13];
    v4 = *a2 * a3[2] + a2[1] * a3[6] + a2[2] * a3[10] + a3[14];
    v5 = *a2 * a3[3] + a2[1] * a3[7] + a2[2] * a3[11] + a3[15];
    *a1 = *a2 * *a3 + a2[1] * a3[4] + a2[2] * a3[8] + a3[12];
    a1[1] = v3;
    a1[2] = v4;
    v7 = v5;
    if (!sub_46B940(v7, 1.0))
        sub_416290(a1, v7);
    return a1;
}

//----- (0046C69B) --------------------------------------------------------
float* __stdcall sub_46C69B(float* a1, float a2, float a3, float a4)
{
    int v5[4]; // [esp+Ch] [ebp-10h] BYREF

    if (!a1)
        return 0;
    sub_46C2C4((float*)v5, a2, a3, a4);
    sub_46C107(a1, (float*)v5);
    return a1;
}

//----- (0046C6DE) --------------------------------------------------------
float* __stdcall sub_46C6DE(float* a1, float* a2, float* a3, float* a4)
{
    double v4; // st7
    double v5; // st7
    double v6; // st6
    float v7; // eax
    double v8; // st7
    double v9; // st6
    float* result; // eax
    float v11; // [esp+8h] [ebp-24h] BYREF
    float v12; // [esp+Ch] [ebp-20h]
    float v13; // [esp+10h] [ebp-1Ch]
    float v14; // [esp+14h] [ebp-18h] BYREF
    float v15; // [esp+18h] [ebp-14h]
    float v16; // [esp+1Ch] [ebp-10h]
    float v17; // [esp+20h] [ebp-Ch] BYREF
    float v18; // [esp+24h] [ebp-8h]
    float v19; // [esp+28h] [ebp-4h]

    if (!a1 || !a2 || !a3 || !a4)
        return 0;
    v17 = *a2 - *a3;
    v18 = a2[1] - a3[1];
    v19 = a2[2] - a3[2];
    sub_46B970(&v17, &v17);
    sub_419690(&v14, a4, &v17);
    sub_46B970(&v14, &v14);
    sub_419690(&v11, &v17, &v14);
    v4 = v14;
    *a1 = v14;
    a1[4] = v15;
    a1[8] = v16;
    v5 = v4 * *a2 + v15 * a2[1];
    v6 = v16 * a2[2];
    a1[1] = v11;
    a1[5] = v12;
    a1[9] = v13;
    v7 = v17;
    a1[12] = -(v5 + v6);
    v8 = v11 * *a2 + v12 * a2[1];
    v9 = v13 * a2[2];
    a1[2] = v7;
    a1[6] = v18;
    a1[10] = v19;
    a1[13] = -(v8 + v9);
    a1[14] = -(v17 * *a2 + v18 * a2[1] + v19 * a2[2]);
    result = a1;
    a1[3] = 0.0;
    a1[7] = 0.0;
    a1[11] = 0.0;
    a1[15] = 1.0;
    return result;
}
// 46B970: using guessed type _DWORD __stdcall sub_46B970(_DWORD, _DWORD);

//----- (0046C80E) --------------------------------------------------------
void* __thiscall sub_46C80E(void* this)
{
    return this;
}

//----- (0046C811) --------------------------------------------------------
float* __thiscall sub_46C811(float* this, unsigned int a2)
{
    float* result; // eax

    result = this;
    *this = (double)BYTE2(a2) * 0.0039215689;
    this[1] = (double)BYTE1(a2) * 0.0039215689;
    this[2] = (double)(unsigned __int8)a2 * 0.0039215689;
    this[3] = (double)HIBYTE(a2) * 0.0039215689;
    return result;
}

//----- (0046C866) --------------------------------------------------------
int __stdcall sub_46C866(int a1, int a2, int a3, int(__thiscall* a4)(int))
{
    int result; // eax
    int v6; // edi

    result = a3 - 1;
    if (a3 - 1 >= 0)
    {
        v6 = a3;
        do
        {
            result = a4(a1);
            a1 += a2;
            --v6;
        } while (v6);
    }
    return result;
}

//----- (0046C888) --------------------------------------------------------
unsigned int* __thiscall sub_46C888(unsigned int* this, unsigned int a2)
{
    unsigned int v3; // ecx
    unsigned int v4; // ebx
    int v5; // edi
    unsigned int v6; // ebx
    int v7; // eax
    unsigned int v8; // ecx

    v3 = a2;
    v4 = a2 & 0xE;
    *this = a2;
    this[2] = 0;
    this[3] = 0;
    this[4] = 0;
    this[5] = 0;
    this[6] = 0;
    this[7] = 0;
    this[8] = 0;
    v5 = 12;
    if (v4 == 4)
    {
        v5 = 16;
        sub_46D8FD(0, "D3DX: Detected a mesh that is using XYZRHW which is not supported.");
        v3 = a2;
    }
    if (v4 >= 6)
    {
        v6 = (v4 - 4) >> 1;
        if (!v6 || v6 > 5)
        {
            if (sub_46D957(
                "d:\\builds\\nt32_chk\\multimedia\\directx\\dxg\\d3dx8\\mesh\\gxcrackfvf.h",
                126,
                "(dwPosition >= 1) && (dwPosition <= 5)"))
            {
                DebugBreak();
            }
            v3 = a2;
        }
        v5 += 4 * v6;
        this[7] = v6;
    }
    if ((v3 & 0x10) != 0)
    {
        this[2] = v5;
        v5 += 12;
    }
    if ((v3 & 0x20) != 0)
    {
        this[3] = v5;
        v5 += 4;
    }
    if ((v3 & 0x40) != 0)
    {
        this[4] = v5;
        v5 += 4;
    }
    if ((v3 & 0x80u) != 0)
    {
        this[5] = v5;
        v5 += 4;
    }
    if ((v3 & 0xF00) != 0)
    {
        v7 = (v3 >> 8) & 0xF;
        v8 = HIWORD(v3);
        this[6] = v5;
        for (this[8] = v7; v7; --v7)
        {
            v5 += dword_499ED8[v8 & 3];
            v8 >>= 2;
        }
    }
    this[1] = v5;
    return this;
}
// 499ED8: using guessed type int dword_499ED8[28];

//----- (0046C967) --------------------------------------------------------
int __stdcall sub_46C967(float* a1, unsigned int a2, unsigned int a3, float* a4, float* a5)
{
    float* v6; // eax
    unsigned int v7; // ecx
    double v8; // st7
    float* v9; // eax
    double v10; // st7
    float v12; // [esp+0h] [ebp-50h]
    unsigned int v13; // [esp+10h] [ebp-40h] BYREF
    int v14; // [esp+14h] [ebp-3Ch]
    float v15[3]; // [esp+34h] [ebp-1Ch] BYREF
    float v16; // [esp+40h] [ebp-10h]
    float v17; // [esp+44h] [ebp-Ch]
    float v18; // [esp+48h] [ebp-8h]
    int v19; // [esp+4Ch] [ebp-4h]
    float v20; // [esp+60h] [ebp+10h]
    unsigned int v21; // [esp+64h] [ebp+14h]

    v19 = 0;
    sub_46C888(&v13, a3);
    if (!a1)
    {
        sub_46D8FD(0, "D3DXComputeBoundingSphere: NULL input vertex array\n");
        return -2005530516;
    }
    if (!a4)
    {
        sub_46D8FD(0, "D3DXComputeBoundingSphere: NULL center output parameter\n");
        return -2005530516;
    }
    if (!a5)
    {
        sub_46D8FD(0, "D3DXComputeBoundingSphere: NULL radius output paramter\n");
        return -2005530516;
    }
    v16 = 0.0;
    v17 = 0.0;
    v18 = 0.0;
    *a4 = 0.0;
    a4[1] = v17;
    a4[2] = v18;
    if (a2)
    {
        v6 = a1;
        v7 = a2;
        do
        {
            *a4 = *v6 + *a4;
            a4[1] = v6[1] + a4[1];
            v8 = v6[2];
            v6 = (float*)((char*)v6 + v14);
            --v7;
            a4[2] = v8 + a4[2];
        } while (v7);
        v12 = (float)a2;
        sub_416290(a4, v12);
        v20 = 0.0;
        v9 = a1;
        v21 = a2;
        while (1)
        {
            v16 = *v9 - *a4;
            v17 = v9[1] - a4[1];
            v18 = v9[2] - a4[2];
            v15[0] = v16;
            v15[1] = v17;
            v15[2] = v18;
            v10 = sub_46C29E(v15);
            if (v10 > v20)
                v20 = v10;
            a1 = (float*)((char*)a1 + v14);
            if (!--v21)
                break;
            v9 = a1;
        }
        *a5 = sqrt(v20);
    }
    else
    {
        v19 = 0;
        *a5 = 1.0;
    }
    return v19;
}
// 46CA18: conditional instruction was optimized away because %arg_4.4!=0

//----- (0046CAA2) --------------------------------------------------------
_DWORD* __cdecl sub_46CAA2(int a1)
{
    _DWORD* result; // eax

    result = &unk_4AE9F0;
    if (off_4AEFB8 <= &unk_4AE9F0)
        return &unk_4AEF90;
    while (a1 != *result)
    {
        result += 10;
        if (result >= (_DWORD*)off_4AEFB8)
            return &unk_4AEF90;
    }
    return result;
}
// 4AEFB8: using guessed type _UNKNOWN *off_4AEFB8;

//----- (0046CAC9) --------------------------------------------------------
int __usercall sub_46CAC9@<eax>(int a1@<eax>, _DWORD* a2@<ecx>)
{
    int v3; // edx
    unsigned int v4; // eax
    int result; // eax
    unsigned int* v6; // esi
    int v7; // edi
    int v8; // ebx
    unsigned int v9; // ecx
    unsigned int v10; // edx

    if (!a2[8])
        return -1;
    v3 = a2[1];
    v4 = *(_DWORD*)(a1 + 4);
    if (v3 != v4
        && (!v3 && v4 > 2 || v3 == 3 && v4 != 3 || v3 == 2 && v4 != 2 || v3 == 1 && v4 != 1 || v3 == 4 && v4 != 4))
    {
        return -1;
    }
    result = 0;
    v6 = a2 + 3;
    v7 = a1 - (_DWORD)a2;
    v8 = 5;
    do
    {
        v9 = *(unsigned int*)((char*)v6 + v7);
        v10 = *v6;
        if (v9 >= *v6)
        {
            if (v9 > *v6)
            {
                if (v10)
                    result += (v9 - v10) << 16;
                else
                    result += 0x1000000;
            }
        }
        else if (v9)
        {
            result += v10 - v9;
        }
        else
        {
            result += 256;
        }
        ++v6;
        --v8;
    } while (v8);
    return result;
}

//----- (0046CB5B) --------------------------------------------------------
int __usercall sub_46CB5B@<eax>(
    int a1@<eax>,
    int a2@<edi>,
    unsigned int* a3,
    unsigned int* a4,
    unsigned int* a5,
    unsigned int* a6,
    int a7,
    unsigned int* a8,
    unsigned int a9,
    int a10)
{
    _DWORD* v12; // eax
    unsigned int v13; // edi
    unsigned int* v14; // ebx
    unsigned int v15; // esi
    unsigned int v16; // eax
    unsigned int v17; // esi
    unsigned int v18; // ebx
    unsigned int v19; // eax
    int v20; // eax
    unsigned int v21; // edi
    unsigned int v22; // eax
    bool v23; // cc
    unsigned int v24; // eax
    unsigned int v25; // eax
    unsigned int i; // eax
    unsigned int v27; // edx
    unsigned int j; // eax
    unsigned int v29; // eax
    unsigned int k; // ecx
    unsigned int v31; // eax
    _DWORD v32[15]; // [esp+8h] [ebp-128h] BYREF
    int v33; // [esp+44h] [ebp-ECh]
    unsigned int v34; // [esp+60h] [ebp-D0h]
    unsigned int v35; // [esp+64h] [ebp-CCh]
    unsigned int v36; // [esp+68h] [ebp-C8h]
    int v37; // [esp+70h] [ebp-C0h]
    _DWORD v38[10]; // [esp+DCh] [ebp-54h] BYREF
    char v39[12]; // [esp+104h] [ebp-2Ch] BYREF
    int v40; // [esp+110h] [ebp-20h]
    _DWORD* v41; // [esp+114h] [ebp-1Ch]
    int v42; // [esp+118h] [ebp-18h]
    int v43; // [esp+11Ch] [ebp-14h]
    int v44; // [esp+120h] [ebp-10h]
    unsigned int v45; // [esp+124h] [ebp-Ch]
    unsigned int v46; // [esp+128h] [ebp-8h]
    unsigned int v47; // [esp+12Ch] [ebp-4h] BYREF

    if (!a1)
    {
        sub_46D8FD(0, "pDevice pointer is invalid");
        return -2005530516;
    }
    if (a7 == -1)
        a7 = 0;
    if (a7 != (a7 & 3) || a10 == 2 && (a7 & 3) != 0)
    {
        sub_46D8FD(0, "Usage parameter is invalid");
        return -2005530516;
    }
    if (a9 > 2)
    {
        sub_46D8FD(0, "Pool parameter is invalid");
        return -2005530516;
    }
    (*(void(__stdcall**)(int, unsigned int*, int))(*(_DWORD*)a1 + 24))(a1, &v47, a2);
    (*(void(__stdcall**)(int, _DWORD*))(*(_DWORD*)a1 + 28))(a1, v32);
    (*(void(__stdcall**)(int, char*))(*(_DWORD*)a1 + 32))(a1, v39);
    v42 = 3;
    v43 = 5;
    v44 = 4;
    if (a8)
        v46 = *a8;
    else
        v46 = 0;
    v45 = 0;
    v12 = sub_46CAA2(v46);
    v38[2] = 0;
    v41 = v12;
    v13 = -1;
    v14 = (unsigned int*)&unk_4AE9F0;
    if (off_4AEFB8 > &unk_4AE9F0)
    {
        do
        {
            if (v14[9]
                && (*(int(__stdcall**)(unsigned int, _DWORD, _DWORD, int, int, _DWORD, unsigned int))(*(_DWORD*)v47 + 40))(
                    v47,
                    v32[1],
                    v32[0],
                    v40,
                    a7,
                    *(&v42 + a10),
                    *v14) >= 0)
            {
                v15 = *v14;
                if (*v14 == v46)
                {
                    v45 = v46;
                    break;
                }
                if (v14[8])
                {
                    v16 = sub_46CAC9((int)v41, v14);
                    if (v16 < v13 || v16 == v13 && v14[2] < v38[2])
                    {
                        v45 = v15;
                        qmemcpy(v38, v14, sizeof(v38));
                        v13 = v16;
                    }
                }
            }
            v14 += 10;
        } while (v14 < (unsigned int*)off_4AEFB8);
    }
    (*(void(__cdecl**)(unsigned int))(*(_DWORD*)v47 + 8))(v47);
    if (!v45)
        return -2005530518;
    if (a3)
        v17 = *a3;
    else
        v17 = -1;
    if (a4)
        v18 = *a4;
    else
        v18 = -1;
    if (a5)
        v47 = *a5;
    else
        v47 = -1;
    if (v17 == -1)
    {
        if (v18 == -1)
        {
            v18 = 256;
            v17 = 256;
            goto LABEL_48;
        }
        v17 = v18;
    }
    else if (v18 == -1)
    {
        v18 = v17;
    }
    if (!v17)
        v17 = 1;
    if (!v18)
        v18 = 1;
LABEL_48:
    if (a10 == 1)
    {
        if (v17 > v18)
            v18 = v17;
        v17 = v18;
    }
    if (v47 == -1 || !v47)
        v47 = 1;
    if (a10 == 2)
    {
        v19 = v36;
        if (v47 > v36)
            v47 = v36;
        if (v17 > v36)
            v17 = v36;
    }
    else
    {
        if (v17 > v34)
            v17 = v34;
        if (v18 > v35)
            v18 = v35;
        if (a10)
            goto LABEL_74;
        v20 = (v33 & 0x20) != 0 ? 1 : v37;
        if (!v20)
            goto LABEL_74;
        if (v17 > v18 * v20)
            v17 = v18 * v20;
        v19 = v17 * v20;
    }
    if (v18 > v19)
        v18 = v19;
LABEL_74:
    v42 = 2;
    v43 = 0x20000;
    v44 = 0x40000;
    v21 = 1;
    if ((v33 & *(&v42 + a10)) != 0)
    {
        v22 = v17;
        v23 = v17 <= 1;
        v17 = 1;
        if (!v23)
        {
            do
                v17 *= 2;
            while (v17 < v22);
        }
        v24 = v18;
        v23 = v18 <= 1;
        v18 = 1;
        if (!v23)
        {
            do
                v18 *= 2;
            while (v18 < v24);
        }
        v25 = v47;
        v23 = v47 <= 1;
        v47 = 1;
        if (!v23)
        {
            do
                v47 *= 2;
            while (v47 < v25);
        }
    }
    if (v45 == 827611204 || v45 == 844388420 || v45 == 861165636 || v45 == 877942852 || v45 == 894720068)
    {
        v17 = (v17 + 3) & 0xFFFFFFFC;
        v18 = (v18 + 3) & 0xFFFFFFFC;
    }
    v42 = 0x4000;
    v43 = 0x10000;
    v44 = 0x8000;
    if (a6)
        v46 = *a6;
    else
        v46 = -1;
    if ((v33 & *(&v42 + a10)) == 0 || ((v17 - 1) & v17) != 0 || ((v18 - 1) & v18) != 0 || ((v47 - 1) & v47) != 0)
    {
        v46 = 1;
    }
    else
    {
        for (i = v17; i; ++v21)
        {
            if ((i & 1) != 0)
                break;
            i >>= 1;
        }
        v27 = 1;
        for (j = v18; j; ++v27)
        {
            if ((j & 1) != 0)
                break;
            j >>= 1;
        }
        v29 = v47;
        for (k = 1; v29; ++k)
        {
            if ((v29 & 1) != 0)
                break;
            v29 >>= 1;
        }
        v31 = v21;
        if (v21 <= v27)
            v31 = v27;
        if (a10 == 2 && k > v31)
            v31 = k;
        if (v46 > v31 || !v46)
            v46 = v31;
    }
    if (a3)
        *a3 = v17;
    if (a4)
        *a4 = v18;
    if (a5)
        *a5 = v47;
    if (a6)
        *a6 = v46;
    if (a8)
        *a8 = v45;
    return 0;
}
// 46CB5B: could not find valid save-restore pair for edi
// 4AEFB8: using guessed type _UNKNOWN *off_4AEFB8;

//----- (0046CF1A) --------------------------------------------------------
int __stdcall sub_46CF1A(int a1, int a2, int* a3, int a4, int a5, int a6, int a7, int* a8, int* a9, int a10)
{
    int v10; // edi
    int v11; // esi
    int v13; // edi
    int v14; // ecx
    int v15; // ecx
    int v16; // ebx
    char* v17; // [esp-4h] [ebp-ECh]
    _DWORD v18[19]; // [esp+Ch] [ebp-DCh] BYREF
    _DWORD v19[19]; // [esp+58h] [ebp-90h] BYREF
    int v20[6]; // [esp+A4h] [ebp-44h] BYREF
    unsigned int v21; // [esp+BCh] [ebp-2Ch]
    unsigned int v22; // [esp+C0h] [ebp-28h]
    int* v23[3]; // [esp+C4h] [ebp-24h] BYREF
    _DWORD v24[2]; // [esp+D0h] [ebp-18h] BYREF
    int v25; // [esp+D8h] [ebp-10h] BYREF
    int v26; // [esp+DCh] [ebp-Ch]
    int v27; // [esp+E0h] [ebp-8h]
    int v28; // [esp+E4h] [ebp-4h]
    int v29; // [esp+F0h] [ebp+8h]

    sub_46DA95(v23);
    v10 = a1;
    if (!a1)
    {
        v17 = "pDestSurface pointer is invalid";
    LABEL_3:
        sub_46D8FD(0, v17);
    LABEL_18:
        v11 = -2005530516;
    LABEL_33:
        sub_46DA9F(v23);
        return v11;
    }
    if (!a4)
    {
        v17 = "pSrcMemory pointer is invalid";
        goto LABEL_3;
    }
    if (!a8)
    {
        v17 = "pSrcRect pointer is invalid";
        goto LABEL_3;
    }
    if (a9 == (int*)-1)
        a9 = (int*)(2 * (sub_46CAA2(a5)[1] != 3) + 524290);
    (*(void(__stdcall**)(int, int*))(*(_DWORD*)a1 + 32))(a1, v20);
    if (a3)
    {
        v25 = *a3;
        v26 = a3[1];
        v27 = a3[2];
        v28 = a3[3];
        if (v25 < 0 || v27 > v21 || v25 > v27 || v26 < 0 || v28 > v22 || v26 > v28)
        {
            sub_46D8FD(0, "Invalid destination rect");
            goto LABEL_18;
        }
        v10 = a1;
    }
    else
    {
        v27 = v21;
        v25 = 0;
        v26 = 0;
        v28 = v22;
    }
    if (v20[0] == 827611204
        || v20[0] == 844388420
        || v20[0] == 844715353
        || v20[0] == 861165636
        || v20[0] == 877942852
        || v20[0] == 894720068
        || v20[0] == 1498831189)
    {
        v13 = (*(int(__stdcall**)(int, _DWORD*, _DWORD, int))(*(_DWORD*)v10 + 36))(v10, v24, 0, 2048);
        if (v13 < 0)
        {
            sub_46D8FD(0, "Could not lock destination surface");
            v11 = v13;
            goto LABEL_33;
        }
        v10 = a1;
    }
    else
    {
        v29 = (*(int(__stdcall**)(int, _DWORD*, int*, int))(*(_DWORD*)v10 + 36))(v10, v24, &v25, 2048);
        if (v29 < 0)
        {
            sub_46D8FD(0, "Could not lock destination surface");
            sub_46DA9F(v23);
            return v29;
        }
        v27 -= v25;
        v28 -= v26;
        v25 = 0;
        v26 = 0;
    }
    v19[10] = v25;
    v19[11] = v26;
    v19[12] = v27;
    v19[13] = v28;
    v19[0] = v24[1];
    v18[0] = a4;
    v19[2] = v24[0];
    v18[2] = a6;
    v19[1] = v20[0];
    v18[1] = a5;
    v19[18] = a2;
    v18[17] = a10;
    v19[6] = v21;
    v18[18] = a7;
    v14 = *a8;
    v19[7] = v22;
    v18[10] = v14;
    v18[11] = a8[1];
    v15 = a8[2];
    v19[9] = 1;
    v19[15] = 1;
    v18[15] = 1;
    v18[12] = v15;
    v18[13] = a8[3];
    memset(&v19[3], 0, 12);
    v19[17] = 0;
    v19[8] = 0;
    v19[14] = 0;
    v18[3] = 0;
    v18[14] = 0;
    v16 = sub_470E39(v23, (int)v19, (int)v18, a9);
    if (v16 >= 0)
        v16 = 0;
    (*(void(__stdcall**)(int))(*(_DWORD*)v10 + 40))(v10);
    sub_46DA9F(v23);
    return v16;
}

//----- (0046D19F) --------------------------------------------------------
int __stdcall sub_46D19F(int a1, int a2, int* a3, int a4, int a5, int* a6, int* a7, int a8)
{
    int v9; // esi
    int v10[6]; // [esp+4h] [ebp-38h] BYREF
    unsigned int v11; // [esp+1Ch] [ebp-20h]
    unsigned int v12; // [esp+20h] [ebp-1Ch]
    int v13; // [esp+24h] [ebp-18h] BYREF
    int v14; // [esp+28h] [ebp-14h]
    int v15; // [esp+2Ch] [ebp-10h]
    int v16; // [esp+30h] [ebp-Ch]
    int v17[2]; // [esp+34h] [ebp-8h] BYREF

    if (!a1)
    {
        sub_46D8FD(0, "pDestSurface pointer is invalid");
        return -2005530516;
    }
    if (!a4)
    {
        sub_46D8FD(0, "pSrcSurface pointer is invalid");
        return -2005530516;
    }
    (*(void(__stdcall**)(int, int*))(*(_DWORD*)a4 + 32))(a4, v10);
    if (a6)
    {
        v13 = *a6;
        v14 = a6[1];
        v15 = a6[2];
        v16 = a6[3];
        if (v13 < 0 || v15 > v11 || v13 > v15 || v14 < 0 || v16 > v12 || v14 > v16)
        {
            sub_46D8FD(0, "Invalid source rect");
            return -2005530516;
        }
    }
    else
    {
        v15 = v11;
        v13 = 0;
        v14 = 0;
        v16 = v12;
    }
    if (v10[0] == 827611204
        || v10[0] == 844388420
        || v10[0] == 844715353
        || v10[0] == 861165636
        || v10[0] == 877942852
        || v10[0] == 894720068
        || v10[0] == 1498831189)
    {
        v9 = (*(int(__stdcall**)(int, int*, _DWORD, int))(*(_DWORD*)a4 + 36))(a4, v17, 0, 2064);
        if (v9 >= 0)
            goto LABEL_24;
    }
    else
    {
        v9 = (*(int(__stdcall**)(int, int*, int*, int))(*(_DWORD*)a4 + 36))(a4, v17, &v13, 2064);
        if (v9 >= 0)
        {
            v15 -= v13;
            v16 -= v14;
            v13 = 0;
            v14 = 0;
        LABEL_24:
            v9 = sub_46CF1A(a1, a2, a3, v17[1], v10[0], v17[0], a5, &v13, a7, a8);
            if (v9 >= 0)
                v9 = 0;
            (*(void(__stdcall**)(int))(*(_DWORD*)a4 + 40))(a4);
            return v9;
        }
    }
    sub_46D8FD(0, "Could not lock source surface");
    return v9;
}

//----- (0046D30C) --------------------------------------------------------
int __stdcall sub_46D30C(int a1, int a2, unsigned int a3, int* a4)
{
    int v4; // esi
    unsigned int v6; // eax
    unsigned int v7; // ebx
    int v8; // edi
    unsigned int v9; // ebx
    int v10[8]; // [esp+8h] [ebp-2Ch] BYREF
    unsigned int v11; // [esp+28h] [ebp-Ch]
    int v12; // [esp+2Ch] [ebp-8h]
    int v13; // [esp+30h] [ebp-4h] BYREF

    v4 = a1;
    if (!a1)
    {
        sub_46D8FD(0, "pTexture pointer is invalid");
        return -2005530516;
    }
    if (a4 == (int*)-1)
    {
        (*(void(__stdcall**)(int, _DWORD, int*))(*(_DWORD*)a1 + 56))(a1, 0, v10);
        a4 = (int*)(sub_46CAA2(v10[0])[1] != 3 ? 5 : 2);
    }
    v6 = (*(int(__stdcall**)(int))(*(_DWORD*)v4 + 52))(v4);
    v7 = a3;
    v11 = v6;
    if (a3 == -1)
        v7 = 0;
    if (v7 >= v6)
    {
        sub_46D8FD(0, "uSrcLevel larger than num Mip level in the texture");
        return -2005530516;
    }
    v13 = 0;
    a1 = 0;
    if ((unsigned __int8)a4 == 2 || (v12 = 0, (unsigned __int8)a4 == 5))
        v12 = 1;
    v8 = (*(int(__stdcall**)(int, unsigned int, int*))(*(_DWORD*)v4 + 60))(v4, v7, &v13);
    if (v8 >= 0)
    {
        v9 = v7 + 1;
        a3 = v9;
        if (v9 < v11)
        {
            while (1)
            {
                v8 = (*(int(__stdcall**)(int, unsigned int, int*))(*(_DWORD*)v4 + 60))(v4, v9, &a1);
                if (v8 < 0)
                    goto LABEL_27;
                v8 = sub_46D19F(a1, a2, 0, v13, a2, 0, a4, 0);
                if (v8 < 0)
                    goto LABEL_27;
                if (v12)
                {
                    if (v13)
                        (*(void(__stdcall**)(int))(*(_DWORD*)v13 + 8))(v13);
                    v13 = a1;
                }
                else
                {
                    if (!a1)
                        goto LABEL_25;
                    (*(void(__stdcall**)(int))(*(_DWORD*)a1 + 8))(a1);
                }
                a1 = 0;
            LABEL_25:
                if (++a3 >= v11)
                    break;
                v9 = a3;
            }
        }
        v8 = 0;
    }
LABEL_27:
    if (v13)
    {
        (*(void(__stdcall**)(int))(*(_DWORD*)v13 + 8))(v13);
        v13 = 0;
    }
    if (a1)
        (*(void(__stdcall**)(int))(*(_DWORD*)a1 + 8))(a1);
    return v8;
}

//----- (0046D461) --------------------------------------------------------
int __stdcall sub_46D461(
    int a1,
    unsigned __int8* a2,
    unsigned int a3,
    int a4,
    int a5,
    unsigned int a6,
    int a7,
    unsigned int a8,
    BOOL a9,
    int* a10,
    int* a11,
    int a12,
    _DWORD* a13,
    char* a14,
    int* a15)
{
    int v15; // esi
    int v16; // eax
    int v18; // eax
    int v19; // esi
    int v20; // edi
    unsigned int v21; // eax
    unsigned int v22; // ecx
    int v23; // esi
    char* v24; // edi
    int v25; // eax
    int v26; // edi
    int v27; // ebx
    BOOL v28; // eax
    int* v29; // esi
    int v30; // ecx
    _DWORD v31[256]; // [esp+8h] [ebp-43Ch] BYREF
    int v32[7]; // [esp+408h] [ebp-3Ch] BYREF
    int v33; // [esp+424h] [ebp-20h]
    int v34; // [esp+430h] [ebp-14h]
    int v35; // [esp+438h] [ebp-Ch] BYREF
    int v36; // [esp+43Ch] [ebp-8h] BYREF
    int v37; // [esp+440h] [ebp-4h] BYREF
    int v38; // [esp+450h] [ebp+Ch]
    unsigned int v39; // [esp+454h] [ebp+10h]

    sub_470F78(v32);
    v37 = 0;
    v36 = 0;
    v35 = 0;
    if (!a1)
    {
        sub_46D8FD(0, "pDevice pointer is invalid");
    LABEL_3:
        v15 = -2005530516;
    LABEL_12:
        sub_470F91((int)v32);
        return v15;
    }
    if (!a2)
    {
        sub_46D8FD(0, "pvSrcData pointer is invalid");
        goto LABEL_3;
    }
    if (!a3)
    {
        sub_46D8FD(0, "cbSrcData value is invalid");
        goto LABEL_3;
    }
    if (!a15)
    {
        sub_46D8FD(0, "ppTexture pointer is invalid");
        goto LABEL_3;
    }
    v16 = sub_4729A4((int)v32, a2, a3, a13);
    if (v16 < 0)
    {
        v15 = v16;
        goto LABEL_12;
    }
    v18 = v34;
    v39 = 1;
    while (v18)
    {
        ++v39;
        v18 = *(_DWORD*)(v18 + 40);
    }
    if (!a4 || a4 == -1)
        a4 = v32[5];
    if (!a5 || a5 == -1)
        a5 = v32[6];
    v19 = v32[0];
    v20 = a12;
    if (!a8)
    {
        if (!a12)
        {
            a8 = 22;
            if (v32[0] == 20)
                goto LABEL_36;
            goto LABEL_35;
        }
        if (v32[0] != 20)
        {
            if (v32[0] <= 21)
            {
            LABEL_35:
                a8 = v32[0];
                goto LABEL_36;
            }
            if (v32[0] > 23)
            {
                if (v32[0] == 24 || v32[0] == 27 || v32[0] == 30)
                {
                    a8 = 25;
                    goto LABEL_36;
                }
                if (v32[0] == 50)
                {
                    a8 = 51;
                    goto LABEL_36;
                }
                goto LABEL_35;
            }
        }
        a8 = 21;
    }
LABEL_36:
    if (a10 == (int*)-1)
        a10 = (int*)(2 * (sub_46CAA2(v32[0])[1] != 3) + 524290);
    if (a11 == (int*)-1)
        a11 = (int*)(sub_46CAA2(v19)[1] != 3 ? 5 : 2);
    if ((_BYTE)a10 == 1 || (unsigned __int8)a11 == 2 || (v38 = 0, (unsigned __int8)a11 == 5))
        v38 = 1;
    if (v33)
    {
        v21 = v20 & 0xFF00FF00 | ((unsigned __int8)v20 << 16) | BYTE2(a12);
        v22 = 0;
        v23 = v33 - (_DWORD)v31;
        do
        {
            v31[v22] = v21 != *(_DWORD*)((char*)&v31[v22] + v23) ? *(_DWORD*)((char*)&v31[v22] + v23) : 0;
            ++v22;
        } while (v22 < 0x100);
        a12 = 0;
    }
    else
    {
        memset(v31, 0xFFu, sizeof(v31));
    }
    v24 = a14;
    if (a14)
    {
        qmemcpy(a14, v31, 0x400u);
        v24 += 1024;
        goto LABEL_58;
    }
    if (a8 != 40)
    {
        if (a8 != 41)
            goto LABEL_58;
        a8 = 22;
        v25 = 0;
        while (HIBYTE(v31[v25]) == 0xFF)
        {
            if ((unsigned int)++v25 >= 0x100)
                goto LABEL_58;
        }
    }
    a8 = 21;
LABEL_58:
    v26 = sub_46CB5B(a1, (int)v24, (unsigned int*)&a4, (unsigned int*)&a5, 0, &a6, a7, &a8, a9, 0);
    if (v26 >= 0)
    {
        v26 = (*(int(__stdcall**)(int, int, int, unsigned int, int, unsigned int, BOOL, int*))(*(_DWORD*)a1 + 80))(
            a1,
            a4,
            a5,
            a6,
            a7,
            a8,
            a9,
            &v36);
        if (v26 >= 0)
        {
            v27 = v36;
            v28 = !a9;
            a9 = v28;
            if (v28)
            {
                v26 = (*(int(__stdcall**)(int, int, int, unsigned int, _DWORD, unsigned int, int, int*))(*(_DWORD*)a1 + 80))(
                    a1,
                    a4,
                    a5,
                    a6,
                    0,
                    a8,
                    2,
                    &v35);
                if (v26 < 0)
                    goto LABEL_62;
                v27 = v35;
            }
            a8 = 0;
            v29 = v32;
            if (v39)
            {
                while (a8 < a6)
                {
                    v26 = (*(int(__stdcall**)(int, unsigned int, int*))(*(_DWORD*)v27 + 60))(v27, a8, &v37);
                    if (v26 < 0)
                        goto LABEL_78;
                    v26 = sub_46CF1A(v37, (int)a14, 0, v29[1], *v29, v29[2], (int)v31, v29 + 3, a10, a12);
                    if (v37)
                    {
                        (*(void(__stdcall**)(int))(*(_DWORD*)v37 + 8))(v37);
                        v37 = 0;
                    }
                    if (v26 < 0)
                        goto LABEL_78;
                    if (++a8 >= v39)
                        break;
                    v29 = (int*)v29[10];
                }
            }
            if (v38)
            {
                if (v39 < a6)
                {
                    v26 = sub_46D30C(v27, (int)v31, v39 - 1, a11);
                    if (v26 < 0)
                        goto LABEL_78;
                }
            }
            else
            {
                while (a8 < a6)
                {
                    v26 = (*(int(__stdcall**)(int, unsigned int, int*))(*(_DWORD*)v27 + 60))(v27, a8, &v37);
                    if (v26 < 0)
                        goto LABEL_78;
                    v26 = sub_46CF1A(v37, (int)a14, 0, v29[1], *v29, v29[2], (int)v31, v29 + 3, a11, a12);
                    if (v37)
                    {
                        (*(void(__stdcall**)(int))(*(_DWORD*)v37 + 8))(v37);
                        v37 = 0;
                    }
                    if (v26 < 0)
                        goto LABEL_78;
                    ++a8;
                }
            }
            if (!a9 || (v26 = (*(int(__stdcall**)(int, int, int))(*(_DWORD*)a1 + 116))(a1, v35, v36), v26 >= 0))
            {
                v30 = v36;
                v36 = 0;
                *a15 = v30;
                v26 = 0;
            }
            goto LABEL_78;
        }
    LABEL_62:
        sub_46D8FD(0, "CreateTexture failed");
    }
LABEL_78:
    if (v37)
    {
        (*(void(__stdcall**)(int))(*(_DWORD*)v37 + 8))(v37);
        v37 = 0;
    }
    if (v36)
    {
        (*(void(__stdcall**)(int))(*(_DWORD*)v36 + 8))(v36);
        v36 = 0;
    }
    if (v35)
    {
        (*(void(__stdcall**)(int))(*(_DWORD*)v35 + 8))(v35);
        v35 = 0;
    }
    sub_470F91((int)v32);
    return v26;
}

//----- (0046D89A) --------------------------------------------------------
int __stdcall sub_46D89A(
    int a1,
    const WCHAR* a2,
    int a3,
    int a4,
    unsigned int a5,
    int a6,
    unsigned int a7,
    BOOL a8,
    int* a9,
    int* a10,
    int a11,
    _DWORD* a12,
    char* a13,
    int* a14)
{
    int v14; // eax
    int v15; // esi
    _DWORD v17[4]; // [esp+4h] [ebp-10h] BYREF

    sub_472AF9(v17);
    v14 = sub_472B0B((int)v17, a2, 0);
    if (v14 >= 0)
        v14 = sub_46D461(a1, (unsigned __int8*)v17[2], v17[3], a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
    v15 = v14;
    sub_472C9E((int)v17);
    return v15;
}

//----- (0046D8FD) --------------------------------------------------------
void sub_46D8FD(int a1, char* Format, ...)
{
    CHAR OutputString[256]; // [esp+4h] [ebp-200h] BYREF
    char Buffer[256]; // [esp+104h] [ebp-100h] BYREF
    va_list va; // [esp+214h] [ebp+10h] BYREF

    va_start(va, Format);
    _vsnprintf(Buffer, 0x100u, Format, va);
    Buffer[255] = 0;
    _snprintf(OutputString, 0x100u, "D3DX: %s\r\n", Buffer);
    OutputString[255] = 0;
    OutputDebugStringA(OutputString);
}

//----- (0046D957) --------------------------------------------------------
BOOL __stdcall sub_46D957(const char* ArgList, int a2, const char* a3)
{
    HMODULE ModuleHandleA; // eax
    LSTATUS v4; // esi
    int v5; // eax
    CHAR Text[256]; // [esp+Ch] [ebp-10Ch] BYREF
    DWORD Type; // [esp+10Ch] [ebp-Ch] BYREF
    HKEY phkResult; // [esp+110h] [ebp-8h] BYREF
    DWORD cbData; // [esp+114h] [ebp-4h] BYREF

    sub_46D8FD(0, "Assertion failure! (%s %d): %s", ArgList, a2, a3);
    if (!dword_521724)
    {
        cbData = 4;
        dword_521724 = 1;
        ModuleHandleA = GetModuleHandleA("kernel32.dll");
        if (ModuleHandleA || (ModuleHandleA = LoadLibraryA("kernel32.dll")) != 0)
            IsDebuggerPresent = GetProcAddress(ModuleHandleA, "IsDebuggerPresent");
        if (RegOpenKeyA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Direct3D", &phkResult))
            return 0;
        v4 = RegQueryValueExA(phkResult, "D3DX", 0, &Type, &Data, &cbData);
        RegCloseKey(phkResult);
        if (v4 || Type != 4 || cbData != 4)
            return 0;
    }
    if (!*(_DWORD*)&Data)
        return 0;
    if (*(_DWORD*)&Data == 1)
        return 1;
    if (*(_DWORD*)&Data != 3 && (!IsDebuggerPresent || IsDebuggerPresent()))
        return 0;
    _snprintf(
        Text,
        0x100u,
        "File:\t %s\nLine:\t %d\nAssertion:\t%s\n\nDo you want to invoke the debugger?",
        ArgList,
        a2,
        a3);
    v5 = MessageBoxA(0, Text, "D3DX Assertion Failure", 0x1003u) - 2;
    if (!v5)
        FatalAppExitA(0, "D3DX Assertion Failure.. Application terminated");
    return v5 == 4;
}
// 521724: using guessed type int dword_521724;

//----- (0046DA95) --------------------------------------------------------
_DWORD* __thiscall sub_46DA95(_DWORD* this)
{
    _DWORD* result; // eax

    result = this;
    this[1] = 0;
    *this = 0;
    return result;
}

//----- (0046DA9F) --------------------------------------------------------
int __thiscall sub_46DA9F(_DWORD* this)
{
    int(__thiscall * **v2)(_DWORD, int); // ecx
    int result; // eax

    v2 = (int(__thiscall***)(_DWORD, int))this[1];
    if (v2)
        result = (**v2)(v2, 1);
    if (*this)
        return (**(int(__thiscall***)(_DWORD, int)) * this)(*this, 1);
    return result;
}

//----- (0046DABD) --------------------------------------------------------
void __thiscall sub_46DABD(int this)
{
    void* v2; // esi

    sub_4885A6(*(LPVOID*)this);
    v2 = *(void**)(this + 8);
    if (v2)
    {
        sub_46DABD(v2);
        sub_4885A6(v2);
    }
}

//----- (0046DADF) --------------------------------------------------------
void* __thiscall sub_46DADF(void* this, char a2)
{
    sub_46DABD((int)this);
    if ((a2 & 1) != 0)
        sub_4885A6(this);
    return this;
}

//----- (0046DAFE) --------------------------------------------------------
unsigned int* __cdecl sub_46DAFE(unsigned int a1, signed int a2, int a3)
{
    unsigned int v3; // esi
    double v4; // st7
    double v5; // st6
    __int64 v6; // rax
    unsigned int* v7; // edi
    unsigned int v8; // esi
    unsigned int* v9; // eax
    double v10; // st7
    double X; // st7
    int v12; // ecx
    double v13; // st7
    int v14; // ebx
    float* v15; // edi
    double v16; // st7
    float* v17; // edi
    unsigned int* v19; // [esp+14h] [ebp-50h]
    unsigned int v20; // [esp+18h] [ebp-4Ch]
    float v21; // [esp+1Ch] [ebp-48h]
    float v22; // [esp+20h] [ebp-44h]
    float v23; // [esp+24h] [ebp-40h]
    unsigned int* v24; // [esp+28h] [ebp-3Ch]
    int v25; // [esp+2Ch] [ebp-38h]
    float v26; // [esp+30h] [ebp-34h]
    float v27; // [esp+34h] [ebp-30h]
    float v28; // [esp+38h] [ebp-2Ch]
    unsigned int v29; // [esp+3Ch] [ebp-28h]
    int v30; // [esp+40h] [ebp-24h]
    int v31; // [esp+44h] [ebp-20h]
    float v32; // [esp+48h] [ebp-1Ch]
    float v33; // [esp+4Ch] [ebp-18h]
    unsigned int i; // [esp+50h] [ebp-14h]
    float v35; // [esp+54h] [ebp-10h]
    unsigned int v36; // [esp+58h] [ebp-Ch]
    float v37; // [esp+5Ch] [ebp-8h]
    float v38; // [esp+60h] [ebp-4h]

    v3 = 0;
    if (a1)
    {
        if (a2)
        {
            v28 = (float)(unsigned int)a2;
            v4 = (double)a1;
            v22 = v4;
            v5 = v28 / v4;
            v36 = 16;
            v26 = v5;
            do
            {
                v6 = (__int64)(((double)v3 - 0.5) * v5 + v5 - ((double)v3 - 0.5) * v5 + (double)(a3 != 0) + 1.0);
                ++v3;
                v36 += 16 * v6 + 12;
            } while (v3 < a1);
            v7 = (unsigned int*)operator new(v36);
            v24 = v7;
            if (v7)
            {
                v30 = 0;
                v29 = 0;
                v38 = 0.0;
                v8 = 4;
                while (1)
                {
                    v9 = &v7[v8 / 4];
                    v20 = v8;
                    v8 += 4;
                    v19 = v9;
                    if (v8 > v36
                        && sub_46D957(
                            "d:\\builds\\nt32_chk\\multimedia\\directx\\dxg\\d3dx8\\tex\\cd3dxblt.cpp",
                            1034,
                            "uSize <= uSizeMax"))
                    {
                        DebugBreak();
                    }
                    for (i = 0; i < 2; ++i)
                    {
                        v23 = (float)v29;
                        v10 = (double)i + v23 - 0.5;
                        v33 = v10;
                        X = v10 * v26;
                        v27 = X;
                        v37 = v26 + X;
                        if (!a3)
                        {
                            if (X < 0.0)
                            {
                                X = 0.0;
                                v27 = 0.0;
                            }
                            if (v37 > (double)v28)
                                v37 = (float)(unsigned int)a2;
                        }
                        v12 = (__int64)floor(X);
                        v31 = v12;
                        v13 = (double)v12;
                        if (v13 < v37)
                        {
                            v14 = v12 - a2;
                            v25 = v12 - a2;
                            while (1)
                            {
                                v35 = v13;
                                v32 = v13 + 1.0;
                                if (v12 >= 0)
                                {
                                    if (v12 < a2)
                                        v14 = v12;
                                }
                                else
                                {
                                    v14 = v12 + a2;
                                }
                                if (v14 != v30)
                                {
                                    if (v38 > 0.0000099999997)
                                    {
                                        v15 = (float*)&v7[v8 / 4];
                                        v8 += 8;
                                        if (v8 > v36
                                            && sub_46D957(
                                                "d:\\builds\\nt32_chk\\multimedia\\directx\\dxg\\d3dx8\\tex\\cd3dxblt.cpp",
                                                1089,
                                                "uSize <= uSizeMax"))
                                        {
                                            DebugBreak();
                                        }
                                        v12 = v31;
                                        *(_DWORD*)v15 = v30;
                                        v15[1] = v38;
                                        v7 = v24;
                                    }
                                    v30 = v14;
                                    v38 = 0.0;
                                }
                                if (v35 < (double)v27)
                                    v35 = v27;
                                if (v32 > (double)v37)
                                    v32 = v37;
                                if (a3)
                                    break;
                                if (v33 >= 0.0)
                                {
                                    if (v33 + 1.0 < v22)
                                        break;
                                    v16 = 0.0;
                                }
                                else
                                {
                                    v16 = 1.0;
                                }
                            LABEL_39:
                                if (i)
                                    v16 = 1.0 - v16;
                                v31 = ++v12;
                                v14 = ++v25;
                                v38 = (v32 - v35) * v16 + v38;
                                v13 = (double)v12;
                                if (v13 >= v37)
                                    goto LABEL_42;
                            }
                            v21 = 0.5 / v5;
                            v16 = (v32 + v35) * v21 - v33;
                            goto LABEL_39;
                        }
                    LABEL_42:
                        ;
                    }
                    if (v38 > 0.0000099999997)
                    {
                        v17 = (float*)&v7[v8 / 4];
                        v8 += 8;
                        if (v8 > v36)
                        {
                            if (sub_46D957(
                                "d:\\builds\\nt32_chk\\multimedia\\directx\\dxg\\d3dx8\\tex\\cd3dxblt.cpp",
                                1136,
                                "uSize <= uSizeMax"))
                            {
                                DebugBreak();
                            }
                        }
                        *(_DWORD*)v17 = v30;
                        v17[1] = v38;
                        v7 = v24;
                    }
                    v38 = 0.0;
                    ++v29;
                    *v19 = v8 - v20;
                    if (v29 >= a1)
                    {
                        *v7 = v8;
                        return v7;
                    }
                }
            }
        }
    }
    return 0;
}
// 46DB6B: conditional instruction was optimized away because %arg_0.4!=0
// 46DBE8: conditional instruction was optimized away because %arg_0.4!=0

//----- (0046DE48) --------------------------------------------------------
int __thiscall sub_46DE48(_DWORD* this)
{
    _DWORD* v2; // edx
    int v3; // edi
    BOOL v4; // ebx
    unsigned int* v5; // edi
    unsigned int v6; // ebx
    _DWORD* v7; // edi
    int v8; // edi
    float* v9; // eax
    float* v10; // eax
    float* v11; // edi
    float* v12; // eax
    void** v13; // ebx
    int v14; // edi
    void* v15; // eax
    void* v16; // eax
    float* v17; // eax
    float* v18; // edx
    float* v19; // ebx
    _DWORD* v20; // ecx
    float* v21; // eax
    double v22; // st7
    float* v23; // edi
    float* v24; // edi
    float* v25; // edi
    float* v26; // ebx
    float* v27; // edi
    double v28; // st7
    unsigned int v29; // ebx
    _DWORD* v30; // ecx
    _DWORD** v31; // edi
    _DWORD* v32; // edi
    int v33; // esi
    unsigned int v35; // [esp+Ch] [ebp-48h]
    float* v36; // [esp+10h] [ebp-44h]
    void* v37; // [esp+14h] [ebp-40h]
    float* v38; // [esp+14h] [ebp-40h]
    float* v39; // [esp+18h] [ebp-3Ch]
    float* v40; // [esp+18h] [ebp-3Ch]
    unsigned int* v41; // [esp+1Ch] [ebp-38h]
    float* v42; // [esp+20h] [ebp-34h]
    unsigned int v43; // [esp+24h] [ebp-30h]
    int v44; // [esp+28h] [ebp-2Ch]
    unsigned int* v45; // [esp+2Ch] [ebp-28h]
    float* v46; // [esp+30h] [ebp-24h]
    float* v47; // [esp+34h] [ebp-20h]
    void** v48; // [esp+38h] [ebp-1Ch]
    int v49; // [esp+3Ch] [ebp-18h]
    _DWORD* v50; // [esp+40h] [ebp-14h]
    float* v51; // [esp+44h] [ebp-10h]
    unsigned int v52; // [esp+44h] [ebp-10h]

    v2 = (_DWORD*)this[1];
    v45 = 0;
    v50 = 0;
    v48 = 0;
    v39 = 0;
    if (v2[2] != 1)
        return -2147467259;
    v3 = *this;
    if (*(_DWORD*)(*this + 8) != 1 || v2[1046] != 1 || *(_DWORD*)(v3 + 4184) != 1)
        return -2147467259;
    v4 = ((this[2] >> 17) & 1) == 0;
    v5 = sub_46DAFE(*(_DWORD*)(v3 + 4176), v2[1044], (this[2] & 0x10000) == 0);
    v41 = v5;
    if (v5 && (v45 = sub_46DAFE(*(_DWORD*)(*this + 4180), *(_DWORD*)(this[1] + 4180), v4)) != 0)
    {
        v43 = (unsigned int)v5 + *v5;
        v6 = (unsigned int)v45 + *v45;
        v35 = v6;
        v7 = operator new(4 * *(_DWORD*)(this[1] + 4180));
        v50 = v7;
        if (!v7)
            goto LABEL_48;
        v49 = 0;
        memset(v7, 0, 4 * *(_DWORD*)(this[1] + 4180));
        v8 = *(_DWORD*)(*this + 4176);
        v9 = (float*)operator new(16 * v8);
        v40 = v9;
        if (v9)
        {
            sub_46C866((int)v9, 16, v8, (int(__thiscall*)(int))sub_46C80E);
            v47 = v40;
        }
        else
        {
            v47 = 0;
        }
        v39 = v47;
        if (v47)
        {
            v44 = 0;
            v10 = (float*)(v45 + 1);
            if ((unsigned int)(v45 + 1) < v6)
            {
                do
                {
                    v11 = (float*)((char*)v10 + *(_DWORD*)v10);
                    v12 = v10 + 1;
                    v46 = v11;
                    v42 = v12;
                    if (v12 < v11)
                    {
                        v51 = v12;
                        do
                        {
                            if (!v50[*(_DWORD*)v51])
                            {
                                v13 = v48;
                                if (v48)
                                {
                                    v48 = (void**)v48[2];
                                }
                                else
                                {
                                    v13 = (void**)operator new(0xCu);
                                    if (!v13)
                                        goto LABEL_48;
                                    v14 = *(_DWORD*)(this[1] + 4176);
                                    v15 = operator new(16 * v14);
                                    v37 = v15;
                                    if (v15)
                                    {
                                        sub_46C866((int)v15, 16, v14, (int(__thiscall*)(int))sub_46C80E);
                                        v16 = v37;
                                    }
                                    else
                                    {
                                        v16 = 0;
                                    }
                                    *v13 = v16;
                                    if (!v16)
                                    {
                                        sub_46DADF(v13, 1);
                                        goto LABEL_48;
                                    }
                                }
                                memset(*v13, 0, 16 * *(_DWORD*)(this[1] + 4176));
                                *((float*)v13 + 1) = 0.0;
                                v13[2] = 0;
                                ++v49;
                                v11 = v46;
                                v50[*(_DWORD*)v51] = v13;
                            }
                            v51 += 2;
                        } while (v51 < v11);
                        (*(void(__thiscall**)(_DWORD, int, _DWORD, float*))(*(_DWORD*)*this + 4))(*this, v44, 0, v47);
                        v17 = (float*)(v41 + 1);
                        if ((unsigned int)(v41 + 1) < v43)
                        {
                            v18 = v47 + 2;
                            do
                            {
                                v19 = (float*)((char*)v17 + *(_DWORD*)v17);
                                v36 = v19;
                                v52 = (unsigned int)v42;
                                v38 = v17 + 1;
                                do
                                {
                                    v20 = (_DWORD*)v50[*(_DWORD*)v52];
                                    v21 = v38;
                                    if (v38 < v19)
                                    {
                                        do
                                        {
                                            v22 = v21[1] * *(float*)(v52 + 4);
                                            *(float*)(*v20 + 16 * *(_DWORD*)v21) = v22 * *(v18 - 2) + *(float*)(*v20 + 16 * *(_DWORD*)v21);
                                            v23 = (float*)(16 * *(_DWORD*)v21 + *v20 + 4);
                                            *v23 = v22 * *(v18 - 1) + *v23;
                                            v24 = (float*)(16 * *(_DWORD*)v21 + *v20 + 8);
                                            *v24 = v22 * *v18 + *v24;
                                            v25 = (float*)(16 * *(_DWORD*)v21 + *v20 + 12);
                                            v19 = v36;
                                            v21 += 2;
                                            *v25 = v22 * v18[1] + *v25;
                                        } while (v21 < v36);
                                        v11 = v46;
                                    }
                                    v52 += 8;
                                } while (v52 < (unsigned int)v11);
                                v18 += 4;
                                v17 = v19;
                            } while ((unsigned int)v19 < v43);
                        }
                        v26 = v42;
                        do
                        {
                            v27 = (float*)v50[*(_DWORD*)v26];
                            v28 = v26[1] + v27[1];
                            v27[1] = v28;
                            if (v28 + 0.0000099999997 >= 1.0)
                            {
                                (*(void(__thiscall**)(_DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD*)this[1] + 8))(
                                    this[1],
                                    *(_DWORD*)v26,
                                    0,
                                    *(_DWORD*)v27);
                                v50[*(_DWORD*)v26] = 0;
                                --v49;
                                *((_DWORD*)v27 + 2) = v48;
                                v48 = (void**)v27;
                            }
                            v26 += 2;
                        } while (v26 < v46);
                        v11 = v46;
                        v6 = v35;
                    }
                    ++v44;
                    v10 = v11;
                } while ((unsigned int)v11 < v6);
                v29 = 0;
                if (v49)
                {
                    v30 = (_DWORD*)this[1];
                    if (v30[1045])
                    {
                        do
                        {
                            v31 = (_DWORD**)&v50[v29];
                            if (*v31)
                            {
                                (*(void(__thiscall**)(_DWORD*, unsigned int, _DWORD, _DWORD))(*v30 + 8))(v30, v29, 0, **v31);
                                v32 = *v31;
                                if (v32)
                                    sub_46DADF(v32, 1);
                                if (!--v49)
                                    break;
                            }
                            v30 = (_DWORD*)this[1];
                            ++v29;
                        } while (v29 < v30[1045]);
                    }
                }
            }
            v33 = 0;
        }
        else
        {
        LABEL_48:
            v33 = -2147024882;
        }
    }
    else
    {
        v33 = -2147467259;
    }
    sub_4885A6(v50);
    if (v48)
        sub_46DADF(v48, 1);
    sub_4885A6(v45);
    sub_4885A6(v41);
    sub_4885A6(v39);
    sub_4885A6(0);
    return v33;
}

//----- (0046E258) --------------------------------------------------------
int __thiscall sub_46E258(_DWORD* this)
{
    int v2; // edx
    int v3; // eax
    BOOL v4; // edi
    unsigned int* v5; // ebx
    unsigned int* v6; // ebx
    _DWORD* v7; // edi
    int v8; // edi
    char* v9; // eax
    void* v10; // eax
    unsigned int* v11; // eax
    unsigned int* v12; // edx
    unsigned int* v13; // eax
    int v14; // edi
    void* v15; // eax
    unsigned int v16; // eax
    char* v17; // edi
    unsigned int v18; // edx
    char* v19; // edi
    char v20; // cl
    _DWORD* v21; // eax
    unsigned int v22; // edi
    char* v23; // eax
    float* v24; // edx
    int v25; // eax
    char* j; // ecx
    double v27; // st7
    float* v28; // edi
    float* k; // edi
    double v30; // st7
    _DWORD* v31; // ecx
    _DWORD* v32; // ecx
    void** v33; // eax
    unsigned int v34; // edi
    void* v35; // eax
    int v36; // esi
    unsigned int* v38; // [esp+8h] [ebp-60h]
    void* v39; // [esp+Ch] [ebp-5Ch]
    char* v40; // [esp+Ch] [ebp-5Ch]
    unsigned int* v41; // [esp+10h] [ebp-58h]
    BOOL v42; // [esp+14h] [ebp-54h]
    float* v43; // [esp+14h] [ebp-54h]
    unsigned int v44; // [esp+18h] [ebp-50h]
    unsigned int v45; // [esp+1Ch] [ebp-4Ch]
    unsigned int v46; // [esp+20h] [ebp-48h]
    unsigned int v47; // [esp+20h] [ebp-48h]
    int v48; // [esp+24h] [ebp-44h]
    unsigned int* v49; // [esp+28h] [ebp-40h]
    int v50; // [esp+2Ch] [ebp-3Ch]
    char* v51; // [esp+30h] [ebp-38h]
    unsigned int* v52; // [esp+34h] [ebp-34h]
    unsigned int* v53; // [esp+38h] [ebp-30h]
    char* v54; // [esp+3Ch] [ebp-2Ch]
    char* v55; // [esp+40h] [ebp-28h]
    unsigned int* v56; // [esp+44h] [ebp-24h]
    unsigned int* v57; // [esp+48h] [ebp-20h]
    unsigned int m; // [esp+48h] [ebp-20h]
    unsigned int* v59; // [esp+4Ch] [ebp-1Ch]
    unsigned int v60; // [esp+4Ch] [ebp-1Ch]
    int v61; // [esp+50h] [ebp-18h]
    _DWORD* v62; // [esp+54h] [ebp-14h]
    unsigned int* v63; // [esp+58h] [ebp-10h]
    float* i; // [esp+58h] [ebp-10h]

    v2 = this[1];
    v52 = 0;
    v53 = 0;
    v62 = 0;
    v56 = 0;
    v39 = 0;
    if (*(_DWORD*)(v2 + 8) != 1 || *(_DWORD*)(*this + 8) != 1)
        return -2147467259;
    v3 = this[2];
    v4 = (v3 & 0x20000) == 0;
    v42 = (v3 & 0x40000) == 0;
    v5 = sub_46DAFE(*(_DWORD*)(*this + 4176), *(_DWORD*)(v2 + 4176), (v3 & 0x10000) == 0);
    v41 = v5;
    if (v5
        && (v52 = sub_46DAFE(*(_DWORD*)(*this + 4180), *(_DWORD*)(this[1] + 4180), v4)) != 0
        && (v53 = sub_46DAFE(*(_DWORD*)(*this + 4184), *(_DWORD*)(this[1] + 4184), v42)) != 0)
    {
        v45 = (unsigned int)v5 + *v5;
        v44 = (unsigned int)v52 + *v52;
        v6 = (unsigned int*)((char*)v53 + *v53);
        v38 = v6;
        v7 = operator new(4 * *(_DWORD*)(this[1] + 4184));
        v62 = v7;
        if (!v7)
            goto LABEL_61;
        v61 = 0;
        memset(v7, 0, 4 * *(_DWORD*)(this[1] + 4184));
        v8 = *(_DWORD*)(*this + 4176);
        v9 = (char*)operator new(16 * v8);
        v40 = v9;
        if (v9)
        {
            sub_46C866((int)v9, 16, v8, (int(__thiscall*)(int))sub_46C80E);
            v10 = v40;
            v55 = v40;
        }
        else
        {
            v55 = 0;
            v10 = 0;
        }
        v39 = v10;
        if (v10)
        {
            v48 = 0;
            v11 = v53 + 1;
            if (v53 + 1 < v6)
            {
                do
                {
                    v12 = (unsigned int*)((char*)v11 + *v11);
                    v13 = v11 + 1;
                    v57 = v12;
                    v43 = (float*)v13;
                    while (1)
                    {
                        v63 = v13;
                        if (v13 >= v12)
                            break;
                        v6 = (unsigned int*)v62[*v13];
                        if (!v6)
                        {
                            v6 = v56;
                            if (v56)
                            {
                                v56 = (unsigned int*)v56[2];
                            }
                            else
                            {
                                v6 = (unsigned int*)operator new(0xCu);
                                if (!v6)
                                    goto LABEL_61;
                                v14 = *(_DWORD*)(this[1] + 4176) * *(_DWORD*)(this[1] + 4180);
                                v15 = operator new(16 * v14);
                                v46 = (unsigned int)v15;
                                if (v15)
                                {
                                    sub_46C866((int)v15, 16, v14, (int(__thiscall*)(int))sub_46C80E);
                                    v16 = v46;
                                }
                                else
                                {
                                    v16 = 0;
                                }
                                *v6 = v16;
                                if (!v16)
                                {
                                    sub_46DADF(v6, 1);
                                    goto LABEL_61;
                                }
                            }
                            v17 = (char*)*v6;
                            v18 = 16 * *(_DWORD*)(this[1] + 4176) * *(_DWORD*)(this[1] + 4180);
                            memset((void*)*v6, 0, 4 * (v18 >> 2));
                            v19 = &v17[4 * (v18 >> 2)];
                            v20 = v18;
                            v12 = v57;
                            memset(v19, 0, v20 & 3);
                            *((float*)v6 + 1) = 0.0;
                            v6[2] = 0;
                            ++v61;
                            v62[*v63] = v6;
                        }
                        v13 = v63 + 2;
                    }
                    v50 = 0;
                    v21 = v52 + 1;
                    v49 = v52 + 1;
                    if ((unsigned int)(v52 + 1) < v44)
                    {
                        while (1)
                        {
                            v22 = (unsigned int)v21 + *v21;
                            v47 = v22;
                            (*(void(__thiscall**)(_DWORD, int, int, char*))(*(_DWORD*)*this + 4))(*this, v50, v48, v55);
                            v23 = (char*)(v41 + 1);
                            v54 = (char*)(v41 + 1);
                            if ((unsigned int)(v41 + 1) < v45)
                            {
                                v24 = (float*)(v55 + 8);
                                do
                                {
                                    v23 = &v54[*(_DWORD*)v23];
                                    v51 = v23;
                                    for (i = v43; i < (float*)v57; i += 2)
                                    {
                                        v59 = v49 + 1;
                                        if ((unsigned int)(v49 + 1) < v22)
                                        {
                                            do
                                            {
                                                v25 = *(_DWORD*)v62[*(_DWORD*)i] + 16 * *v59 * *(_DWORD*)(this[1] + 4176);
                                                for (j = v54 + 4; j < v51; j += 8)
                                                {
                                                    v27 = *((float*)j + 1) * i[1] * *((float*)v59 + 1);
                                                    *(float*)(v25 + 16 * *(_DWORD*)j) = v27 * *(v24 - 2) + *(float*)(v25 + 16 * *(_DWORD*)j);
                                                    *(float*)(16 * *(_DWORD*)j + v25 + 4) = v27 * *(v24 - 1)
                                                        + *(float*)(16 * *(_DWORD*)j + v25 + 4);
                                                    *(float*)(16 * *(_DWORD*)j + v25 + 8) = v27 * *v24 + *(float*)(16 * *(_DWORD*)j + v25 + 8);
                                                    v28 = (float*)(16 * *(_DWORD*)j + v25 + 12);
                                                    *v28 = v27 * v24[1] + *v28;
                                                }
                                                v59 += 2;
                                            } while ((unsigned int)v59 < v47);
                                            v22 = v47;
                                            v23 = v51;
                                        }
                                    }
                                    v24 += 4;
                                    v54 = v23;
                                } while ((unsigned int)v23 < v45);
                            }
                            ++v50;
                            v49 = (unsigned int*)v22;
                            if (v22 >= v44)
                                break;
                            v21 = (_DWORD*)v22;
                        }
                        v12 = v57;
                    }
                    for (k = v43; k < (float*)v12; k += 2)
                    {
                        v6 = (unsigned int*)v62[*(_DWORD*)k];
                        v30 = k[1] + *((float*)v6 + 1);
                        *((float*)v6 + 1) = v30;
                        if (v30 + 0.0000099999997 >= 1.0)
                        {
                            v31 = (_DWORD*)this[1];
                            v60 = 0;
                            if (v31[1045])
                            {
                                do
                                {
                                    (*(void(__stdcall**)(unsigned int, _DWORD, unsigned int))(*v31 + 8))(
                                        v60,
                                        *(_DWORD*)k,
                                        *v6 + 16 * v60 * v31[1044]);
                                    ++v60;
                                    v31 = (_DWORD*)this[1];
                                } while (v60 < v31[1045]);
                                v12 = v57;
                            }
                            v62[*(_DWORD*)k] = 0;
                            --v61;
                            v6[2] = (unsigned int)v56;
                            v56 = v6;
                        }
                    }
                    ++v48;
                    v11 = v12;
                } while (v12 < v38);
                if (v61)
                {
                    v32 = (_DWORD*)this[1];
                    for (m = 0; m < v32[1046]; v32 = (_DWORD*)this[1])
                    {
                        v33 = (void**)&v62[m];
                        v34 = 0;
                        if (*v33)
                        {
                            if (v32[1045])
                            {
                                do
                                {
                                    (*(void(__stdcall**)(unsigned int, unsigned int, unsigned int))(*v32 + 8))(
                                        v34,
                                        m,
                                        *v6 + 16 * v34 * v32[1044]);
                                    v32 = (_DWORD*)this[1];
                                    ++v34;
                                } while (v34 < v32[1045]);
                                v33 = (void**)&v62[m];
                            }
                            v35 = *v33;
                            if (v35)
                                sub_46DADF(v35, 1);
                            if (!--v61)
                                break;
                        }
                        ++m;
                    }
                }
            }
            v36 = 0;
        }
        else
        {
        LABEL_61:
            v36 = -2147024882;
        }
    }
    else
    {
        v36 = -2147467259;
    }
    sub_4885A6(v62);
    if (v56)
        sub_46DADF(v56, 1);
    sub_4885A6(v53);
    sub_4885A6(v52);
    sub_4885A6(v41);
    sub_4885A6(v39);
    sub_4885A6(0);
    return v36;
}

//----- (0046E785) --------------------------------------------------------
float* __thiscall sub_46E785(float* this, float* a2, float* a3)
{
    double v3; // st7
    double v4; // st6
    double v5; // st5
    float* result; // eax

    v3 = a3[3] + this[3];
    v4 = a3[2] + this[2];
    v5 = a3[1] + this[1];
    result = a2;
    *a2 = *a3 + *this;
    a2[1] = v5;
    a2[2] = v4;
    a2[3] = v3;
    return result;
}

//----- (0046E7B3) --------------------------------------------------------
float* __thiscall sub_46E7B3(float* this, float* a2, float a3)
{
    float* result; // eax
    double v4; // st7
    double v5; // st6
    double v6; // st5

    result = a2;
    v4 = a3 * this[3];
    v5 = a3 * this[2];
    v6 = a3 * this[1];
    *a2 = a3 * *this;
    a2[1] = v6;
    a2[2] = v5;
    a2[3] = v4;
    return result;
}

//----- (0046E7DF) --------------------------------------------------------
int __thiscall sub_46E7DF(_DWORD* this)
{
    _DWORD* v1; // edi
    unsigned int v2; // esi
    int v4; // eax
    unsigned int v5; // ecx
    int v6; // edx
    unsigned int v7; // eax
    _DWORD* v8; // edx
    char* v9; // ebx
    int v10; // eax
    int v11; // ecx
    int v12; // [esp-8h] [ebp-28h]
    unsigned int v13; // [esp+8h] [ebp-18h]
    int v14; // [esp+Ch] [ebp-14h]
    unsigned int v15; // [esp+10h] [ebp-10h]
    unsigned int v16; // [esp+10h] [ebp-10h]
    int v17; // [esp+14h] [ebp-Ch]
    unsigned int v18; // [esp+18h] [ebp-8h]
    unsigned int v19; // [esp+18h] [ebp-8h]
    char* i; // [esp+1Ch] [ebp-4h]

    v1 = (_DWORD*)*this;
    v2 = *(_DWORD*)(*this + 4148);
    v18 = *(_DWORD*)(*this + 4144);
    if ((((unsigned __int8)v2
        | (unsigned __int8)(*(_BYTE*)(*this + 4144) | *(_BYTE*)(*this + 4152) | *(_BYTE*)(*this + 4156)))
        & 3) != 0)
        return -2147467259;
    v4 = this[1];
    v5 = *(_DWORD*)(v4 + 4148);
    v15 = *(_DWORD*)(v4 + 4144);
    if ((((unsigned __int8)v5 | (unsigned __int8)(v15 | *(_BYTE*)(v4 + 4152) | *(_BYTE*)(v4 + 4156))) & 3) != 0)
        return -2147467259;
    v6 = *(_DWORD*)(v4 + 4);
    if (v6 == 827611204)
    {
        v12 = 8;
    }
    else
    {
        if (v6 != 844388420 && v6 != 861165636 && v6 != 877942852 && v6 != 894720068)
            return -2147467259;
        v12 = 16;
    }
    v13 = v12 * (*(_DWORD*)(v4 + 4176) >> 2);
    v17 = *(_DWORD*)(v4 + 24)
        + v12 * (v15 >> 2)
        + *(_DWORD*)(v4 + 4160) * *(_DWORD*)(v4 + 4172)
        + *(_DWORD*)(v4 + 4168) * (v5 >> 2);
    v16 = 0;
    v14 = v1[6] + v12 * (v18 >> 2) + v1[1040] * v1[1043] + v1[1042] * (v2 >> 2);
    if (*(_DWORD*)(v4 + 4184))
    {
        v7 = *(_DWORD*)(v4 + 4180);
        v8 = this;
        do
        {
            v19 = 0;
            v9 = (char*)v17;
            for (i = (char*)v14; v19 < v7; i += *(_DWORD*)(*v8 + 4168))
            {
                v19 += 4;
                qmemcpy(v9, i, v13);
                v10 = v8[1];
                v9 += *(_DWORD*)(v10 + 4168);
                v7 = *(_DWORD*)(v10 + 4180);
            }
            v11 = v8[1];
            v17 += *(_DWORD*)(*v8 + 4172) + *(_DWORD*)(v11 + 4172);
            ++v16;
        } while (v16 < *(_DWORD*)(v11 + 4184));
    }
    return 0;
}

//----- (0046E96A) --------------------------------------------------------
int __thiscall sub_46E96A(_DWORD* this)
{
    unsigned int* v1; // ebx
    int v2; // esi
    int v3; // eax
    char* v4; // edx
    int v5; // ecx
    char* v6; // ecx
    unsigned int v7; // esi
    unsigned int v8; // ebx
    unsigned int v9; // ebx
    unsigned int* v10; // ecx
    char* i; // [esp+8h] [ebp-28h]
    char* v14; // [esp+10h] [ebp-20h]
    char* v15; // [esp+14h] [ebp-1Ch]
    unsigned int* v16; // [esp+18h] [ebp-18h]
    char* v17; // [esp+1Ch] [ebp-14h]
    char* v18; // [esp+20h] [ebp-10h]
    unsigned int* v19; // [esp+28h] [ebp-8h]

    v1 = *(unsigned int**)(this[1] + 24);
    v2 = *this;
    v3 = *(_DWORD*)(*this + 4180);
    v4 = *(char**)(*this + 24);
    v5 = *(_DWORD*)(*this + 4168);
    v16 = v1;
    v15 = v4;
    for (i = &v4[v5 * v3]; v4 < i; v15 = v4)
    {
        v6 = &v4[v5];
        v19 = v1;
        v18 = v4;
        v17 = v6;
        v14 = &v4[4 * *(_DWORD*)(v2 + 4176)];
        if (v4 < v14)
        {
            do
            {
                v7 = *((_DWORD*)v6 + 1);
                v8 = *((_DWORD*)v4 + 1);
                v9 = (((v8 >> 2) & 0x3FC03FC0)
                    + ((*(_DWORD*)v6 >> 2) & 0x3FC03FC0)
                    + ((*(_DWORD*)v4 >> 2) & 0x3FC03FC0)
                    + ((v7 >> 2) & 0x3FC03FC0)
                    + 8388736)
                    ^ ((((v8 & 0xFF00FF) + (*(_DWORD*)v6 & 0xFF00FF) + (*(_DWORD*)v4 & 0xFF00FF) + (v7 & 0xFF00FF) + 131074) >> 2)
                        ^ (((v8 >> 2) & 0xFFC03FC0)
                            + ((*(_DWORD*)v6 >> 2) & 0xFFC03FC0)
                            + ((*(_DWORD*)v4 >> 2) & 0xFFC03FC0)
                            + ((v7 >> 2) & 0xFFC03FC0)
                            - 8388480))
                    & 0xFF00FF;
                v10 = v19++;
                *v10 = v9;
                v4 = v18 + 8;
                v6 = v17 + 8;
                v18 = v4;
                v17 += 8;
            } while (v4 < v14);
            v4 = v15;
        }
        v1 = (unsigned int*)((char*)v16 + *(_DWORD*)(this[1] + 4168));
        v2 = *this;
        v5 = *(_DWORD*)(*this + 4168);
        v4 += 2 * v5;
        v16 = v1;
    }
    return 0;
}

//----- (0046EAAE) --------------------------------------------------------
int __thiscall sub_46EAAE(_DWORD* this)
{
    unsigned int* v1; // ebx
    int v2; // eax
    int v3; // edx
    int v4; // ecx
    char* v5; // edi
    char* v6; // ecx
    char* v7; // ebx
    unsigned int* v8; // eax
    bool v9; // cf
    char* i; // [esp+8h] [ebp-28h]
    unsigned int v13; // [esp+10h] [ebp-20h]
    char* v14; // [esp+18h] [ebp-18h]
    unsigned int* v15; // [esp+1Ch] [ebp-14h]
    char* v16; // [esp+20h] [ebp-10h]
    char* v17; // [esp+24h] [ebp-Ch]
    unsigned int* v18; // [esp+2Ch] [ebp-4h]

    v1 = *(unsigned int**)(this[1] + 24);
    v2 = *this;
    v3 = *(_DWORD*)(*this + 4180);
    v4 = *(_DWORD*)(*this + 4168);
    v5 = *(char**)(v2 + 24);
    v15 = v1;
    v14 = v5;
    for (i = &v5[v4 * v3]; v5 < i; v14 = v5)
    {
        v18 = v1;
        v6 = &v5[v4];
        v7 = v5;
        v17 = v5;
        v16 = v6;
        v13 = (unsigned int)&v5[4 * *(_DWORD*)(v2 + 4176)];
        if ((unsigned int)v5 < v13)
        {
            do
            {
                v8 = v18++;
                *v8 = (((*((_DWORD*)v7 + 1) & 0xFF00)
                    + (*(_DWORD*)v6 & 0xFF00)
                    + (*(_DWORD*)v7 & 0xFF00)
                    + (*((_DWORD*)v6 + 1) & 0xFF00)
                    + 512)
                    & 0x3FC00
                    | ((*((_DWORD*)v7 + 1) & 0xFF00FF)
                        + (*(_DWORD*)v6 & 0xFF00FF)
                        + (*(_DWORD*)v7 & 0xFF00FF)
                        + (*((_DWORD*)v6 + 1) & 0xFF00FF)
                        + 131074)
                    & 0x3FC03FCu) >> 2;
                v7 = v17 + 8;
                v6 = v16 + 8;
                v9 = (unsigned int)(v17 + 8) < v13;
                v17 += 8;
                v16 += 8;
            } while (v9);
            v5 = v14;
        }
        v1 = (unsigned int*)((char*)v15 + *(_DWORD*)(this[1] + 4168));
        v2 = *this;
        v4 = *(_DWORD*)(*this + 4168);
        v5 += 2 * v4;
        v15 = v1;
    }
    return 0;
}

//----- (0046EBB4) --------------------------------------------------------
int __thiscall sub_46EBB4(_DWORD* this)
{
    _DWORD* v2; // edx
    _WORD* v3; // ecx
    int v4; // ebx
    unsigned __int16* v5; // edi
    unsigned __int16* v6; // esi
    unsigned __int16* v7; // ebx
    int v8; // edx
    int v9; // esi
    int v10; // ecx
    __int16 v11; // di
    int v12; // edx
    _WORD* v13; // ecx
    bool v14; // cf
    unsigned __int16* i; // [esp+10h] [ebp-24h]
    unsigned int v17; // [esp+14h] [ebp-20h]
    unsigned __int16* v18; // [esp+1Ch] [ebp-18h]
    _WORD* v19; // [esp+20h] [ebp-14h]
    unsigned __int16* v20; // [esp+24h] [ebp-10h]
    unsigned __int16* v21; // [esp+28h] [ebp-Ch]
    _WORD* v22; // [esp+2Ch] [ebp-8h]
    int v23; // [esp+30h] [ebp-4h]

    v2 = (_DWORD*)*this;
    v3 = *(_WORD**)(this[1] + 24);
    v4 = v2[1042];
    v5 = (unsigned __int16*)v2[6];
    v6 = (unsigned __int16*)((char*)v5 + v4 * v2[1045]);
    v19 = v3;
    v18 = v5;
    for (i = v6; v5 < v6; v18 = v5)
    {
        v7 = (unsigned __int16*)((char*)v5 + v4);
        v22 = v3;
        v21 = v5;
        v20 = v7;
        v17 = (unsigned int)&v5[v2[1044]];
        if ((unsigned int)v5 < v17)
        {
            do
            {
                v8 = v7[1];
                v9 = v5[1];
                v23 = *v7;
                v10 = *v5;
                v11 = (((v23 & 0xFFFF07E0) + (v10 & 0xFFFF07E0) + (v8 & 0xFFFF07E0) + (v9 & 0xFFFF07E0) + 64) >> 2)
                    ^ (((v23 & 0xFFFFF81F) + (v10 & 0xFFFFF81F) + (v8 & 0xFFFFF81F) + (v9 & 0xFFFFF81F) + 4098) >> 2);
                v12 = (v23 & 0xF81F) + (v10 & 0xF81F) + (v8 & 0xF81F);
                v13 = v22++;
                *v13 = ((v12 + (v9 & 0xF81Fu) + 4098) >> 2) ^ v11 & 0x7E0;
                v5 = v21 + 2;
                v7 = v20 + 2;
                v14 = (unsigned int)(v21 + 2) < v17;
                v21 += 2;
                v20 += 2;
            } while (v14);
            v3 = v19;
            v5 = v18;
            v6 = i;
        }
        v3 = (_WORD*)((char*)v3 + *(_DWORD*)(this[1] + 4168));
        v2 = (_DWORD*)*this;
        v4 = *(_DWORD*)(*this + 4168);
        v5 += v4;
        v19 = v3;
    }
    return 0;
}

//----- (0046ECF4) --------------------------------------------------------
int __thiscall sub_46ECF4(_DWORD* this)
{
    int v1; // edx
    _WORD* v2; // eax
    int v3; // esi
    int v4; // ecx
    char* v5; // edi
    char* v6; // esi
    unsigned __int16* v7; // ecx
    char* v8; // ebx
    int v9; // edx
    _WORD* v10; // ecx
    bool v11; // cf
    char* i; // [esp+Ch] [ebp-20h]
    unsigned int v15; // [esp+10h] [ebp-1Ch]
    unsigned __int16* v16; // [esp+18h] [ebp-14h]
    char* v17; // [esp+1Ch] [ebp-10h]
    int v18; // [esp+20h] [ebp-Ch]
    _WORD* v19; // [esp+24h] [ebp-8h]
    _WORD* v20; // [esp+28h] [ebp-4h]

    v1 = *this;
    v2 = *(_WORD**)(this[1] + 24);
    v3 = *(_DWORD*)(*this + 4180);
    v4 = *(_DWORD*)(*this + 4168);
    v5 = *(char**)(v1 + 24);
    v6 = &v5[v4 * v3];
    v19 = v2;
    for (i = v6; v5 < v6; v5 += 2 * v4)
    {
        v20 = v19;
        v7 = (unsigned __int16*)&v5[v4];
        v8 = v5;
        v17 = v5;
        v16 = v7;
        v15 = (unsigned int)&v5[2 * *(_DWORD*)(v1 + 4176)];
        if ((unsigned int)v5 < v15)
        {
            do
            {
                v9 = v7[1];
                v18 = *v7;
                v10 = v20++;
                *v10 = (((v18 & 0x7C1F) + (*(_WORD*)v8 & 0x7C1F) + (v9 & 0x7C1F) + (*((_WORD*)v8 + 1) & 0x7C1Fu) + 2050) >> 2)
                    & 0x7C1F
                    | (((v18 & 0xFFFF03E0) + (*(_WORD*)v8 & 0x3E0) + (v9 & 0xFFFF03E0) + (*((_WORD*)v8 + 1) & 0x3E0) + 64) >> 2)
                    & 0x3E0;
                v8 = v17 + 4;
                v7 = v16 + 2;
                v11 = (unsigned int)(v17 + 4) < v15;
                v17 += 4;
                v16 += 2;
            } while (v11);
            v6 = i;
        }
        v19 = (_WORD*)((char*)v19 + *(_DWORD*)(this[1] + 4168));
        v1 = *this;
        v4 = *(_DWORD*)(*this + 4168);
    }
    return 0;
}

//----- (0046EE09) --------------------------------------------------------
int __thiscall sub_46EE09(_DWORD* this)
{
    _WORD* v1; // ebx
    int v2; // esi
    int v3; // eax
    int v4; // ecx
    char* v5; // edi
    char* v6; // ecx
    __int16 v7; // si
    _WORD* v8; // ecx
    bool v9; // cf
    char* i; // [esp+Ch] [ebp-2Ch]
    unsigned int v13; // [esp+14h] [ebp-24h]
    char* v14; // [esp+1Ch] [ebp-1Ch]
    _WORD* v15; // [esp+20h] [ebp-18h]
    char* v16; // [esp+24h] [ebp-14h]
    char* v17; // [esp+28h] [ebp-10h]
    _WORD* v18; // [esp+2Ch] [ebp-Ch]
    __int16 v19; // [esp+30h] [ebp-8h]
    __int16 v20; // [esp+34h] [ebp-4h]

    v1 = *(_WORD**)(this[1] + 24);
    v2 = *this;
    v3 = *(_DWORD*)(*this + 4180);
    v4 = *(_DWORD*)(*this + 4168);
    v5 = *(char**)(v2 + 24);
    v15 = v1;
    v14 = v5;
    for (i = &v5[v4 * v3]; v5 < i; v14 = v5)
    {
        v6 = &v5[v4];
        v18 = v1;
        v17 = v5;
        v16 = v6;
        v13 = (unsigned int)&v5[2 * *(_DWORD*)(v2 + 4176)];
        if ((unsigned int)v5 < v13)
        {
            do
            {
                v7 = *((_WORD*)v6 + 1);
                v20 = *(_WORD*)v6;
                v19 = *((_WORD*)v5 + 1);
                v8 = v18++;
                *v8 = (((v20 & 0x83E0) + (*(_WORD*)v5 & 0x83E0) + (v7 & 0x83E0) + (v19 & 0x83E0u) + 65600) >> 2)
                    ^ ((((v20 & 0x7C1F) + (*(_WORD*)v5 & 0x7C1F) + (v7 & 0x7C1F) + (v19 & 0x7C1Fu) + 2050) >> 2)
                        ^ (((v20 & 0x83E0) + (*(_WORD*)v5 & 0x83E0) + (v7 & 0x83E0) + (v19 & 0x83E0u) + 65600) >> 2))
                    & 0x7C1F;
                v5 = v17 + 4;
                v6 = v16 + 4;
                v9 = (unsigned int)(v17 + 4) < v13;
                v17 += 4;
                v16 += 4;
            } while (v9);
            v5 = v14;
        }
        v1 = (_WORD*)((char*)v15 + *(_DWORD*)(this[1] + 4168));
        v2 = *this;
        v4 = *(_DWORD*)(*this + 4168);
        v5 += 2 * v4;
        v15 = v1;
    }
    return 0;
}

//----- (0046EF3E) --------------------------------------------------------
int __thiscall sub_46EF3E(_DWORD* this)
{
    _DWORD* v2; // edx
    _WORD* v3; // ecx
    int v4; // ebx
    unsigned __int16* v5; // edi
    unsigned __int16* v6; // esi
    unsigned __int16* v7; // ebx
    int v8; // edx
    int v9; // esi
    int v10; // ecx
    __int16 v11; // di
    int v12; // edx
    _WORD* v13; // ecx
    bool v14; // cf
    unsigned __int16* i; // [esp+10h] [ebp-24h]
    unsigned int v17; // [esp+14h] [ebp-20h]
    unsigned __int16* v18; // [esp+1Ch] [ebp-18h]
    _WORD* v19; // [esp+20h] [ebp-14h]
    unsigned __int16* v20; // [esp+24h] [ebp-10h]
    unsigned __int16* v21; // [esp+28h] [ebp-Ch]
    _WORD* v22; // [esp+2Ch] [ebp-8h]
    int v23; // [esp+30h] [ebp-4h]

    v2 = (_DWORD*)*this;
    v3 = *(_WORD**)(this[1] + 24);
    v4 = v2[1042];
    v5 = (unsigned __int16*)v2[6];
    v6 = (unsigned __int16*)((char*)v5 + v4 * v2[1045]);
    v19 = v3;
    v18 = v5;
    for (i = v6; v5 < v6; v18 = v5)
    {
        v7 = (unsigned __int16*)((char*)v5 + v4);
        v22 = v3;
        v21 = v5;
        v20 = v7;
        v17 = (unsigned int)&v5[v2[1044]];
        if ((unsigned int)v5 < v17)
        {
            do
            {
                v8 = v7[1];
                v9 = v5[1];
                v23 = *v7;
                v10 = *v5;
                v11 = (((v23 & 0xFFFF0F0F) + (v10 & 0xFFFF0F0F) + (v8 & 0xFFFF0F0F) + (v9 & 0xFFFF0F0F) + 514) >> 2)
                    ^ (((v23 & 0xFFFFF0F0) + (v10 & 0xFFFFF0F0) + (v8 & 0xFFFFF0F0) + (v9 & 0xFFFFF0F0) + 8224) >> 2);
                v12 = (v23 & 0xF0F0) + (v10 & 0xF0F0) + (v8 & 0xF0F0);
                v13 = v22++;
                *v13 = ((v12 + (v9 & 0xF0F0u) + 8224) >> 2) ^ v11 & 0xF0F;
                v5 = v21 + 2;
                v7 = v20 + 2;
                v14 = (unsigned int)(v21 + 2) < v17;
                v21 += 2;
                v20 += 2;
            } while (v14);
            v3 = v19;
            v5 = v18;
            v6 = i;
        }
        v3 = (_WORD*)((char*)v3 + *(_DWORD*)(this[1] + 4168));
        v2 = (_DWORD*)*this;
        v4 = *(_DWORD*)(*this + 4168);
        v5 += v4;
        v19 = v3;
    }
    return 0;
}

//----- (0046F081) --------------------------------------------------------
int __thiscall sub_46F081(_DWORD* this)
{
    _BYTE* v2; // ecx
    _DWORD* v3; // eax
    int v4; // ebx
    _BYTE* v5; // edx
    _BYTE* v6; // edi
    _BYTE* v7; // ebx
    char v8; // di
    _BYTE* v9; // eax
    bool v10; // cf
    _DWORD* v12; // [esp+8h] [ebp-28h]
    _BYTE* i; // [esp+Ch] [ebp-24h]
    unsigned int v14; // [esp+10h] [ebp-20h]
    _BYTE* v15; // [esp+18h] [ebp-18h]
    _BYTE* v16; // [esp+1Ch] [ebp-14h]
    _BYTE* v17; // [esp+20h] [ebp-10h]
    _BYTE* v18; // [esp+24h] [ebp-Ch]
    _BYTE* v19; // [esp+28h] [ebp-8h]

    v2 = *(_BYTE**)(this[1] + 24);
    v12 = this;
    v3 = (_DWORD*)*this;
    v4 = v3[1042];
    v5 = (_BYTE*)v3[6];
    v6 = &v5[v4 * v3[1045]];
    v16 = v2;
    v15 = v5;
    for (i = v6; v5 < v6; v15 = v5)
    {
        v7 = &v5[v4];
        v19 = v2;
        v18 = v5;
        v17 = v7;
        v14 = (unsigned int)&v5[v3[1044]];
        if ((unsigned int)v5 < v14)
        {
            do
            {
                v8 = v5[1];
                v9 = v19++;
                *v9 = (((*v7 & 0xE3) + (*v5 & 0xE3) + (v7[1] & 0xE3) + (v8 & 0xE3u) + 66) >> 2)
                    ^ ((((*v7 & 0xE3) + (*v5 & 0xE3) + (v7[1] & 0xE3) + (v8 & 0xE3u) + 66) >> 2)
                        ^ (((*v7 & 0x1C) + (*v5 & 0x1C) + (v7[1] & 0x1C) + (v8 & 0x1Cu) + 8) >> 2))
                    & 0x1C;
                v5 = v18 + 2;
                v7 = v17 + 2;
                v10 = (unsigned int)(v18 + 2) < v14;
                v18 += 2;
                v17 += 2;
            } while (v10);
            v2 = v16;
            v5 = v15;
            v6 = i;
        }
        v2 += *(_DWORD*)(v12[1] + 4168);
        v3 = (_DWORD*)*v12;
        v4 = *(_DWORD*)(*v12 + 4168);
        v5 += 2 * v4;
        v16 = v2;
    }
    return 0;
}

//----- (0046F1AB) --------------------------------------------------------
int __thiscall sub_46F1AB(_DWORD* this)
{
    _BYTE* v1; // ebx
    int v2; // eax
    unsigned __int8* v3; // edx
    int v4; // edi
    unsigned __int8* v5; // esi
    unsigned int v6; // eax
    unsigned __int8* v7; // edi
    bool i; // cf
    int v9; // edi
    int v10; // ebx
    unsigned int v11; // ebx
    _BYTE* v12; // edi
    _BYTE* v14; // [esp+Ch] [ebp-10h]
    unsigned __int8* v15; // [esp+10h] [ebp-Ch]
    _BYTE* v16; // [esp+14h] [ebp-8h]
    unsigned __int8* v17; // [esp+18h] [ebp-4h]

    v1 = *(_BYTE**)(this[1] + 24);
    v2 = *this;
    v3 = *(unsigned __int8**)(*this + 24);
    v4 = *(_DWORD*)(*this + 4168);
    v5 = &v3[v4 * *(_DWORD*)(*this + 4180)];
    while (1)
    {
        v14 = v1;
        if (v3 >= v5)
            break;
        v6 = (unsigned int)&v3[*(_DWORD*)(v2 + 4176)];
        v7 = &v3[v4];
        v16 = v1;
        v17 = v3;
        for (i = (unsigned int)v3 < v6; ; i = (unsigned int)v17 < v6)
        {
            v15 = v7;
            if (!i)
                break;
            v9 = *v7 + v17[1] + v7[1];
            v10 = *v17;
            v17 += 2;
            v11 = v9 + v10 + 2;
            v12 = v16++;
            *v12 = v11 >> 2;
            v7 = v15 + 2;
        }
        v1 = &v14[*(_DWORD*)(this[1] + 4168)];
        v2 = *this;
        v4 = *(_DWORD*)(*this + 4168);
        v3 += 2 * v4;
    }
    return 0;
}

//----- (0046F246) --------------------------------------------------------
int __thiscall sub_46F246(_DWORD* this)
{
    int v1; // edx
    int v2; // eax
    unsigned __int16* v3; // ebx
    int v4; // esi
    int v5; // ecx
    unsigned __int16* v6; // esi
    _WORD* v7; // edi
    unsigned __int16* v8; // ecx
    unsigned __int16 v9; // si
    int v10; // edx
    int v11; // edi
    unsigned int v12; // edx
    int v13; // ebx
    int v14; // edi
    _WORD* v15; // ecx
    unsigned __int16* i; // [esp+10h] [ebp-24h]
    unsigned __int16* v19; // [esp+14h] [ebp-20h]
    unsigned __int16* v20; // [esp+18h] [ebp-1Ch]
    _WORD* v21; // [esp+1Ch] [ebp-18h]
    unsigned __int16* v22; // [esp+20h] [ebp-14h]
    unsigned __int16* v23; // [esp+24h] [ebp-10h]
    int v24; // [esp+28h] [ebp-Ch]
    _WORD* v25; // [esp+2Ch] [ebp-8h]
    int v26; // [esp+30h] [ebp-4h]

    v1 = *this;
    v2 = this[1];
    v3 = *(unsigned __int16**)(*this + 24);
    v4 = *(_DWORD*)(*this + 4180);
    v5 = *(_DWORD*)(*this + 4168);
    v6 = (unsigned __int16*)((char*)v3 + v5 * v4);
    v7 = *(_WORD**)(v2 + 24);
    v21 = v7;
    v20 = v3;
    for (i = v6; v3 < v6; v20 = v3)
    {
        v8 = (unsigned __int16*)((char*)v3 + v5);
        v25 = v7;
        v23 = v3;
        v22 = v8;
        v19 = &v3[*(_DWORD*)(v1 + 4176)];
        if (v3 < v19)
        {
            do
            {
                v9 = v8[1];
                v10 = *v3;
                v11 = v3[1];
                v26 = *v8;
                v24 = v10;
                LOWORD(v10) = *v3 & 0xE3;
                v12 = (v26 & 0xE3) + v10 + (v9 & 0xE3) + (v11 & 0xFFFF00E3) + 66;
                HIWORD(v13) = 0;
                v14 = v11 & 0xFF1C;
                LOWORD(v13) = v14;
                v15 = v25++;
                *v15 = (((v26 & 0xFF1C) + (v24 & 0xFF1C) + (v9 & 0xFF1Cu) + v14 + 520) >> 2)
                    ^ ((unsigned __int8)(((v26 & 0xFFFFFF1C) + (v24 & 0xFFFFFF1C) + (v9 & 0xFF1C) + v13 + 520) >> 2)
                        ^ (unsigned __int8)(v12 >> 2))
                    & 0xE3;
                v3 = v23 + 2;
                v8 = v22 + 2;
                v23 = v3;
                v22 += 2;
            } while (v3 < v19);
            v7 = v21;
            v3 = v20;
            v6 = i;
        }
        v7 = (_WORD*)((char*)v7 + *(_DWORD*)(this[1] + 4168));
        v1 = *this;
        v5 = *(_DWORD*)(*this + 4168);
        v3 += v5;
        v21 = v7;
    }
    return 0;
}

//----- (0046F37E) --------------------------------------------------------
int __thiscall sub_46F37E(_DWORD* this)
{
    _WORD* v2; // ecx
    _DWORD* v3; // eax
    unsigned __int16* v4; // esi
    int v5; // edi
    unsigned __int16* v6; // edx
    unsigned __int16* v7; // edi
    unsigned __int16* v8; // ebx
    int v9; // edx
    int v10; // eax
    int v11; // edi
    unsigned int v12; // ebx
    int v13; // eax
    _WORD* v14; // eax
    _DWORD* v16; // [esp+8h] [ebp-20h]
    unsigned __int16* i; // [esp+Ch] [ebp-1Ch]
    unsigned __int16* v18; // [esp+10h] [ebp-18h]
    int v19; // [esp+14h] [ebp-14h]
    _WORD* v20; // [esp+18h] [ebp-10h]
    unsigned __int16* v21; // [esp+1Ch] [ebp-Ch]
    unsigned __int16* v22; // [esp+20h] [ebp-8h]
    _WORD* v23; // [esp+24h] [ebp-4h]

    v2 = *(_WORD**)(this[1] + 24);
    v16 = this;
    v3 = (_DWORD*)*this;
    v4 = (unsigned __int16*)v3[6];
    v5 = v3[1042];
    v6 = (unsigned __int16*)((char*)v4 + v5 * v3[1045]);
    v20 = v2;
    for (i = v6; v4 < v6; v20 = v2)
    {
        v7 = (unsigned __int16*)((char*)v4 + v5);
        v8 = v4;
        v23 = v2;
        v22 = v4;
        v21 = v7;
        v18 = &v4[v3[1044]];
        if (v4 < v18)
        {
            do
            {
                v9 = v8[1];
                v10 = v7[1];
                v11 = *v7;
                v19 = *v8;
                v12 = (v11 & 0xFFFF00F0) + (v19 & 0xFFFF00F0) + (v10 & 0xFFFF00F0) + (v9 & 0xFFFF00F0) + 32;
                LOWORD(v11) = v11 & 0xF0F;
                LOWORD(v9) = v9 & 0xF0F;
                v13 = v11 + (v19 & 0xFFFF0F0F) + (v10 & 0xFFFF0F0F);
                v7 = v21 + 2;
                v21 += 2;
                LOWORD(v12) = ((unsigned int)(v13 + v9 + 514) >> 2) & 0xF0F | (v12 >> 2) & 0xF0;
                v14 = v23++;
                *v14 = v12;
                v8 = v22 + 2;
                v22 += 2;
            } while (v22 < v18);
            v2 = v20;
            v6 = i;
        }
        v2 = (_WORD*)((char*)v2 + *(_DWORD*)(v16[1] + 4168));
        v3 = (_DWORD*)*v16;
        v5 = *(_DWORD*)(*v16 + 4168);
        v4 += v5;
    }
    return 0;
}

//----- (0046F497) --------------------------------------------------------
int __thiscall sub_46F497(_DWORD* this)
{
    int v1; // edx
    int v2; // eax
    unsigned __int16* v3; // ebx
    int v4; // esi
    int v5; // ecx
    unsigned __int16* v6; // esi
    _WORD* v7; // edi
    unsigned __int16* v8; // ecx
    int v9; // edx
    int v10; // edi
    int v11; // esi
    unsigned int v12; // edx
    int v13; // ebx
    int v14; // edi
    _WORD* v15; // ecx
    unsigned __int16* i; // [esp+10h] [ebp-24h]
    unsigned __int16* v19; // [esp+14h] [ebp-20h]
    unsigned __int16* v20; // [esp+18h] [ebp-1Ch]
    _WORD* v21; // [esp+1Ch] [ebp-18h]
    unsigned __int16* v22; // [esp+20h] [ebp-14h]
    unsigned __int16* v23; // [esp+24h] [ebp-10h]
    int v24; // [esp+28h] [ebp-Ch]
    _WORD* v25; // [esp+2Ch] [ebp-8h]
    int v26; // [esp+30h] [ebp-4h]

    v1 = *this;
    v2 = this[1];
    v3 = *(unsigned __int16**)(*this + 24);
    v4 = *(_DWORD*)(*this + 4180);
    v5 = *(_DWORD*)(*this + 4168);
    v6 = (unsigned __int16*)((char*)v3 + v5 * v4);
    v7 = *(_WORD**)(v2 + 24);
    v21 = v7;
    v20 = v3;
    for (i = v6; v3 < v6; v20 = v3)
    {
        v8 = (unsigned __int16*)((char*)v3 + v5);
        v25 = v7;
        v23 = v3;
        v22 = v8;
        v19 = &v3[*(_DWORD*)(v1 + 4176)];
        if (v3 < v19)
        {
            do
            {
                v9 = *v3;
                v10 = v3[1];
                v26 = *v8;
                v24 = v9;
                LOWORD(v9) = (unsigned __int8)*v3;
                v11 = v8[1] & 0xFF00;
                v12 = (unsigned __int8)*v8 + v9 + (unsigned __int8)v8[1] + (v10 & 0xFFFF00FF) + 2;
                HIWORD(v13) = 0;
                v14 = v10 & 0xFF00;
                LOWORD(v13) = v14;
                v15 = v25++;
                *v15 = (((v26 & 0xFF00) + (v24 & 0xFF00u) + v11 + v14 + 512) >> 2)
                    ^ (unsigned __int8)((((v26 & 0xFFFFFF00) + (v24 & 0xFFFFFF00) + v11 + v13 + 512) >> 2) ^ (v12 >> 2));
                v3 = v23 + 2;
                v8 = v22 + 2;
                v23 = v3;
                v22 += 2;
            } while (v3 < v19);
            v7 = v21;
            v3 = v20;
            v6 = i;
        }
        v7 = (_WORD*)((char*)v7 + *(_DWORD*)(this[1] + 4168));
        v1 = *this;
        v5 = *(_DWORD*)(*this + 4168);
        v3 += v5;
        v21 = v7;
    }
    return 0;
}

//----- (0046F5CF) --------------------------------------------------------
int __thiscall sub_46F5CF(_DWORD* this)
{
    _BYTE* v2; // ecx
    _DWORD* v3; // eax
    int v4; // ebx
    _BYTE* v5; // edx
    _BYTE* v6; // edi
    _BYTE* v7; // ebx
    char v8; // di
    _BYTE* v9; // eax
    bool v10; // cf
    _DWORD* v12; // [esp+8h] [ebp-28h]
    _BYTE* i; // [esp+Ch] [ebp-24h]
    unsigned int v14; // [esp+10h] [ebp-20h]
    _BYTE* v15; // [esp+18h] [ebp-18h]
    _BYTE* v16; // [esp+1Ch] [ebp-14h]
    _BYTE* v17; // [esp+20h] [ebp-10h]
    _BYTE* v18; // [esp+24h] [ebp-Ch]
    _BYTE* v19; // [esp+28h] [ebp-8h]

    v2 = *(_BYTE**)(this[1] + 24);
    v12 = this;
    v3 = (_DWORD*)*this;
    v4 = v3[1042];
    v5 = (_BYTE*)v3[6];
    v6 = &v5[v4 * v3[1045]];
    v16 = v2;
    v15 = v5;
    for (i = v6; v5 < v6; v15 = v5)
    {
        v7 = &v5[v4];
        v19 = v2;
        v18 = v5;
        v17 = v7;
        v14 = (unsigned int)&v5[v3[1044]];
        if ((unsigned int)v5 < v14)
        {
            do
            {
                v8 = v5[1];
                v9 = v19++;
                *v9 = (((*v7 & 0xF0) + (*v5 & 0xF0) + (v7[1] & 0xF0) + (v8 & 0xF0u) + 32) >> 2)
                    ^ ((((*v7 & 0xF0) + (*v5 & 0xF0) + (v7[1] & 0xF0) + (v8 & 0xF0u) + 32) >> 2)
                        ^ (((*v7 & 0xF) + (*v5 & 0xF) + (v7[1] & 0xF) + (v8 & 0xFu) + 2) >> 2))
                    & 0xF;
                v5 = v18 + 2;
                v7 = v17 + 2;
                v10 = (unsigned int)(v18 + 2) < v14;
                v18 += 2;
                v17 += 2;
            } while (v10);
            v2 = v16;
            v5 = v15;
            v6 = i;
        }
        v2 += *(_DWORD*)(v12[1] + 4168);
        v3 = (_DWORD*)*v12;
        v4 = *(_DWORD*)(*v12 + 4168);
        v5 += 2 * v4;
        v16 = v2;
    }
    return 0;
}

//----- (0046F6F9) --------------------------------------------------------
int __thiscall sub_46F6F9(_DWORD* this)
{
    _DWORD* v1; // ebx
    _DWORD* v2; // eax
    _DWORD* v3; // ecx
    char* v5; // edx
    char* v6; // ebx
    unsigned int v7; // [esp+Ch] [ebp-10h]
    unsigned int i; // [esp+10h] [ebp-Ch]
    _DWORD* v9; // [esp+14h] [ebp-8h]
    unsigned int v10; // [esp+18h] [ebp-4h]

    v1 = this;
    v2 = (_DWORD*)this[1];
    v3 = (_DWORD*)*this;
    v9 = v1;
    if (v2[1] != v3[1])
        return -2147467259;
    if (v3[4])
        return -2147467259;
    if (v2[1044] != v3[1044])
        return -2147467259;
    v7 = v2[1045];
    if (v7 != v3[1045] || v2[1046] != v3[1046])
        return -2147467259;
    if (!v2[3])
        return sub_46E7DF(v1);
    if (v2[5] && v2 + 12 != v3 + 12 && memcmp(v2 + 12, v3 + 12, 0x400u))
        return -2147467259;
    v10 = 0;
    if (v2[1046])
    {
        while (1)
        {
            v5 = (char*)(v2[6] + v10 * v2[1043]);
            v6 = (char*)(*(_DWORD*)(*v9 + 24) + v10 * *(_DWORD*)(*v1 + 4172));
            for (i = 0; i < v7; v7 = v2[1045])
            {
                qmemcpy(v5, v6, v2[1047]);
                v2 = (_DWORD*)v9[1];
                v6 += *(_DWORD*)(*v9 + 4168);
                v5 += v2[1042];
                ++i;
            }
            ++v10;
            v2 = (_DWORD*)v9[1];
            if (v10 >= v2[1046])
                break;
            v1 = v9;
        }
    }
    return 0;
}

//----- (0046F82B) --------------------------------------------------------
int __thiscall sub_46F82B(_DWORD* this)
{
    _DWORD* v2; // eax
    _DWORD* v3; // ecx
    int v4; // edi
    void* v5; // eax
    void* v6; // ebx
    unsigned int v7; // ebx
    int v8; // eax
    unsigned int v9; // eax
    unsigned int i; // edi
    void* v12; // [esp+Ch] [ebp-10h]

    v2 = (_DWORD*)this[1];
    v3 = (_DWORD*)*this;
    v4 = v2[1044];
    if (v4 != v3[1044] || v2[1045] != v3[1045] || v2[1046] != v3[1046])
        return -2147467259;
    v5 = operator new(16 * v4);
    v6 = v5;
    if (v5)
    {
        sub_46C866((int)v5, 16, v4, (int(__thiscall*)(int))sub_46C80E);
        v12 = v6;
    }
    else
    {
        v12 = 0;
    }
    v7 = 0;
    if (!v12)
        return -2147467259;
    v8 = this[1];
    if (*(_DWORD*)(v8 + 4184))
    {
        v9 = *(_DWORD*)(v8 + 4180);
        do
        {
            for (i = 0; i < v9; ++i)
            {
                (*(void(__thiscall**)(_DWORD, unsigned int, unsigned int, void*))(*(_DWORD*)*this + 4))(*this, i, v7, v12);
                (*(void(__thiscall**)(_DWORD, unsigned int, unsigned int, void*))(*(_DWORD*)this[1] + 8))(
                    this[1],
                    i,
                    v7,
                    v12);
                v9 = *(_DWORD*)(this[1] + 4180);
            }
            ++v7;
        } while (v7 < *(_DWORD*)(this[1] + 4184));
    }
    sub_4885A6(v12);
    return 0;
}

//----- (0046F91C) --------------------------------------------------------
int __thiscall sub_46F91C(_DWORD* this)
{
    _DWORD* v3; // eax
    _DWORD* v4; // ecx
    unsigned int v5; // ecx
    unsigned int v6; // edi
    void* v7; // eax
    void* v8; // eax
    unsigned int v9; // ebx
    unsigned int i; // edi
    _DWORD* v11; // ecx
    unsigned int j; // edi
    _DWORD* v13; // ecx
    unsigned int v14; // eax
    unsigned int k; // edi
    unsigned int v16; // [esp+4h] [ebp-20h]
    unsigned int v17; // [esp+8h] [ebp-1Ch]
    unsigned int v18; // [esp+Ch] [ebp-18h]
    int v19; // [esp+Ch] [ebp-18h]
    void* v20; // [esp+Ch] [ebp-18h]
    void* v21; // [esp+10h] [ebp-14h]
    void* v22; // [esp+10h] [ebp-14h]
    unsigned int v23; // [esp+10h] [ebp-14h]
    void* v24; // [esp+14h] [ebp-10h]

    if (*((_BYTE*)this + 8) != 1)
        return -2147467259;
    v3 = (_DWORD*)this[1];
    v4 = (_DWORD*)*this;
    v18 = v3[1044];
    if (v18 <= v4[1044])
        v18 = v4[1044];
    v16 = v3[1045];
    if (v16 >= v4[1045])
        v16 = v4[1045];
    v5 = v4[1046];
    v17 = v3[1046];
    if (v17 >= v5)
        v17 = v5;
    v6 = 16 * v18;
    v7 = operator new(16 * v18);
    v21 = v7;
    if (v7)
    {
        sub_46C866((int)v7, 16, v18, (int(__thiscall*)(int))sub_46C80E);
        v24 = v21;
    }
    else
    {
        v24 = 0;
    }
    if (!v24)
        return -2147467259;
    v19 = *(_DWORD*)(this[1] + 4176);
    v8 = operator new(16 * v19);
    v22 = v8;
    if (v8)
    {
        sub_46C866((int)v8, 16, v19, (int(__thiscall*)(int))sub_46C80E);
        v20 = v22;
    }
    else
    {
        v20 = 0;
    }
    if (v20)
    {
        v9 = v17;
        v23 = 0;
        memset(v24, 0, v6);
        memset(v20, 0, 16 * *(_DWORD*)(this[1] + 4176));
        if (v17)
        {
            do
            {
                for (i = 0; i < v16; ++i)
                {
                    (*(void(__thiscall**)(_DWORD, unsigned int, unsigned int, void*))(*(_DWORD*)*this + 4))(
                        *this,
                        i,
                        v23,
                        v24);
                    (*(void(__thiscall**)(_DWORD, unsigned int, unsigned int, void*))(*(_DWORD*)this[1] + 8))(
                        this[1],
                        i,
                        v23,
                        v24);
                }
                v11 = (_DWORD*)this[1];
                for (j = v16; j < v11[1045]; ++j)
                {
                    (*(void(__thiscall**)(_DWORD*, unsigned int, unsigned int, void*))(*v11 + 8))(v11, j, v23, v20);
                    v11 = (_DWORD*)this[1];
                }
                v9 = v17;
                ++v23;
            } while (v23 < v17);
        }
        v13 = (_DWORD*)this[1];
        if (v9 < v13[1046])
        {
            v14 = v13[1045];
            do
            {
                for (k = 0; k < v14; ++k)
                {
                    (*(void(__thiscall**)(_DWORD*, unsigned int, unsigned int, void*))(*v13 + 8))(v13, k, v9, v20);
                    v13 = (_DWORD*)this[1];
                    v14 = v13[1045];
                }
                v13 = (_DWORD*)this[1];
                ++v9;
            } while (v9 < v13[1046]);
        }
        sub_4885A6(v24);
        sub_4885A6(v20);
        return 0;
    }
    else
    {
        sub_4885A6(v24);
        return -2147467259;
    }
}

//----- (0046FB1E) --------------------------------------------------------
int __thiscall sub_46FB1E(_DWORD* this)
{
    int v3; // edi
    char* v4; // eax
    int v5; // edi
    _DWORD* v6; // eax
    _DWORD* v7; // esi
    unsigned int v8; // edi
    unsigned int v9; // esi
    _DWORD* v10; // eax
    unsigned int v11; // esi
    char* v12; // esi
    int v13; // [esp+4h] [ebp-3Ch]
    int v14; // [esp+8h] [ebp-38h]
    int v15; // [esp+Ch] [ebp-34h]
    char* v16; // [esp+10h] [ebp-30h]
    _DWORD* v17; // [esp+10h] [ebp-30h]
    int v18; // [esp+10h] [ebp-30h]
    int v19; // [esp+14h] [ebp-2Ch]
    unsigned int v20; // [esp+18h] [ebp-28h]
    unsigned int v21; // [esp+1Ch] [ebp-24h]
    unsigned int v22; // [esp+20h] [ebp-20h]
    unsigned int v23; // [esp+24h] [ebp-1Ch]
    unsigned int i; // [esp+28h] [ebp-18h]
    _DWORD* v25; // [esp+2Ch] [ebp-14h]
    char* v26; // [esp+30h] [ebp-10h]

    if (*((_BYTE*)this + 8) != 2)
        return -2147467259;
    v3 = *(_DWORD*)(*this + 4176);
    v4 = (char*)operator new(16 * v3);
    v16 = v4;
    if (v4)
    {
        sub_46C866((int)v4, 16, v3, (int(__thiscall*)(int))sub_46C80E);
        v26 = v16;
    }
    else
    {
        v26 = 0;
    }
    if (!v26)
        return -2147024882;
    v5 = *(_DWORD*)(this[1] + 4176);
    v6 = operator new(16 * v5);
    v17 = v6;
    if (v6)
    {
        sub_46C866((int)v6, 16, v5, (int(__thiscall*)(int))sub_46C80E);
        v25 = v17;
    }
    else
    {
        v25 = 0;
    }
    if (v25)
    {
        v7 = (_DWORD*)this[1];
        v8 = v7[1045];
        v20 = 0;
        v23 = 0;
        v15 = (*(_DWORD*)(*this + 4176) << 16) / v7[1044];
        v14 = (*(_DWORD*)(*this + 4180) << 16) / v8;
        v13 = (*(_DWORD*)(*this + 4184) << 16) / v7[1046];
        do
        {
            v19 = -1;
            v9 = 0;
            v18 = 0;
            for (i = 0; i < v8; v18 += v14)
            {
                v22 = 0;
                v21 = 0;
                if (((v9 ^ v19) & 0xFFFF0000) != 0)
                {
                    (*(void(__thiscall**)(_DWORD, unsigned int, unsigned int, char*))(*(_DWORD*)*this + 4))(
                        *this,
                        HIWORD(v9),
                        HIWORD(v20),
                        v26);
                    v19 = v9;
                }
                if (*(_DWORD*)(this[1] + 4176))
                {
                    v10 = v25;
                    do
                    {
                        v11 = v22;
                        v22 += v15;
                        v12 = &v26[16 * HIWORD(v11)];
                        ++v21;
                        *v10 = *(_DWORD*)v12;
                        v12 += 4;
                        v10[1] = *(_DWORD*)v12;
                        v12 += 4;
                        v10[2] = *(_DWORD*)v12;
                        v10[3] = *((_DWORD*)v12 + 1);
                        v10 += 4;
                    } while (v21 < *(_DWORD*)(this[1] + 4176));
                }
                (*(void(__thiscall**)(_DWORD, unsigned int, unsigned int, _DWORD*))(*(_DWORD*)this[1] + 8))(
                    this[1],
                    i,
                    v23,
                    v25);
                v9 = v14 + v18;
                ++i;
                v8 = *(_DWORD*)(this[1] + 4180);
            }
            v20 += v13;
            ++v23;
        } while (v23 < *(_DWORD*)(this[1] + 4184));
        sub_4885A6(v26);
        sub_4885A6(v25);
        return 0;
    }
    else
    {
        sub_4885A6(v26);
        return -2147024882;
    }
}
// 46FC32: conditional instruction was optimized away because esi.4!=0

//----- (0046FD22) --------------------------------------------------------
int __thiscall sub_46FD22(_DWORD* this)
{
    _DWORD* v2; // edx
    _DWORD* v3; // ecx
    unsigned int v4; // eax
    int v5; // esi
    int v6; // esi
    _DWORD* v7; // ecx
    int v8; // eax
    int v9; // ecx
    int v10; // eax
    int v11; // ecx
    int v12; // ecx
    int v13; // ecx
    int v14; // ecx
    int v15; // ecx
    int v16; // ecx
    int v18; // esi
    char* v19; // eax
    int v20; // esi
    char* v21; // eax
    char* v22; // eax
    int v23; // esi
    char* v24; // eax
    char* v25; // ecx
    int v26; // eax
    int v27; // esi
    char* v28; // ecx
    bool v29; // zf
    char* v30; // edi
    int v31; // esi
    int v32; // eax
    float* v33; // eax
    float* v34; // eax
    float* v35; // eax
    float* v36; // eax
    char* v37; // edi
    unsigned int v38; // ecx
    float* v39; // [esp-10h] [ebp-90h]
    float* v40; // [esp-8h] [ebp-88h]
    float v41[4]; // [esp+10h] [ebp-70h] BYREF
    float v42[4]; // [esp+20h] [ebp-60h] BYREF
    float v43[4]; // [esp+30h] [ebp-50h] BYREF
    float v44[4]; // [esp+40h] [ebp-40h] BYREF
    char* v45; // [esp+50h] [ebp-30h]
    char* v46; // [esp+54h] [ebp-2Ch]
    char* v47; // [esp+58h] [ebp-28h]
    char* v48; // [esp+5Ch] [ebp-24h]
    int v49; // [esp+60h] [ebp-20h]
    char* v50; // [esp+64h] [ebp-1Ch]
    unsigned int v51; // [esp+68h] [ebp-18h]
    char* v52; // [esp+6Ch] [ebp-14h]
    char* v53; // [esp+70h] [ebp-10h]
    int v54; // [esp+7Ch] [ebp-4h]

    if (*((_BYTE*)this + 8) != 5)
        return -2147467259;
    v2 = (_DWORD*)this[1];
    if (v2[2] != 1)
        return -2147467259;
    v3 = (_DWORD*)*this;
    if (*(_DWORD*)(*this + 8) != 1)
        return -2147467259;
    v4 = v3[1044];
    v5 = v2[1044];
    if (v5 != v4 >> 1 && (v5 != 1 || v4 != 1))
        return -2147467259;
    v6 = v2[1045];
    if (v6 != v3[1045] >> 1 && (v6 != 1 || v3[1045] != 1))
        return -2147467259;
    if (v2[1046] != 1 || v3[1046] != 1)
        return -2147467259;
    if (v4 > 1 && (v4 & 1) != 0)
    {
        v3[1044] = v4 & 0xFFFFFFFE;
        *(_DWORD*)(*this + 4188) -= *(_DWORD*)(*this + 4192);
    }
    v7 = (_DWORD*)(*this + 4180);
    if (*v7 > 1u)
        *v7 &= ~1u;
    if ((*((_BYTE*)this + 10) & 8) != 0)
        goto LABEL_45;
    v8 = *this;
    v9 = *(_DWORD*)(*this + 4);
    if (v9 != *(_DWORD*)(this[1] + 4) || *(_DWORD*)(v8 + 4176) < 2u || *(_DWORD*)(v8 + 4180) < 2u)
        goto LABEL_45;
    if (v9 <= 28)
    {
        if (v9 != 28)
        {
            switch (v9)
            {
            case 21:
                v10 = sub_46E96A(this);
                goto LABEL_43;
            case 22:
                v10 = sub_46EAAE(this);
                goto LABEL_43;
            case 23:
                v10 = sub_46EBB4(this);
                goto LABEL_43;
            case 24:
                v10 = sub_46ECF4(this);
                goto LABEL_43;
            case 25:
                v10 = sub_46EE09(this);
                goto LABEL_43;
            case 26:
                v10 = sub_46EF3E(this);
                goto LABEL_43;
            case 27:
                v10 = sub_46F081(this);
                goto LABEL_43;
            default:
                goto LABEL_45;
            }
        }
        goto LABEL_40;
    }
    v11 = v9 - 29;
    if (!v11)
    {
        v10 = sub_46F246(this);
    LABEL_43:
        if (v10 >= 0)
            return 0;
        goto LABEL_45;
    }
    v12 = v11 - 1;
    if (!v12)
    {
        v10 = sub_46F37E(this);
        goto LABEL_43;
    }
    v13 = v12 - 10;
    if (v13)
    {
        v14 = v13 - 1;
        if (v14)
        {
            v15 = v14 - 9;
            if (!v15)
            {
            LABEL_40:
                v10 = sub_46F1AB(this);
                goto LABEL_43;
            }
            v16 = v15 - 1;
            if (!v16)
            {
                v10 = sub_46F497(this);
                goto LABEL_43;
            }
            if (v16 == 1)
            {
                v10 = sub_46F5CF(this);
                goto LABEL_43;
            }
        }
    }
LABEL_45:
    v18 = *(_DWORD*)(this[1] + 4176);
    v19 = (char*)operator new(16 * v18);
    v45 = v19;
    v54 = 0;
    if (v19)
    {
        sub_46C866((int)v19, 16, v18, (int(__thiscall*)(int))sub_46C80E);
        v50 = v45;
    }
    else
    {
        v50 = 0;
    }
    v54 = -1;
    if (!v50)
        return -2147024882;
    v20 = *(_DWORD*)(*this + 4176);
    if (*(_DWORD*)(*this + 4180) == 1)
    {
        v21 = (char*)operator new(16 * v20);
        v45 = v21;
        v54 = 1;
        if (v21)
        {
            sub_46C866((int)v21, 16, v20, (int(__thiscall*)(int))sub_46C80E);
            v22 = v45;
        }
        else
        {
            v22 = 0;
        }
        v54 = -1;
        v47 = v22;
        v52 = v22;
    }
    else
    {
        v23 = 2 * v20;
        v24 = (char*)operator new(16 * v23);
        v45 = v24;
        v54 = 2;
        if (v24)
        {
            sub_46C866((int)v24, 16, v23, (int(__thiscall*)(int))sub_46C80E);
            v25 = v45;
        }
        else
        {
            v25 = 0;
        }
        v26 = *(_DWORD*)(*this + 4176);
        v54 = -1;
        v47 = v25;
        v52 = v25;
        v22 = &v25[16 * v26];
    }
    v53 = v22;
    if (v47)
    {
        if (*(_DWORD*)(*this + 4176) == 1)
        {
            v45 = v52;
            v28 = v53;
        }
        else
        {
            v45 = v52 + 16;
            v28 = v53 + 16;
        }
        v46 = v28;
        v29 = *(_DWORD*)(this[1] + 4180) == 0;
        v51 = 0;
        if (!v29)
        {
            do
            {
                v30 = v52;
                v31 = 2 * v51;
                (*(void(__thiscall**)(_DWORD, unsigned int, _DWORD, char*))(*(_DWORD*)*this + 4))(*this, 2 * v51, 0, v52);
                if (v53 != v30)
                    (*(void(__thiscall**)(_DWORD, int, _DWORD, char*))(*(_DWORD*)*this + 4))(*this, v31 + 1, 0, v53);
                v32 = this[1];
                v49 = 0;
                if (*(_DWORD*)(v32 + 4176))
                {
                    v48 = v50;
                    do
                    {
                        v40 = (float*)&v46[32 * v49];
                        v39 = (float*)&v53[32 * v49];
                        v33 = sub_46E785((float*)&v52[32 * v49], v41, (float*)&v45[32 * v49]);
                        v34 = sub_46E785(v33, v42, v39);
                        v35 = sub_46E785(v34, v43, v40);
                        v36 = sub_46E7B3(v35, v44, 0.25);
                        v37 = v48;
                        v38 = ++v49;
                        v48 += 16;
                        *(float*)v37 = *v36;
                        v37 += 4;
                        *(float*)v37 = v36[1];
                        v37 += 4;
                        *(float*)v37 = v36[2];
                        *((float*)v37 + 1) = v36[3];
                    } while (v38 < *(_DWORD*)(this[1] + 4176));
                }
                (*(void(__thiscall**)(_DWORD, unsigned int, _DWORD, char*))(*(_DWORD*)this[1] + 8))(this[1], v51++, 0, v50);
            } while (v51 < *(_DWORD*)(this[1] + 4180));
        }
        sub_4885A6(v47);
        v27 = 0;
    }
    else
    {
        v27 = -2147024882;
    }
    sub_4885A6(v50);
    return v27;
}

//----- (00470113) --------------------------------------------------------
int __thiscall sub_470113(_DWORD* this)
{
    _DWORD* v2; // edx
    _DWORD* v3; // ecx
    unsigned int v4; // eax
    int v5; // esi
    int v6; // esi
    _DWORD* v7; // ecx
    _DWORD* v8; // ecx
    int v9; // esi
    char* v10; // eax
    int v12; // esi
    int v13; // esi
    char* v14; // eax
    char* v15; // ecx
    int v16; // eax
    char* v17; // esi
    char* v18; // edx
    int v19; // esi
    char* v20; // eax
    char* v21; // edx
    int v22; // esi
    int v23; // eax
    bool v24; // zf
    int v25; // edi
    int v26; // eax
    float* v27; // eax
    float* v28; // eax
    float* v29; // eax
    float* v30; // eax
    float* v31; // eax
    float* v32; // eax
    float* v33; // eax
    float* v34; // eax
    char* v35; // edi
    unsigned int v36; // ecx
    float* v37; // [esp-30h] [ebp-104h]
    float* v38; // [esp-28h] [ebp-FCh]
    float* v39; // [esp-20h] [ebp-F4h]
    float* v40; // [esp-18h] [ebp-ECh]
    float* v41; // [esp-10h] [ebp-E4h]
    float* v42; // [esp-8h] [ebp-DCh]
    float v43[4]; // [esp+10h] [ebp-C4h] BYREF
    float v44[4]; // [esp+20h] [ebp-B4h] BYREF
    float v45[4]; // [esp+30h] [ebp-A4h] BYREF
    float v46[4]; // [esp+40h] [ebp-94h] BYREF
    float v47[4]; // [esp+50h] [ebp-84h] BYREF
    float v48[4]; // [esp+60h] [ebp-74h] BYREF
    float v49[4]; // [esp+70h] [ebp-64h] BYREF
    float v50[4]; // [esp+80h] [ebp-54h] BYREF
    char* v51; // [esp+90h] [ebp-44h]
    char* v52; // [esp+94h] [ebp-40h]
    char* v53; // [esp+98h] [ebp-3Ch]
    LPVOID v54; // [esp+9Ch] [ebp-38h]
    char* v55; // [esp+A0h] [ebp-34h]
    char* v56; // [esp+A4h] [ebp-30h]
    int v57; // [esp+A8h] [ebp-2Ch]
    char* v58; // [esp+ACh] [ebp-28h]
    unsigned int v59; // [esp+B0h] [ebp-24h]
    char* v60; // [esp+B4h] [ebp-20h]
    char* v61; // [esp+B8h] [ebp-1Ch]
    char* v62; // [esp+BCh] [ebp-18h]
    char* v63; // [esp+C0h] [ebp-14h]
    unsigned int v64; // [esp+C4h] [ebp-10h]
    int v65; // [esp+D0h] [ebp-4h]

    if (*((_BYTE*)this + 8) != 5)
        return -2147467259;
    v2 = (_DWORD*)this[1];
    if (v2[2] != 1)
        return -2147467259;
    v3 = (_DWORD*)*this;
    if (*(_DWORD*)(*this + 8) != 1)
        return -2147467259;
    v4 = v3[1044];
    v5 = v2[1044];
    if (v5 != v4 >> 1 && (v5 != 1 || v4 != 1))
        return -2147467259;
    v6 = v2[1045];
    if (v6 != v3[1045] >> 1 && (v6 != 1 || v3[1045] != 1))
        return -2147467259;
    if (v2[1046] != v3[1046] >> 1)
        return -2147467259;
    if (v4 > 1 && (v4 & 1) != 0)
    {
        v3[1044] = v4 & 0xFFFFFFFE;
        *(_DWORD*)(*this + 4188) -= *(_DWORD*)(*this + 4192);
    }
    v7 = (_DWORD*)(*this + 4180);
    if (*v7 > 1u)
        *v7 &= ~1u;
    v8 = (_DWORD*)(*this + 4184);
    if (*v8 > 1u)
        *v8 &= ~1u;
    v9 = *(_DWORD*)(this[1] + 4176);
    v10 = (char*)operator new(16 * v9);
    v63 = v10;
    v65 = 0;
    if (v10)
    {
        sub_46C866((int)v10, 16, v9, (int(__thiscall*)(int))sub_46C80E);
        v60 = v63;
    }
    else
    {
        v60 = 0;
    }
    v65 = -1;
    if (!v60)
        return -2147024882;
    v12 = *(_DWORD*)(*this + 4176);
    if (*(_DWORD*)(*this + 4180) == 1)
    {
        v13 = 2 * v12;
        v14 = (char*)operator new(16 * v13);
        v63 = v14;
        v65 = 1;
        if (v14)
        {
            sub_46C866((int)v14, 16, v13, (int(__thiscall*)(int))sub_46C80E);
            v15 = v63;
        }
        else
        {
            v15 = 0;
        }
        v16 = *(_DWORD*)(*this + 4176);
        v65 = -1;
        v17 = &v15[16 * v16];
        v18 = v17;
        v54 = v15;
        v62 = v15;
        v56 = v17;
        v61 = v15;
        v58 = v17;
    }
    else
    {
        v19 = 4 * v12;
        v20 = (char*)operator new(16 * v19);
        v63 = v20;
        v65 = 2;
        if (v20)
        {
            sub_46C866((int)v20, 16, v19, (int(__thiscall*)(int))sub_46C80E);
            v21 = v63;
        }
        else
        {
            v21 = 0;
        }
        v16 = *(_DWORD*)(*this + 4176);
        v65 = -1;
        v56 = &v21[16 * v16];
        v17 = v56;
        v61 = &v21[32 * v16];
        v54 = v21;
        v62 = v21;
        v58 = &v21[48 * v16];
        v18 = v58;
        v15 = v61;
    }
    if (v54)
    {
        if (v16 == 1)
        {
            v63 = v62;
            v52 = v17;
        }
        else
        {
            v63 = v62 + 16;
            v15 += 16;
            v52 = v17 + 16;
            v18 += 16;
        }
        v23 = this[1];
        v59 = 0;
        v24 = *(_DWORD*)(v23 + 4184) == 0;
        v51 = v15;
        v53 = v18;
        if (!v24)
        {
            do
            {
                v64 = 0;
                if (*(_DWORD*)(v23 + 4180))
                {
                    do
                    {
                        v25 = 2 * v59;
                        (*(void(__thiscall**)(_DWORD, unsigned int, unsigned int, char*))(*(_DWORD*)*this + 4))(
                            *this,
                            2 * v64,
                            2 * v59,
                            v62);
                        if (v17 != v62)
                            (*(void(__thiscall**)(_DWORD, unsigned int, int, char*))(*(_DWORD*)*this + 4))(
                                *this,
                                2 * v64,
                                v25 + 1,
                                v17);
                        if (v61 != v62)
                            (*(void(__thiscall**)(_DWORD, unsigned int, int, char*))(*(_DWORD*)*this + 4))(
                                *this,
                                2 * v64 + 1,
                                v25,
                                v61);
                        if (v58 != v17 && v58 != v61)
                            (*(void(__thiscall**)(_DWORD, unsigned int, int, char*))(*(_DWORD*)*this + 4))(
                                *this,
                                2 * v64 + 1,
                                v25 + 1,
                                v58);
                        v26 = this[1];
                        v57 = 0;
                        if (*(_DWORD*)(v26 + 4176))
                        {
                            v55 = v60;
                            do
                            {
                                v42 = (float*)&v53[32 * v57];
                                v41 = (float*)&v58[32 * v57];
                                v40 = (float*)&v51[32 * v57];
                                v39 = (float*)&v61[32 * v57];
                                v38 = (float*)&v52[32 * v57];
                                v37 = (float*)&v17[32 * v57];
                                v27 = sub_46E785((float*)&v62[32 * v57], v43, (float*)&v63[32 * v57]);
                                v28 = sub_46E785(v27, v45, v37);
                                v29 = sub_46E785(v28, v47, v38);
                                v30 = sub_46E785(v29, v49, v39);
                                v31 = sub_46E785(v30, v46, v40);
                                v32 = sub_46E785(v31, v50, v41);
                                v33 = sub_46E785(v32, v48, v42);
                                v34 = sub_46E7B3(v33, v44, 0.125);
                                v35 = v55;
                                v36 = ++v57;
                                v55 += 16;
                                *(float*)v35 = *v34;
                                v35 += 4;
                                *(float*)v35 = v34[1];
                                v35 += 4;
                                *(float*)v35 = v34[2];
                                *((float*)v35 + 1) = v34[3];
                                v17 = v56;
                            } while (v36 < *(_DWORD*)(this[1] + 4176));
                        }
                        (*(void(__thiscall**)(_DWORD, unsigned int, unsigned int, char*))(*(_DWORD*)this[1] + 8))(
                            this[1],
                            v64++,
                            v59,
                            v60);
                    } while (v64 < *(_DWORD*)(this[1] + 4180));
                }
                ++v59;
                v23 = this[1];
            } while (v59 < *(_DWORD*)(v23 + 4184));
        }
        sub_4885A6(v54);
        v22 = 0;
    }
    else
    {
        v22 = -2147024882;
    }
    sub_4885A6(v60);
    return v22;
}

//----- (00470516) --------------------------------------------------------
int* __usercall sub_470516@<eax>(unsigned int a1@<ebx>, unsigned int a2@<edi>, int a3)
{
    int* result; // eax
    int* v4; // esi
    int v5; // eax
    double X; // st7
    int v7; // eax
    unsigned int v8; // ecx
    double v9; // st7
    int* v10; // [esp+Ch] [ebp-18h]
    float v11; // [esp+14h] [ebp-10h]
    float v12; // [esp+18h] [ebp-Ch]
    float v13; // [esp+1Ch] [ebp-8h]
    int v14; // [esp+20h] [ebp-4h]
    unsigned int v15; // [esp+20h] [ebp-4h]

    result = (int*)operator new(16 * a1);
    v4 = result;
    if (result)
    {
        v10 = result;
        v5 = v14;
        v15 = 0;
        for (dword_521728 = v5; v15 < a1; *((float*)v4 - 1) = 1.0 - v9)
        {
            v11 = (double)a2 / (double)a1;
            X = (double)v15 * v11 - 0.5;
            v13 = X;
            v12 = floor(X);
            v7 = (int)v12;
            v8 = v7 + 1;
            if (v7 < 0)
                v7 = a3 != 0 ? a2 - 1 : 0;
            if (v8 >= a2)
                v8 = a3 == 0 ? a2 - 1 : 0;
            *v4 = v7;
            v4[2] = v8;
            v4 += 4;
            ++v15;
            v9 = 1.0 - (v13 - v12);
            *((float*)v4 - 3) = v9;
        }
        return v10;
    }
    return result;
}
// 47056C: variable 'v14' is possibly undefined
// 521728: using guessed type int dword_521728;

//----- (00470616) --------------------------------------------------------
int __thiscall sub_470616(int** this)
{
    int** v1; // esi
    int* v2; // edx
    bool v3; // zf
    unsigned int v4; // eax
    unsigned int v5; // edi
    unsigned int v6; // ebx
    int* v7; // eax
    unsigned int v8; // edi
    int* v9; // eax
    int v10; // edi
    void* v11; // eax
    void* v12; // eax
    int v13; // edi
    char* v14; // eax
    char* v15; // eax
    int v16; // edi
    char* v17; // edi
    int* v18; // ebx
    int v19; // eax
    int v20; // ecx
    int* v21; // ecx
    int v22; // edx
    char* v23; // eax
    int v24; // eax
    int* v25; // ecx
    int v26; // edx
    char* v27; // ebx
    int v28; // esi
    int v29; // edi
    float* v30; // eax
    float* v31; // eax
    float* v32; // eax
    float* v33; // eax
    float* v34; // eax
    float* v35; // eax
    _DWORD* v36; // edi
    float* v37; // esi
    int** v38; // eax
    unsigned int v39; // ecx
    int* v40; // eax
    bool v41; // cf
    int v42; // esi
    float* v44; // [esp+8h] [ebp-F4h]
    float* v45; // [esp+10h] [ebp-ECh]
    float v46; // [esp+10h] [ebp-ECh]
    float v47; // [esp+18h] [ebp-E4h]
    float* v48; // [esp+18h] [ebp-E4h]
    float v49[4]; // [esp+28h] [ebp-D4h] BYREF
    float v50[4]; // [esp+38h] [ebp-C4h] BYREF
    float v51[4]; // [esp+48h] [ebp-B4h] BYREF
    float v52[4]; // [esp+58h] [ebp-A4h] BYREF
    float v53[4]; // [esp+68h] [ebp-94h] BYREF
    float v54[4]; // [esp+78h] [ebp-84h] BYREF
    float v55[4]; // [esp+88h] [ebp-74h] BYREF
    float v56[4]; // [esp+98h] [ebp-64h] BYREF
    float v57[4]; // [esp+A8h] [ebp-54h] BYREF
    int** v58; // [esp+B8h] [ebp-44h]
    int v59; // [esp+BCh] [ebp-40h]
    int v60; // [esp+C0h] [ebp-3Ch]
    _DWORD* v61; // [esp+C4h] [ebp-38h]
    char* v62; // [esp+C8h] [ebp-34h]
    _DWORD* v63; // [esp+CCh] [ebp-30h]
    int v64; // [esp+D0h] [ebp-2Ch]
    int v65; // [esp+D4h] [ebp-28h]
    float* v66; // [esp+D8h] [ebp-24h]
    char* v67; // [esp+DCh] [ebp-20h]
    LPVOID v68; // [esp+E0h] [ebp-1Ch]
    BOOL v69; // [esp+E4h] [ebp-18h]
    char* v70; // [esp+E8h] [ebp-14h]
    char* v71; // [esp+ECh] [ebp-10h]
    int v72; // [esp+F8h] [ebp-4h]

    v68 = 0;
    v67 = 0;
    v1 = this;
    v2 = this[1];
    v3 = v2[2] == 1;
    v58 = this;
    if (!v3)
        return -2147467259;
    if ((*this)[2] != 1)
        return -2147467259;
    v4 = (unsigned int)this[2];
    if ((_BYTE)v4 != 3)
        return -2147467259;
    v5 = (*this)[1044];
    v6 = v2[1044];
    v69 = ((v4 >> 17) & 1) == 0;
    v7 = sub_470516(v6, v5, (v4 & 0x10000) == 0);
    v8 = (*v1)[1045];
    v62 = (char*)v7;
    v9 = sub_470516(v1[1][1045], v8, v69);
    v69 = (BOOL)v9;
    if (!v62 || !v9)
        goto LABEL_28;
    v10 = v1[1][1044];
    v11 = operator new(16 * v10);
    v68 = v11;
    v72 = 0;
    if (v11)
    {
        sub_46C866((int)v11, 16, v10, (int(__thiscall*)(int))sub_46C80E);
        v12 = v68;
        v63 = v68;
    }
    else
    {
        v63 = 0;
        v12 = 0;
    }
    v72 = -1;
    v68 = v12;
    if (!v12)
        goto LABEL_28;
    v13 = 2 * (*v1)[1044];
    v14 = (char*)operator new(32 * (*v1)[1044]);
    v67 = v14;
    v72 = 1;
    if (v14)
    {
        sub_46C866((int)v14, 16, v13, (int(__thiscall*)(int))sub_46C80E);
        v15 = v67;
    }
    else
    {
        v15 = 0;
    }
    v72 = -1;
    v67 = v15;
    if (v15)
    {
        v16 = (*v1)[1044];
        v64 = 0;
        v59 = -1;
        v65 = -1;
        v17 = &v15[16 * v16];
        v71 = v15;
        v3 = v1[1][1045] == 0;
        v70 = v17;
        if (!v3)
        {
            v18 = (int*)(v69 + 8);
            v66 = (float*)(v69 + 8);
            do
            {
                v19 = *(v18 - 2);
                v60 = 0;
                if (v19 != v59)
                {
                    v20 = v65;
                    if (v19 == v65)
                    {
                        v23 = v71;
                        v65 = -1;
                        v71 = v17;
                        v59 = v20;
                        v70 = v23;
                        v17 = v23;
                    }
                    else
                    {
                        v21 = *v1;
                        v22 = **v1;
                        v59 = v19;
                        (*(void(__thiscall**)(int*, int, _DWORD, char*))(v22 + 4))(v21, v19, 0, v71);
                    }
                }
                v24 = *v18;
                if (*v18 != v65)
                {
                    v25 = *v1;
                    v26 = **v1;
                    v65 = *v18;
                    (*(void(__thiscall**)(int*, int, _DWORD, char*))(v26 + 4))(v25, v24, 0, v17);
                }
                if (v1[1][1044])
                {
                    v27 = v62 + 8;
                    v61 = v63;
                    do
                    {
                        v47 = v66[1];
                        v28 = 16 * *(_DWORD*)v27;
                        v29 = 16 * *((_DWORD*)v27 - 2);
                        v45 = sub_46E7B3((float*)&v70[v28], v52, *((float*)v27 + 1));
                        v30 = sub_46E7B3((float*)&v70[v29], v50, *((float*)v27 - 1));
                        v31 = sub_46E785(v30, v54, v45);
                        v48 = sub_46E7B3(v31, v57, v47);
                        v46 = *(v66 - 1);
                        v44 = sub_46E7B3((float*)&v71[v28], v53, *((float*)v27 + 1));
                        v32 = sub_46E7B3((float*)&v71[v29], v49, *((float*)v27 - 1));
                        v33 = sub_46E785(v32, v51, v44);
                        v34 = sub_46E7B3(v33, v55, v46);
                        v35 = sub_46E785(v34, v56, v48);
                        v36 = v61;
                        v61 += 4;
                        v37 = v35;
                        v38 = v58;
                        *v36 = *(_DWORD*)v37++;
                        *++v36 = *(_DWORD*)v37++;
                        *++v36 = *(_DWORD*)v37;
                        v27 += 16;
                        v39 = ++v60;
                        v36[1] = *((_DWORD*)v37 + 1);
                    } while (v39 < v38[1][1044]);
                    v1 = v58;
                    v18 = (int*)v66;
                    v17 = v70;
                }
                (*(void(__thiscall**)(int*, int, _DWORD, _DWORD*))(*v1[1] + 8))(v1[1], v64, 0, v63);
                v40 = v1[1];
                v18 += 4;
                v41 = ++v64 < (unsigned int)v40[1045];
                v66 = (float*)v18;
            } while (v41);
        }
        v42 = 0;
    }
    else
    {
    LABEL_28:
        v42 = -2147024882;
    }
    sub_4885A6(v62);
    sub_4885A6((LPVOID)v69);
    sub_4885A6(v68);
    sub_4885A6(v67);
    return v42;
}

//----- (00470947) --------------------------------------------------------
int __thiscall sub_470947(_DWORD* this)
{
    _DWORD* v1; // esi
    int v2; // ebx
    bool v3; // zf
    int v4; // eax
    unsigned int v5; // ebx
    unsigned int v6; // edi
    int* v7; // eax
    unsigned int v8; // edi
    int* v9; // eax
    unsigned int v10; // edi
    int* v11; // eax
    int v12; // edi
    void* v13; // eax
    void* v14; // eax
    int v15; // edi
    char* v16; // eax
    char* v17; // ecx
    int v18; // eax
    int v19; // edx
    int v20; // edi
    int v21; // eax
    char* v22; // edi
    float* v23; // ebx
    int v24; // eax
    int v25; // ecx
    int v26; // ecx
    char* v27; // ecx
    char* v28; // eax
    int v29; // eax
    int v30; // ecx
    char* v31; // ebx
    int v32; // esi
    int v33; // edi
    float* v34; // eax
    float* v35; // eax
    float* v36; // eax
    float* v37; // eax
    float* v38; // eax
    float* v39; // eax
    float* v40; // eax
    float* v41; // eax
    float* v42; // eax
    float* v43; // eax
    float* v44; // eax
    float* v45; // eax
    float* v46; // eax
    float* v47; // eax
    _DWORD* v48; // edi
    float* v49; // esi
    _DWORD* v50; // eax
    bool v51; // cf
    int v52; // esi
    float* v54; // [esp+8h] [ebp-1D8h]
    float* v55; // [esp+10h] [ebp-1D0h]
    float* v56; // [esp+10h] [ebp-1D0h]
    float v57; // [esp+10h] [ebp-1D0h]
    float* v58; // [esp+18h] [ebp-1C8h]
    float v59; // [esp+18h] [ebp-1C8h]
    float v60; // [esp+18h] [ebp-1C8h]
    float* v61; // [esp+18h] [ebp-1C8h]
    float v62; // [esp+20h] [ebp-1C0h]
    float* v63; // [esp+20h] [ebp-1C0h]
    float v64; // [esp+20h] [ebp-1C0h]
    int v65; // [esp+24h] [ebp-1BCh]
    int v66; // [esp+24h] [ebp-1BCh]
    float v67; // [esp+28h] [ebp-1B8h]
    float* v68; // [esp+28h] [ebp-1B8h]
    float v69[4]; // [esp+38h] [ebp-1A8h] BYREF
    float v70[4]; // [esp+48h] [ebp-198h] BYREF
    float v71[4]; // [esp+58h] [ebp-188h] BYREF
    float v72[4]; // [esp+68h] [ebp-178h] BYREF
    float v73[4]; // [esp+78h] [ebp-168h] BYREF
    float v74[4]; // [esp+88h] [ebp-158h] BYREF
    float v75[4]; // [esp+98h] [ebp-148h] BYREF
    float v76[4]; // [esp+A8h] [ebp-138h] BYREF
    float v77[4]; // [esp+B8h] [ebp-128h] BYREF
    float v78[4]; // [esp+C8h] [ebp-118h] BYREF
    float v79[4]; // [esp+D8h] [ebp-108h] BYREF
    float v80[4]; // [esp+E8h] [ebp-F8h] BYREF
    float v81[4]; // [esp+F8h] [ebp-E8h] BYREF
    float v82[4]; // [esp+108h] [ebp-D8h] BYREF
    float v83[4]; // [esp+118h] [ebp-C8h] BYREF
    float v84[4]; // [esp+128h] [ebp-B8h] BYREF
    float v85[4]; // [esp+138h] [ebp-A8h] BYREF
    float v86[4]; // [esp+148h] [ebp-98h] BYREF
    float v87[4]; // [esp+158h] [ebp-88h] BYREF
    float v88[4]; // [esp+168h] [ebp-78h] BYREF
    float v89[4]; // [esp+178h] [ebp-68h] BYREF
    _DWORD* v90; // [esp+188h] [ebp-58h]
    _DWORD* v91; // [esp+18Ch] [ebp-54h]
    char* v92; // [esp+190h] [ebp-50h]
    char* v93; // [esp+194h] [ebp-4Ch]
    LPVOID v94; // [esp+198h] [ebp-48h]
    char* v95; // [esp+19Ch] [ebp-44h]
    BOOL v96; // [esp+1A0h] [ebp-40h]
    int v97; // [esp+1A4h] [ebp-3Ch]
    _DWORD* v98; // [esp+1A8h] [ebp-38h]
    unsigned int v99; // [esp+1ACh] [ebp-34h]
    float* v100; // [esp+1B0h] [ebp-30h]
    int v101; // [esp+1B4h] [ebp-2Ch]
    char* v102; // [esp+1B8h] [ebp-28h]
    char* v103; // [esp+1BCh] [ebp-24h]
    unsigned int v104; // [esp+1C0h] [ebp-20h]
    char* v105; // [esp+1C4h] [ebp-1Ch]
    char* v106; // [esp+1C8h] [ebp-18h]
    int v107; // [esp+1CCh] [ebp-14h]
    char* v108; // [esp+1D0h] [ebp-10h]
    int v109; // [esp+1DCh] [ebp-4h]

    v94 = 0;
    v95 = 0;
    v1 = this;
    v2 = this[1];
    v3 = *(_DWORD*)(v2 + 8) == 1;
    v90 = this;
    if (!v3)
        return -2147467259;
    if (*(_DWORD*)(*this + 8) != 1)
        return -2147467259;
    v4 = this[2];
    if ((_BYTE)v4 != 3)
        return -2147467259;
    v5 = *(_DWORD*)(v2 + 4176);
    v6 = *(_DWORD*)(*this + 4176);
    v96 = (v4 & 0x20000) == 0;
    v104 = (v4 & 0x40000) == 0;
    v7 = sub_470516(v5, v6, (v4 & 0x10000) == 0);
    v8 = *(_DWORD*)(*v1 + 4180);
    v93 = (char*)v7;
    v9 = sub_470516(*(_DWORD*)(v1[1] + 4180), v8, v96);
    v10 = *(_DWORD*)(*v1 + 4184);
    v92 = (char*)v9;
    v11 = sub_470516(*(_DWORD*)(v1[1] + 4184), v10, v104);
    v96 = (BOOL)v11;
    if (!v93 || !v92 || !v11)
        goto LABEL_32;
    v12 = *(_DWORD*)(v1[1] + 4176);
    v13 = operator new(16 * v12);
    v94 = v13;
    v109 = 0;
    if (v13)
    {
        sub_46C866((int)v13, 16, v12, (int(__thiscall*)(int))sub_46C80E);
        v14 = v94;
        v98 = v94;
    }
    else
    {
        v98 = 0;
        v14 = 0;
    }
    v109 = -1;
    v94 = v14;
    if (!v14)
        goto LABEL_32;
    v15 = 4 * *(_DWORD*)(*v1 + 4176);
    v16 = (char*)operator new(*(_DWORD*)(*v1 + 4176) << 6);
    v95 = v16;
    v109 = 1;
    if (v16)
    {
        sub_46C866((int)v16, 16, v15, (int(__thiscall*)(int))sub_46C80E);
        v17 = v95;
    }
    else
    {
        v17 = 0;
    }
    v109 = -1;
    v95 = v17;
    if (v17)
    {
        v18 = *(_DWORD*)(*v1 + 4176);
        v97 = 0;
        v102 = &v17[16 * v18];
        v19 = v18;
        v20 = 3 * v18;
        v21 = v1[1];
        v22 = &v17[16 * v20];
        v3 = *(_DWORD*)(v21 + 4184) == 0;
        v105 = v17;
        v106 = &v17[32 * v19];
        v103 = v22;
        if (!v3)
        {
            v23 = (float*)(v96 + 8);
            v100 = (float*)(v96 + 8);
            do
            {
                v99 = 0;
                v101 = -1;
                v107 = -1;
                if (*(_DWORD*)(v21 + 4180))
                {
                    v108 = v92 + 8;
                    do
                    {
                        v24 = *((_DWORD*)v108 - 2);
                        v104 = 0;
                        if (v24 != v101)
                        {
                            v25 = v107;
                            if (v24 == v107)
                            {
                                v107 = -1;
                                v101 = v25;
                                v27 = v102;
                                v102 = v105;
                                v28 = v106;
                                v106 = v22;
                                v105 = v27;
                                v103 = v28;
                                v22 = v28;
                            }
                            else
                            {
                                v26 = *v1;
                                v65 = *((_DWORD*)v23 - 2);
                                v101 = v24;
                                (*(void(__thiscall**)(int, int, int, char*))(*(_DWORD*)v26 + 4))(v26, v24, v65, v105);
                                (*(void(__thiscall**)(_DWORD, int, _DWORD, char*))(*(_DWORD*)*v1 + 4))(
                                    *v1,
                                    v101,
                                    *(_DWORD*)v23,
                                    v106);
                            }
                        }
                        v29 = *(_DWORD*)v108;
                        if (*(_DWORD*)v108 != v107)
                        {
                            v30 = *v1;
                            v66 = *((_DWORD*)v23 - 2);
                            v107 = *(_DWORD*)v108;
                            (*(void(__thiscall**)(int, int, int, char*))(*(_DWORD*)v30 + 4))(v30, v29, v66, v102);
                            (*(void(__thiscall**)(_DWORD, int, _DWORD, char*))(*(_DWORD*)*v1 + 4))(*v1, v107, *(_DWORD*)v23, v22);
                        }
                        if (*(_DWORD*)(v1[1] + 4176))
                        {
                            v31 = v93 + 8;
                            v91 = v98;
                            do
                            {
                                v67 = v100[1];
                                v62 = *((float*)v108 + 1);
                                v32 = 16 * *(_DWORD*)v31;
                                v33 = 16 * *((_DWORD*)v31 - 2);
                                v58 = sub_46E7B3((float*)&v103[v32], v86, *((float*)v31 + 1));
                                v34 = sub_46E7B3((float*)&v103[v33], v84, *((float*)v31 - 1));
                                v35 = sub_46E785(v34, v70, v58);
                                v63 = sub_46E7B3(v35, v78, v62);
                                v59 = *((float*)v108 - 1);
                                v55 = sub_46E7B3((float*)&v106[v32], v72, *((float*)v31 + 1));
                                v36 = sub_46E7B3((float*)&v106[v33], v74, *((float*)v31 - 1));
                                v37 = sub_46E785(v36, v80, v55);
                                v38 = sub_46E7B3(v37, v82, v59);
                                v39 = sub_46E785(v38, v76, v63);
                                v68 = sub_46E7B3(v39, v89, v67);
                                v64 = *(v100 - 1);
                                v60 = *((float*)v108 + 1);
                                v56 = sub_46E7B3((float*)&v102[v32], v83, *((float*)v31 + 1));
                                v40 = sub_46E7B3((float*)&v102[v33], v79, *((float*)v31 - 1));
                                v41 = sub_46E785(v40, v81, v56);
                                v61 = sub_46E7B3(v41, v85, v60);
                                v57 = *((float*)v108 - 1);
                                v54 = sub_46E7B3((float*)&v105[v32], v73, *((float*)v31 + 1));
                                v42 = sub_46E7B3((float*)&v105[v33], v69, *((float*)v31 - 1));
                                v43 = sub_46E785(v42, v71, v54);
                                v44 = sub_46E7B3(v43, v75, v57);
                                v45 = sub_46E785(v44, v77, v61);
                                v46 = sub_46E7B3(v45, v87, v64);
                                v47 = sub_46E785(v46, v88, v68);
                                v48 = v91;
                                v49 = v47;
                                v50 = v90;
                                *v91 = *(_DWORD*)v49++;
                                *++v48 = *(_DWORD*)v49++;
                                *++v48 = *(_DWORD*)v49;
                                v31 += 16;
                                ++v104;
                                v91 += 4;
                                v48[1] = *((_DWORD*)v49 + 1);
                            } while (v104 < *(_DWORD*)(v50[1] + 4176));
                            v1 = v90;
                            v23 = v100;
                            v22 = v103;
                        }
                        (*(void(__thiscall**)(_DWORD, unsigned int, int, _DWORD*))(*(_DWORD*)v1[1] + 8))(v1[1], v99, v97, v98);
                        v108 += 16;
                        ++v99;
                    } while (v99 < *(_DWORD*)(v1[1] + 4180));
                }
                v21 = v1[1];
                v23 += 4;
                v51 = (unsigned int)++v97 < *(_DWORD*)(v21 + 4184);
                v100 = v23;
            } while (v51);
        }
        v52 = 0;
    }
    else
    {
    LABEL_32:
        v52 = -2147024882;
    }
    sub_4885A6(v93);
    sub_4885A6(v92);
    sub_4885A6((LPVOID)v96);
    sub_4885A6(v94);
    sub_4885A6(v95);
    return v52;
}

//----- (00470E39) --------------------------------------------------------
int __thiscall sub_470E39(int** this, int a2, int a3, int* a4)
{
    float* v5; // eax
    float* v6; // eax
    int v7; // ebx
    int* v8; // ecx

    this[1] = 0;
    *this = 0;
    this[2] = a4;
    if (!(_WORD)a4 || (unsigned __int16)a4 > 5u || ((unsigned int)a4 & 0xFFF00000) != 0)
    {
        sub_46D8FD(0, "Invalid image filter");
        return -2005530516;
    }
    *(_DWORD*)(a2 + 64) = (unsigned int)a4 & 0x80000;
    v5 = sub_476468(a2);
    this[1] = (int*)v5;
    if (!v5 || (v6 = sub_476468(a3), (*this = (int*)v6) == 0))
    {
        sub_46D8FD(0, "Unsupported image format");
        goto LABEL_21;
    }
    if (this[1][2] != *((_DWORD*)v6 + 2))
    {
        sub_46D8FD(0, "No conversion exists between source and destination image formats");
    LABEL_21:
        v7 = -2147467259;
        goto LABEL_22;
    }
    if (sub_46F6F9(this) < 0
        && sub_46F82B(this) < 0
        && sub_46F91C(this) < 0
        && sub_46FB1E(this) < 0
        && sub_46FD22(this) < 0
        && sub_470113(this) < 0
        && sub_470616(this) < 0
        && sub_470947(this) < 0
        && sub_46DE48(this) < 0
        && sub_46E258(this) < 0)
    {
        sub_46D8FD(0, "No suitable image filter found");
        goto LABEL_21;
    }
    v7 = 0;
LABEL_22:
    v8 = this[1];
    if (v8)
    {
        (*(void(__thiscall**)(int*, int)) * v8)(v8, 1);
        this[1] = 0;
    }
    if (*this)
    {
        (*(void(__thiscall**)(int*, int)) * *this)(*this, 1);
        *this = 0;
    }
    return v7;
}

//----- (00470F78) --------------------------------------------------------
_DWORD* __thiscall sub_470F78(_DWORD* this)
{
    _DWORD* result; // eax

    result = this;
    *this = 0;
    this[1] = 0;
    this[7] = 0;
    this[8] = 0;
    this[9] = 0;
    this[10] = 0;
    this[11] = 0;
    return result;
}

//----- (00470F91) --------------------------------------------------------
void __thiscall sub_470F91(int this)
{
    void* v2; // edi
    void* v3; // esi

    if (*(_DWORD*)(this + 4) && *(_DWORD*)(this + 32))
        sub_4885A6(*(LPVOID*)(this + 4));
    if (*(_DWORD*)(this + 28) && *(_DWORD*)(this + 36))
        sub_4885A6(*(LPVOID*)(this + 28));
    v2 = *(void**)(this + 40);
    if (v2)
    {
        sub_470F91(*(_DWORD*)(this + 40));
        sub_4885A6(v2);
    }
    v3 = *(void**)(this + 44);
    if (v3)
    {
        sub_470F91(v3);
        sub_4885A6(v3);
    }
}

//----- (00470FEA) --------------------------------------------------------
void* __thiscall sub_470FEA(void* this, char a2)
{
    sub_470F91((int)this);
    if ((a2 & 1) != 0)
        sub_4885A6(this);
    return this;
}

//----- (00471009) --------------------------------------------------------
int __thiscall sub_471009(int* this, int a2, unsigned int a3)
{
    int* v3; // esi
    unsigned int v6; // edx
    int v7; // eax
    unsigned __int16 v8; // bx
    int v9; // eax
    int v10; // eax
    unsigned int v11; // eax
    int* v12; // eax
    int v13; // ecx
    int v14; // edx
    int v15; // eax
    int v16; // ebx
    char v17; // cl
    unsigned int v18; // ebx
    void* v19; // eax
    _BYTE* v20; // eax
    int v21; // ecx
    int v22; // eax
    int v23; // eax
    int v24; // ecx
    unsigned int v25; // ecx
    unsigned int v26; // eax
    unsigned __int8* v27; // ebx
    int v28; // eax
    char* v29; // edx
    char* v30; // ecx
    int v31; // eax
    int v32; // ecx
    unsigned int v33; // eax
    unsigned int v34; // eax
    int v35; // ecx
    int v36; // eax
    unsigned __int8 v37; // al
    int v38; // eax
    unsigned __int8 v39; // si
    unsigned int v40; // ecx
    int v41; // eax
    __int16 v42; // di
    unsigned int j; // ecx
    unsigned int v44; // eax
    const void* v45; // esi
    char* v46; // edi
    unsigned __int8* v47; // [esp+4h] [ebp-1Ch]
    unsigned int v48; // [esp+8h] [ebp-18h]
    unsigned int v49; // [esp+8h] [ebp-18h]
    unsigned int v50; // [esp+Ch] [ebp-14h]
    int v51; // [esp+Ch] [ebp-14h]
    unsigned int i; // [esp+10h] [ebp-10h]
    unsigned int v54; // [esp+14h] [ebp-Ch]
    unsigned int v55; // [esp+14h] [ebp-Ch]
    int v56; // [esp+18h] [ebp-8h]
    char* v57; // [esp+18h] [ebp-8h]
    char* v58; // [esp+1Ch] [ebp-4h]
    unsigned int v59; // [esp+28h] [ebp+8h]
    int v60; // [esp+2Ch] [ebp+Ch]
    int v61; // [esp+2Ch] [ebp+Ch]
    char* v62; // [esp+2Ch] [ebp+Ch]

    v3 = this;
    if (a3 < 0x28)
        return -2147467259;
    v6 = *(_DWORD*)a2;
    if (*(_DWORD*)a2 < 0x28u)
        return -2147467259;
    v59 = *(_DWORD*)(a2 + 4);
    v7 = *(_DWORD*)(a2 + 8);
    if (v7 <= 0)
        v7 = -v7;
    v8 = *(_WORD*)(a2 + 14);
    v56 = v7;
    v9 = *(_DWORD*)(a2 + 32);
    if (v8 <= 8u && !v9)
        v9 = 1 << v8;
    v50 = v6 + 4 * v9;
    if (v50 > a3)
        return -2147467259;
    if (*(_WORD*)(a2 + 12) != 1)
        return -2147467259;
    if (*(int*)(a2 + 8) < 0)
    {
        v10 = *(_DWORD*)(a2 + 16);
        if (v10)
        {
            if (v10 != 3)
                return -2147467259;
        }
    }
    v11 = *(_DWORD*)(a2 + 16);
    if (v11 <= 2)
    {
        v17 = *(_WORD*)(a2 + 14);
        if (v8 == 1 || v8 == 4 || v8 == 8)
        {
            v18 = *(_DWORD*)(a2 + 32);
            v61 = 41;
            v48 = v18;
            if (!v18)
            {
                v18 = 1 << v17;
                v48 = 1 << v17;
            }
            v3[9] = 1;
            v19 = operator new(0x400u);
            v3[7] = (int)v19;
            if (!v19)
                return -2147024882;
            v54 = 0;
            v20 = (_BYTE*)(a2 + *(_DWORD*)a2);
            if (v18)
            {
                do
                {
                    v21 = 4 * v54;
                    *(_BYTE*)(v21 + v3[7]) = v20[2];
                    *(_BYTE*)(v21 + v3[7] + 1) = v20[1];
                    *(_BYTE*)(v21 + v3[7] + 2) = *v20;
                    *(_BYTE*)(v21 + v3[7] + 3) = -1;
                    ++v54;
                    v18 = v48;
                    v20 += 4;
                } while (v54 < v48);
            }
            while (v18 < 0x100)
            {
                v22 = 4 * v18;
                *(_BYTE*)(v22 + v3[7]) = -1;
                *(_BYTE*)(v22 + v3[7] + 1) = -1;
                *(_BYTE*)(v22 + v3[7] + 2) = -1;
                *(_BYTE*)(v22 + v3[7] + 3) = -1;
                ++v18;
            }
            goto LABEL_76;
        }
        if (v8 != 16)
        {
            if (v8 != 24)
            {
                if (v8 != 32)
                    return -2147467259;
            LABEL_65:
                v61 = 22;
                goto LABEL_76;
            }
        LABEL_33:
            v61 = 20;
            goto LABEL_76;
        }
        goto LABEL_66;
    }
    if (v11 == 3)
    {
        if (v6 >= 0x6C)
        {
            v13 = *(_DWORD*)(a2 + 48);
            v14 = *(_DWORD*)(a2 + 44);
            v15 = *(_DWORD*)(a2 + 40);
            v60 = *(_DWORD*)(a2 + 52);
        }
        else
        {
            v60 = 0;
            v12 = (int*)(v6 + a2);
            v13 = *(_DWORD*)(v6 + a2 + 8);
            v14 = *(_DWORD*)(v6 + a2 + 4);
            v15 = *v12;
        }
        v16 = *(unsigned __int16*)(a2 + 14);
        if (v16 != 16)
        {
            if (v16 != 24)
            {
                if (v16 != 32 || v13 != 255 || v14 != 65280 || v15 != 16711680)
                    return -2147467259;
                if (v60)
                {
                    if (v60 == -16777216)
                    {
                        v61 = 21;
                        goto LABEL_76;
                    }
                    return -2147467259;
                }
                goto LABEL_65;
            }
            if (v13 != 255 || v14 != 65280 || v15 != 16711680 || v60)
                return -2147467259;
            goto LABEL_33;
        }
        if (v13 == 255)
        {
            if (v14 != 255 || v15 != 255 || v60 != 65280)
                return -2147467259;
            v61 = 51;
            goto LABEL_76;
        }
        if (v13 != 31)
        {
            if (v13 == 15)
            {
                if (v14 != 240 || v15 != 3840 || v60 != 61440)
                    return -2147467259;
                v61 = 26;
            }
            else
            {
                if (v13 != 3 || v14 != 28 || v15 != 224 || v60 != 65280)
                    return -2147467259;
                v61 = 29;
            }
            goto LABEL_76;
        }
        if (v14 == 2016)
        {
            if (v15 != 63488 || v60)
                return -2147467259;
            v61 = 23;
            goto LABEL_76;
        }
        if (v14 != 992 || v15 != 31744)
            return -2147467259;
        if (v60)
        {
            if (v60 != 0x8000)
                return -2147467259;
            v61 = 25;
        LABEL_76:
            if (*(_WORD*)(a2 + 14) == 1)
            {
                v25 = v59 >> 3;
            }
            else
            {
                if (*(_WORD*)(a2 + 14) != 4)
                {
                    v23 = v59 * (*(unsigned __int16*)(a2 + 14) >> 3);
                    v24 = v23 + 3;
                LABEL_82:
                    v55 = v24 & 0xFFFFFFFC;
                    v49 = v23;
                    *v3 = v61;
                    v3[5] = v59;
                    v26 = (v23 + 3) & 0xFFFFFFFC;
                    v3[2] = v26;
                    v3[3] = 0;
                    v3[4] = 0;
                    v3[6] = v56;
                    if (*(int*)(a2 + 8) < 0 && *(_WORD*)(a2 + 14) >= 8u)
                    {
                        v3[8] = 0;
                        v3[1] = a2 + v50;
                        return 0;
                    }
                    v3[8] = 1;
                    v62 = (char*)operator new(v56 * v26);
                    v3[1] = (int)v62;
                    if (v62)
                    {
                        v27 = (unsigned __int8*)(v50 + a2);
                        v28 = v3[2];
                        v47 = (unsigned __int8*)(v50 + a2);
                        if (*(int*)(a2 + 8) >= 0)
                        {
                            v29 = &v62[v28 * (v56 - 1)];
                            v51 = -v28;
                        }
                        else
                        {
                            v29 = v62;
                            v51 = v3[2];
                        }
                        v30 = v62;
                        v57 = &v62[v56 * v28];
                        v31 = *(_DWORD*)(a2 + 16);
                        v58 = v29;
                        if (v31 == 2)
                        {
                            if (v29 >= v62)
                            {
                                while (1)
                                {
                                    if (*v27)
                                    {
                                        v35 = 0;
                                        do
                                        {
                                            if ((v35 & 1) != 0)
                                                LOBYTE(v36) = v27[1] & 0xF;
                                            else
                                                v36 = v27[1] >> 4;
                                            v29[v35++] = v36;
                                        } while (v35 < *v27);
                                        v3 = this;
                                        v29 += *v27;
                                    }
                                    else if (v27[1])
                                    {
                                        if (v27[1] == 1)
                                        {
                                            v29 = &v30[-v3[2]];
                                        }
                                        else if (v27[1] == 2)
                                        {
                                            v29 += v27[2] - v3[2] * v27[3];
                                            v27 += 2;
                                        }
                                        else
                                        {
                                            v32 = 0;
                                            if (v27[1])
                                            {
                                                do
                                                {
                                                    v33 = v27[(v32 >> 1) + 2];
                                                    if ((v32 & 1) != 0)
                                                        LOBYTE(v33) = v33 & 0xF;
                                                    else
                                                        v33 >>= 4;
                                                    v29[v32++] = v33;
                                                } while (v32 < v27[1]);
                                                v3 = this;
                                            }
                                            v34 = v27[1];
                                            v29 += v34;
                                            v27 += ((v34 >> 1) + 1) & 0xFFFFFFFE;
                                        }
                                    }
                                    else
                                    {
                                        if (v29 != &v58[v59]
                                            && sub_46D957(
                                                "d:\\builds\\nt32_chk\\multimedia\\directx\\dxg\\d3dx8\\tex\\cd3dximage.cpp",
                                                392,
                                                "pbDest == pbDestLine + dwWidth"))
                                        {
                                            DebugBreak();
                                        }
                                        v29 = &v58[-v3[2]];
                                        v58 = v29;
                                    }
                                    v27 += 2;
                                    if (v29 < v62)
                                        break;
                                    v30 = v62;
                                }
                            }
                            return 0;
                        }
                        if (v31 != 1)
                        {
                            v42 = *(_WORD*)(a2 + 14);
                            if (v42 == 1)
                            {
                                for (; v29 >= v62; v27 += v55)
                                {
                                    if (v29 >= v57)
                                        break;
                                    for (i = 0; i < v59; ++i)
                                        v29[i] = (v27[i >> 3] >> (7 - (i & 7))) & 1;
                                    v29 += v51;
                                }
                            }
                            else if (v42 == 4)
                            {
                                for (; v29 >= v62; v27 += v55)
                                {
                                    if (v29 >= v57)
                                        break;
                                    for (j = 0; j < v59; ++j)
                                    {
                                        v44 = v27[j >> 1];
                                        if ((j & 1) != 0)
                                            LOBYTE(v44) = v44 & 0xF;
                                        else
                                            v44 >>= 4;
                                        v29[j] = v44;
                                    }
                                    v29 += v51;
                                }
                            }
                            else
                            {
                                while (v29 >= v62)
                                {
                                    if (v29 >= v57)
                                        break;
                                    v45 = v27;
                                    v27 += v55;
                                    v46 = v29;
                                    v29 += v51;
                                    qmemcpy(v46, v45, v49);
                                }
                            }
                            return 0;
                        }
                        if (v29 < v62)
                            return 0;
                        while (1)
                        {
                            v37 = *v27;
                            if (*v27)
                                break;
                            switch (v27[1])
                            {
                            case 0u:
                                if (v29 != &v58[v59]
                                    && sub_46D957(
                                        "d:\\builds\\nt32_chk\\multimedia\\directx\\dxg\\d3dx8\\tex\\cd3dximage.cpp",
                                        440,
                                        "pbDest == pbDestLine + dwWidth"))
                                {
                                    DebugBreak();
                                }
                                v29 = &v58[-v3[2]];
                                v58 = v29;
                                break;
                            case 1u:
                                v29 = &v62[-v3[2]];
                                break;
                            case 2u:
                                v29 += v27[2] - v3[2] * v27[3];
                                v27 += 2;
                                break;
                            default:
                                qmemcpy(v29, v27 + 2, v27[1]);
                                v38 = v27[1];
                                v29 += v38;
                                v27 += (v38 + 1) & 0xFFFFFFFE;
                            LABEL_133:
                                v3 = this;
                                break;
                            }
                            v27 += 2;
                            v47 = v27;
                            if (v29 < v62)
                                return 0;
                        }
                        LOBYTE(v27) = v27[1];
                        BYTE1(v27) = (_BYTE)v27;
                        v39 = v37;
                        v40 = v37 >> 2;
                        v41 = (_DWORD)v27 << 16;
                        LOWORD(v41) = (_WORD)v27;
                        v27 = v47;
                        memset32(v29, v41, v40);
                        memset(&v29[4 * v40], v41, v39 & 3);
                        v29 += *v47;
                        goto LABEL_133;
                    }
                    return -2147024882;
                }
                v25 = v59 >> 1;
            }
            v23 = v59;
            v24 = v25 + 3;
            goto LABEL_82;
        }
    LABEL_66:
        v61 = 24;
        goto LABEL_76;
    }
    sub_46D8FD(0, "LoadBMP: JPEG compression not supported");
    return -2147467263;
}

//----- (004716F6) --------------------------------------------------------
void __cdecl __noreturn sub_4716F6(int a1)
{
    (*(void(__cdecl**)(int))(*(_DWORD*)a1 + 8))(a1);
    longjmp((int*)(*(_DWORD*)a1 + 132), 1);
}
// 47170E: control flows out of bounds to 471713

//----- (00471746) --------------------------------------------------------
char __cdecl sub_471746(int a1)
{
    _DWORD* v1; // eax

    v1 = *(_DWORD**)(a1 + 20);
    *v1 = v1[7];
    v1[1] = v1[8];
    return 1;
}

//----- (0047175E) --------------------------------------------------------
_DWORD* __cdecl sub_47175E(int a1, int a2)
{
    _DWORD* result; // eax

    result = *(_DWORD**)(a1 + 20);
    *result += a2;
    result[1] -= a2;
    return result;
}

//----- (00471771) --------------------------------------------------------
int __thiscall sub_471771(_DWORD* this, int a2, int a3)
{
    int v3; // esi
    _DWORD* v4; // eax
    unsigned int v5; // eax
    _DWORD* v6; // esi
    unsigned int v7; // ecx
    int v8; // ecx
    unsigned int v9; // eax
    void* v10; // eax
    const void** v11; // edi
    char* v12; // ebx
    int* v13; // esi
    _BYTE* v14; // eax
    int* i; // ecx
    int v16; // ebx
    unsigned __int16 v17; // dx
    unsigned int v19; // [esp-4h] [ebp-284h]
    void(__cdecl __noreturn * v20)(int); // [esp+Ch] [ebp-274h] BYREF
    int (*v21)(); // [esp+14h] [ebp-26Ch]
    char v22[64]; // [esp+90h] [ebp-1F0h] BYREF
    void(__cdecl __noreturn * *v23)(int); // [esp+D0h] [ebp-1B0h] BYREF
    int v24; // [esp+D4h] [ebp-1ACh]
    _DWORD* v25; // [esp+E4h] [ebp-19Ch]
    unsigned int v26; // [esp+12Ch] [ebp-154h]
    unsigned int v27; // [esp+130h] [ebp-150h]
    int v28; // [esp+138h] [ebp-148h]
    unsigned int v29; // [esp+148h] [ebp-138h]
    const void** v30; // [esp+278h] [ebp-8h]
    _DWORD* v31; // [esp+27Ch] [ebp-4h]

    v31 = this;
    v23 = sub_4789FA(&v20);
    v20 = sub_4716F6;
    v21 = nullsub_2;
    if (((int(__cdecl*)(char*, _DWORD))_setjmp3)(v22, 0))
        goto LABEL_2;
    sub_476C11(&v23, 61, 424);
    v4 = (_DWORD*)(*(int(__cdecl**)(void(__cdecl __noreturn***)(int), _DWORD, int))v24)(&v23, 0, 36);
    v25 = v4;
    v4[8] = a3;
    v4[2] = nullsub_2;
    v4[3] = sub_471746;
    v4[4] = sub_47175E;
    v4[5] = sub_478747;
    v4[6] = nullsub_2;
    v4[1] = 0;
    *v4 = 0;
    v4[7] = a2;
    sub_476F95(&v23, 1);
    v21 = sub_471714;
    sub_477129((int)&v23);
    if (v28 == 1)
    {
        v6 = v31;
        v5 = v26;
        *v31 = 50;
        v6[2] = v5;
    }
    else
    {
        if (v28 != 3)
        {
        LABEL_2:
            v3 = -2147467259;
            goto LABEL_22;
        }
        v5 = v26;
        v6 = v31;
        v7 = 4 * v26;
        *v31 = 22;
        v6[2] = v7;
    }
    v8 = v6[2];
    v6[5] = v5;
    v9 = v27;
    v19 = v27 * v8;
    v6[8] = 1;
    v6[3] = 0;
    v6[4] = 0;
    v6[6] = v9;
    v10 = operator new(v19);
    v6[1] = v10;
    if (v10
        && (v11 = (const void**)(*(int(__cdecl**)(void(__cdecl __noreturn***)(int), int, unsigned int, int))(v24 + 8))(
            &v23,
            1,
            v28 * v26,
            1),
            (v30 = v11) != 0))
    {
        if (*v6 == 50)
        {
            v12 = (char*)v6[1];
            if (v29 < v27)
            {
                while (1)
                {
                    sub_4770A5(&v23, (int)v11, 1);
                    qmemcpy(v12, *v11, v26);
                    v12 += v26;
                    if (v29 >= v27)
                        break;
                    v11 = v30;
                }
            }
        }
        else if (*v6 == 22)
        {
            v13 = (int*)v6[1];
            while (v29 < v27)
            {
                sub_4770A5(&v23, (int)v11, 1);
                v14 = *v11;
                for (i = &v13[v26]; v13 < i; ++v13)
                {
                    v16 = (unsigned __int8)v14[2];
                    HIBYTE(v17) = *v14;
                    v14 += 3;
                    LOBYTE(v17) = *(v14 - 2);
                    *v13 = v16 | (v17 << 8);
                }
            }
        }
        sub_476EEB((int)&v23);
        v3 = 0;
    }
    else
    {
        v3 = -2147024882;
    }
LABEL_22:
    sub_476CD2((int)&v23);
    return v3;
}
// 471714: using guessed type int sub_471714();
// 471745: using guessed type int nullsub_2();
// 48B798: using guessed type int _setjmp3();

//----- (004719C6) --------------------------------------------------------
int __thiscall sub_4719C6(int* this, unsigned __int8* a2, unsigned int a3)
{
    int* v3; // esi
    unsigned __int8 v5; // cl
    int v6; // edx
    int v7; // eax
    unsigned int v8; // edi
    int v9; // eax
    int v10; // eax
    int v11; // eax
    int v12; // ecx
    int v13; // ecx
    int v14; // ecx
    int v15; // ecx
    unsigned int v16; // eax
    void* v17; // edx
    unsigned __int16* v18; // edi
    unsigned int v19; // eax
    unsigned int v20; // eax
    unsigned int v21; // ecx
    int v22; // edx
    unsigned int v23; // edx
    unsigned int v24; // edx
    _BYTE* v25; // esi
    unsigned int v26; // ecx
    unsigned int v27; // eax
    char* v28; // eax
    char* v30; // edx
    unsigned int v31; // eax
    int v32; // ecx
    unsigned int v33; // [esp+Ch] [ebp-30h]
    unsigned int v34; // [esp+Ch] [ebp-30h]
    unsigned int v35; // [esp+10h] [ebp-2Ch]
    int v37; // [esp+18h] [ebp-24h]
    BOOL v38; // [esp+1Ch] [ebp-20h]
    BOOL v39; // [esp+20h] [ebp-1Ch]
    int v40; // [esp+24h] [ebp-18h]
    int v41; // [esp+24h] [ebp-18h]
    char v42; // [esp+28h] [ebp-14h]
    unsigned int v43; // [esp+28h] [ebp-14h]
    int v44; // [esp+2Ch] [ebp-10h]
    int v45; // [esp+2Ch] [ebp-10h]
    _BYTE* v46; // [esp+30h] [ebp-Ch]
    char* v47; // [esp+30h] [ebp-Ch]
    int v48; // [esp+34h] [ebp-8h]
    unsigned int v49; // [esp+38h] [ebp-4h]
    int v50; // [esp+44h] [ebp+8h]
    _BYTE* v51; // [esp+44h] [ebp+8h]
    unsigned int v52; // [esp+48h] [ebp+Ch]
    unsigned int v53; // [esp+48h] [ebp+Ch]
    unsigned int v54; // [esp+48h] [ebp+Ch]

    v3 = this;
    if (a3 < 0x12)
        return -2147467259;
    v5 = a2[1];
    if ((v5 & 0xFE) != 0)
        return -2147467259;
    v6 = a2[2];
    if ((v6 & 0xFFFFFFF4) != 0 || !*((_WORD*)a2 + 6) || !*((_WORD*)a2 + 7))
        return -2147467259;
    v7 = a2[7];
    v44 = 0;
    v8 = (unsigned int)(v7 + 7) >> 3;
    if (v5)
    {
        v9 = v7 - 15;
        if (v9)
        {
            v10 = v9 - 1;
            if (v10)
            {
                v11 = v10 - 8;
                if (v11)
                {
                    if (v11 != 8)
                        return -2147467259;
                    v44 = 21;
                }
                else
                {
                    v44 = 20;
                }
            }
            else
            {
                v44 = 25;
            }
        }
        else
        {
            v44 = 24;
        }
    }
    v12 = a2[16];
    v49 = (unsigned int)(v12 + 7) >> 3;
    if ((v6 & 3) == 1)
    {
        if (!a2[1] || a2[16] != 8)
            return -2147467259;
        v48 = 41;
    }
    else if ((v6 & 3) == 2)
    {
        v13 = v12 - 15;
        if (v13)
        {
            v14 = v13 - 1;
            if (v14)
            {
                v15 = v14 - 8;
                if (v15)
                {
                    if (v15 != 8)
                        return -2147467259;
                    v48 = 21;
                }
                else
                {
                    v48 = 20;
                }
            }
            else
            {
                v48 = 25;
            }
        }
        else
        {
            v48 = 24;
        }
    }
    else
    {
        if ((v6 & 3) != 3 || a2[16] != 8)
            return -2147467259;
        v48 = 50;
    }
    v37 = v6 & 8;
    v38 = (a2[17] & 0x20) == 32;
    v16 = *a2;
    v52 = a3 - 18;
    v39 = (a2[17] & 0x10) != 16;
    if (v52 < v16)
        return -2147467259;
    v53 = v52 - v16;
    v50 = (int)&a2[v16 + 18];
    v33 = v8 * *(unsigned __int16*)(a2 + 5);
    if (v53 < v33)
        return -2147467259;
    if (v48 == 41)
    {
        if (*(unsigned __int16*)(a2 + 5) + *(unsigned __int16*)(a2 + 3) > 256)
            return -2147467259;
        v17 = operator new(0x400u);
        v3[7] = (int)v17;
        if (!v17)
            return -2147024882;
        v3[9] = 1;
        memset(v17, 0xFFu, 0x400u);
        v18 = (unsigned __int16*)v50;
        v19 = v3[7] + 4 * *(unsigned __int16*)(a2 + 3);
        v46 = (_BYTE*)v19;
        v35 = v19 + 4 * *(unsigned __int16*)(a2 + 5);
        if (v19 < v35)
        {
            LOBYTE(v20) = v53;
            LOBYTE(v21) = v53;
            while (1)
            {
                LOBYTE(v22) = v42;
                if (v44 == 20)
                    break;
                switch (v44)
                {
                case 21:
                    LOBYTE(v21) = BYTE1(*(_DWORD*)v18);
                    v40 = HIBYTE(*(_DWORD*)v18);
                    LOBYTE(v20) = BYTE2(*(_DWORD*)v18);
                    LOBYTE(v22) = *(_DWORD*)v18;
                    v18 += 2;
                    goto LABEL_47;
                case 24:
                    v24 = *v18;
                    v20 = (8 * ((v24 >> 10) & 0x1F)) | (((v24 >> 10) & 0x1F) >> 2);
                    v21 = (8 * ((v24 >> 5) & 0x1F)) | (((v24 >> 5) & 0x1F) >> 2);
                    v22 = (8 * (v24 & 0x1F)) | ((unsigned __int8)(v24 & 0x1F) >> 2);
                    ++v18;
                LABEL_46:
                    LOBYTE(v40) = -1;
                    goto LABEL_47;
                case 25:
                    v40 = 255 * (*v18 >> 15);
                    v23 = *v18;
                    v20 = (8 * ((v23 >> 10) & 0x1F)) | (((v23 >> 10) & 0x1F) >> 2);
                    v21 = (8 * ((v23 >> 5) & 0x1F)) | (((v23 >> 5) & 0x1F) >> 2);
                    v22 = (8 * (v23 & 0x1F)) | ((unsigned __int8)(v23 & 0x1F) >> 2);
                    ++v18;
                LABEL_47:
                    v42 = v22;
                    break;
                }
                v25 = v46;
                v46 += 4;
                v25[2] = v22;
                v25[3] = v40;
                *v25 = v20;
                v25[1] = v21;
                if ((unsigned int)v46 >= v35)
                {
                    v3 = this;
                    goto LABEL_50;
                }
            }
            LOBYTE(v20) = *((_BYTE*)v18 + 2);
            LOBYTE(v21) = *((_BYTE*)v18 + 1);
            LOBYTE(v22) = *(_BYTE*)v18;
            v18 = (unsigned __int16*)((char*)v18 + 3);
            goto LABEL_46;
        }
    }
LABEL_50:
    v54 = v53 - v33;
    v26 = v33 + v50;
    v27 = v49 * *((unsigned __int16*)a2 + 6) * *((unsigned __int16*)a2 + 7);
    *v3 = v48;
    v3[1] = v33 + v50;
    v3[2] = v49 * *((unsigned __int16*)a2 + 6);
    v3[3] = 0;
    v3[4] = 0;
    v3[5] = *((unsigned __int16*)a2 + 6);
    v51 = (_BYTE*)(v33 + v50);
    v3[6] = *((unsigned __int16*)a2 + 7);
    if (v37 || !v38 || !v39)
    {
        v28 = (char*)operator new(v27);
        v3[1] = (int)v28;
        if (v28)
        {
            v3[8] = 1;
            if (v38)
                v30 = v28;
            else
                v30 = &v28[v3[2] * (*((unsigned __int16*)a2 + 7) - 1)];
            v45 = 0;
            if (!*((_WORD*)a2 + 7))
                return 0;
            while (1)
            {
                v47 = v39 ? v30 : &v30[v3[2] - v49];
                v31 = *((unsigned __int16*)a2 + 6);
                v43 = 0;
                if (*((_WORD*)a2 + 6))
                    break;
            LABEL_81:
                if (v38)
                    v30 += v3[2];
                else
                    v30 -= v3[2];
                if (++v45 >= (unsigned int)*((unsigned __int16*)a2 + 7))
                    return 0;
            }
            while (1)
            {
                if (v37)
                {
                    if (!v54)
                        return -2147467259;
                    v32 = *v51 & 0x80;
                    v31 = (*v51++ & 0x7F) + 1;
                    --v54;
                    v41 = v32;
                }
                else
                {
                    v41 = 0;
                }
                v43 += v31;
                if (v31)
                    break;
            LABEL_78:
                if (v41)
                {
                    v51 += v49;
                    v54 -= v49;
                }
                v31 = *((unsigned __int16*)a2 + 6);
                if (v43 >= v31)
                    goto LABEL_81;
            }
            while (1)
            {
                v34 = v31 - 1;
                if (v54 < v49)
                    return -2147467259;
                qmemcpy(v47, v51, v49);
                if (!v41)
                {
                    v51 += v49;
                    v54 -= v49;
                }
                if (v39)
                    v47 += v49;
                else
                    v47 -= v49;
                --v31;
                if (!v34)
                {
                    v3 = this;
                    goto LABEL_78;
                }
            }
        }
        return -2147024882;
    }
    if (v54 >= v27)
    {
        v3[1] = v26;
        v3[8] = 0;
        return 0;
    }
    return -2147467259;
}
// 471BAB: variable 'v42' is possibly undefined
// 471C8D: variable 'v40' is possibly undefined

//----- (00471E3C) --------------------------------------------------------
unsigned int __thiscall sub_471E3C(_DWORD* this, _BYTE* a2, unsigned int a3)
{
    _BYTE* v4; // edi
    bool v5; // zf
    int v6; // ebx
    int v7; // ecx
    _BYTE* v8; // eax
    unsigned __int8* v10; // edi
    unsigned __int8 v11; // al
    int v12; // [esp+Ch] [ebp-18h]
    int v13; // [esp+10h] [ebp-14h]
    _BYTE* v14; // [esp+14h] [ebp-10h]
    _BYTE* v15; // [esp+18h] [ebp-Ch]
    unsigned int v16; // [esp+1Ch] [ebp-8h]
    int v17; // [esp+20h] [ebp-4h]
    unsigned int v18; // [esp+30h] [ebp+Ch]
    unsigned int v19; // [esp+30h] [ebp+Ch]

    if (a3 < 2 || *a2 != 80)
        return -2147467259;
    if (a2[1] == 51)
    {
        v12 = 1;
    }
    else
    {
        if (a2[1] != 54)
            return -2147467259;
        v12 = 0;
    }
    v4 = a2 + 2;
    v5 = a3 == 2;
    v18 = a3 - 2;
    v6 = 0;
    v15 = a2 + 2;
    v17 = 0;
    v13 = 0;
    v16 = 255;
    if (v5)
        return -2147467259;
    while (v12 || v17 != 3)
    {
        if (!isspace((unsigned __int8)*v4))
        {
            if (*v4 != 35)
            {
                if (v18)
                {
                    do
                    {
                        if (isspace((unsigned __int8)*v4))
                            break;
                        if (!isdigit((unsigned __int8)*v4))
                            return -2147467259;
                        v7 = (unsigned __int8)*v4++;
                        v5 = v18-- == 1;
                        v6 = v7 + 10 * v6 - 48;
                        v15 = v4;
                    } while (!v5);
                }
                if (v17)
                {
                    if (v17 == 1)
                    {
                        if (!v6)
                            return -2147467259;
                        v8 = operator new(4 * v13 * v6);
                        this[1] = v8;
                        if (!v8)
                            return -2147024882;
                        this[3] = 0;
                        a2 = v8;
                        this[4] = 0;
                        v14 = &v8[4 * v13 * v6];
                        v4 = v15;
                        this[8] = 1;
                        *this = 22;
                        this[2] = 4 * v13;
                        this[5] = v13;
                        this[6] = v6;
                        goto LABEL_38;
                    }
                    if (v17 != 2)
                    {
                        switch (v17)
                        {
                        case 3:
                            if (a2 >= v14)
                                return -2147467259;
                            *(_DWORD*)a2 = ((255 * v6 / v16) | 0xFFFFFF00) << 16;
                            break;
                        case 4:
                            *(_DWORD*)a2 |= (255 * v6 / v16) << 8;
                            break;
                        case 5:
                            *(_DWORD*)a2 |= 255 * v6 / v16;
                            a2 += 4;
                            if (a2 == v14)
                                return 0;
                            v17 = 2;
                            break;
                        }
                        goto LABEL_38;
                    }
                    v16 = v6;
                }
                else
                {
                    v13 = v6;
                }
                if (!v6)
                    return -2147467259;
            LABEL_38:
                ++v17;
                goto LABEL_39;
            }
            for (; v18; --v18)
            {
                if (*v4 == 10)
                    break;
                ++v4;
            }
        }
        ++v4;
        --v18;
        v15 = v4;
    LABEL_39:
        v6 = 0;
        if (!v18)
            return -2147467259;
    }
    if (v16 > 0xFF)
        return -2147467259;
    if (v18 > 1 && *v4 == 13)
    {
        ++v4;
        --v18;
    }
    v10 = v4 + 1;
    v19 = v18 - 1;
    if (v19)
    {
        do
        {
            if (a2 >= v14)
                break;
            v11 = 255 * (unsigned int)*v10 / v16;
            v10 += 3;
            *(_DWORD*)a2 = (255 * (unsigned int)*(v10 - 1) / v16)
                | (((255 * (unsigned int)*(v10 - 2) / v16) | ((v11 | 0xFFFFFF00) << 8)) << 8);
            v5 = v19 == 3;
            v19 -= 3;
            a2 += 4;
        } while (!v5);
    }
    return v14 != a2 ? 0x80004005 : 0;
}
// 471E6F: conditional instruction was optimized away because al.1==50
// 471F5A: variable 'v14' is possibly undefined

//----- (004720BE) --------------------------------------------------------
unsigned int __cdecl sub_4720BE(jmp_buf Buf, void* a2, unsigned int a3)
{
    int v3; // ebx
    unsigned int result; // eax

    v3 = Buf[21];
    if (a3 > *(_DWORD*)(v3 + 4))
        sub_478AEB(Buf, (int)"read error");
    qmemcpy(a2, *(const void**)v3, a3);
    result = a3;
    *(_DWORD*)v3 += a3;
    *(_DWORD*)(v3 + 4) -= a3;
    return result;
}

//----- (00472101) --------------------------------------------------------
void __cdecl __noreturn sub_472101(jmp_buf Buf, const char* ArgList)
{
    sub_46D8FD(0, "LoadPNG: %s", ArgList);
    longjmp(Buf, 1);
}

//----- (00472121) --------------------------------------------------------
void __cdecl sub_472121(int a1, const char* ArgList)
{
    sub_46D8FD(0, "LoadPNG: %s", ArgList);
}

//----- (00472138) --------------------------------------------------------
int __thiscall sub_472138(_DWORD* this, int a2, unsigned int a3)
{
    int* v4; // eax
    _DWORD* v5; // esi
    unsigned __int8 v6; // al
    int v7; // esi
    unsigned int v8; // eax
    int v9; // eax
    void* v10; // eax
    void* v11; // ecx
    unsigned int i; // eax
    double v13; // st7
    __int64 v14; // rax
    int v15; // ecx
    bool v16; // cc
    int j; // eax
    void* v18; // eax
    int v19; // eax
    int v20; // edi
    int v21; // ecx
    char v22; // bl
    int v23; // edi
    int v24; // ecx
    int v25; // eax
    int* __attribute__((__org_typedef(jmp_buf))) v26; // [esp+8h] [ebp-168h]
    int v27; // [esp+Ch] [ebp-164h]
    unsigned int v28; // [esp+Ch] [ebp-164h]
    _BYTE v29[256]; // [esp+1Ch] [ebp-154h]
    double v30; // [esp+11Ch] [ebp-54h] BYREF
    long double v31; // [esp+124h] [ebp-4Ch]
    _DWORD v32[2]; // [esp+12Ch] [ebp-44h] BYREF
    int v33; // [esp+134h] [ebp-3Ch] BYREF
    _DWORD* v34; // [esp+138h] [ebp-38h]
    unsigned int v35; // [esp+13Ch] [ebp-34h] BYREF
    int v36; // [esp+140h] [ebp-30h] BYREF
    int v37; // [esp+144h] [ebp-2Ch] BYREF
    int v38; // [esp+148h] [ebp-28h] BYREF
    int v39; // [esp+14Ch] [ebp-24h] BYREF
    int v40; // [esp+150h] [ebp-20h] BYREF
    LPVOID v41; // [esp+154h] [ebp-1Ch]
    int v42; // [esp+158h] [ebp-18h]
    unsigned int v43; // [esp+15Ch] [ebp-14h] BYREF
    int v44; // [esp+160h] [ebp-10h] BYREF
    int v45; // [esp+164h] [ebp-Ch]
    int v46; // [esp+168h] [ebp-8h] BYREF
    int* __attribute__((__org_typedef(jmp_buf))) Buf; // [esp+16Ch] [ebp-4h] BYREF

    v34 = this;
    Buf = 0;
    v46 = 0;
    v41 = 0;
    if (sub_47AE90(a2, 0, a3))
        return -2147467259;
    v4 = sub_478B71("1.0.5", 0, (int)sub_472101, (int)sub_472121);
    Buf = v4;
    if (!v4)
        goto LABEL_67;
    v46 = (int)sub_47AFA4((int)v4);
    if (!v46)
        goto LABEL_67;
    if (!_setjmp3(Buf, 0))
    {
        v32[0] = a2;
        v32[1] = a3;
        sub_47AE50(Buf, (int)v32, (int(__cdecl*)(int, int))sub_4720BE);
        sub_478C74(Buf, v46);
        sub_479447((int)Buf, v46, &v35, &v43, &v39, &v37, 0, 0, 0);
        v5 = v34;
        if (v37)
        {
            switch (v37)
            {
            case 2:
                *v34 = 20;
                break;
            case 3:
                *v34 = 41;
                break;
            case 4:
                *v34 = 51;
                break;
            case 6:
                *v34 = 21;
                break;
            }
        }
        else
        {
            *v34 = 50;
        }
        if (v39 == 16)
            sub_479705((int)Buf);
        if (v39 < 8)
            sub_4795BF((int)Buf);
        if (!v37 && v39 < 8)
            sub_479748((int)Buf);
        if (sub_47941A((int)Buf, v46, &v36))
        {
            sub_47AD90((int)Buf, v46, v36);
        }
        else if (sub_4793EF((int)Buf, v46, &v30))
        {
            sub_479711((int)Buf, 2.2, v30);
        }
        if (*v5 != 41 && sub_4793A1((int)Buf, v46, 16))
        {
            sub_479748((int)Buf);
            if (*v5 == 20)
            {
                *v5 = 21;
            }
            else if (*v5 == 50)
            {
                *v5 = 51;
            }
        }
        if (*v5 == 20 || *v5 == 21)
            sub_4795B3((int)Buf);
        if (*v5 == 20)
        {
            sub_4795F8((int)Buf, 0xFFu, 1);
            *v5 = 22;
        }
        sub_478DE7(Buf, v46);
        switch (*v5)
        {
        case 0x14:
            v45 = 3;
            break;
        case 0x15:
        case 0x16:
            v45 = 4;
            break;
        case 0x29:
        case 0x32:
            v45 = 1;
            break;
        case 0x33:
            v45 = 2;
            break;
        }
        v6 = sub_4793D6((int)Buf, v46);
        if (v45 == v6)
        {
            v27 = v46;
            v5[5] = v35;
            v8 = v43;
            v26 = Buf;
            v5[3] = 0;
            v5[4] = 0;
            v5[6] = v8;
            v9 = sub_4793BD((int)v26, v27);
            v5[2] = v9;
            v10 = operator new(v43 * v9);
            v5[1] = v10;
            if (v10)
            {
                v28 = 4 * v43;
                v5[8] = 1;
                v11 = operator new(v28);
                v41 = v11;
                if (v11)
                {
                    for (i = 0; i < v43; ++i)
                        *((_DWORD*)v11 + i) = v5[1] + i * v5[2];
                    sub_4791B0(Buf, (char**)v11);
                    if (*v5 == 41)
                    {
                        v38 = 0;
                        v40 = 0;
                        if (sub_4793A1((int)Buf, v46, 8))
                            sub_479518((int)Buf, v46, &v44, &v40);
                        if (sub_4793A1((int)Buf, v46, 16))
                            sub_47954C((int)Buf, v46, &v33, &v38, 0);
                        if (*((float*)Buf + 76) <= 0.000001 || *((float*)Buf + 77) <= 0.000001)
                        {
                            for (j = 0; j < 256; ++j)
                                v29[j] = j;
                        }
                        else
                        {
                            v13 = *((float*)Buf + 76);
                            v42 = 0;
                            v31 = 1.0 / (v13 * *((float*)Buf + 77));
                            do
                            {
                                v14 = (__int64)(pow((double)v42 * 0.00392156862745098, v31) * 255.0 + 0.5);
                                v15 = v42++;
                                v16 = v42 < 256;
                                v29[v15] = v14;
                            } while (v16);
                        }
                        v18 = operator new(0x400u);
                        v5[7] = v18;
                        if (!v18)
                            goto LABEL_67;
                        v19 = 0;
                        v16 = v38 <= 0;
                        v5[9] = 1;
                        if (!v16)
                        {
                            v20 = 0;
                            do
                            {
                                v21 = 4 * v19;
                                *(_BYTE*)(v21 + v5[7]) = v29[*(unsigned __int8*)(v20 + v44)];
                                *(_BYTE*)(v21 + v5[7] + 1) = v29[*(unsigned __int8*)(v20 + v44 + 1)];
                                *(_BYTE*)(v21 + v5[7] + 2) = v29[*(unsigned __int8*)(v20 + v44 + 2)];
                                v22 = *(_BYTE*)(v19 + v33);
                                ++v19;
                                *(_BYTE*)(v21 + v5[7] + 3) = v22;
                                v20 += 3;
                            } while (v19 < v38);
                        }
                        if (v19 < v40)
                        {
                            v23 = 3 * v19;
                            do
                            {
                                v24 = 4 * v19;
                                *(_BYTE*)(v24 + v5[7]) = v29[*(unsigned __int8*)(v23 + v44)];
                                *(_BYTE*)(v24 + v5[7] + 1) = v29[*(unsigned __int8*)(v23 + v44 + 1)];
                                *(_BYTE*)(v24 + v5[7] + 2) = v29[*(unsigned __int8*)(v23 + v44 + 2)];
                                *(_BYTE*)(v24 + v5[7] + 3) = -1;
                                ++v19;
                                v23 += 3;
                            } while (v19 < v40);
                        }
                        if (v19 < 256)
                        {
                            v25 = 4 * v19;
                            do
                            {
                                *(_BYTE*)(v25 + v5[7]) = -1;
                                *(_BYTE*)(v25 + v5[7] + 1) = -1;
                                *(_BYTE*)(v25 + v5[7] + 2) = -1;
                                *(_BYTE*)(v25 + v5[7] + 3) = -1;
                                v25 += 4;
                            } while (v25 < 1024);
                        }
                    }
                    v7 = 0;
                    goto LABEL_78;
                }
            }
        LABEL_67:
            v7 = -2147024882;
            goto LABEL_78;
        }
    }
    v7 = -2147467259;
LABEL_78:
    if (Buf)
        sub_479320((void**)&Buf, (void**)&v46, 0);
    if (v41)
        sub_4885A6(v41);
    return v7;
}
// 48B798: using guessed type int __cdecl _setjmp3(_DWORD, _DWORD);

//----- (0047264E) --------------------------------------------------------
int __thiscall sub_47264E(_DWORD* this, _DWORD* a2, unsigned int a3)
{
    _DWORD* v3; // edx
    int v5; // ecx
    int v6; // ecx
    int v7; // esi
    int v8; // ecx
    _DWORD* v9; // eax
    _DWORD* v10; // eax
    _DWORD* v11; // eax
    _DWORD* v12; // eax
    int v13; // ecx
    int v14; // ebx
    unsigned int v15; // ebx
    int v16; // [esp+8h] [ebp-34h]
    int v17; // [esp+Ch] [ebp-30h]
    int v18; // [esp+10h] [ebp-2Ch]
    int v19; // [esp+14h] [ebp-28h]
    unsigned int v21; // [esp+1Ch] [ebp-20h]
    unsigned int v22; // [esp+20h] [ebp-1Ch]
    _DWORD* v23; // [esp+24h] [ebp-18h]
    _DWORD* v24; // [esp+28h] [ebp-14h]
    _DWORD* v25; // [esp+2Ch] [ebp-10h]
    int v26; // [esp+30h] [ebp-Ch]
    int v27; // [esp+34h] [ebp-8h]
    int v28; // [esp+44h] [ebp+8h]
    unsigned int v29; // [esp+48h] [ebp+Ch]
    unsigned int v30; // [esp+48h] [ebp+Ch]

    v3 = this;
    if (a3 < 4)
        return -2147467259;
    if (*a2 != 542327876)
        return -2147467259;
    v29 = a3 - 4;
    if (v29 < 0x7C)
        return -2147467259;
    v30 = v29 - 124;
    v23 = a2 + 32;
    this[3] = 0;
    this[4] = 0;
    this[5] = a2[4];
    this[6] = a2[3];
    v5 = a2[28] & 0xFC00;
    if (v5 == 64512)
    {
        v21 = 6;
    }
    else
    {
        if (v5)
        {
            sub_46D8FD(0, "LoadDDS: Partial cubemaps not supported.");
            return -2147467259;
        }
        v21 = 1;
    }
    v22 = a2[7];
    if (!v22)
        v22 = 1;
    v6 = a2[21];
    v7 = 827611204;
    if (v6 == 827611204
        || (v7 = 844388420, v6 == 844388420)
        || (v7 = 861165636, v6 == 861165636)
        || (v7 = 877942852, v6 == 877942852)
        || (v7 = 894720068, v6 == 894720068))
    {
        v28 = v7;
    LABEL_38:
        v26 = 0;
        while (1)
        {
            v16 = v3[3];
            v17 = v3[4];
            v18 = v3[5];
            v19 = v3[6];
            if (v26)
            {
                v9 = operator new(0x30u);
                if (v9)
                    v10 = sub_470F78(v9);
                else
                    v10 = 0;
                if (!v10)
                    return -2147024882;
                v3 = this;
                v25[11] = v10;
                v25 = v10;
            }
            else
            {
                v25 = v3;
            }
            v27 = 0;
            if (v22)
            {
                while (1)
                {
                    if (v27)
                    {
                        v12 = operator new(0x30u);
                        if (v12)
                            v11 = sub_470F78(v12);
                        else
                            v11 = 0;
                        if (!v11)
                            return -2147024882;
                        v3 = this;
                        v24[10] = v11;
                        v24 = v11;
                    }
                    else
                    {
                        v11 = v25;
                        v24 = v25;
                    }
                    if (v28 >= 844388420)
                        break;
                    if (v28 <= 22)
                    {
                        v13 = 4 * v18;
                    }
                    else
                    {
                        if (v28 > 26)
                        {
                            v13 = 8 * ((v18 + 3) >> 2);
                        LABEL_62:
                            v14 = (v19 + 3) >> 2;
                            goto LABEL_63;
                        }
                        v13 = 2 * v18;
                    }
                    v14 = v19;
                LABEL_63:
                    v15 = v13 * v14;
                    v11[3] = v16;
                    *v11 = v28;
                    v11[4] = v17;
                    v11[1] = v23;
                    v11[5] = v18;
                    v11[2] = v13;
                    v11[6] = v19;
                    v11[7] = 0;
                    v11[8] = 0;
                    v11[9] = 0;
                    if (v30 < v15)
                        return -2147467259;
                    v23 = (_DWORD*)((char*)v23 + v15);
                    v30 -= v15;
                    if (v18 == 1)
                        v18 = 1;
                    else
                        v18 >>= 1;
                    if (v19 == 1)
                        v19 = 1;
                    else
                        v19 >>= 1;
                    if (++v27 >= v22)
                        goto LABEL_71;
                }
                v13 = 16 * ((v18 + 3) >> 2);
                goto LABEL_62;
            }
        LABEL_71:
            if (++v26 >= v21)
                return 0;
        }
    }
    v8 = a2[20];
    if (v8 == 65 && a2[22] == 32 && a2[26] == -16777216)
    {
        v28 = 21;
        goto LABEL_38;
    }
    if (v8 == 64 && a2[22] == 32)
    {
        v28 = 22;
        goto LABEL_38;
    }
    if (v8 == 64)
    {
        if (a2[22] == 16 && a2[24] == 2016)
        {
            v28 = 23;
            goto LABEL_38;
        }
        if (a2[22] == 16 && a2[24] == 992)
        {
            v28 = 24;
            goto LABEL_38;
        }
    }
    if (v8 == 65)
    {
        if (a2[22] == 16 && a2[26] == 0x8000)
        {
            v28 = 25;
            goto LABEL_38;
        }
        if (a2[22] == 16 && a2[26] == 61440)
        {
            v28 = 26;
            goto LABEL_38;
        }
    }
    sub_46D8FD(0, "LoadDDS: Unsupported pixel format");
    return -2147467259;
}
// 47276F: conditional instruction was optimized away because ecx.4==40
// 4727AB: conditional instruction was optimized away because ecx.4==41
// 4727D4: conditional instruction was optimized away because %var_20.4 is in (==1|==6)
// 472874: conditional instruction was optimized away because %arg_0.4 is in (15..1A|==31545844)
// 472886: conditional instruction was optimized away because %arg_0.4==31545844
// 4728BE: conditional instruction was optimized away because %arg_0.4==35545844
// 472818: variable 'v25' is possibly undefined
// 47285D: variable 'v24' is possibly undefined

//----- (00472972) --------------------------------------------------------
int __thiscall sub_472972(int* this, int a2, unsigned int a3)
{
    if (a3 >= 0xE && *(_WORD*)a2 == 19778 && *(_DWORD*)(a2 + 2) <= a3)
        return sub_471009(this, a2 + 14, a3 - 14);
    else
        return -2147467259;
}

//----- (004729A4) --------------------------------------------------------
int __thiscall sub_4729A4(int this, unsigned __int8* a2, unsigned int a3, _DWORD* a4)
{
    int v4; // edi
    unsigned int v6; // eax
    void* v7; // ecx
    void* v8; // ecx
    _DWORD* i; // eax
    int v11; // [esp+Ch] [ebp-4h]

    v4 = a3;
    v11 = 0;
    do
    {
        switch (v11)
        {
        case 0:
            v6 = sub_472972((int*)this, (int)a2, a3);
            goto LABEL_16;
        case 1:
            v6 = sub_471E3C((_DWORD*)this, a2, a3);
            goto LABEL_16;
        case 2:
            v6 = sub_47264E((_DWORD*)this, a2, a3);
            goto LABEL_16;
        case 3:
            v6 = sub_471771((_DWORD*)this, (int)a2, a3);
            goto LABEL_16;
        case 4:
            v6 = sub_472138((_DWORD*)this, (int)a2, a3);
            goto LABEL_16;
        case 5:
            v6 = sub_4719C6((int*)this, a2, a3);
            goto LABEL_16;
        case 6:
            v6 = sub_471009((int*)this, (int)a2, a3);
        LABEL_16:
            v4 = v6;
            break;
        }
        if (v4 >= 0)
            break;
        if (*(_DWORD*)(this + 4) && *(_DWORD*)(this + 32))
            sub_4885A6(*(LPVOID*)(this + 4));
        if (*(_DWORD*)(this + 28) && *(_DWORD*)(this + 36))
            sub_4885A6(*(LPVOID*)(this + 28));
        v7 = *(void**)(this + 40);
        if (v7)
            sub_470FEA(v7, 1);
        v8 = *(void**)(this + 44);
        if (v8)
            sub_470FEA(v8, 1);
        ++v11;
        *(_DWORD*)(this + 4) = 0;
        *(_DWORD*)(this + 28) = 0;
        *(_DWORD*)(this + 32) = 0;
        *(_DWORD*)(this + 36) = 0;
        *(_DWORD*)(this + 40) = 0;
        *(_DWORD*)(this + 44) = 0;
    } while (v11 < 7);
    if (v11 == 7)
    {
        sub_46D8FD(0, "Unsupported file format");
        return -2005529767;
    }
    else
    {
        if (a4)
        {
            *a4 = 0;
            a4[1] = 0;
            a4[2] = 0;
            a4[3] = 0;
            a4[4] = 0;
            *a4 = *(_DWORD*)(this + 20);
            a4[1] = *(_DWORD*)(this + 24);
            a4[2] = 1;
            a4[3] = 1;
            a4[4] = *(_DWORD*)this;
            for (i = (_DWORD*)(this + 40); *i; i = (_DWORD*)(*i + 40))
                ++a4[3];
        }
        return 0;
    }
}

//----- (00472AF9) --------------------------------------------------------
_DWORD* __thiscall sub_472AF9(_DWORD* this)
{
    _DWORD* result; // eax

    result = this;
    *this = -1;
    this[1] = -1;
    this[2] = 0;
    this[3] = 0;
    return result;
}

//----- (00472B0B) --------------------------------------------------------
int __thiscall sub_472B0B(int this, const WCHAR* lpWideCharStr, LPSTR lpMultiByteStr)
{
    void* v5; // esp
    HANDLE FileW; // eax
    HANDLE FileMappingA; // eax
    LPVOID v8; // eax
    DWORD FileSize; // eax
    DWORD LastError; // eax
    CHAR v11[12]; // [esp+0h] [ebp-A8h] BYREF
    _OSVERSIONINFOA VersionInformation; // [esp+Ch] [ebp-9Ch] BYREF
    int cbMultiByte; // [esp+A0h] [ebp-8h]
    CHAR Buffer[4]; // [esp+A4h] [ebp-4h] BYREF

    if (lpWideCharStr)
    {
        if (!lpMultiByteStr)
            goto LABEL_8;
        VersionInformation.dwOSVersionInfoSize = 148;
        GetVersionExA(&VersionInformation);
        if (VersionInformation.dwPlatformId != 2)
        {
            cbMultiByte = WideCharToMultiByte(0, 0, lpWideCharStr, -1, 0, 0, 0, 0);
            v5 = alloca(cbMultiByte);
            WideCharToMultiByte(0, 0, lpWideCharStr, -1, v11, cbMultiByte, 0, 0);
            lpWideCharStr = (const WCHAR*)v11;
            lpMultiByteStr = 0;
        }
        if (lpMultiByteStr)
            FileW = CreateFileW(lpWideCharStr, 0x80000000, 1u, 0, 3u, 0x10000000u, 0);
        else
            LABEL_8:
        FileW = CreateFileA((LPCSTR)lpWideCharStr, 0x80000000, 1u, 0, 3u, 0x10000000u, 0);
        *(_DWORD*)this = FileW;
        if (FileW == (HANDLE)-1
            || (FileMappingA = CreateFileMappingA(FileW, 0, 2u, 0, 0, 0),
                *(_DWORD*)(this + 4) = FileMappingA,
                FileMappingA == (HANDLE)-1)
            || (v8 = MapViewOfFile(FileMappingA, 4u, 0, 0, 0), (*(_DWORD*)(this + 8) = v8) == 0)
            || (FileSize = GetFileSize(*(HANDLE*)this, 0), *(_DWORD*)(this + 12) = FileSize, FileSize == -1))
        {
            LastError = GetLastError();
            FormatMessageA(0x1100u, 0, LastError, 0, Buffer, 0, 0);
            sub_46D8FD(0, "%s", *(const char**)Buffer);
            LocalFree(*(HLOCAL*)Buffer);
            return -2005529767;
        }
        else
        {
            return 0;
        }
    }
    else
    {
        sub_46D8FD(0, "Invalid file name");
        return -2005530516;
    }
}

//----- (00472C9E) --------------------------------------------------------
void __thiscall sub_472C9E(int this)
{
    const void* v2; // eax

    if (*(_DWORD*)this != -1)
    {
        v2 = *(const void**)(this + 8);
        if (v2)
        {
            UnmapViewOfFile(v2);
            *(_DWORD*)(this + 8) = 0;
            *(_DWORD*)(this + 12) = 0;
        }
        if (*(_DWORD*)(this + 4) != -1)
        {
            CloseHandle(*(HANDLE*)(this + 4));
            *(_DWORD*)(this + 4) = -1;
        }
        if (*(_DWORD*)this != -1)
        {
            CloseHandle(*(HANDLE*)this);
            *(_DWORD*)this = -1;
        }
    }
}

//----- (00472CA9) --------------------------------------------------------
float* __stdcall sub_472CA9(float* a1, float* a2, float* a3)
{
    double v3; // st5
    double v4; // st6
    double v5; // st7

    if (!a1 || !a2 || !a3)
        return 0;
    v3 = *a2 * a3[1] + a2[1] * a3[5] + a3[13];
    v4 = *a2 * a3[2] + a2[1] * a3[6] + a3[14];
    v5 = *a2 * a3[3] + a2[1] * a3[7] + a3[15];
    *a1 = *a2 * *a3 + a2[1] * a3[4] + a3[12];
    a1[1] = v3;
    a1[2] = v4;
    a1[3] = v5;
    return a1;
}

//----- (00472D27) --------------------------------------------------------
float* __stdcall sub_472D27(float* a1, float* a2, float* a3)
{
    double v3; // st7

    if (!a1 || !a2 || !a3)
        return 0;
    v3 = *a2 * a3[1] + a2[1] * a3[5];
    *a1 = *a2 * *a3 + a2[1] * a3[4];
    a1[1] = v3;
    return a1;
}

//----- (00472D71) --------------------------------------------------------
float* __stdcall sub_472D71(float* a1, float* a2, float* a3)
{
    double v3; // st5
    double v4; // st6
    double v5; // st7

    if (!a1 || !a2 || !a3)
        return 0;
    v3 = *a2 * a3[1] + a2[1] * a3[5] + a2[2] * a3[9] + a3[13];
    v4 = *a2 * a3[2] + a2[1] * a3[6] + a2[2] * a3[10] + a3[14];
    v5 = *a2 * a3[3] + a2[1] * a3[7] + a2[2] * a3[11] + a3[15];
    *a1 = *a2 * *a3 + a2[1] * a3[4] + a2[2] * a3[8] + a3[12];
    a1[1] = v3;
    a1[2] = v4;
    a1[3] = v5;
    return a1;
}

//----- (00472E1D) --------------------------------------------------------
float* __stdcall sub_472E1D(float* a1, float* a2, float* a3)
{
    double v3; // st6
    double v4; // st7

    if (!a1 || !a2 || !a3)
        return 0;
    v3 = *a2 * a3[1] + a2[1] * a3[5] + a2[2] * a3[9];
    v4 = *a2 * a3[2] + a2[1] * a3[6] + a2[2] * a3[10];
    *a1 = *a2 * *a3 + a2[1] * a3[4] + a2[2] * a3[8];
    a1[1] = v3;
    a1[2] = v4;
    return a1;
}

//----- (00472E91) --------------------------------------------------------
float* __stdcall sub_472E91(float* a1, float* a2, float* a3)
{
    double v3; // st5
    double v4; // st6
    double v5; // st7

    if (!a1 || !a2 || !a3)
        return 0;
    v3 = *a2 * a3[1] + a2[1] * a3[5] + a2[2] * a3[9] + a2[3] * a3[13];
    v4 = *a2 * a3[2] + a2[1] * a3[6] + a2[2] * a3[10] + a2[3] * a3[14];
    v5 = *a2 * a3[3] + a2[1] * a3[7] + a2[2] * a3[11] + a2[3] * a3[15];
    *a1 = *a2 * *a3 + a2[1] * a3[4] + a2[2] * a3[8] + a2[3] * a3[12];
    a1[1] = v3;
    a1[2] = v4;
    a1[3] = v5;
    return a1;
}

//----- (00472F4B) --------------------------------------------------------
_BYTE* __stdcall sub_472F4B(_BYTE* a1, _BYTE* a2, _BYTE* a3)
{
    _BYTE* result; // eax
    _BYTE* v4; // ebx
    _BYTE* v10; // ebx
    int v13; // edi
    _BYTE v16[64]; // [esp+Ch] [ebp-40h] BYREF

    result = a1;
    if (!a1 || !a2 || !a3)
        return 0;
    if (a3 == a1)
    {
        if (a2 != a1)
        {
            v4 = a1;
            _ECX = a2;
            _EDX = a3;
            _EDI = -4;
            do
            {
                _ESI = -16;
                __asm
                {
                    fld     dword ptr[edx + edi * 4 + 10h]
                    fld     dword ptr[edx + edi * 4 + 20h]
                    fld     dword ptr[edx + edi * 4 + 30h]
                    fld     dword ptr[edx + edi * 4 + 40h]
                }
                do
                {
                    __asm
                    {
                        fld     st(3)
                        fmul    dword ptr[ecx + esi * 4 + 40h]
                        fld     st(3)
                        fmul    dword ptr[ecx + esi * 4 + 44h]
                        fld     st(3)
                        fmul    dword ptr[ecx + esi * 4 + 48h]
                        fld     st(3)
                        fmul    dword ptr[ecx + esi * 4 + 4Ch]
                        fxch    st(3)
                        faddp   st(1), st
                        fxch    st(2)
                        faddp   st(1), st
                        faddp   st(1), st
                        fstp    dword ptr[ebx + esi * 4 + 40h]
                    }
                    *(float*)&v4[4 * _ESI + 64] = _ET1;
                    _ESI += 4;
                } while (_ESI);
                __asm
                {
                    ffree   st(3)
                    ffree   st(2)
                    ffree   st(1)
                    ffree   st
                }
                v4 += 4;
                ++_EDI;
            } while (_EDI);
            return result;
        }
        qmemcpy(v16, a3, sizeof(v16));
        a3 = v16;
    }
    v10 = a1;
    _ECX = a2;
    _EDX = a3;
    v13 = -4;
    do
    {
        _ESI = -4;
        __asm
        {
            fld     dword ptr[ecx]
            fld     dword ptr[ecx + 4]
            fld     dword ptr[ecx + 8]
            fld     dword ptr[ecx + 0Ch]
        }
        do
        {
            __asm
            {
                fld     st(3)
                fmul    dword ptr[edx + esi * 4 + 10h]
                fld     st(3)
                fmul    dword ptr[edx + esi * 4 + 20h]
                fld     st(3)
                fmul    dword ptr[edx + esi * 4 + 30h]
                fld     st(3)
                fmul    dword ptr[edx + esi * 4 + 40h]
                fxch    st(3)
                faddp   st(1), st
                fxch    st(2)
                faddp   st(1), st
                faddp   st(1), st
                fstp    dword ptr[ebx + esi * 4 + 10h]
            }
            *(float*)&v10[4 * _ESI++ + 16] = _ET1;
        } while (_ESI);
        __asm
        {
            ffree   st(3)
            ffree   st(2)
            ffree   st(1)
            ffree   st
        }
        _ECX += 16;
        v10 += 16;
        ++v13;
    } while (v13);
    return result;
}
// 472F90: inconsistent fpu stack

//----- (0047304C) --------------------------------------------------------
BOOL __thiscall sub_47304C(float* this, float* a2)
{
    return *this == *a2 && this[1] == a2[1] && this[2] == a2[2] && this[3] == a2[3];
}

//----- (00473099) --------------------------------------------------------
char* __thiscall sub_473099(_DWORD* this, int a2, int a3, float* a4)
{
    char* result; // eax
    char* i; // edx
    int v7; // [esp+8h] [ebp+8h]

    result = (char*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    for (i = &result[2 * this[1044]]; result < i; *(a4 - 1) = 1.0)
    {
        v7 = *result;
        result += 2;
        *a4 = (double)v7 * 0.0078125;
        a4 += 4;
        *(a4 - 3) = (double)*(result - 1) * 0.0078125;
        *(a4 - 2) = 0.0;
    }
    return result;
}

//----- (00473102) --------------------------------------------------------
_BYTE* __thiscall sub_473102(_DWORD* this, int a2, int a3, float* a4)
{
    _BYTE* result; // eax
    _BYTE* i; // esi
    int v7; // [esp+Ch] [ebp+8h]
    int v8; // [esp+Ch] [ebp+8h]

    result = (_BYTE*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    for (i = &result[2 * this[1044]]; result < i; *(a4 - 1) = (double)v8 * 0.015873017)
    {
        v7 = (char)(8 * (*(unsigned __int16*)result >> 5)) >> 3;
        *a4 = (double)((char)(8 * *result) >> 3) * 0.0625;
        a4 += 4;
        *(a4 - 3) = (double)v7 * 0.0625;
        *(a4 - 2) = 0.0;
        v8 = *(_WORD*)result >> 10;
        result += 2;
    }
    return result;
}

//----- (00473198) --------------------------------------------------------
char* __thiscall sub_473198(_DWORD* this, int a2, int a3, float* a4)
{
    char* result; // eax
    char* i; // edx
    int v7; // [esp+8h] [ebp+8h]

    result = (char*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    for (i = &result[4 * this[1044]]; result < i; *(a4 - 1) = (double)(unsigned __int8)*(result - 2) * 0.0039215689)
    {
        v7 = *result;
        result += 4;
        *a4 = (double)v7 * 0.0078125;
        a4 += 4;
        *(a4 - 3) = (double)*(result - 3) * 0.0078125;
        *(a4 - 2) = 0.0;
    }
    return result;
}

//----- (00473210) --------------------------------------------------------
char* __thiscall sub_473210(_DWORD* this, int a2, int a3, float* a4)
{
    char* result; // eax
    char* i; // edx
    int v7; // [esp+8h] [ebp+8h]

    result = (char*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    for (i = &result[4 * this[1044]]; result < i; *(a4 - 1) = (double)*(result - 1) * 0.0078125)
    {
        v7 = *result;
        result += 4;
        *a4 = (double)v7 * 0.0078125;
        a4 += 4;
        *(a4 - 3) = (double)*(result - 3) * 0.0078125;
        *(a4 - 2) = (double)*(result - 2) * 0.0078125;
    }
    return result;
}

//----- (0047328E) --------------------------------------------------------
__int16* __thiscall sub_47328E(_DWORD* this, int a2, int a3, float* a4)
{
    __int16* result; // eax
    __int16* i; // edx
    int v7; // [esp+8h] [ebp+8h]

    result = (__int16*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    for (i = &result[2 * this[1044]]; result < i; *(a4 - 1) = 1.0)
    {
        v7 = *result;
        result += 2;
        *a4 = (double)v7 * 0.000030517578;
        a4 += 4;
        *(a4 - 3) = (double)*(result - 1) * 0.000030517578;
        *(a4 - 2) = 0.0;
    }
    return result;
}

//----- (004732F8) --------------------------------------------------------
unsigned int* __thiscall sub_4732F8(_DWORD* this, int a2, int a3, float* a4)
{
    unsigned int* result; // eax
    unsigned int* i; // edi
    unsigned int v7; // ecx
    int v8; // [esp+Ch] [ebp+8h]

    result = (unsigned int*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    for (i = &result[this[1044]]; result < i; *(a4 - 1) = 1.0)
    {
        v7 = *result;
        v8 = (__int16)(32 * (*result >> 10)) >> 5;
        *a4 = (double)((__int16)(*(_WORD*)result++ << 6) >> 6) * 0.001953125;
        a4 += 4;
        *(a4 - 3) = (double)v8 * 0.0009765625;
        *(a4 - 2) = (double)((__int16)(32 * (v7 >> 21)) >> 5) * 0.0009765625;
    }
    return result;
}

//----- (00473397) --------------------------------------------------------
float* __thiscall sub_473397(float* this, float* a2, float* a3)
{
    double v3; // st7
    double v4; // st6
    double v5; // st5
    float* result; // eax

    v3 = this[3] - a3[3];
    v4 = this[2] - a3[2];
    v5 = this[1] - a3[1];
    result = a2;
    *a2 = *this - *a3;
    a2[1] = v5;
    a2[2] = v4;
    a2[3] = v3;
    return result;
}

//----- (004733C5) --------------------------------------------------------
float* __thiscall sub_4733C5(float* this, float* a2, unsigned int a3, int a4)
{
    void* v6; // ecx
    unsigned int v7; // edx
    float* v8; // ecx
    float* v9; // eax
    int v10; // ecx
    int v11; // esi
    int v12; // edi
    _DWORD* v13; // ecx
    int v14; // edx
    int v15; // eax
    bool v16; // zf
    float v18[4]; // [esp+Ch] [ebp-10h] BYREF
    int v19; // [esp+24h] [ebp+8h]

    sub_46C866((int)(this + 12), 16, 256, (int(__thiscall*)(int))sub_46C80E);
    *(_DWORD*)this = &off_49A774;
    this[6] = *a2;
    this[1] = a2[1];
    this[1042] = a2[2];
    this[1043] = a2[3];
    qmemcpy(this + 1036, a2 + 10, 0x18u);
    sub_46C811(v18, *((_DWORD*)a2 + 17));
    this[7] = v18[0];
    this[8] = v18[1];
    this[9] = v18[2];
    this[10] = v18[3];
    *((_DWORD*)this + 4) = *((_DWORD*)a2 + 17) != 0;
    v6 = &unk_4B14E0;
    if (!*((_DWORD*)a2 + 16))
        v6 = &unk_4B1460;
    *((_DWORD*)this + 11) = v6;
    *((_DWORD*)this + 1048) = a3 >> 3;
    *((_DWORD*)this + 3) = a3 != 0;
    *((_DWORD*)this + 2) = a4;
    if (a4 == 2)
    {
        *((_DWORD*)this + 2) = 1;
        *((_DWORD*)this + 5) = 1;
        if (*((_DWORD*)a2 + 18))
        {
            v7 = 0;
            v8 = this + 13;
            do
            {
                v19 = *(unsigned __int8*)(v7 + *((_DWORD*)a2 + 18));
                v7 += 4;
                *(v8 - 1) = (double)v19 * 0.0039215689;
                *v8 = (double)*(unsigned __int8*)(v7 + *((_DWORD*)a2 + 18) - 3) * 0.0039215689;
                v8 += 4;
                *(v8 - 3) = (double)*(unsigned __int8*)(v7 + *((_DWORD*)a2 + 18) - 2) * 0.0039215689;
                *(v8 - 2) = (double)*(unsigned __int8*)(v7 + *((_DWORD*)a2 + 18) - 1) * 0.0039215689;
            } while (v7 < 0x400);
        }
        else
        {
            v9 = this + 14;
            v10 = 256;
            do
            {
                v9[1] = 1.0;
                *v9 = 1.0;
                v9 += 4;
                --v10;
                *(v9 - 5) = 1.0;
                *(v9 - 6) = 1.0;
            } while (v10);
        }
    }
    else
    {
        this[5] = 0.0;
    }
    v11 = *((_DWORD*)this + 1037);
    v12 = *((_DWORD*)this + 1041);
    v13 = this + 1036;
    v14 = *((_DWORD*)this + 1038) - *((_DWORD*)this + 1036);
    *((_DWORD*)this + 1045) = *((_DWORD*)this + 1039) - v11;
    v15 = *((_DWORD*)this + 1048);
    *((_DWORD*)this + 1046) = v12 - *((_DWORD*)this + 1040);
    v16 = *((_DWORD*)this + 3) == 0;
    *((_DWORD*)this + 1044) = v14;
    *((_DWORD*)this + 1047) = v14 * v15;
    if (!v16)
    {
        *((_DWORD*)this + 6) += *v13 * v15
            + v11 * *((_DWORD*)this + 1042)
            + *((_DWORD*)this + 1040) * *((_DWORD*)this + 1043);
        *v13 = 0;
        this[1037] = 0.0;
        this[1040] = 0.0;
        this[1038] = this[1044];
        this[1039] = this[1045];
        this[1041] = this[1046];
    }
    return this;
}
// 49A774: using guessed type int (__stdcall *off_49A774)(char);

//----- (004735C3) --------------------------------------------------------
_DWORD* __thiscall sub_4735C3(_DWORD* this, char a2)
{
    *this = &off_49A774;
    if ((a2 & 1) != 0)
        sub_4885A6(this);
    return this;
}
// 49A774: using guessed type int (__stdcall *off_49A774)(char);

//----- (004735E3) --------------------------------------------------------
void __thiscall sub_4735E3(float* this, float* a2)
{
    float* v2; // edi
    unsigned int v3; // esi
    float* v4; // ebx

    v2 = a2;
    v3 = (unsigned int)&a2[4 * *((_DWORD*)this + 1044)];
    if ((unsigned int)a2 < v3)
    {
        v4 = this + 7;
        do
        {
            if (sub_47304C(v2, v4))
            {
                v2[3] = 0.0;
                v2[2] = 0.0;
                v2[1] = 0.0;
                *v2 = 0.0;
            }
            v2 += 4;
        } while ((unsigned int)v2 < v3);
    }
}

//----- (0047362B) --------------------------------------------------------
int __thiscall sub_47362B(_DWORD* this, int a2, int a3, int a4)
{
    _BYTE* v4; // edx
    int v5; // ebx
    unsigned int v6; // edi
    bool v7; // zf
    float* v8; // esi
    float v10; // [esp+24h] [ebp+Ch]
    float v11; // [esp+24h] [ebp+Ch]
    float v12; // [esp+28h] [ebp+10h]
    float v13; // [esp+28h] [ebp+10h]

    v4 = (_BYTE*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v5 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v6 = 0;
    v7 = this[1044] == 0;
    dword_52230C = a2;
    if (!v7)
    {
        v8 = (float*)(a4 + 4);
        do
        {
            v10 = *(float*)(v5 + 4 * (v6 & 3));
            v12 = v8[1] * 255.0 + v10;
            *v4 = (int)v12;
            v13 = *v8 * 255.0 + v10;
            v4[1] = (int)v13;
            v11 = *(v8 - 1) * 255.0 + v10;
            v4[2] = (int)v11;
            v4 += 3;
            ++v6;
            v8 += 4;
        } while (v6 < this[1044]);
    }
    return a2;
}
// 52230C: using guessed type int dword_52230C;

//----- (00473703) --------------------------------------------------------
int __thiscall sub_473703(_DWORD* this, int a2, int a3, int a4)
{
    int* v4; // edx
    unsigned int v5; // edi
    bool v6; // zf
    float* v7; // esi
    int v8; // ebx
    int v10; // [esp+8h] [ebp-18h]
    int v11; // [esp+1Ch] [ebp-4h]
    float v12; // [esp+28h] [ebp+8h]
    float v13; // [esp+28h] [ebp+8h]
    float v14; // [esp+30h] [ebp+10h]
    float v15; // [esp+30h] [ebp+10h]
    float v16; // [esp+30h] [ebp+10h]

    v4 = (int*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v11 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v5 = 0;
    v6 = this[1044] == 0;
    dword_52230C = a3;
    if (!v6)
    {
        v7 = (float*)(a4 + 8);
        do
        {
            v12 = *(float*)(v11 + 4 * (v5 & 3));
            v14 = *(v7 - 2) * 255.0 + v12;
            v8 = (int)v14;
            v15 = *(v7 - 1) * 255.0 + v12;
            v10 = (int)v15;
            v16 = *v7 * 255.0 + v12;
            v13 = v7[1] * 255.0 + v12;
            v7 += 4;
            *v4++ = (int)v16 | ((v10 | ((v8 | ((int)v13 << 8)) << 8)) << 8);
            ++v5;
        } while (v5 < this[1044]);
    }
    return a3;
}
// 52230C: using guessed type int dword_52230C;

//----- (00473812) --------------------------------------------------------
int __thiscall sub_473812(_DWORD* this, int a2, int a3, int a4)
{
    int* v4; // edx
    unsigned int v5; // edi
    bool v6; // zf
    float* v7; // esi
    int v8; // eax
    int v10; // [esp+14h] [ebp-4h]
    float v11; // [esp+24h] [ebp+Ch]
    float v12; // [esp+24h] [ebp+Ch]
    float v13; // [esp+28h] [ebp+10h]
    float v14; // [esp+28h] [ebp+10h]

    v4 = (int*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v10 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v5 = 0;
    v6 = this[1044] == 0;
    dword_52230C = a2;
    if (!v6)
    {
        v7 = (float*)(a4 + 8);
        do
        {
            v11 = *(float*)(v10 + 4 * (v5 & 3));
            v13 = *(v7 - 2) * 255.0 + v11;
            v8 = (int)v13;
            v14 = *(v7 - 1) * 255.0 + v11;
            v12 = *v7 * 255.0 + v11;
            v7 += 4;
            *v4++ = (int)v12 | (((int)v14 | (v8 << 8)) << 8);
            ++v5;
        } while (v5 < this[1044]);
    }
    return a2;
}
// 52230C: using guessed type int dword_52230C;

//----- (004738FF) --------------------------------------------------------
int __thiscall sub_4738FF(_DWORD* this, int a2, int a3, int a4)
{
    _WORD* v4; // edx
    unsigned int v5; // edi
    bool v6; // zf
    float* v7; // esi
    int v8; // eax
    int v10; // [esp+14h] [ebp-4h]
    float v11; // [esp+24h] [ebp+Ch]
    float v12; // [esp+24h] [ebp+Ch]
    float v13; // [esp+28h] [ebp+10h]
    float v14; // [esp+28h] [ebp+10h]

    v4 = (_WORD*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v10 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v5 = 0;
    v6 = this[1044] == 0;
    dword_52230C = a2;
    if (!v6)
    {
        v7 = (float*)(a4 + 8);
        do
        {
            v11 = *(float*)(v10 + 4 * (v5 & 3));
            v13 = *(v7 - 2) * 31.0 + v11;
            v8 = (int)v13;
            v14 = *(v7 - 1) * 63.0 + v11;
            v12 = *v7 * 31.0 + v11;
            v7 += 4;
            *v4++ = (int)v12 | (32 * ((int)v14 | ((_WORD)v8 << 6)));
            ++v5;
        } while (v5 < this[1044]);
    }
    return a2;
}
// 52230C: using guessed type int dword_52230C;

//----- (004739EC) --------------------------------------------------------
int __thiscall sub_4739EC(_DWORD* this, int a2, int a3, int a4)
{
    _WORD* v4; // edx
    unsigned int v5; // edi
    bool v6; // zf
    float* v7; // esi
    int v8; // eax
    int v10; // [esp+14h] [ebp-4h]
    float v11; // [esp+24h] [ebp+Ch]
    float v12; // [esp+24h] [ebp+Ch]
    float v13; // [esp+28h] [ebp+10h]
    float v14; // [esp+28h] [ebp+10h]

    v4 = (_WORD*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v10 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v5 = 0;
    v6 = this[1044] == 0;
    dword_52230C = a2;
    if (!v6)
    {
        v7 = (float*)(a4 + 8);
        do
        {
            v11 = *(float*)(v10 + 4 * (v5 & 3));
            v13 = *(v7 - 2) * 31.0 + v11;
            v8 = (int)v13;
            v14 = *(v7 - 1) * 31.0 + v11;
            v12 = *v7 * 31.0 + v11;
            v7 += 4;
            *v4++ = (int)v12 | (32 * ((int)v14 | (32 * v8)));
            ++v5;
        } while (v5 < this[1044]);
    }
    return a2;
}
// 52230C: using guessed type int dword_52230C;

//----- (00473AD9) --------------------------------------------------------
int __thiscall sub_473AD9(_DWORD* this, int a2, int a3, int a4)
{
    _WORD* v4; // edx
    unsigned int v5; // edi
    bool v6; // zf
    float* v7; // esi
    int v8; // ebx
    int v10; // [esp+8h] [ebp-18h]
    int v11; // [esp+1Ch] [ebp-4h]
    float v12; // [esp+28h] [ebp+8h]
    float v13; // [esp+28h] [ebp+8h]
    float v14; // [esp+30h] [ebp+10h]
    float v15; // [esp+30h] [ebp+10h]
    float v16; // [esp+30h] [ebp+10h]

    v4 = (_WORD*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v11 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v5 = 0;
    v6 = this[1044] == 0;
    dword_52230C = a3;
    if (!v6)
    {
        v7 = (float*)(a4 + 8);
        do
        {
            v12 = *(float*)(v11 + 4 * (v5 & 3));
            v14 = *(v7 - 2) * 31.0 + v12;
            v8 = (int)v14;
            v15 = *(v7 - 1) * 31.0 + v12;
            v10 = (int)v15;
            v16 = *v7 * 31.0 + v12;
            v13 = v12 + v7[1];
            v7 += 4;
            *v4++ = (int)v16 | (32 * (v10 | (32 * (v8 | (32 * (int)v13)))));
            ++v5;
        } while (v5 < this[1044]);
    }
    return a3;
}
// 52230C: using guessed type int dword_52230C;

//----- (00473BE2) --------------------------------------------------------
int __thiscall sub_473BE2(_DWORD* this, int a2, int a3, int a4)
{
    _WORD* v4; // edx
    unsigned int v5; // edi
    bool v6; // zf
    float* v7; // esi
    int v8; // ebx
    int v10; // [esp+8h] [ebp-18h]
    int v11; // [esp+1Ch] [ebp-4h]
    float v12; // [esp+28h] [ebp+8h]
    float v13; // [esp+28h] [ebp+8h]
    float v14; // [esp+30h] [ebp+10h]
    float v15; // [esp+30h] [ebp+10h]
    float v16; // [esp+30h] [ebp+10h]

    v4 = (_WORD*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v11 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v5 = 0;
    v6 = this[1044] == 0;
    dword_52230C = a3;
    if (!v6)
    {
        v7 = (float*)(a4 + 8);
        do
        {
            v12 = *(float*)(v11 + 4 * (v5 & 3));
            v14 = *(v7 - 2) * 15.0 + v12;
            v8 = (int)v14;
            v15 = *(v7 - 1) * 15.0 + v12;
            v10 = (int)v15;
            v16 = *v7 * 15.0 + v12;
            v13 = v7[1] * 15.0 + v12;
            v7 += 4;
            *v4++ = (int)v16 | (16 * (v10 | (16 * (v8 | (16 * (int)v13)))));
            ++v5;
        } while (v5 < this[1044]);
    }
    return a3;
}
// 52230C: using guessed type int dword_52230C;

//----- (00473CF1) --------------------------------------------------------
int __thiscall sub_473CF1(_DWORD* this, int a2, int a3, int a4)
{
    _BYTE* v5; // edx
    unsigned int v6; // ecx
    bool v7; // zf
    float* v8; // edi
    int v9; // eax
    int v11; // [esp+14h] [ebp-4h]
    float v12; // [esp+24h] [ebp+Ch]
    float v13; // [esp+24h] [ebp+Ch]
    float v14; // [esp+28h] [ebp+10h]
    float v15; // [esp+28h] [ebp+10h]

    v5 = (_BYTE*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v11 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v6 = 0;
    v7 = this[1044] == 0;
    dword_52230C = a2;
    if (!v7)
    {
        v8 = (float*)(a4 + 8);
        do
        {
            v12 = *(float*)(v11 + 4 * (v6 & 3));
            v14 = *(v8 - 2) * 7.0 + v12;
            v9 = (int)v14;
            v15 = *(v8 - 1) * 7.0 + v12;
            v13 = *v8 * 3.0 + v12;
            v8 += 4;
            *v5++ = (int)v13 | (4 * ((int)v15 | (8 * v9)));
            ++v6;
        } while (v6 < this[1044]);
    }
    return a2;
}
// 52230C: using guessed type int dword_52230C;

//----- (00473DDA) --------------------------------------------------------
int __thiscall sub_473DDA(_DWORD* this, int a2, int a3, int a4)
{
    _BYTE* v4; // edx
    int v5; // esi
    unsigned int v6; // edi
    bool v7; // zf
    float* v8; // ebx
    float v10; // [esp+14h] [ebp+Ch]

    v4 = (_BYTE*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v5 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v6 = 0;
    v7 = this[1044] == 0;
    dword_52230C = a2;
    if (!v7)
    {
        v8 = (float*)(a4 + 12);
        do
        {
            v10 = *(float*)(v5 + 4 * (v6 & 3)) + *v8 * 255.0;
            *v4++ = (int)v10;
            ++v6;
            v8 += 4;
        } while (v6 < this[1044]);
    }
    return a2;
}
// 52230C: using guessed type int dword_52230C;

//----- (00473E72) --------------------------------------------------------
int __thiscall sub_473E72(_DWORD* this, int a2, int a3, int a4)
{
    _WORD* v4; // edx
    unsigned int v5; // edi
    bool v6; // zf
    float* v7; // eax
    int v8; // ebx
    int v10; // [esp+8h] [ebp-18h]
    int v11; // [esp+1Ch] [ebp-4h]
    float v12; // [esp+28h] [ebp+8h]
    float v13; // [esp+28h] [ebp+8h]
    float v14; // [esp+30h] [ebp+10h]
    float v15; // [esp+30h] [ebp+10h]
    float v16; // [esp+30h] [ebp+10h]

    v4 = (_WORD*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v11 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v5 = 0;
    v6 = this[1044] == 0;
    dword_52230C = a3;
    if (!v6)
    {
        v7 = (float*)(a4 + 8);
        do
        {
            v12 = *(float*)(v11 + 4 * (v5 & 3));
            v14 = *(v7 - 2) * 7.0 + v12;
            v8 = (int)v14;
            v15 = *(v7 - 1) * 7.0 + v12;
            v10 = (int)v15;
            v16 = *v7 * 3.0 + v12;
            v13 = v7[1] * 255.0 + v12;
            v7 += 4;
            *v4++ = (int)v16 | (4 * (v10 | (8 * (v8 | (8 * (int)v13)))));
            ++v5;
        } while (v5 < this[1044]);
    }
    return a3;
}
// 52230C: using guessed type int dword_52230C;

//----- (00473F81) --------------------------------------------------------
int __thiscall sub_473F81(_DWORD* this, int a2, int a3, int a4)
{
    _WORD* v4; // edx
    unsigned int v5; // edi
    bool v6; // zf
    float* v7; // esi
    int v8; // eax
    int v10; // [esp+14h] [ebp-4h]
    float v11; // [esp+24h] [ebp+Ch]
    float v12; // [esp+24h] [ebp+Ch]
    float v13; // [esp+28h] [ebp+10h]
    float v14; // [esp+28h] [ebp+10h]

    v4 = (_WORD*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v10 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v5 = 0;
    v6 = this[1044] == 0;
    dword_52230C = a2;
    if (!v6)
    {
        v7 = (float*)(a4 + 8);
        do
        {
            v11 = *(float*)(v10 + 4 * (v5 & 3));
            v13 = *(v7 - 2) * 15.0 + v11;
            v8 = (int)v13;
            v14 = *(v7 - 1) * 15.0 + v11;
            v12 = *v7 * 15.0 + v11;
            v7 += 4;
            *v4++ = (int)v12 | (16 * ((int)v14 | (16 * v8)));
            ++v5;
        } while (v5 < this[1044]);
    }
    return a2;
}
// 52230C: using guessed type int dword_52230C;

//----- (0047406E) --------------------------------------------------------
int __thiscall sub_47406E(float* this, int a2, int a3, float* a4)
{
    _WORD* v5; // edi
    unsigned int v6; // ebx
    bool v7; // zf
    __int16 v8; // cx
    float v10; // [esp+Ch] [ebp-28h] BYREF
    float v11; // [esp+10h] [ebp-24h]
    float v12; // [esp+14h] [ebp-20h]
    int v13; // [esp+1Ch] [ebp-18h]
    float v14; // [esp+20h] [ebp-14h]
    int v15; // [esp+24h] [ebp-10h]
    unsigned int v16; // [esp+28h] [ebp-Ch]
    int v17; // [esp+2Ch] [ebp-8h]
    float* v18; // [esp+30h] [ebp-4h]
    unsigned int v19; // [esp+3Ch] [ebp+8h]
    float v20; // [esp+3Ch] [ebp+8h]
    float* v21; // [esp+40h] [ebp+Ch]

    v5 = (_WORD*)(*((_DWORD*)this + 6) + a3 * *((_DWORD*)this + 1043) + a2 * *((_DWORD*)this + 1042));
    v15 = *((_DWORD*)this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v6 = 0;
    v7 = *((_DWORD*)this + 1044) == 0;
    dword_52230C = v17;
    if (!v7)
    {
        v18 = a4 + 3;
        do
        {
            v16 = 0;
            v19 = 0;
            v14 = *(float*)(v15 + 4 * (v6 & 3));
            v21 = this + 12;
            do
            {
                sub_473397(a4, &v10, v21);
                if (v12 * v12 + v11 * v11 + v10 * v10 < 3.4028235e38)
                    v16 = v19;
                ++v19;
                v21 += 4;
            } while (v19 < 0x100);
            v20 = *v18 * 255.0 + v14;
            v13 = (int)v20;
            v18 += 4;
            LOBYTE(v8) = 0;
            HIBYTE(v8) = v13;
            *v5++ = v16 | v8;
            ++v6;
        } while (v6 < *((_DWORD*)this + 1044));
    }
    return v17;
}
// 52230C: using guessed type int dword_52230C;

//----- (00474183) --------------------------------------------------------
int __thiscall sub_474183(float* this, int a2, int a3, float* a4)
{
    int result; // eax
    _BYTE* i; // esi
    char v7; // bl
    double v8; // st7
    float v9; // [esp+8h] [ebp-18h] BYREF
    float v10; // [esp+Ch] [ebp-14h]
    float v11; // [esp+10h] [ebp-10h]
    float v12; // [esp+14h] [ebp-Ch]
    float v13; // [esp+18h] [ebp-8h]
    unsigned int v14; // [esp+1Ch] [ebp-4h]
    unsigned int v15; // [esp+28h] [ebp+8h]
    float* v16; // [esp+2Ch] [ebp+Ch]

    v14 = 0;
    result = a3 * *((_DWORD*)this + 1043);
    for (i = (_BYTE*)(*((_DWORD*)this + 6) + result + a2 * *((_DWORD*)this + 1042));
        v14 < *((_DWORD*)this + 1044);
        result = v14)
    {
        v7 = 0;
        v13 = 3.4028235e38;
        v15 = 0;
        v16 = this + 12;
        do
        {
            sub_473397(a4, &v9, v16);
            v8 = v12 * v12 + v11 * v11 + v10 * v10 + v9 * v9;
            if (v8 < v13)
            {
                v7 = v15;
                v13 = v8;
            }
            ++v15;
            v16 += 4;
        } while (v15 < 0x100);
        a4 += 4;
        *i++ = v7;
        ++v14;
    }
    return result;
}

//----- (0047423D) --------------------------------------------------------
int __thiscall sub_47423D(_DWORD* this, int a2, int a3, int a4)
{
    _BYTE* v4; // edx
    int v5; // edi
    unsigned int v6; // ebx
    bool v7; // zf
    float* v8; // esi
    float v10; // [esp+18h] [ebp+Ch]

    v4 = (_BYTE*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v5 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v6 = 0;
    v7 = this[1044] == 0;
    dword_52230C = a2;
    if (!v7)
    {
        v8 = (float*)(a4 + 4);
        do
        {
            v10 = (*(v8 - 1) * 0.21250001 + v8[1] * 0.072099999 + *v8 * 0.71539998) * 255.0 + *(float*)(v5 + 4 * (v6 & 3));
            *v4++ = (int)v10;
            ++v6;
            v8 += 4;
        } while (v6 < this[1044]);
    }
    return a2;
}
// 52230C: using guessed type int dword_52230C;

//----- (004742F1) --------------------------------------------------------
int __thiscall sub_4742F1(_DWORD* this, int a2, int a3, int a4)
{
    _WORD* v5; // edx
    int v6; // ecx
    bool v7; // zf
    float* v8; // edi
    __int16 v9; // bx
    int v11; // [esp+8h] [ebp-10h]
    unsigned int v12; // [esp+20h] [ebp+8h]
    float v13; // [esp+28h] [ebp+10h]
    float v14; // [esp+28h] [ebp+10h]

    v5 = (_WORD*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v6 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v12 = 0;
    v7 = this[1044] == 0;
    dword_52230C = a3;
    if (!v7)
    {
        v8 = (float*)(a4 + 4);
        do
        {
            v13 = (*(v8 - 1) * 0.21250001 + v8[1] * 0.072099999 + *v8 * 0.71539998) * 255.0 + *(float*)(v6 + 4 * (v12 & 3));
            v11 = (int)v13;
            v14 = v8[2] * 255.0 + *(float*)(v6 + 4 * (v12 & 3));
            LOBYTE(v9) = 0;
            HIBYTE(v9) = (int)v14;
            v8 += 4;
            *v5++ = v11 | v9;
            ++v12;
        } while (v12 < this[1044]);
    }
    return a3;
}
// 52230C: using guessed type int dword_52230C;

//----- (004743E0) --------------------------------------------------------
int __thiscall sub_4743E0(_DWORD* this, int a2, int a3, int a4)
{
    _BYTE* v5; // edx
    int v6; // ecx
    bool v7; // zf
    float* v8; // edi
    int v9; // ebx
    unsigned int v11; // [esp+1Ch] [ebp+8h]
    float v12; // [esp+24h] [ebp+10h]
    float v13; // [esp+24h] [ebp+10h]

    v5 = (_BYTE*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v6 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v11 = 0;
    v7 = this[1044] == 0;
    dword_52230C = a3;
    if (!v7)
    {
        v8 = (float*)(a4 + 4);
        do
        {
            v12 = (*(v8 - 1) * 0.21250001 + v8[1] * 0.072099999 + *v8 * 0.71539998) * 15.0 + *(float*)(v6 + 4 * (v11 & 3));
            v9 = (int)v12;
            v13 = v8[2] * 15.0 + *(float*)(v6 + 4 * (v11 & 3));
            *v5++ = v9 | (16 * (int)v13);
            ++v11;
            v8 += 4;
        } while (v11 < this[1044]);
    }
    return a3;
}
// 52230C: using guessed type int dword_52230C;

//----- (004744C4) --------------------------------------------------------
int __thiscall sub_4744C4(_DWORD* this, int a2, int a3, float* a4)
{
    _WORD* v5; // edx
    int v6; // ecx
    bool v7; // zf
    __int16 v9; // ax
    unsigned int v11; // [esp+1Ch] [ebp+8h]
    float v12; // [esp+24h] [ebp+10h]
    float v13; // [esp+24h] [ebp+10h]

    v5 = (_WORD*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v6 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v11 = 0;
    v7 = this[1044] == 0;
    dword_52230C = a3;
    if (!v7)
    {
        do
        {
            v12 = *a4 * 128.0 + *(float*)(v6 + 4 * (v11 & 3));
            LOBYTE(v9) = (int)v12;
            v13 = a4[1] * 128.0 + *(float*)(v6 + 4 * (v11 & 3));
            a4 += 4;
            HIBYTE(v9) = (int)v13;
            *v5++ = v9;
            ++v11;
        } while (v11 < this[1044]);
    }
    return a3;
}
// 52230C: using guessed type int dword_52230C;

//----- (0047458F) --------------------------------------------------------
int __thiscall sub_47458F(_DWORD* this, int a2, int a3, int a4)
{
    _WORD* v5; // edx
    bool v6; // zf
    float* v7; // edi
    char v8; // cl
    float v10; // [esp+14h] [ebp-8h]
    float v11; // [esp+14h] [ebp-8h]
    int v12; // [esp+18h] [ebp-4h]
    unsigned int v13; // [esp+24h] [ebp+8h]
    float v14; // [esp+2Ch] [ebp+10h]
    float v15; // [esp+2Ch] [ebp+10h]

    v5 = (_WORD*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v12 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v13 = 0;
    v6 = this[1044] == 0;
    dword_52230C = a3;
    if (!v6)
    {
        v7 = (float*)(a4 + 12);
        do
        {
            v14 = *(float*)(v12 + 4 * (v13 & 3));
            v10 = *(v7 - 3) * 16.0 + v14;
            v8 = (int)v10;
            v11 = *(v7 - 2) * 16.0 + v14;
            v15 = *v7 * 63.0 + v14;
            *v5++ = v8 & 0x1F | (32 * ((32 * (int)v15) | (int)v11 & 0x1F));
            ++v13;
            v7 += 4;
        } while (v13 < this[1044]);
    }
    return a3;
}
// 52230C: using guessed type int dword_52230C;

//----- (00474686) --------------------------------------------------------
int __thiscall sub_474686(_DWORD* this, int a2, int a3, int a4)
{
    int* v4; // edx
    bool v5; // zf
    float* v6; // edi
    unsigned __int8 v7; // al
    unsigned __int16 v8; // bx
    float v10; // [esp+14h] [ebp-8h]
    float v11; // [esp+14h] [ebp-8h]
    int v12; // [esp+18h] [ebp-4h]
    unsigned int v13; // [esp+24h] [ebp+8h]
    float v14; // [esp+2Ch] [ebp+10h]
    float v15; // [esp+2Ch] [ebp+10h]

    v4 = (int*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v12 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v13 = 0;
    v5 = this[1044] == 0;
    dword_52230C = a3;
    if (!v5)
    {
        v6 = (float*)(a4 + 12);
        do
        {
            v14 = *(float*)(v12 + 4 * (v13 & 3));
            v10 = *(v6 - 3) * 128.0 + v14;
            v7 = (int)v10;
            v11 = *(v6 - 2) * 128.0 + v14;
            v15 = *v6 * 255.0 + v14;
            HIBYTE(v8) = (int)v15;
            v6 += 4;
            LOBYTE(v8) = (int)v11;
            *v4++ = v7 | (v8 << 8);
            ++v13;
        } while (v13 < this[1044]);
    }
    return a3;
}
// 52230C: using guessed type int dword_52230C;

//----- (00474785) --------------------------------------------------------
int __thiscall sub_474785(_DWORD* this, int a2, int a3, int a4)
{
    int* v4; // edx
    bool v5; // zf
    float* v6; // esi
    int v8; // [esp+8h] [ebp-20h]
    int v9; // [esp+Ch] [ebp-1Ch]
    int v10; // [esp+20h] [ebp-8h]
    int v11; // [esp+24h] [ebp-4h]
    unsigned int v12; // [esp+30h] [ebp+8h]
    float v13; // [esp+34h] [ebp+Ch]
    float v14; // [esp+34h] [ebp+Ch]
    float v15; // [esp+38h] [ebp+10h]
    float v16; // [esp+38h] [ebp+10h]
    float v17; // [esp+38h] [ebp+10h]

    v4 = (int*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v10 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v12 = 0;
    v5 = this[1044] == 0;
    dword_52230C = v11;
    if (!v5)
    {
        v6 = (float*)(a4 + 8);
        do
        {
            v13 = *(float*)(v10 + 4 * (v12 & 3));
            v15 = *(v6 - 2) * 128.0 + v13;
            v8 = (int)v15;
            v16 = *(v6 - 1) * 128.0 + v13;
            v9 = (int)v16;
            v17 = *v6 * 128.0 + v13;
            v14 = v6[1] * 128.0 + v13;
            *v4++ = (unsigned __int8)v8 | (((unsigned __int8)v9 | ((((int)v14 << 8) | (unsigned __int8)(int)v17) << 8)) << 8);
            ++v12;
            v6 += 4;
        } while (v12 < this[1044]);
    }
    return v11;
}
// 4747DB: variable 'v11' is possibly undefined
// 52230C: using guessed type int dword_52230C;

//----- (004748AC) --------------------------------------------------------
int __thiscall sub_4748AC(_DWORD* this, int a2, int a3, float* a4)
{
    int* v4; // edx
    int v5; // ebx
    bool v6; // zf
    unsigned __int16 v8; // si
    unsigned int v10; // [esp+20h] [ebp+8h]
    float v11; // [esp+28h] [ebp+10h]
    float v12; // [esp+28h] [ebp+10h]

    v4 = (int*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v5 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v10 = 0;
    v6 = this[1044] == 0;
    dword_52230C = a3;
    if (!v6)
    {
        do
        {
            v11 = *a4 * 32768.0 + *(float*)(v5 + 4 * (v10 & 3));
            v8 = (int)v11;
            v12 = a4[1] * 32768.0 + *(float*)(v5 + 4 * (v10 & 3));
            *v4++ = v8 | ((int)v12 << 16);
            ++v10;
            a4 += 4;
        } while (v10 < this[1044]);
    }
    return a3;
}
// 52230C: using guessed type int dword_52230C;

//----- (00474977) --------------------------------------------------------
int __thiscall sub_474977(_DWORD* this, int a2, int a3, int a4)
{
    unsigned int* v4; // edx
    bool v5; // zf
    float* v6; // esi
    __int16 v7; // di
    float v9; // [esp+14h] [ebp-8h]
    float v10; // [esp+14h] [ebp-8h]
    int v11; // [esp+18h] [ebp-4h]
    unsigned int v12; // [esp+24h] [ebp+8h]
    float v13; // [esp+2Ch] [ebp+10h]
    float v14; // [esp+2Ch] [ebp+10h]

    v4 = (unsigned int*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v11 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    v12 = 0;
    v5 = this[1044] == 0;
    dword_52230C = a3;
    if (!v5)
    {
        v6 = (float*)(a4 + 8);
        do
        {
            v13 = *(float*)(v11 + 4 * (v12 & 3));
            v9 = *(v6 - 2) * 512.0 + v13;
            v7 = (int)v9;
            v10 = *(v6 - 1) * 1024.0 + v13;
            v14 = *v6 * 1024.0 + v13;
            *v4++ = v7 & 0x3FF | (((int)v10 & 0x7FF | (((int)v14 & 0xFFFFFFFE) << 11)) << 10);
            ++v12;
            v6 += 4;
        } while (v12 < this[1044]);
    }
    return a3;
}
// 52230C: using guessed type int dword_52230C;

//----- (00474A79) --------------------------------------------------------
int __thiscall sub_474A79(_DWORD* this, int a2, int a3, float* a4)
{
    _WORD* v4; // edx
    int v5; // esi
    unsigned int i; // eax
    float v9; // [esp+14h] [ebp+Ch]

    v4 = (_WORD*)(this[6] + a3 * this[1043] + a2 * this[1042]);
    v5 = this[11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    dword_52230C = a2;
    for (i = 0; i < this[1044]; a4 += 4)
    {
        v9 = *(float*)(v5 + 4 * (i & 3)) + *a4 * 65535.0;
        *v4++ = (int)v9;
        ++i;
    }
    return a2;
}
// 52230C: using guessed type int dword_52230C;

//----- (00474B10) --------------------------------------------------------
void __thiscall sub_474B10(int this, int a2, int a3, float* a4)
{
    unsigned __int8* v4; // eax
    unsigned __int8* i; // esi
    int v7; // [esp+14h] [ebp+10h]

    v4 = (unsigned __int8*)(*(_DWORD*)(this + 24) + a3 * *(_DWORD*)(this + 4172) + a2 * *(_DWORD*)(this + 4168));
    for (i = &v4[*(_DWORD*)(this + 4188)]; v4 < i; *(a4 - 1) = 1.0)
    {
        *a4 = (double)v4[2] * 0.0039215689;
        a4 += 4;
        *(a4 - 3) = (double)v4[1] * 0.0039215689;
        v7 = *v4;
        v4 += 3;
        *(a4 - 2) = (double)v7 * 0.0039215689;
    }
    if (*(_DWORD*)(this + 16))
        sub_4735E3((float*)this, &a4[-4 * *(_DWORD*)(this + 4176)]);
}

//----- (00474B9C) --------------------------------------------------------
void __thiscall sub_474B9C(int this, int a2, int a3, float* a4)
{
    unsigned int v4; // eax
    unsigned int i; // esi
    double v7; // st6

    v4 = *(_DWORD*)(this + 24) + a3 * *(_DWORD*)(this + 4172) + a2 * *(_DWORD*)(this + 4168);
    for (i = v4 + 4 * *(_DWORD*)(this + 4176); v4 < i; *(a4 - 1) = (double)*(unsigned __int8*)(v4 - 1) * 0.0039215689)
    {
        *a4 = (double)*(unsigned __int8*)(v4 + 2) * 0.0039215689;
        a4[1] = (double)*(unsigned __int8*)(v4 + 1) * 0.0039215689;
        v7 = (double)(unsigned __int8)*(_DWORD*)v4;
        v4 += 4;
        a4 += 4;
        *(a4 - 2) = v7 * 0.0039215689;
    }
    if (*(_DWORD*)(this + 16))
        sub_4735E3((float*)this, &a4[-4 * *(_DWORD*)(this + 4176)]);
}

//----- (00474C42) --------------------------------------------------------
void __thiscall sub_474C42(int this, int a2, int a3, float* a4)
{
    unsigned int v4; // eax
    unsigned int i; // esi
    double v7; // st6

    v4 = *(_DWORD*)(this + 24) + a3 * *(_DWORD*)(this + 4172) + a2 * *(_DWORD*)(this + 4168);
    for (i = v4 + 4 * *(_DWORD*)(this + 4176); v4 < i; *(a4 - 1) = 1.0)
    {
        *a4 = (double)*(unsigned __int8*)(v4 + 2) * 0.0039215689;
        a4[1] = (double)*(unsigned __int8*)(v4 + 1) * 0.0039215689;
        v7 = (double)(unsigned __int8)*(_DWORD*)v4;
        v4 += 4;
        a4 += 4;
        *(a4 - 2) = v7 * 0.0039215689;
    }
    if (*(_DWORD*)(this + 16))
        sub_4735E3((float*)this, &a4[-4 * *(_DWORD*)(this + 4176)]);
}

//----- (00474CDE) --------------------------------------------------------
void __thiscall sub_474CDE(int this, int a2, int a3, float* a4)
{
    _WORD* v5; // eax
    _WORD* i; // edi
    int v7; // [esp+18h] [ebp+10h]

    v5 = (_WORD*)(*(_DWORD*)(this + 24) + a3 * *(_DWORD*)(this + 4172) + a2 * *(_DWORD*)(this + 4168));
    for (i = &v5[*(_DWORD*)(this + 4176)]; v5 < i; *(a4 - 1) = 1.0)
    {
        *a4 = (double)(*v5 >> 11) * 0.032258064;
        a4 += 4;
        *(a4 - 3) = (double)(((unsigned __int16)*v5 >> 5) & 0x3F) * 0.015873017;
        v7 = *(_BYTE*)v5++ & 0x1F;
        *(a4 - 2) = (double)v7 * 0.032258064;
    }
    if (*(_DWORD*)(this + 16))
        sub_4735E3((float*)this, &a4[-4 * *(_DWORD*)(this + 4176)]);
}

//----- (00474D83) --------------------------------------------------------
void __thiscall sub_474D83(int this, int a2, int a3, float* a4)
{
    _BYTE* v5; // eax
    _BYTE* i; // edi
    int v7; // [esp+18h] [ebp+10h]

    v5 = (_BYTE*)(*(_DWORD*)(this + 24) + a3 * *(_DWORD*)(this + 4172) + a2 * *(_DWORD*)(this + 4168));
    for (i = &v5[2 * *(_DWORD*)(this + 4176)]; v5 < i; *(a4 - 1) = 1.0)
    {
        *a4 = (double)((*(unsigned __int16*)v5 >> 10) & 0x1F) * 0.032258064;
        a4 += 4;
        *(a4 - 3) = (double)((*(unsigned __int16*)v5 >> 5) & 0x1F) * 0.032258064;
        v7 = *v5 & 0x1F;
        v5 += 2;
        *(a4 - 2) = (double)v7 * 0.032258064;
    }
    if (*(_DWORD*)(this + 16))
        sub_4735E3((float*)this, &a4[-4 * *(_DWORD*)(this + 4176)]);
}

//----- (00474E25) --------------------------------------------------------
void __thiscall sub_474E25(int this, int a2, int a3, float* a4)
{
    _BYTE* v5; // eax
    _BYTE* i; // edi
    int v7; // [esp+18h] [ebp+10h]

    v5 = (_BYTE*)(*(_DWORD*)(this + 24) + a3 * *(_DWORD*)(this + 4172) + a2 * *(_DWORD*)(this + 4168));
    for (i = &v5[2 * *(_DWORD*)(this + 4176)]; v5 < i; *(a4 - 1) = (float)v7)
    {
        *a4 = (double)((*(unsigned __int16*)v5 >> 10) & 0x1F) * 0.032258064;
        a4 += 4;
        *(a4 - 3) = (double)((*(unsigned __int16*)v5 >> 5) & 0x1F) * 0.032258064;
        *(a4 - 2) = (double)(*v5 & 0x1F) * 0.032258064;
        v7 = *(_WORD*)v5 >> 15;
        v5 += 2;
    }
    if (*(_DWORD*)(this + 16))
        sub_4735E3((float*)this, &a4[-4 * *(_DWORD*)(this + 4176)]);
}

//----- (00474ED5) --------------------------------------------------------
void __thiscall sub_474ED5(int this, int a2, int a3, float* a4)
{
    _BYTE* v5; // eax
    _BYTE* i; // edi
    int v7; // [esp+18h] [ebp+10h]

    v5 = (_BYTE*)(*(_DWORD*)(this + 24) + a3 * *(_DWORD*)(this + 4172) + a2 * *(_DWORD*)(this + 4168));
    for (i = &v5[2 * *(_DWORD*)(this + 4176)]; v5 < i; *(a4 - 1) = (double)v7 * 0.06666667)
    {
        *a4 = (double)(v5[1] & 0xF) * 0.06666667;
        a4 += 4;
        *(a4 - 3) = (double)((*v5 >> 4) & 0xF) * 0.06666667;
        *(a4 - 2) = (double)(*v5 & 0xF) * 0.06666667;
        v7 = *(_WORD*)v5 >> 12;
        v5 += 2;
    }
    if (*(_DWORD*)(this + 16))
        sub_4735E3((float*)this, &a4[-4 * *(_DWORD*)(this + 4176)]);
}

//----- (00474F84) --------------------------------------------------------
void __thiscall sub_474F84(int this, int a2, int a3, float* a4)
{
    _BYTE* v5; // eax
    _BYTE* i; // edi
    int v7; // [esp+18h] [ebp+10h]

    v5 = (_BYTE*)(*(_DWORD*)(this + 24) + a3 * *(_DWORD*)(this + 4172) + a2 * *(_DWORD*)(this + 4168));
    for (i = &v5[*(_DWORD*)(this + 4176)]; v5 < i; *(a4 - 1) = 1.0)
    {
        *a4 = (double)(*v5 >> 5) * 0.14285715;
        a4 += 4;
        *(a4 - 3) = (double)((*v5 >> 2) & 7) * 0.14285715;
        v7 = *v5++ & 3;
        *(a4 - 2) = (double)v7 * 0.33333334;
    }
    if (*(_DWORD*)(this + 16))
        sub_4735E3((float*)this, &a4[-4 * *(_DWORD*)(this + 4176)]);
}

//----- (00475026) --------------------------------------------------------
void __thiscall sub_475026(int this, int a2, int a3, float* a4)
{
    unsigned __int8* v4; // eax
    unsigned __int8* i; // esi
    int v7; // [esp+14h] [ebp+10h]

    v4 = (unsigned __int8*)(*(_DWORD*)(this + 24) + a3 * *(_DWORD*)(this + 4172) + a2 * *(_DWORD*)(this + 4168));
    for (i = &v4[*(_DWORD*)(this + 4176)]; v4 < i; *(a4 - 1) = (double)v7 * 0.0039215689)
    {
        *a4 = 1.0;
        a4 += 4;
        *(a4 - 3) = 1.0;
        *(a4 - 2) = 1.0;
        v7 = *v4++;
    }
    if (*(_DWORD*)(this + 16))
        sub_4735E3((float*)this, &a4[-4 * *(_DWORD*)(this + 4176)]);
}

//----- (00475098) --------------------------------------------------------
void __thiscall sub_475098(int this, int a2, int a3, float* a4)
{
    _BYTE* v5; // eax
    _BYTE* i; // edi
    int v7; // [esp+18h] [ebp+10h]

    v5 = (_BYTE*)(*(_DWORD*)(this + 24) + a3 * *(_DWORD*)(this + 4172) + a2 * *(_DWORD*)(this + 4168));
    for (i = &v5[2 * *(_DWORD*)(this + 4176)]; v5 < i; *(a4 - 1) = (double)(unsigned __int8)*(v5 - 1) * 0.0039215689)
    {
        *a4 = (double)((*v5 >> 5) & 7) * 0.14285715;
        a4 += 4;
        *(a4 - 3) = (double)((*v5 >> 2) & 7) * 0.14285715;
        v7 = *v5 & 3;
        v5 += 2;
        *(a4 - 2) = (double)v7 * 0.33333334;
    }
    if (*(_DWORD*)(this + 16))
        sub_4735E3((float*)this, &a4[-4 * *(_DWORD*)(this + 4176)]);
}

//----- (0047514A) --------------------------------------------------------
void __thiscall sub_47514A(int this, int a2, int a3, float* a4)
{
    _BYTE* v5; // eax
    _BYTE* i; // edi
    int v7; // [esp+18h] [ebp+10h]

    v5 = (_BYTE*)(*(_DWORD*)(this + 24) + a3 * *(_DWORD*)(this + 4172) + a2 * *(_DWORD*)(this + 4168));
    for (i = &v5[2 * *(_DWORD*)(this + 4176)]; v5 < i; *(a4 - 1) = 1.0)
    {
        *a4 = (double)(v5[1] & 0xF) * 0.06666667;
        a4 += 4;
        *(a4 - 3) = (double)((*v5 >> 4) & 0xF) * 0.06666667;
        v7 = *v5 & 0xF;
        v5 += 2;
        *(a4 - 2) = (double)v7 * 0.06666667;
    }
    if (*(_DWORD*)(this + 16))
        sub_4735E3((float*)this, &a4[-4 * *(_DWORD*)(this + 4176)]);
}

//----- (004751E9) --------------------------------------------------------
void __thiscall sub_4751E9(int this, int a2, int a3, float* a4)
{
    unsigned __int8* v4; // eax
    float* v6; // edi
    float* v7; // esi
    unsigned __int8* i; // [esp+8h] [ebp+8h]
    int v9; // [esp+10h] [ebp+10h]

    v4 = (unsigned __int8*)(*(_DWORD*)(this + 24) + a3 * *(_DWORD*)(this + 4172) + a2 * *(_DWORD*)(this + 4168));
    for (i = &v4[2 * *(_DWORD*)(this + 4176)]; v4 < i; *(a4 - 1) = (double)v9 * 0.0039215689)
    {
        v6 = a4;
        a4 += 4;
        v7 = (float*)(this + 16 * (*v4 + 3));
        *v6 = *v7++;
        *++v6 = *v7++;
        *++v6 = *v7;
        v6[1] = v7[1];
        v9 = v4[1];
        v4 += 2;
    }
    if (*(_DWORD*)(this + 16))
        sub_4735E3((float*)this, &a4[-4 * *(_DWORD*)(this + 4176)]);
}

//----- (00475270) --------------------------------------------------------
void __thiscall sub_475270(int this, int a2, int a3, _DWORD* a4)
{
    unsigned __int8* v4; // eax
    unsigned __int8* i; // edx
    _DWORD* v7; // esi
    _DWORD* v8; // edi

    v4 = (unsigned __int8*)(*(_DWORD*)(this + 24) + a3 * *(_DWORD*)(this + 4172) + a2 * *(_DWORD*)(this + 4168));
    for (i = &v4[*(_DWORD*)(this + 4176)]; v4 < i; *v8 = v7[1])
    {
        v7 = (_DWORD*)(this + 16 * (*v4 + 3));
        *a4 = *v7++;
        a4[1] = *v7++;
        a4[2] = *v7;
        v8 = a4 + 3;
        ++v4;
        a4 += 4;
    }
    if (*(_DWORD*)(this + 16))
        sub_4735E3((float*)this, (float*)&a4[-4 * *(_DWORD*)(this + 4176)]);
}

//----- (004752D5) --------------------------------------------------------
void __thiscall sub_4752D5(int this, int a2, int a3, float* a4)
{
    unsigned __int8* v4; // eax
    unsigned __int8* i; // esi
    double v7; // st7
    int v8; // [esp+14h] [ebp+10h]

    v4 = (unsigned __int8*)(*(_DWORD*)(this + 24) + a3 * *(_DWORD*)(this + 4172) + a2 * *(_DWORD*)(this + 4168));
    for (i = &v4[*(_DWORD*)(this + 4176)]; v4 < i; *(a4 - 1) = 1.0)
    {
        v8 = *v4++;
        v7 = (double)v8 * 0.0039215689;
        a4[2] = v7;
        a4[1] = v7;
        *a4 = v7;
        a4 += 4;
    }
    if (*(_DWORD*)(this + 16))
        sub_4735E3((float*)this, &a4[-4 * *(_DWORD*)(this + 4176)]);
}

//----- (00475343) --------------------------------------------------------
void __thiscall sub_475343(int this, int a2, int a3, float* a4)
{
    unsigned __int8* v5; // eax
    unsigned __int8* i; // edi
    double v7; // st6
    int v8; // [esp+18h] [ebp+10h]

    v5 = (unsigned __int8*)(*(_DWORD*)(this + 24) + a3 * *(_DWORD*)(this + 4172) + a2 * *(_DWORD*)(this + 4168));
    for (i = &v5[2 * *(_DWORD*)(this + 4176)]; v5 < i; *(a4 - 1) = (double)*(v5 - 1) * 0.0039215689)
    {
        v8 = *v5;
        v5 += 2;
        v7 = (double)v8 * 0.0039215689;
        a4[2] = v7;
        a4[1] = v7;
        *a4 = v7;
        a4 += 4;
    }
    if (*(_DWORD*)(this + 16))
        sub_4735E3((float*)this, &a4[-4 * *(_DWORD*)(this + 4176)]);
}

//----- (004753CC) --------------------------------------------------------
void __thiscall sub_4753CC(int this, int a2, int a3, float* a4)
{
    _BYTE* v5; // eax
    _BYTE* i; // edi
    double v7; // st6
    int v8; // [esp+18h] [ebp+10h]

    v5 = (_BYTE*)(*(_DWORD*)(this + 24) + a3 * *(_DWORD*)(this + 4172) + a2 * *(_DWORD*)(this + 4168));
    for (i = &v5[*(_DWORD*)(this + 4176)]; v5 < i; *(a4 - 1) = (double)v8 * 0.06666667)
    {
        v7 = (double)(*v5 & 0xF) * 0.06666667;
        a4[2] = v7;
        a4[1] = v7;
        *a4 = v7;
        v8 = *v5++ >> 4;
        a4 += 4;
    }
    if (*(_DWORD*)(this + 16))
        sub_4735E3((float*)this, &a4[-4 * *(_DWORD*)(this + 4176)]);
}

//----- (00475455) --------------------------------------------------------
void __thiscall sub_475455(int this, int a2, int a3, float* a4)
{
    unsigned __int16* v4; // eax
    unsigned __int16* i; // esi
    double v7; // st7
    int v8; // [esp+14h] [ebp+10h]

    v4 = (unsigned __int16*)(*(_DWORD*)(this + 24) + a3 * *(_DWORD*)(this + 4172) + a2 * *(_DWORD*)(this + 4168));
    for (i = &v4[*(_DWORD*)(this + 4176)]; v4 < i; *(a4 - 1) = 0.0)
    {
        v8 = *v4++;
        v7 = (double)v8 * 0.000015259022;
        a4[2] = v7;
        a4[1] = v7;
        *a4 = v7;
        a4 += 4;
    }
    if (*(_DWORD*)(this + 16))
        sub_4735E3((float*)this, &a4[-4 * *(_DWORD*)(this + 4176)]);
}

//----- (004754C5) --------------------------------------------------------
int __thiscall sub_4754C5(int this, int a2)
{
    unsigned int v3; // ecx
    int v4; // ebx
    void* v5; // eax
    void* v6; // eax
    void* v8; // [esp+10h] [ebp-10h]

    sub_4733C5((float*)this, (float*)a2, 0, 1);
    v3 = *(_DWORD*)(this + 4144) & 0xFFFFFFFE;
    v4 = ((*(_DWORD*)(this + 4152) + 1) & 0xFFFFFFFE) - v3;
    *(_DWORD*)(this + 4208) = (*(_DWORD*)(this + 4152) + 1) & 0xFFFFFFFE;
    *(_DWORD*)this = &off_49A7D8;
    *(_DWORD*)(this + 4200) = v3;
    *(_DWORD*)(this + 4204) = 0;
    *(_DWORD*)(this + 4216) = 0;
    *(_DWORD*)(this + 4212) = 0;
    *(_DWORD*)(this + 4220) = 0;
    *(_DWORD*)(this + 4224) = v4;
    *(_DWORD*)(this + 4228) = 0;
    *(_DWORD*)(this + 4232) = 1;
    v5 = operator new(16 * v4);
    v8 = v5;
    if (v5)
    {
        sub_46C866((int)v5, 16, v4, (int(__thiscall*)(int))sub_46C80E);
        v6 = v8;
    }
    else
    {
        v6 = 0;
    }
    *(_DWORD*)(this + 4196) = v6;
    if (!v6)
        *(_DWORD*)(this + 4232) = 0;
    if (*(_DWORD*)(a2 + 4) == 1498831189)
    {
        *(_DWORD*)(this + 4236) = 8;
        *(_DWORD*)(this + 4240) = 0;
    }
    else
    {
        *(_DWORD*)(this + 4236) = 0;
        *(_DWORD*)(this + 4240) = 8;
    }
    return this;
}
// 49A7D8: using guessed type int (__stdcall *off_49A7D8)(char);

//----- (004755BD) --------------------------------------------------------
int __thiscall sub_4755BD(_DWORD* this)
{
    int v2; // eax
    unsigned int v3; // ecx
    float* v4; // eax
    int v5; // esi
    int v6; // edi
    int v7; // ebx
    float v9; // [esp+4h] [ebp-24h]
    float v10; // [esp+4h] [ebp-24h]
    float v11; // [esp+Ch] [ebp-1Ch]
    float v12; // [esp+Ch] [ebp-1Ch]
    float v13; // [esp+14h] [ebp-14h]
    float v14; // [esp+14h] [ebp-14h]
    _WORD* v15; // [esp+1Ch] [ebp-Ch]
    unsigned int i; // [esp+20h] [ebp-8h]
    float v17; // [esp+24h] [ebp-4h]
    int v18; // [esp+24h] [ebp-4h]

    if (this[1057] && this[1058])
    {
        v2 = this[1043] * this[1054];
        v3 = this[1050];
        v15 = (_WORD*)(this[6] + this[1042] * this[1051] + v2 + 2 * v3);
        v4 = (float*)this[1049];
        for (i = v3; i < this[1052]; *(v15 - 1) = ((_WORD)v18 << this[1060]) | ((_WORD)v6 << this[1059]))
        {
            v13 = v4[4] * 65.481003 + v4[6] * 24.966 + v4[5] * 128.55299;
            v11 = v4[2] * 112.0 - v4[1] * 74.203003 - *v4 * 37.797001;
            v9 = *v4 * 112.0 - (v4[1] * 93.786003 + v4[2] * 18.214001);
            v17 = *v4 * 65.481003 + v4[1] * 128.55299 + v4[2] * 24.966 + 0.5;
            v5 = (int)v17 + 16;
            v14 = v13 + 0.5;
            v6 = (int)v14 + 16;
            v12 = v11 + 0.5;
            v7 = (int)v12 + 128;
            v10 = v9 + 0.5;
            v18 = (int)v10 + 128;
            if (v5 >= 0)
            {
                if (v5 > 255)
                    v5 = 255;
            }
            else
            {
                v5 = 0;
            }
            if (v6 >= 0)
            {
                if (v6 > 255)
                    LOWORD(v6) = 255;
            }
            else
            {
                LOWORD(v6) = 0;
            }
            if (v7 >= 0)
            {
                if (v7 > 255)
                    v7 = 255;
            }
            else
            {
                v7 = 0;
            }
            if (v18 >= 0)
            {
                if (v18 > 255)
                    LOWORD(v18) = 255;
            }
            else
            {
                LOWORD(v18) = 0;
            }
            i += 2;
            v4 += 8;
            *v15 = (v7 << this[1060]) | (v5 << this[1059]);
            v15 += 2;
        }
        this[1057] = 0;
    }
    return 0;
}

//----- (004757B0) --------------------------------------------------------
int __thiscall sub_4757B0(int this, unsigned int a2, unsigned int a3, int a4)
{
    int result; // eax
    unsigned int v6; // eax
    float* v7; // edx
    _WORD* v8; // ebx
    unsigned __int16 v9; // ax
    double v10; // st4
    _WORD* v11; // ebx
    unsigned __int16 v12; // ax
    double v13; // st4
    double v14; // st3
    double v15; // st3
    double v16; // st2
    double v17; // st2
    double v18; // st1
    double v19; // st1
    double v20; // st2
    double v21; // st2
    double v22; // st2
    double v23; // st4
    double v24; // st4
    double v25; // st4
    float v26; // [esp+4h] [ebp-Ch]
    float v27; // [esp+8h] [ebp-8h]
    float v28; // [esp+8h] [ebp-8h]
    float v29; // [esp+Ch] [ebp-4h]
    float v30; // [esp+Ch] [ebp-4h]
    _WORD* v31; // [esp+18h] [ebp+8h]
    float v32; // [esp+18h] [ebp+8h]
    float v33; // [esp+18h] [ebp+8h]
    float v34; // [esp+18h] [ebp+8h]
    float v35; // [esp+18h] [ebp+8h]
    int v36; // [esp+1Ch] [ebp+Ch]
    float v37; // [esp+1Ch] [ebp+Ch]
    float v38; // [esp+1Ch] [ebp+Ch]
    float v39; // [esp+1Ch] [ebp+Ch]
    unsigned int i; // [esp+20h] [ebp+10h]

    if (!*(_DWORD*)(this + 4232))
        return -2147024882;
    if (a2 < *(_DWORD*)(this + 4204)
        || a2 >= *(_DWORD*)(this + 4212)
        || a3 < *(_DWORD*)(this + 4216)
        || a3 >= *(_DWORD*)(this + 4220))
    {
        result = sub_4755BD((_DWORD*)this);
        if (result < 0)
            return result;
        *(_DWORD*)(this + 4212) = a2 + 1;
        *(_DWORD*)(this + 4204) = a2;
        *(_DWORD*)(this + 4216) = a3;
        *(_DWORD*)(this + 4220) = a3 + 1;
        if (a4)
        {
            v6 = *(_DWORD*)(this + 4200);
            v7 = *(float**)(this + 4196);
            v8 = (_WORD*)(*(_DWORD*)(this + 24) + a3 * *(_DWORD*)(this + 4172) + a2 * *(_DWORD*)(this + 4168) + 2 * v6);
            v31 = v8;
            for (i = v6; i < *(_DWORD*)(this + 4208); v31 = v8)
            {
                v9 = *v8;
                v10 = (double)(unsigned __int8)(*v8 >> *(_WORD*)(this + 4236));
                v11 = v31;
                v36 = (unsigned __int8)(v9 >> *(_WORD*)(this + 4240));
                v12 = v31[1];
                v27 = v10 - 16.0;
                v29 = (double)v36 - 128.0;
                v13 = (double)(unsigned __int8)(v12 >> *(_WORD*)(this + 4236)) - 16.0;
                v14 = (double)(unsigned __int8)(v12 >> *(_WORD*)(this + 4240)) - 128.0;
                v37 = v14;
                v15 = v14 * 0.0062589301;
                v16 = v27 * 0.0045662099;
                v32 = v16;
                v17 = v16 + v15;
                *v7 = v17;
                v28 = v29 * 0.00153632;
                v18 = v37 * 0.00318811;
                v26 = v18;
                v38 = v32 - v28 - v18;
                v7[1] = v38;
                v19 = v29 * 0.0079107098;
                v33 = v19 + v32;
                v7[2] = v33;
                v7[3] = 1.0;
                if (v17 >= 0.0)
                {
                    if (v17 > 1.0)
                        v17 = 1.0;
                }
                else
                {
                    v17 = 0.0;
                }
                *v7 = v17;
                if (v38 >= 0.0)
                {
                    if (v38 <= 1.0)
                        v20 = v38;
                    else
                        v20 = 1.0;
                }
                else
                {
                    v20 = 0.0;
                }
                v7[1] = v20;
                if (v33 >= 0.0)
                {
                    if (v33 <= 1.0)
                        v21 = v33;
                    else
                        v21 = 1.0;
                }
                else
                {
                    v21 = 0.0;
                }
                v7[2] = v21;
                v34 = v13 * 0.0045662099;
                v22 = v13 * 0.0045662099 + v15;
                v23 = v22;
                v7[4] = v22;
                v39 = v34 - v28 - v26;
                v7[5] = v39;
                v30 = v19;
                v35 = v34 + v30;
                v7[6] = v35;
                v7[7] = 1.0;
                if (v22 >= 0.0)
                {
                    if (v22 > 1.0)
                        v23 = 1.0;
                }
                else
                {
                    v23 = 0.0;
                }
                v7[4] = v23;
                if (v39 >= 0.0)
                {
                    if (v39 <= 1.0)
                        v24 = v39;
                    else
                        v24 = 1.0;
                }
                else
                {
                    v24 = 0.0;
                }
                v7[5] = v24;
                if (v35 >= 0.0)
                {
                    if (v35 <= 1.0)
                        v25 = v35;
                    else
                        v25 = 1.0;
                }
                else
                {
                    v25 = 0.0;
                }
                i += 2;
                v7[6] = v25;
                v8 = v11 + 2;
                v7 += 8;
            }
        }
    }
    return 0;
}

//----- (00475A81) --------------------------------------------------------
signed int __thiscall sub_475A81(_DWORD* this, int a2, int a3, const void* a4)
{
    signed int result; // eax

    result = sub_4757B0((int)this, this[1037] + a2, this[1040] + a3, this[1056] != this[1044]);
    if (result >= 0)
    {
        result = 16 * this[1044];
        qmemcpy((void*)(this[1049] + 16 * (this[1036] - this[1050])), a4, result);
        this[1057] = 1;
    }
    return result;
}

//----- (00475AFA) --------------------------------------------------------
void __thiscall sub_475AFA(int this, int a2, int a3, void* a4)
{
    if (sub_4757B0(this, *(_DWORD*)(this + 4148) + a2, *(_DWORD*)(this + 4160) + a3, 1) >= 0)
    {
        qmemcpy(
            a4,
            (const void*)(*(_DWORD*)(this + 4196) + 16 * (*(_DWORD*)(this + 4144) - *(_DWORD*)(this + 4200))),
            16 * *(_DWORD*)(this + 4176));
        if (*(_DWORD*)(this + 16))
            sub_4735E3((float*)this, (float*)a4);
    }
}

//----- (00475B69) --------------------------------------------------------
int __thiscall sub_475B69(int this, int a2)
{
    unsigned int v3; // eax
    unsigned int v4; // ecx
    _DWORD* v5; // edi
    void* v6; // eax
    void* v7; // eax
    void* v9; // [esp+10h] [ebp-14h]
    int v10; // [esp+14h] [ebp-10h]
    int v11; // [esp+2Ch] [ebp+8h]

    sub_4733C5((float*)this, (float*)a2, 0, 1);
    *(_DWORD*)this = &off_49A818;
    *(_DWORD*)(this + 4248) = 0;
    if (*(_DWORD*)(a2 + 24) == 1)
    {
        *(_DWORD*)(this + 4252) = 0;
    }
    else
    {
        if (*(_DWORD*)(a2 + 24) != 2)
        {
            *(_DWORD*)(this + 4252) = 3;
            goto LABEL_7;
        }
        *(_DWORD*)(this + 4252) = 1;
    }
    *(_DWORD*)(this + 4248) = 1;
LABEL_7:
    if (*(_DWORD*)(a2 + 28) == 1)
    {
        *(_DWORD*)(this + 4256) = 0;
        goto LABEL_12;
    }
    if (*(_DWORD*)(a2 + 28) == 2)
    {
        *(_DWORD*)(this + 4256) = 1;
    LABEL_12:
        *(_DWORD*)(this + 4248) = 1;
        goto LABEL_13;
    }
    *(_DWORD*)(this + 4256) = 3;
LABEL_13:
    v3 = (*(_DWORD*)(this + 4152) + 3) & 0xFFFFFFFC;
    v4 = *(_DWORD*)(this + 4144) & 0xFFFFFFFC;
    *(_DWORD*)(this + 4220) = v3;
    *(_DWORD*)(this + 4244) = 1;
    *(_DWORD*)(this + 4212) = v4;
    *(_DWORD*)(this + 4216) = 0;
    *(_DWORD*)(this + 4228) = 0;
    *(_DWORD*)(this + 4224) = 0;
    *(_DWORD*)(this + 4232) = 0;
    *(_DWORD*)(this + 4260) = 0;
    *(_DWORD*)(this + 4236) = v3 - v4;
    *(_DWORD*)(this + 4240) = 0;
    v5 = (_DWORD*)(this + 4196);
    v11 = 4;
    do
    {
        v10 = *(_DWORD*)(this + 4236);
        v6 = operator new(16 * v10);
        v9 = v6;
        if (v6)
        {
            sub_46C866((int)v6, 16, v10, (int(__thiscall*)(int))sub_46C80E);
            v7 = v9;
        }
        else
        {
            v7 = 0;
        }
        *v5 = v7;
        if (!v7)
            *(_DWORD*)(this + 4244) = 0;
        ++v5;
        --v11;
    } while (v11);
    return this;
}
// 49A818: using guessed type int (__stdcall *off_49A818)(char);

//----- (00475CAA) --------------------------------------------------------
int __thiscall sub_475CAA(_DWORD* this)
{
    int v2; // eax
    bool v3; // cf
    int* v4; // edx
    float* v5; // eax
    double v6; // st7
    float* v7; // eax
    double v8; // st7
    unsigned int v9; // edi
    _DWORD* v10; // ecx
    unsigned int v11; // edx
    int v12; // eax
    int v13; // eax
    _DWORD v15[17]; // [esp+4h] [ebp-84h] BYREF
    int v16; // [esp+48h] [ebp-40h]
    int v17; // [esp+4Ch] [ebp-3Ch]
    float v18; // [esp+50h] [ebp-38h]
    int v19; // [esp+54h] [ebp-34h]
    int v20; // [esp+58h] [ebp-30h]
    int v21; // [esp+5Ch] [ebp-2Ch]
    int v22; // [esp+60h] [ebp-28h]
    int v23; // [esp+64h] [ebp-24h]
    int v24; // [esp+68h] [ebp-20h]
    int v25; // [esp+6Ch] [ebp-1Ch]
    int v26; // [esp+70h] [ebp-18h]
    int v27; // [esp+74h] [ebp-14h]
    _DWORD* v28; // [esp+78h] [ebp-10h]
    unsigned int v29; // [esp+7Ch] [ebp-Ch]
    float v30; // [esp+80h] [ebp-8h]
    float v31; // [esp+84h] [ebp-4h]

    if (this[1060] && this[1061])
    {
        v2 = this[1];
        if (v2 == 844388420 || (v24 = 0, v2 == 877942852))
            v24 = 1;
        v3 = this[1053] < this[1055];
        v29 = this[1053];
        if (v3)
        {
            do
            {
                v15[16] = v25 | 0xC00;
                dword_52230C = v25;
                v4 = v15;
                if (v24)
                {
                    v28 = this + 1049;
                    v26 = 4;
                    do
                    {
                        v5 = (float*)(*v28 + 16 * (v29 - this[1053]));
                        v27 = 4;
                        do
                        {
                            v30 = *v5 * v5[3] * 255.0 + 0.5;
                            v23 = (int)v30;
                            v30 = v5[1] * v5[3] * 255.0 + 0.5;
                            v21 = (int)v30;
                            v30 = v5[3] * v5[2] * 255.0 + 0.5;
                            v17 = (int)v30;
                            v6 = v5[3] * 255.0;
                            v31 = *(float*)&v17;
                            v30 = v6 + 0.5;
                            v19 = (int)v30;
                            v5 += 4;
                            *v4++ = v17 | ((v21 | ((v23 | (v19 << 8)) << 8)) << 8);
                            --v27;
                        } while (v27);
                        ++v28;
                        --v26;
                    } while (v26);
                }
                else
                {
                    v28 = this + 1049;
                    v27 = 4;
                    do
                    {
                        v7 = (float*)(*v28 + 16 * (v29 - this[1053]));
                        v26 = 4;
                        do
                        {
                            v31 = *v7 * 255.0 + 0.5;
                            v22 = (int)v31;
                            v31 = v7[1] * 255.0 + 0.5;
                            v20 = (int)v31;
                            v31 = v7[2] * 255.0 + 0.5;
                            LODWORD(v18) = (int)v31;
                            v8 = v7[3] * 255.0;
                            v30 = v18;
                            v31 = v8 + 0.5;
                            v16 = (int)v31;
                            v7 += 4;
                            *v4++ = LODWORD(v18) | ((v20 | ((v22 | (v16 << 8)) << 8)) << 8);
                            --v26;
                        } while (v26);
                        ++v28;
                        --v27;
                    } while (v27);
                }
                v31 = *(float*)&v25;
                v9 = 0;
                if (this[1062])
                {
                    v10 = v15;
                    do
                    {
                        v11 = 0;
                        v12 = 4 * (v9 & this[1064]);
                        do
                            *v10++ = v15[v12 + (v11++ & this[1063])];
                        while (v11 < 4);
                        ++v9;
                    } while (v9 < 4);
                }
                v13 = this[1];
                switch (v13)
                {
                case 827611204:
                    sub_47AFCE(v15, this[6] + this[1043] * this[1057] + this[1042] * (this[1054] >> 2) + 8 * (v29 >> 2));
                    break;
                case 844388420:
                case 861165636:
                    sub_47BB23(
                        v15,
                        (_WORD*)(this[6] + 16 * (v29 >> 2) + this[1043] * this[1057] + this[1042] * (this[1054] >> 2)));
                    break;
                case 877942852:
                case 894720068:
                    sub_47BB7C(v15, this[6] + 16 * (v29 >> 2) + this[1043] * this[1057] + this[1042] * (this[1054] >> 2));
                    break;
                }
                v29 += 4;
            } while (v29 < this[1055]);
        }
        this[1060] = 0;
    }
    return 0;
}
// 52230C: using guessed type int dword_52230C;

//----- (00476004) --------------------------------------------------------
int __thiscall sub_476004(_DWORD* this, unsigned int a2, unsigned int a3, int a4)
{
    int result; // eax
    unsigned int v6; // edi
    bool v7; // cc
    int v8; // eax
    unsigned int v9; // ebx
    int v10; // eax
    char* v11; // edx
    _DWORD* v12; // edi
    unsigned int v13; // ecx
    float* v14; // ecx
    double v15; // st7
    double v16; // st7
    double v17; // st7
    char v18[64]; // [esp+4h] [ebp-4Ch] BYREF
    int v19; // [esp+44h] [ebp-Ch]
    int v20; // [esp+48h] [ebp-8h]
    int v21; // [esp+4Ch] [ebp-4h]
    BOOL v22; // [esp+60h] [ebp+10h]

    if (!this[1061])
        return -2147024882;
    if (a2 < this[1054] || a2 >= this[1056])
    {
        v6 = a3;
    }
    else
    {
        v6 = a3;
        if (a3 >= this[1057] && a3 < this[1058])
            return 0;
    }
    result = sub_475CAA(this);
    if (result >= 0)
    {
        this[1056] = (a2 & 0xFFFFFFFC) + 4;
        this[1058] = v6 + 1;
        v7 = this[1065] <= (a2 & 0xFFFFFFFC);
        this[1054] = a2 & 0xFFFFFFFC;
        this[1057] = v6;
        if (v7)
        {
            this[1065] = a2 & 0xFFFFFFFC;
            if (!a4)
                return 0;
        }
        v8 = this[1];
        v22 = v8 == 844388420 || v8 == 877942852;
        v9 = this[1053];
        if (v9 >= this[1055])
            return 0;
    LABEL_19:
        v10 = this[1];
        switch (v10)
        {
        case 827611204:
            sub_47B039((unsigned __int16*)(this[6] + v6 * this[1043] + this[1042] * (a2 >> 2) + 8 * (v9 >> 2)), v18);
            break;
        case 844388420:
        case 861165636:
            sub_47B9A3(this[6] + 16 * (v9 >> 2) + v6 * this[1043] + this[1042] * (a2 >> 2), v18);
            break;
        case 877942852:
        case 894720068:
            sub_47B9F1((unsigned __int16*)(this[6] + 16 * (v9 >> 2) + v6 * this[1043] + this[1042] * (a2 >> 2)), v18);
            break;
        }
        v11 = v18;
        v12 = this + 1049;
        v20 = 4;
        while (1)
        {
            v13 = v9 - this[1053];
            v21 = 4;
            v14 = (float*)(*v12 + 16 * v13);
            do
            {
                v19 = (unsigned __int8)v11[3];
                v14[3] = (double)v19 * 0.0039215689;
                v19 = (unsigned __int8)v11[2];
                *v14 = (double)v19 * 0.0039215689;
                v19 = (unsigned __int8)v11[1];
                v14[1] = (double)v19 * 0.0039215689;
                v19 = (unsigned __int8)*(_DWORD*)v11;
                v14[2] = (double)v19 * 0.0039215689;
                if (!v22)
                    goto LABEL_43;
                if (0.0 == v14[3])
                {
                    *v14 = 0.0;
                    v14[1] = 0.0;
                    v15 = 0.0;
                }
                else
                {
                    if (v14[3] >= 1.0)
                        goto LABEL_43;
                    if (*v14 >= (double)v14[3])
                        v16 = 1.0;
                    else
                        v16 = *v14 / v14[3];
                    *v14 = v16;
                    if (v14[1] >= (double)v14[3])
                        v17 = 1.0;
                    else
                        v17 = v14[1] / v14[3];
                    v14[1] = v17;
                    if (v14[2] >= (double)v14[3])
                        v15 = 1.0;
                    else
                        v15 = v14[2] / v14[3];
                }
                v14[2] = v15;
            LABEL_43:
                v14 += 4;
                v11 += 4;
                --v21;
            } while (v21);
            ++v12;
            if (!--v20)
            {
                v9 += 4;
                if (v9 < this[1055])
                {
                    v6 = a3;
                    goto LABEL_19;
                }
                return 0;
            }
        }
    }
    return result;
}

//----- (004762B1) --------------------------------------------------------
signed int __thiscall sub_4762B1(_DWORD* this, int a2, int a3, const void* a4)
{
    unsigned int v5; // edi
    signed int result; // eax

    v5 = this[1037] + a2;
    result = sub_476004(this, v5, this[1040] + a3, this[1059] != this[1044]);
    if (result >= 0)
    {
        result = 16 * this[1044];
        qmemcpy((void*)(this[v5 - this[1054] + 1049] + 16 * (this[1036] - this[1053])), a4, result);
        this[1060] = 1;
    }
    return result;
}

//----- (00476337) --------------------------------------------------------
void __thiscall sub_476337(int this, int a2, int a3, void* a4)
{
    unsigned int v5; // edi

    v5 = *(_DWORD*)(this + 4148) + a2;
    if (sub_476004((_DWORD*)this, v5, *(_DWORD*)(this + 4160) + a3, 1) >= 0)
    {
        qmemcpy(
            a4,
            (const void*)(*(_DWORD*)(this + 4 * (v5 - *(_DWORD*)(this + 4216)) + 4196)
                + 16 * (*(_DWORD*)(this + 4144) - *(_DWORD*)(this + 4212))),
            16 * *(_DWORD*)(this + 4176));
        if (*(_DWORD*)(this + 16))
            sub_4735E3((float*)this, (float*)a4);
    }
}

//----- (004763AB) --------------------------------------------------------
void __thiscall sub_4763AB(_DWORD* this)
{
    *this = &off_49A774;
}
// 49A774: using guessed type int (__stdcall *off_49A774)(char);

//----- (004763B2) --------------------------------------------------------
_DWORD* __thiscall sub_4763B2(_DWORD* this, char a2)
{
    sub_4763AB(this);
    if ((a2 & 1) != 0)
        sub_4885A6(this);
    return this;
}

//----- (004763D1) --------------------------------------------------------
void __thiscall sub_4763D1(int this)
{
    *(_DWORD*)this = &off_49A7D8;
    sub_4755BD((_DWORD*)this);
    if (*(_DWORD*)(this + 4196))
        sub_4885A6(*(LPVOID*)(this + 4196));
    *(_DWORD*)this = &off_49A774;
}
// 49A774: using guessed type int (__stdcall *off_49A774)(char);
// 49A7D8: using guessed type int (__stdcall *off_49A7D8)(char);

//----- (00476415) --------------------------------------------------------
void __thiscall sub_476415(LPVOID* this)
{
    LPVOID* v2; // edi
    int v3; // ebx

    *this = &off_49A818;
    sub_475CAA(this);
    v2 = this + 1049;
    v3 = 4;
    do
    {
        if (*v2)
            sub_4885A6(*v2);
        ++v2;
        --v3;
    } while (v3);
    *this = &off_49A774;
}
// 49A774: using guessed type int (__stdcall *off_49A774)(char);
// 49A818: using guessed type int (__stdcall *off_49A818)(char);

//----- (00476468) --------------------------------------------------------
float* __cdecl sub_476468(int a1)
{
    int v1; // eax
    float* v2; // eax
    float* v3; // esi
    float* v4; // eax
    float* v5; // eax
    float* v6; // eax
    float* v7; // eax
    float* v8; // eax
    float* v9; // eax
    float* v10; // eax
    float* v11; // eax
    float* v12; // eax
    int v13; // eax
    int v14; // eax
    int v15; // eax
    int v16; // eax
    float* v17; // eax
    float* v18; // eax
    float* v19; // eax
    float* v20; // eax
    float* v21; // eax
    int v22; // eax
    int v23; // eax
    int v24; // eax
    float* v25; // eax
    float* v26; // eax
    float* v27; // eax
    float* v28; // eax
    float* v29; // eax
    float* v30; // eax
    float* v31; // eax
    float* v32; // eax
    float* v33; // eax
    float* v34; // eax
    float* v35; // eax
    float* v36; // eax

    v1 = *(_DWORD*)(a1 + 4);
    if (v1 > 70)
    {
        switch (v1)
        {
        case 827611204:
            v36 = (float*)operator new(0x10A8u);
            v3 = v36;
            if (v36)
            {
                sub_475B69((int)v36, a1);
                *(_DWORD*)v3 = &off_49A950;
                return v3;
            }
            break;
        case 844388420:
            v35 = (float*)operator new(0x10A8u);
            v3 = v35;
            if (v35)
            {
                sub_475B69((int)v35, a1);
                *(_DWORD*)v3 = &off_49A95C;
                return v3;
            }
            break;
        case 844715353:
            v34 = (float*)operator new(0x1094u);
            v3 = v34;
            if (v34)
            {
                sub_4754C5((int)v34, a1);
                *(_DWORD*)v3 = &off_49A944;
                return v3;
            }
            break;
        case 861165636:
            v33 = (float*)operator new(0x10A8u);
            v3 = v33;
            if (v33)
            {
                sub_475B69((int)v33, a1);
                *(_DWORD*)v3 = &off_49A968;
                return v3;
            }
            break;
        case 877942852:
            v32 = (float*)operator new(0x10A8u);
            v3 = v32;
            if (v32)
            {
                sub_475B69((int)v32, a1);
                *(_DWORD*)v3 = &off_49A974;
                return v3;
            }
            break;
        case 894720068:
            v31 = (float*)operator new(0x10A8u);
            v3 = v31;
            if (v31)
            {
                sub_475B69((int)v31, a1);
                *(_DWORD*)v3 = &off_49A980;
                return v3;
            }
            break;
        case 1498831189:
            v30 = (float*)operator new(0x1094u);
            v3 = v30;
            if (v30)
            {
                sub_4754C5((int)v30, a1);
                *(_DWORD*)v3 = &off_49A938;
                return v3;
            }
            break;
        }
    }
    else if (v1 == 70)
    {
        v29 = (float*)operator new(0x1064u);
        v3 = v29;
        if (v29)
        {
            sub_4733C5(v29, (float*)a1, 0x10u, 4);
            *(_DWORD*)v3 = &off_49A92C;
            return v3;
        }
    }
    else if (v1 > 40)
    {
        if (v1 > 61)
        {
            v22 = v1 - 62;
            if (v22)
            {
                v23 = v22 - 1;
                if (v23)
                {
                    v24 = v23 - 1;
                    if (v24)
                    {
                        if (v24 == 1)
                        {
                            v25 = (float*)operator new(0x1064u);
                            v3 = v25;
                            if (v25)
                            {
                                sub_4733C5(v25, (float*)a1, 0x20u, 3);
                                *(_DWORD*)v3 = &off_49A920;
                                return v3;
                            }
                        }
                    }
                    else
                    {
                        v26 = (float*)operator new(0x1064u);
                        v3 = v26;
                        if (v26)
                        {
                            sub_4733C5(v26, (float*)a1, 0x20u, 3);
                            *(_DWORD*)v3 = &off_49A914;
                            return v3;
                        }
                    }
                }
                else
                {
                    v27 = (float*)operator new(0x1064u);
                    v3 = v27;
                    if (v27)
                    {
                        sub_4733C5(v27, (float*)a1, 0x20u, 3);
                        *(_DWORD*)v3 = &off_49A908;
                        return v3;
                    }
                }
            }
            else
            {
                v28 = (float*)operator new(0x1064u);
                v3 = v28;
                if (v28)
                {
                    sub_4733C5(v28, (float*)a1, 0x20u, 3);
                    *(_DWORD*)v3 = &off_49A8FC;
                    return v3;
                }
            }
        }
        else if (v1 == 61)
        {
            v21 = (float*)operator new(0x1064u);
            v3 = v21;
            if (v21)
            {
                sub_4733C5(v21, (float*)a1, 0x10u, 3);
                *(_DWORD*)v3 = &off_49A8F0;
                return v3;
            }
        }
        else
        {
            v13 = v1 - 41;
            if (v13)
            {
                v14 = v13 - 9;
                if (v14)
                {
                    v15 = v14 - 1;
                    if (v15)
                    {
                        v16 = v15 - 1;
                        if (v16)
                        {
                            if (v16 == 8)
                            {
                                v3 = (float*)operator new(0x1064u);
                                if (v3)
                                {
                                    sub_4733C5(v3, (float*)a1, 0x10u, 3);
                                    *(_DWORD*)v3 = &off_49A8E4;
                                    return v3;
                                }
                            }
                        }
                        else
                        {
                            v17 = (float*)operator new(0x1064u);
                            v3 = v17;
                            if (v17)
                            {
                                sub_4733C5(v17, (float*)a1, 8u, 1);
                                *(_DWORD*)v3 = &off_49A8D8;
                                return v3;
                            }
                        }
                    }
                    else
                    {
                        v18 = (float*)operator new(0x1064u);
                        v3 = v18;
                        if (v18)
                        {
                            sub_4733C5(v18, (float*)a1, 0x10u, 1);
                            *(_DWORD*)v3 = &off_49A8CC;
                            return v3;
                        }
                    }
                }
                else
                {
                    v19 = (float*)operator new(0x1064u);
                    v3 = v19;
                    if (v19)
                    {
                        sub_4733C5(v19, (float*)a1, 8u, 1);
                        *(_DWORD*)v3 = &off_49A8C0;
                        return v3;
                    }
                }
            }
            else
            {
                v20 = (float*)operator new(0x1064u);
                v3 = v20;
                if (v20)
                {
                    sub_4733C5(v20, (float*)a1, 8u, 2);
                    *(_DWORD*)v3 = &off_49A8B4;
                    return v3;
                }
            }
        }
    }
    else
    {
        if (v1 != 40)
        {
            switch (v1)
            {
            case 20:
                v2 = (float*)operator new(0x1064u);
                v3 = v2;
                if (!v2)
                    return 0;
                sub_4733C5(v2, (float*)a1, 0x18u, 1);
                *(_DWORD*)v3 = &off_49A824;
                break;
            case 21:
                v3 = (float*)operator new(0x1064u);
                if (!v3)
                    return 0;
                sub_4733C5(v3, (float*)a1, 0x20u, 1);
                *(_DWORD*)v3 = &off_49A830;
                break;
            case 22:
                v4 = (float*)operator new(0x1064u);
                v3 = v4;
                if (!v4)
                    return 0;
                sub_4733C5(v4, (float*)a1, 0x20u, 1);
                *(_DWORD*)v3 = &off_49A83C;
                break;
            case 23:
                v5 = (float*)operator new(0x1064u);
                v3 = v5;
                if (!v5)
                    return 0;
                sub_4733C5(v5, (float*)a1, 0x10u, 1);
                *(_DWORD*)v3 = &off_49A848;
                break;
            case 24:
                v6 = (float*)operator new(0x1064u);
                v3 = v6;
                if (!v6)
                    return 0;
                sub_4733C5(v6, (float*)a1, 0x10u, 1);
                *(_DWORD*)v3 = &off_49A854;
                break;
            case 25:
                v7 = (float*)operator new(0x1064u);
                v3 = v7;
                if (!v7)
                    return 0;
                sub_4733C5(v7, (float*)a1, 0x10u, 1);
                *(_DWORD*)v3 = &off_49A860;
                break;
            case 26:
                v8 = (float*)operator new(0x1064u);
                v3 = v8;
                if (!v8)
                    return 0;
                sub_4733C5(v8, (float*)a1, 0x10u, 1);
                *(_DWORD*)v3 = &off_49A86C;
                break;
            case 27:
                v9 = (float*)operator new(0x1064u);
                v3 = v9;
                if (!v9)
                    return 0;
                sub_4733C5(v9, (float*)a1, 8u, 1);
                *(_DWORD*)v3 = &off_49A878;
                break;
            case 28:
                v3 = (float*)operator new(0x1064u);
                if (!v3)
                    return 0;
                sub_4733C5(v3, (float*)a1, 8u, 1);
                *(_DWORD*)v3 = &off_49A884;
                break;
            case 29:
                v10 = (float*)operator new(0x1064u);
                v3 = v10;
                if (!v10)
                    return 0;
                sub_4733C5(v10, (float*)a1, 0x10u, 1);
                *(_DWORD*)v3 = &off_49A890;
                break;
            case 30:
                v11 = (float*)operator new(0x1064u);
                v3 = v11;
                if (!v11)
                    return 0;
                sub_4733C5(v11, (float*)a1, 0x10u, 1);
                *(_DWORD*)v3 = &off_49A89C;
                break;
            default:
                return 0;
            }
            return v3;
        }
        v12 = (float*)operator new(0x1064u);
        v3 = v12;
        if (v12)
        {
            sub_4733C5(v12, (float*)a1, 0x10u, 2);
            *(_DWORD*)v3 = &off_49A8A8;
            return v3;
        }
    }
    return 0;
}
// 49A824: using guessed type int (__stdcall *off_49A824)(char);
// 49A830: using guessed type int (__stdcall *off_49A830)(char);
// 49A83C: using guessed type int (__stdcall *off_49A83C)(char);
// 49A848: using guessed type int (__stdcall *off_49A848)(char);
// 49A854: using guessed type int (__stdcall *off_49A854)(char);
// 49A860: using guessed type int (__stdcall *off_49A860)(char);
// 49A86C: using guessed type int (__stdcall *off_49A86C)(char);
// 49A878: using guessed type int (__stdcall *off_49A878)(char);
// 49A884: using guessed type int (__stdcall *off_49A884)(char);
// 49A890: using guessed type int (__stdcall *off_49A890)(char);
// 49A89C: using guessed type int (__stdcall *off_49A89C)(char);
// 49A8A8: using guessed type int (__stdcall *off_49A8A8)(char);
// 49A8B4: using guessed type int (__stdcall *off_49A8B4)(char);
// 49A8C0: using guessed type int (__stdcall *off_49A8C0)(char);
// 49A8CC: using guessed type int (__stdcall *off_49A8CC)(char);
// 49A8D8: using guessed type int (__stdcall *off_49A8D8)(char);
// 49A8E4: using guessed type int (__stdcall *off_49A8E4)(char);
// 49A8F0: using guessed type int (__stdcall *off_49A8F0)(char);
// 49A8FC: using guessed type int (__stdcall *off_49A8FC)(char);
// 49A908: using guessed type int (__stdcall *off_49A908)(char);
// 49A914: using guessed type int (__stdcall *off_49A914)(char);
// 49A920: using guessed type int (__stdcall *off_49A920)(char);
// 49A92C: using guessed type int (__stdcall *off_49A92C)(char);
// 49A938: using guessed type int (__stdcall *off_49A938)(char);
// 49A944: using guessed type int (__stdcall *off_49A944)(char);
// 49A950: using guessed type int (__stdcall *off_49A950)(char);
// 49A95C: using guessed type int (__stdcall *off_49A95C)(char);
// 49A968: using guessed type int (__stdcall *off_49A968)(char);
// 49A974: using guessed type int (__stdcall *off_49A974)(char);
// 49A980: using guessed type int (__stdcall *off_49A980)(char);

//----- (00476B8B) --------------------------------------------------------
void* __thiscall sub_476B8B(void* this, char a2)
{
    sub_4763D1((int)this);
    if ((a2 & 1) != 0)
        sub_4885A6(this);
    return this;
}

//----- (00476BAA) --------------------------------------------------------
LPVOID* __thiscall sub_476BAA(LPVOID* this, char a2)
{
    sub_476415(this);
    if ((a2 & 1) != 0)
        sub_4885A6(this);
    return this;
}

//----- (00476BC9) --------------------------------------------------------
void* __thiscall sub_476BC9(void* this, char a2)
{
    sub_476BE8((int)this);
    if ((a2 & 1) != 0)
        sub_4885A6(this);
    return this;
}

//----- (00476BED) --------------------------------------------------------
LPVOID* __thiscall sub_476BED(LPVOID* this, char a2)
{
    sub_476C0C(this);
    if ((a2 & 1) != 0)
        sub_4885A6(this);
    return this;
}

//----- (00476C11) --------------------------------------------------------
unsigned int __cdecl sub_476C11(_DWORD* a1, int a2, int a3)
{
    int v3; // edx
    int v4; // ecx
    _DWORD* v5; // eax
    unsigned int result; // eax

    a1[1] = 0;
    if (a2 != 61)
    {
        *(_DWORD*)(*a1 + 20) = 10;
        *(_DWORD*)(*a1 + 24) = 61;
        *(_DWORD*)(*a1 + 28) = a2;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    if (a3 != 424)
    {
        *(_DWORD*)(*a1 + 20) = 19;
        *(_DWORD*)(*a1 + 24) = 424;
        *(_DWORD*)(*a1 + 28) = a3;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    v3 = *a1;
    memset(a1, 0, 0x1A8u);
    *a1 = v3;
    *((_BYTE*)a1 + 12) = 1;
    sub_47CC85(a1);
    a1[2] = 0;
    a1[5] = 0;
    a1[36] = 0;
    a1[37] = 0;
    a1[38] = 0;
    a1[39] = 0;
    v4 = 4;
    v5 = a1 + 44;
    do
    {
        *(v5 - 4) = 0;
        *v5++ = 0;
        --v4;
    } while (v4);
    sub_478861((int)a1);
    result = sub_47C29B((int)a1);
    if (byte_4B15AC == 2)
    {
        result = sub_47BD85();
        byte_4B15AC = result;
    }
    a1[4] = 200;
    return result;
}
// 4B15AC: using guessed type char byte_4B15AC;

//----- (00476CD2) --------------------------------------------------------
int __cdecl sub_476CD2(int a1)
{
    return sub_47CD61(a1);
}

//----- (00476CDB) --------------------------------------------------------
int __usercall sub_476CDB@<eax>(int a1@<esi>)
{
    int* v1; // eax
    int v2; // ecx
    int v3; // edx
    int v4; // edi
    _DWORD* v5; // eax
    int result; // eax

    switch (*(_DWORD*)(a1 + 32))
    {
    case 1:
        *(_DWORD*)(a1 + 36) = 1;
        *(_DWORD*)(a1 + 40) = 1;
        break;
    case 3:
        if (*(_BYTE*)(a1 + 256))
            goto LABEL_17;
        if (*(_BYTE*)(a1 + 262))
        {
            if (!*(_BYTE*)(a1 + 263))
            {
                *(_DWORD*)(a1 + 36) = 2;
                goto LABEL_24;
            }
            if (*(_BYTE*)(a1 + 263) != 1)
            {
                *(_DWORD*)(*(_DWORD*)a1 + 20) = 110;
                *(_DWORD*)(*(_DWORD*)a1 + 24) = *(unsigned __int8*)(a1 + 263);
                (*(void(__cdecl**)(int, int))(*(_DWORD*)a1 + 4))(a1, -1);
            }
        LABEL_17:
            *(_DWORD*)(a1 + 36) = 3;
        LABEL_24:
            *(_DWORD*)(a1 + 40) = 2;
            break;
        }
        v1 = *(int**)(a1 + 196);
        v2 = *v1;
        v3 = v1[21];
        v4 = v1[42];
        if (*v1 == 1)
        {
            if (v3 == 2 && v4 == 3)
                goto LABEL_23;
        }
        else if (v2 == 82 && v3 == 71 && v4 == 66)
        {
            *(_DWORD*)(a1 + 36) = 2;
            goto LABEL_24;
        }
        v5 = (_DWORD*)(*(_DWORD*)a1 + 24);
        *v5 = v2;
        v5[1] = v3;
        v5[2] = v4;
        *(_DWORD*)(*(_DWORD*)a1 + 20) = 107;
        (*(void(__cdecl**)(int, int))(*(_DWORD*)a1 + 4))(a1, 1);
    LABEL_23:
        *(_DWORD*)(a1 + 36) = 3;
        goto LABEL_24;
    case 4:
        if (*(_BYTE*)(a1 + 262) && *(_BYTE*)(a1 + 263))
        {
            if (*(_BYTE*)(a1 + 263) != 2)
            {
                *(_DWORD*)(*(_DWORD*)a1 + 20) = 110;
                *(_DWORD*)(*(_DWORD*)a1 + 24) = *(unsigned __int8*)(a1 + 263);
                (*(void(__cdecl**)(int, int))(*(_DWORD*)a1 + 4))(a1, -1);
            }
            *(_DWORD*)(a1 + 36) = 5;
        }
        else
        {
            *(_DWORD*)(a1 + 36) = 4;
        }
        *(_DWORD*)(a1 + 40) = 4;
        break;
    default:
        *(_DWORD*)(a1 + 36) = 0;
        *(_DWORD*)(a1 + 40) = 0;
        break;
    }
    *(_BYTE*)(a1 + 64) = 0;
    *(_BYTE*)(a1 + 65) = 0;
    *(double*)(a1 + 56) = 1.0;
    *(_DWORD*)(a1 + 68) = 0;
    *(_BYTE*)(a1 + 74) = 0;
    *(_DWORD*)(a1 + 116) = 0;
    *(_BYTE*)(a1 + 88) = 0;
    *(_BYTE*)(a1 + 89) = 0;
    *(_BYTE*)(a1 + 90) = 0;
    result = 1;
    *(_DWORD*)(a1 + 44) = 1;
    *(_DWORD*)(a1 + 48) = 1;
    *(_BYTE*)(a1 + 72) = 1;
    *(_BYTE*)(a1 + 73) = 1;
    *(_DWORD*)(a1 + 76) = 2;
    *(_BYTE*)(a1 + 80) = 1;
    *(_DWORD*)(a1 + 84) = 256;
    return result;
}

//----- (00476E4E) --------------------------------------------------------
int __cdecl sub_476E4E(_DWORD* a1)
{
    int v1; // eax
    int v2; // edi

    v1 = a1[4];
    v2 = 0;
    switch (v1)
    {
    case 200:
        (*(void(__cdecl**)(_DWORD*))(a1[99] + 4))(a1);
        (*(void(__cdecl**)(_DWORD*))(a1[5] + 8))(a1);
        a1[4] = 201;
        break;
    case 201:
        break;
    case 202:
        return 1;
    default:
        if (v1 > 202 && (v1 <= 208 || v1 == 210))
            return (*(int(__cdecl**)(_DWORD*))a1[99])(a1);
        *(_DWORD*)(*a1 + 20) = 18;
        *(_DWORD*)(*a1 + 24) = a1[4];
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
        return v2;
    }
    v2 = (*(int(__cdecl**)(_DWORD*))a1[99])(a1);
    if (v2 == 1)
    {
        sub_476CDB((int)a1);
        a1[4] = 202;
    }
    return v2;
}

//----- (00476EEB) --------------------------------------------------------
char __cdecl sub_476EEB(int a1)
{
    int v1; // eax

    v1 = *(_DWORD*)(a1 + 16);
    if ((v1 == 205 || v1 == 206) && !*(_BYTE*)(a1 + 64))
    {
        if (*(_DWORD*)(a1 + 120) < *(_DWORD*)(a1 + 96))
        {
            *(_DWORD*)(*(_DWORD*)a1 + 20) = 66;
            (**(void(__cdecl***)(int))a1)(a1);
        }
        (*(void(__cdecl**)(int))(*(_DWORD*)(a1 + 380) + 4))(a1);
        *(_DWORD*)(a1 + 16) = 210;
    }
    else if (v1 == 207)
    {
        *(_DWORD*)(a1 + 16) = 210;
    }
    else if (v1 != 210)
    {
        *(_DWORD*)(*(_DWORD*)a1 + 20) = 18;
        *(_DWORD*)(*(_DWORD*)a1 + 24) = *(_DWORD*)(a1 + 16);
        (**(void(__cdecl***)(int))a1)(a1);
    }
    do
    {
        if (*(_BYTE*)(*(_DWORD*)(a1 + 396) + 17))
        {
            (*(void(__cdecl**)(int))(*(_DWORD*)(a1 + 20) + 24))(a1);
            sub_47CD3C(a1);
            return 1;
        }
    } while ((**(int(__cdecl***)(int))(a1 + 396))(a1));
    return 0;
}

//----- (00476F95) --------------------------------------------------------
int __cdecl sub_476F95(_DWORD* a1, char a2)
{
    int v2; // eax
    int result; // eax

    v2 = a1[4];
    if (v2 != 200 && v2 != 201)
    {
        *(_DWORD*)(*a1 + 20) = 18;
        *(_DWORD*)(*a1 + 24) = a1[4];
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    result = sub_476E4E(a1);
    if (result == 1)
        return 1;
    if (result == 2)
    {
        if (a2)
        {
            *(_DWORD*)(*a1 + 20) = 50;
            (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
        }
        sub_47CD3C((int)a1);
        return 2;
    }
    return result;
}

//----- (00476FFA) --------------------------------------------------------
char __usercall sub_476FFA@<al>(int a1@<esi>)
{
    unsigned int* v1; // edi
    unsigned int v2; // eax
    int v3; // ecx
    unsigned int v4; // ebx

    if (*(_DWORD*)(a1 + 16) != 204)
    {
        (**(void(__cdecl***)(int))(a1 + 380))(a1);
        *(_DWORD*)(a1 + 120) = 0;
        *(_DWORD*)(a1 + 16) = 204;
    }
    if (*(_BYTE*)(*(_DWORD*)(a1 + 380) + 8))
    {
        v1 = (unsigned int*)(a1 + 120);
        while (1)
        {
            v2 = *v1;
            if (*v1 < *(_DWORD*)(a1 + 96))
                break;
        LABEL_10:
            (*(void(__cdecl**)(int))(*(_DWORD*)(a1 + 380) + 4))(a1);
            (**(void(__cdecl***)(int))(a1 + 380))(a1);
            *v1 = 0;
            if (!*(_BYTE*)(*(_DWORD*)(a1 + 380) + 8))
                goto LABEL_11;
        }
        while (1)
        {
            v3 = *(_DWORD*)(a1 + 8);
            if (v3)
            {
                *(_DWORD*)(v3 + 4) = v2;
                *(_DWORD*)(*(_DWORD*)(a1 + 8) + 8) = *(_DWORD*)(a1 + 96);
                (**(void(__cdecl***)(int))(a1 + 8))(a1);
            }
            v4 = *v1;
            (*(void(__cdecl**)(int, _DWORD, int, _DWORD))(*(_DWORD*)(a1 + 384) + 4))(a1, 0, a1 + 120, 0);
            v2 = *v1;
            if (*v1 == v4)
                return 0;
            if (v2 >= *(_DWORD*)(a1 + 96))
                goto LABEL_10;
        }
    }
    else
    {
    LABEL_11:
        *(_DWORD*)(a1 + 16) = (*(_BYTE*)(a1 + 65) != 0) + 205;
        return 1;
    }
}

//----- (004770A5) --------------------------------------------------------
_DWORD* __cdecl sub_4770A5(_DWORD* a1, int a2, int a3)
{
    _DWORD* v3; // esi
    unsigned int v4; // ecx
    _DWORD* result; // eax
    int v6; // eax
    int v7; // eax

    v3 = a1;
    if (a1[4] != 205)
    {
        *(_DWORD*)(*a1 + 20) = 18;
        *(_DWORD*)(*v3 + 24) = v3[4];
        (*(void(__cdecl**)(_DWORD*)) * v3)(v3);
    }
    v4 = v3[30];
    if (v4 < v3[24])
    {
        v6 = v3[2];
        if (v6)
        {
            *(_DWORD*)(v6 + 4) = v4;
            *(_DWORD*)(v3[2] + 8) = v3[24];
            (*(void(__cdecl**)(_DWORD*))v3[2])(v3);
        }
        v7 = v3[96];
        a1 = 0;
        (*(void(__cdecl**)(_DWORD*, int, _DWORD**, int))(v7 + 4))(v3, a2, &a1, a3);
        result = a1;
        v3[30] += a1;
    }
    else
    {
        *(_DWORD*)(*v3 + 20) = 119;
        (*(void(__cdecl**)(_DWORD*, int))(*v3 + 4))(v3, -1);
        return 0;
    }
    return result;
}

//----- (00477129) --------------------------------------------------------
char __cdecl sub_477129(int a1)
{
    int v2; // eax
    void(__cdecl * *v3)(int); // eax
    int v4; // eax
    int v5; // ecx
    int v6; // eax
    int v7; // ecx

    if (*(_DWORD*)(a1 + 16) == 202)
    {
        sub_47D39E(a1);
        if (*(_BYTE*)(a1 + 64))
        {
            *(_DWORD*)(a1 + 16) = 207;
            return 1;
        }
        *(_DWORD*)(a1 + 16) = 203;
    }
    v2 = *(_DWORD*)(a1 + 16);
    if (v2 != 203)
    {
        if (v2 != 204)
        {
            *(_DWORD*)(*(_DWORD*)a1 + 20) = 18;
            *(_DWORD*)(*(_DWORD*)a1 + 24) = *(_DWORD*)(a1 + 16);
            (**(void(__cdecl***)(int))a1)(a1);
        }
        return sub_476FFA(a1);
    }
    if (!*(_BYTE*)(*(_DWORD*)(a1 + 396) + 16))
    {
    LABEL_17:
        *(_DWORD*)(a1 + 132) = *(_DWORD*)(a1 + 124);
        return sub_476FFA(a1);
    }
    while (1)
    {
        v3 = *(void(__cdecl***)(int))(a1 + 8);
        if (v3)
            (*v3)(a1);
        v4 = (**(int(__cdecl***)(int))(a1 + 396))(a1);
        if (!v4)
            return 0;
        if (v4 == 2)
            goto LABEL_17;
        v5 = *(_DWORD*)(a1 + 8);
        if (v5 && (v4 == 3 || v4 == 1))
        {
            ++*(_DWORD*)(v5 + 4);
            v6 = *(_DWORD*)(a1 + 8);
            v7 = *(_DWORD*)(v6 + 8);
            if (*(_DWORD*)(v6 + 4) >= v7)
                *(_DWORD*)(v6 + 8) = v7 + *(_DWORD*)(a1 + 280);
        }
    }
}

//----- (004771F0) --------------------------------------------------------
char __usercall sub_4771F0@<al>(int a1@<esi>)
{
    _BYTE* v1; // eax
    int v2; // ecx
    int v3; // eax

    *(_DWORD*)(*(_DWORD*)a1 + 20) = 101;
    (*(void(__cdecl**)(int, int))(*(_DWORD*)a1 + 4))(a1, 1);
    if (*(_BYTE*)(*(_DWORD*)(a1 + 400) + 80))
    {
        *(_DWORD*)(*(_DWORD*)a1 + 20) = 60;
        (**(void(__cdecl***)(int))a1)(a1);
    }
    v1 = (_BYTE*)(a1 + 218);
    v2 = 16;
    do
    {
        *(v1 - 16) = 0;
        *v1 = 1;
        v1[16] = 5;
        ++v1;
        --v2;
    } while (v2);
    v3 = *(_DWORD*)(a1 + 400);
    *(_DWORD*)(a1 + 252) = 0;
    *(_DWORD*)(a1 + 36) = 0;
    *(_BYTE*)(a1 + 264) = 0;
    *(_BYTE*)(a1 + 256) = 0;
    *(_BYTE*)(a1 + 257) = 0;
    *(_BYTE*)(a1 + 262) = 0;
    *(_BYTE*)(a1 + 263) = 0;
    *(_WORD*)(a1 + 258) = 1;
    *(_WORD*)(a1 + 260) = 1;
    *(_BYTE*)(v3 + 80) = 1;
    return 1;
}

//----- (0047727E) --------------------------------------------------------
char __usercall sub_47727E@<al>(char a1@<cl>, int a2@<esi>, char a3)
{
    unsigned __int8** v3; // ebx
    unsigned __int8* v4; // eax
    unsigned __int8* v5; // edi
    unsigned __int16 v6; // ax
    unsigned __int8* v7; // edi
    unsigned __int8* v8; // edi
    int v9; // eax
    unsigned __int8* v10; // edi
    unsigned __int16 v11; // ax
    unsigned __int8* v12; // edi
    unsigned __int8* v13; // edi
    unsigned __int16 v14; // ax
    unsigned __int8* v15; // edi
    unsigned __int8* v16; // edi
    int v17; // ecx
    _DWORD* v18; // eax
    unsigned __int8* v19; // edi
    _DWORD* v20; // eax
    int v22; // ecx
    unsigned __int8* v23; // edi
    int v24; // ecx
    unsigned __int8* v25; // edi
    int v26; // edx
    _DWORD* v27; // ecx
    int v28; // [esp+8h] [ebp-8h]
    unsigned __int8* v29; // [esp+Ch] [ebp-4h]
    unsigned __int8* v30; // [esp+Ch] [ebp-4h]
    unsigned __int8* v31; // [esp+Ch] [ebp-4h]
    unsigned __int8* v32; // [esp+Ch] [ebp-4h]
    unsigned __int8* v33; // [esp+Ch] [ebp-4h]
    unsigned __int8* v34; // [esp+Ch] [ebp-4h]
    unsigned __int8* v35; // [esp+Ch] [ebp-4h]
    unsigned __int8* v36; // [esp+Ch] [ebp-4h]
    unsigned __int8* v37; // [esp+Ch] [ebp-4h]
    unsigned __int8* v38; // [esp+Ch] [ebp-4h]
    unsigned __int8* v39; // [esp+Ch] [ebp-4h]
    int v40; // [esp+18h] [ebp+8h]
    int v41; // [esp+18h] [ebp+8h]
    int v42; // [esp+18h] [ebp+8h]
    _DWORD* v43; // [esp+18h] [ebp+8h]

    v3 = *(unsigned __int8***)(a2 + 20);
    v4 = v3[1];
    v5 = *v3;
    *(_BYTE*)(a2 + 200) = a1;
    v29 = v4;
    *(_BYTE*)(a2 + 201) = a3;
    if (!v4)
    {
        if (!((unsigned __int8(__cdecl*)(int))v3[3])(a2))
            return 0;
        v5 = *v3;
        v29 = v3[1];
    }
    v30 = v29 - 1;
    LOBYTE(v6) = 0;
    HIBYTE(v6) = *v5;
    v7 = v5 + 1;
    v40 = v6;
    if (!v30)
    {
        if (!((unsigned __int8(__cdecl*)(int))v3[3])(a2))
            return 0;
        v7 = *v3;
        v30 = v3[1];
    }
    v31 = v30 - 1;
    v41 = *v7 + v40;
    v8 = v7 + 1;
    if (!v31)
    {
        if (!((unsigned __int8(__cdecl*)(int))v3[3])(a2))
            return 0;
        v8 = *v3;
        v31 = v3[1];
    }
    v9 = *v8;
    v32 = v31 - 1;
    v10 = v8 + 1;
    *(_DWORD*)(a2 + 192) = v9;
    if (!v32)
    {
        if (!((unsigned __int8(__cdecl*)(int))v3[3])(a2))
            return 0;
        v10 = *v3;
        v32 = v3[1];
    }
    v33 = v32 - 1;
    LOBYTE(v11) = 0;
    HIBYTE(v11) = *v10;
    v12 = v10 + 1;
    *(_DWORD*)(a2 + 28) = v11;
    if (!v33)
    {
        if (!((unsigned __int8(__cdecl*)(int))v3[3])(a2))
            return 0;
        v12 = *v3;
        v33 = v3[1];
    }
    v34 = v33 - 1;
    *(_DWORD*)(a2 + 28) += *v12;
    v13 = v12 + 1;
    if (!v34)
    {
        if (!((unsigned __int8(__cdecl*)(int))v3[3])(a2))
            return 0;
        v13 = *v3;
        v34 = v3[1];
    }
    v35 = v34 - 1;
    LOBYTE(v14) = 0;
    HIBYTE(v14) = *v13;
    v15 = v13 + 1;
    *(_DWORD*)(a2 + 24) = v14;
    if (!v35)
    {
        if (!((unsigned __int8(__cdecl*)(int))v3[3])(a2))
            return 0;
        v15 = *v3;
        v35 = v3[1];
    }
    v36 = v35 - 1;
    *(_DWORD*)(a2 + 24) += *v15;
    v16 = v15 + 1;
    if (!v36)
    {
        if (((unsigned __int8(__cdecl*)(int))v3[3])(a2))
        {
            v16 = *v3;
            v36 = v3[1];
            goto LABEL_25;
        }
        return 0;
    }
LABEL_25:
    v17 = *(_DWORD*)(a2 + 376);
    v37 = v36 - 1;
    v42 = v41 - 8;
    *(_DWORD*)(a2 + 32) = *v16;
    v18 = (_DWORD*)(*(_DWORD*)a2 + 24);
    *v18 = v17;
    v18[1] = *(_DWORD*)(a2 + 24);
    v18[2] = *(_DWORD*)(a2 + 28);
    v18[3] = *(_DWORD*)(a2 + 32);
    *(_DWORD*)(*(_DWORD*)a2 + 20) = 99;
    v19 = v16 + 1;
    (*(void(__cdecl**)(int, int))(*(_DWORD*)a2 + 4))(a2, 1);
    if (*(_BYTE*)(*(_DWORD*)(a2 + 400) + 81))
    {
        *(_DWORD*)(*(_DWORD*)a2 + 20) = 57;
        (**(void(__cdecl***)(int))a2)(a2);
    }
    if (!*(_DWORD*)(a2 + 28) || !*(_DWORD*)(a2 + 24) || *(int*)(a2 + 32) <= 0)
    {
        *(_DWORD*)(*(_DWORD*)a2 + 20) = 31;
        (**(void(__cdecl***)(int))a2)(a2);
    }
    if (v42 != 3 * *(_DWORD*)(a2 + 32))
    {
        *(_DWORD*)(*(_DWORD*)a2 + 20) = 9;
        (**(void(__cdecl***)(int))a2)(a2);
    }
    if (!*(_DWORD*)(a2 + 196))
        *(_DWORD*)(a2 + 196) = (**(int(__cdecl***)(int, int, int))(a2 + 4))(a2, 1, 84 * *(_DWORD*)(a2 + 32));
    v28 = 0;
    v20 = *(_DWORD**)(a2 + 196);
    v43 = v20;
    if (*(int*)(a2 + 32) > 0)
    {
        while (1)
        {
            v20[1] = v28;
            if (!v37)
            {
                if (!((unsigned __int8(__cdecl*)(int))v3[3])(a2))
                    return 0;
                v19 = *v3;
                v37 = v3[1];
                v20 = v43;
            }
            v22 = *v19;
            v38 = v37 - 1;
            v23 = v19 + 1;
            *v20 = v22;
            if (!v38)
            {
                if (!((unsigned __int8(__cdecl*)(int))v3[3])(a2))
                    return 0;
                v23 = *v3;
                v38 = v3[1];
                v20 = v43;
            }
            v24 = *v23;
            v39 = v38 - 1;
            v25 = v23 + 1;
            v20[2] = (v24 >> 4) & 0xF;
            v20[3] = v24 & 0xF;
            if (!v39)
            {
                if (!((unsigned __int8(__cdecl*)(int))v3[3])(a2))
                    return 0;
                v25 = *v3;
                v39 = v3[1];
                v20 = v43;
            }
            v26 = *v20;
            v37 = v39 - 1;
            v20[4] = *v25;
            v27 = (_DWORD*)(*(_DWORD*)a2 + 24);
            *v27 = v26;
            v27[1] = v20[2];
            v27[2] = v20[3];
            v27[3] = v20[4];
            *(_DWORD*)(*(_DWORD*)a2 + 20) = 100;
            v19 = v25 + 1;
            (*(void(__cdecl**)(int, int))(*(_DWORD*)a2 + 4))(a2, 1);
            ++v28;
            v43 += 21;
            if (v28 >= *(_DWORD*)(a2 + 32))
                break;
            v20 = v43;
        }
    }
    *(_BYTE*)(*(_DWORD*)(a2 + 400) + 81) = 1;
    v3[1] = v37;
    *v3 = v19;
    return 1;
}

//----- (00477579) --------------------------------------------------------
char __usercall sub_477579@<al>(_DWORD* a1@<esi>)
{
    unsigned __int8** v1; // ebx
    unsigned __int8* v2; // edi
    unsigned __int16 v3; // ax
    unsigned __int8* v4; // edi
    unsigned __int8* v5; // edi
    int v6; // eax
    unsigned __int8* v7; // edi
    int v8; // eax
    unsigned __int8* v9; // edi
    int v10; // eax
    _DWORD* v11; // ecx
    _DWORD* v12; // eax
    int v13; // eax
    unsigned __int8* v14; // edi
    int v15; // eax
    unsigned __int8* v16; // edi
    int v18; // ecx
    _DWORD* v19; // eax
    int v20; // [esp+8h] [ebp-20h]
    _DWORD* v21; // [esp+Ch] [ebp-1Ch]
    int v22; // [esp+10h] [ebp-18h]
    int v23; // [esp+14h] [ebp-14h]
    _DWORD* v24; // [esp+18h] [ebp-10h]
    int v25; // [esp+1Ch] [ebp-Ch]
    int v26; // [esp+20h] [ebp-8h]
    int v27; // [esp+20h] [ebp-8h]
    int v28; // [esp+20h] [ebp-8h]
    unsigned __int8* v29; // [esp+24h] [ebp-4h]
    unsigned __int8* v30; // [esp+24h] [ebp-4h]
    unsigned __int8* v31; // [esp+24h] [ebp-4h]
    unsigned __int8* v32; // [esp+24h] [ebp-4h]
    unsigned __int8* v33; // [esp+24h] [ebp-4h]
    unsigned __int8* v34; // [esp+24h] [ebp-4h]
    unsigned __int8* v35; // [esp+24h] [ebp-4h]

    v1 = (unsigned __int8**)a1[5];
    v29 = v1[1];
    v2 = *v1;
    if (!*(_BYTE*)(a1[100] + 81))
    {
        *(_DWORD*)(*a1 + 20) = 61;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    if (!v29)
    {
        if (!((unsigned __int8(__cdecl*)(_DWORD*))v1[3])(a1))
            return 0;
        v2 = *v1;
        v29 = v1[1];
    }
    v30 = v29 - 1;
    LOBYTE(v3) = 0;
    HIBYTE(v3) = *v2;
    v4 = v2 + 1;
    v26 = v3;
    if (!v30)
    {
        if (!((unsigned __int8(__cdecl*)(_DWORD*))v1[3])(a1))
            return 0;
        v4 = *v1;
        v30 = v1[1];
    }
    v31 = v30 - 1;
    v27 = *v4 + v26;
    v5 = v4 + 1;
    if (!v31)
    {
        if (!((unsigned __int8(__cdecl*)(_DWORD*))v1[3])(a1))
            return 0;
        v5 = *v1;
        v31 = v1[1];
    }
    v6 = *v5;
    v32 = v31 - 1;
    v7 = v5 + 1;
    v22 = v6;
    if (v27 != 2 * v6 + 6 || v6 < 1 || v6 > 4)
    {
        *(_DWORD*)(*a1 + 20) = 9;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
        v6 = v22;
    }
    *(_DWORD*)(*a1 + 20) = 102;
    *(_DWORD*)(*a1 + 24) = v6;
    (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
    v23 = 0;
    a1[72] = v22;
    if (v22 > 0)
    {
        v24 = a1 + 73;
        do
        {
            if (!v32)
            {
                if (!((unsigned __int8(__cdecl*)(_DWORD*))v1[3])(a1))
                    return 0;
                v7 = *v1;
                v32 = v1[1];
            }
            v8 = *v7;
            v33 = v32 - 1;
            v9 = v7 + 1;
            v25 = v8;
            if (!v33)
            {
                if (!((unsigned __int8(__cdecl*)(_DWORD*))v1[3])(a1))
                    return 0;
                v9 = *v1;
                v33 = v1[1];
            }
            v10 = *v9;
            v32 = v33 - 1;
            v28 = 0;
            v11 = (_DWORD*)a1[49];
            v7 = v9 + 1;
            v20 = v10;
            v21 = v11;
            if ((int)a1[8] <= 0)
            {
            LABEL_27:
                *(_DWORD*)(*a1 + 20) = 5;
                *(_DWORD*)(*a1 + 24) = v25;
                (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
                v10 = v20;
                v11 = v21;
            }
            else
            {
                while (v25 != *v11)
                {
                    ++v28;
                    v11 += 21;
                    v21 = v11;
                    if (v28 >= a1[8])
                        goto LABEL_27;
                }
            }
            *v24 = v11;
            v11[6] = v10 & 0xF;
            v11[5] = (v10 >> 4) & 0xF;
            v12 = (_DWORD*)(*a1 + 24);
            *v12 = v25;
            v12[1] = v11[5];
            v12[2] = v11[6];
            *(_DWORD*)(*a1 + 20) = 103;
            (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
            ++v23;
            ++v24;
        } while (v23 < v22);
    }
    if (!v32)
    {
        if (!((unsigned __int8(__cdecl*)(_DWORD*))v1[3])(a1))
            return 0;
        v7 = *v1;
        v32 = v1[1];
    }
    v13 = *v7;
    v34 = v32 - 1;
    v14 = v7 + 1;
    a1[90] = v13;
    if (v34)
        goto LABEL_35;
    if (!((unsigned __int8(__cdecl*)(_DWORD*))v1[3])(a1))
        return 0;
    v14 = *v1;
    v34 = v1[1];
LABEL_35:
    v15 = *v14;
    v35 = v34 - 1;
    v16 = v14 + 1;
    a1[91] = v15;
    if (!v35)
    {
        if (!((unsigned __int8(__cdecl*)(_DWORD*))v1[3])(a1))
            return 0;
        v16 = *v1;
        v35 = v1[1];
    }
    v18 = (int)*v16 >> 4;
    a1[93] = *v16 & 0xF;
    v19 = (_DWORD*)*a1;
    a1[92] = v18 & 0xF;
    v19 += 6;
    *v19 = a1[90];
    v19[1] = a1[91];
    v19[2] = a1[92];
    v19[3] = a1[93];
    *(_DWORD*)(*a1 + 20) = 104;
    (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
    *(_DWORD*)(a1[100] + 84) = 0;
    ++a1[31];
    v1[1] = v35 - 1;
    *v1 = v16 + 1;
    return 1;
}

//----- (0047782B) --------------------------------------------------------
char __cdecl sub_47782B(_DWORD* a1)
{
    unsigned __int8** v2; // edi
    unsigned __int8* v3; // ebx
    unsigned __int16 v4; // ax
    unsigned __int8* v5; // ebx
    unsigned __int8* v6; // ebx
    unsigned __int8 v7; // al
    int v8; // ecx
    bool v9; // cc
    __int16 v11; // cx
    __int16 v12; // dx
    __int16 v13; // ax
    unsigned __int16 v14; // cx
    __int16 v15; // ax
    _DWORD* v16; // eax
    int v17; // eax
    int v18; // ecx
    _BYTE v19[5]; // [esp+Ch] [ebp-18h]
    unsigned __int8 v20; // [esp+11h] [ebp-13h]
    unsigned __int8 v21; // [esp+12h] [ebp-12h]
    char v22; // [esp+13h] [ebp-11h]
    unsigned __int8 v23; // [esp+14h] [ebp-10h]
    unsigned __int8 v24; // [esp+15h] [ebp-Fh]
    unsigned __int8 v25; // [esp+16h] [ebp-Eh]
    unsigned __int8 v26; // [esp+17h] [ebp-Dh]
    __int16 v27; // [esp+18h] [ebp-Ch]
    int v28; // [esp+1Ch] [ebp-8h]
    int v29; // [esp+20h] [ebp-4h]
    unsigned __int8* v30; // [esp+2Ch] [ebp+8h]
    unsigned __int8* v31; // [esp+2Ch] [ebp+8h]
    unsigned __int8* v32; // [esp+2Ch] [ebp+8h]

    v2 = (unsigned __int8**)a1[5];
    v3 = *v2;
    v30 = v2[1];
    if (!v30)
    {
        if (!((unsigned __int8(__cdecl*)(_DWORD*))v2[3])(a1))
            return 0;
        v3 = *v2;
        v30 = v2[1];
    }
    v31 = v30 - 1;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = *v3;
    v5 = v3 + 1;
    v29 = v4;
    if (v31)
        goto LABEL_7;
    if (!((unsigned __int8(__cdecl*)(_DWORD*))v2[3])(a1))
        return 0;
    v5 = *v2;
    v31 = v2[1];
LABEL_7:
    v32 = v31 - 1;
    v29 = *v5 + v29 - 2;
    v6 = v5 + 1;
    if (v29 < 14)
    {
        v18 = v29;
        *(_DWORD*)(*a1 + 20) = 76;
        *(_DWORD*)(*a1 + 24) = v18;
    }
    else
    {
        v28 = 0;
        do
        {
            if (!v32)
            {
                if (!((unsigned __int8(__cdecl*)(_DWORD*))v2[3])(a1))
                    return 0;
                v6 = *v2;
                v32 = v2[1];
            }
            --v32;
            v7 = *v6;
            v8 = v28;
            ++v6;
            v9 = ++v28 < 14;
            v19[v8] = v7;
        } while (v9);
        v29 -= 14;
        if (v19[0] == 74 && v19[1] == 70 && v19[2] == 73 && v19[3] == 70 && !v19[4])
        {
            if (v20 == 1)
            {
                if (v21 > 2u)
                {
                    *(_DWORD*)(*a1 + 20) = 88;
                    *(_DWORD*)(*a1 + 24) = 1;
                    *(_DWORD*)(*a1 + 28) = v21;
                    (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
                }
            }
            else
            {
                *(_DWORD*)(*a1 + 20) = 115;
                *(_DWORD*)(*a1 + 24) = v20;
                *(_DWORD*)(*a1 + 28) = v21;
                (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, -1);
            }
            v11 = v24;
            v12 = v26;
            *((_BYTE*)a1 + 257) = v22;
            v13 = v23;
            *((_BYTE*)a1 + 256) = 1;
            v14 = (v13 << 8) + v11;
            v15 = v25;
            *((_WORD*)a1 + 129) = v14;
            *((_WORD*)a1 + 130) = v12 + (v15 << 8);
            v16 = (_DWORD*)(*a1 + 24);
            *v16 = v14;
            v16[1] = *((unsigned __int16*)a1 + 130);
            v16[2] = *((unsigned __int8*)a1 + 257);
            *(_DWORD*)(*a1 + 20) = 86;
            (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
            if (v27)
            {
                *(_DWORD*)(*a1 + 20) = 89;
                *(_DWORD*)(*a1 + 24) = (unsigned __int8)v27;
                *(_DWORD*)(*a1 + 28) = HIBYTE(v27);
                (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
            }
            v17 = v29;
            if (v29 == 3 * (unsigned __int8)v27 * HIBYTE(v27))
                goto LABEL_31;
            *(_DWORD*)(*a1 + 20) = 87;
        }
        else
        {
            *(_DWORD*)(*a1 + 20) = 76;
            v17 = v29 + 14;
        }
        *(_DWORD*)(*a1 + 24) = v17;
    }
    (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
LABEL_31:
    v9 = v29 <= 0;
    *v2 = v6;
    v2[1] = v32;
    if (!v9)
        (*(void(__cdecl**)(_DWORD*, int))(a1[5] + 16))(a1, v29);
    return 1;
}

//----- (00477A67) --------------------------------------------------------
char __cdecl sub_477A67(_DWORD* a1)
{
    unsigned __int8** v2; // edi
    unsigned __int8* v3; // ebx
    unsigned __int16 v4; // ax
    unsigned __int8* v5; // ebx
    unsigned __int8* v6; // ebx
    unsigned __int8 v7; // al
    int v8; // ecx
    bool v9; // cc
    int v10; // edx
    _DWORD* v11; // eax
    int v12; // ecx
    int v13; // edx
    unsigned __int8 v14; // al
    int v16; // ecx
    _BYTE v17[11]; // [esp+Ch] [ebp-14h]
    unsigned __int8 v18; // [esp+17h] [ebp-9h]
    int v19; // [esp+18h] [ebp-8h]
    int v20; // [esp+1Ch] [ebp-4h]
    unsigned __int8* v21; // [esp+28h] [ebp+8h]
    unsigned __int8* v22; // [esp+28h] [ebp+8h]
    unsigned __int8* v23; // [esp+28h] [ebp+8h]

    v2 = (unsigned __int8**)a1[5];
    v3 = *v2;
    v21 = v2[1];
    if (!v21)
    {
        if (!((unsigned __int8(__cdecl*)(_DWORD*))v2[3])(a1))
            return 0;
        v3 = *v2;
        v21 = v2[1];
    }
    v22 = v21 - 1;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = *v3;
    v5 = v3 + 1;
    v20 = v4;
    if (v22)
        goto LABEL_7;
    if (!((unsigned __int8(__cdecl*)(_DWORD*))v2[3])(a1))
        return 0;
    v5 = *v2;
    v22 = v2[1];
LABEL_7:
    v23 = v22 - 1;
    v20 = *v5 + v20 - 2;
    v6 = v5 + 1;
    if (v20 < 12)
    {
        v16 = v20;
        *(_DWORD*)(*a1 + 20) = 77;
        *(_DWORD*)(*a1 + 24) = v16;
        goto LABEL_22;
    }
    v19 = 0;
    do
    {
        if (!v23)
        {
            if (!((unsigned __int8(__cdecl*)(_DWORD*))v2[3])(a1))
                return 0;
            v6 = *v2;
            v23 = v2[1];
        }
        --v23;
        v7 = *v6;
        v8 = v19;
        ++v6;
        v9 = ++v19 < 12;
        v17[v8] = v7;
    } while (v9);
    v20 -= 12;
    if (v17[0] != 65 || v17[1] != 100 || v17[2] != 111 || v17[3] != 98 || v17[4] != 101)
    {
        *(_DWORD*)(*a1 + 20) = 77;
        *(_DWORD*)(*a1 + 24) = v20 + 12;
    LABEL_22:
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
        goto LABEL_23;
    }
    v10 = v17[8];
    v11 = (_DWORD*)(*a1 + 24);
    *v11 = v17[6] + (v17[5] << 8);
    v12 = v10 + (v17[7] << 8);
    v13 = v17[10];
    v11[1] = v12;
    v11[2] = v13 + (v17[9] << 8);
    v11[3] = v18;
    *(_DWORD*)(*a1 + 20) = 75;
    (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
    v14 = v18;
    *((_BYTE*)a1 + 262) = 1;
    *((_BYTE*)a1 + 263) = v14;
LABEL_23:
    v9 = v20 <= 0;
    *v2 = v6;
    v2[1] = v23;
    if (!v9)
        (*(void(__cdecl**)(_DWORD*, int))(a1[5] + 16))(a1, v20);
    return 1;
}

//----- (00477BE1) --------------------------------------------------------
char __usercall sub_477BE1@<al>(_DWORD* a1@<esi>)
{
    unsigned __int8** v1; // ebx
    unsigned __int8* v2; // edi
    unsigned __int16 v3; // ax
    unsigned __int8* v4; // edi
    unsigned __int8* v5; // edi
    int v6; // eax
    unsigned __int8* v7; // edi
    int v8; // eax
    int v9; // eax
    int v11; // [esp+8h] [ebp-10h]
    int v12; // [esp+Ch] [ebp-Ch]
    int v13; // [esp+10h] [ebp-8h]
    int v14; // [esp+10h] [ebp-8h]
    int v15; // [esp+10h] [ebp-8h]
    unsigned __int8* v16; // [esp+14h] [ebp-4h]
    unsigned __int8* v17; // [esp+14h] [ebp-4h]
    unsigned __int8* v18; // [esp+14h] [ebp-4h]
    unsigned __int8* v19; // [esp+14h] [ebp-4h]

    v1 = (unsigned __int8**)a1[5];
    v2 = *v1;
    v16 = v1[1];
    if (!v16)
    {
        if (!((unsigned __int8(__cdecl*)(_DWORD*))v1[3])(a1))
            return 0;
        v2 = *v1;
        v16 = v1[1];
    }
    v17 = v16 - 1;
    LOBYTE(v3) = 0;
    HIBYTE(v3) = *v2;
    v4 = v2 + 1;
    v13 = v3;
    if (v17)
        goto LABEL_7;
    if (!((unsigned __int8(__cdecl*)(_DWORD*))v1[3])(a1))
        return 0;
    v4 = *v1;
    v17 = v1[1];
LABEL_7:
    v18 = v17 - 1;
    v14 = *v4 + v13;
    v5 = v4 + 1;
    v15 = v14 - 2;
    while (v15 > 0)
    {
        if (!v18)
        {
            if (!((unsigned __int8(__cdecl*)(_DWORD*))v1[3])(a1))
                return 0;
            v5 = *v1;
            v18 = v1[1];
        }
        v6 = *v5;
        v19 = v18 - 1;
        v7 = v5 + 1;
        v12 = v6;
        if (!v19)
        {
            if (!((unsigned __int8(__cdecl*)(_DWORD*))v1[3])(a1))
                return 0;
            v7 = *v1;
            v19 = v1[1];
        }
        v8 = *v7;
        v18 = v19 - 1;
        v15 -= 2;
        *(_DWORD*)(*a1 + 20) = 78;
        *(_DWORD*)(*a1 + 24) = v12;
        v11 = v8;
        *(_DWORD*)(*a1 + 28) = v8;
        v5 = v7 + 1;
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
        v9 = v12;
        if (v12 >= 32)
        {
            *(_DWORD*)(*a1 + 20) = 26;
            *(_DWORD*)(*a1 + 24) = v12;
            (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
            v9 = v12;
        }
        if (v9 < 16)
        {
            *((_BYTE*)a1 + v9 + 202) = v11 & 0xF;
            *((_BYTE*)a1 + v9 + 218) = v11 >> 4;
            if ((unsigned __int8)(v11 & 0xF) > (unsigned __int8)(v11 >> 4))
            {
                *(_DWORD*)(*a1 + 20) = 27;
                *(_DWORD*)(*a1 + 24) = v11;
                (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
            }
        }
        else
        {
            *((_BYTE*)a1 + v9 + 218) = v11;
        }
    }
    v1[1] = v18;
    *v1 = v5;
    return 1;
}
// 477CB9: conditional instruction was optimized away because %var_C.4<100u

//----- (00477D38) --------------------------------------------------------
char __usercall sub_477D38@<al>(_DWORD* a1@<ebx>)
{
    int v1; // esi
    int v2; // eax
    char* v3; // edi
    unsigned __int16 v4; // ax
    char* v5; // edi
    int v6; // eax
    char* v7; // edi
    unsigned int v8; // eax
    int v9; // ecx
    int v10; // ecx
    unsigned __int8* v11; // edi
    unsigned __int8 v12; // cl
    _DWORD* v13; // eax
    _DWORD* v14; // eax
    int i; // edi
    char v16; // al
    unsigned int v17; // eax
    int* v18; // edi
    int v19; // edi
    int v20; // eax
    _BYTE v22[256]; // [esp+8h] [ebp-130h] BYREF
    unsigned int v23; // [esp+108h] [ebp-30h]
    int v24; // [esp+10Ch] [ebp-2Ch]
    int v25; // [esp+110h] [ebp-28h]
    int v26; // [esp+114h] [ebp-24h]
    int v27; // [esp+118h] [ebp-20h]
    int v28; // [esp+11Ch] [ebp-1Ch]
    unsigned __int8 v29; // [esp+120h] [ebp-18h]
    int v30; // [esp+124h] [ebp-14h]
    int v31; // [esp+128h] [ebp-10h]
    int v32; // [esp+12Ch] [ebp-Ch]
    char* v33; // [esp+130h] [ebp-8h]
    int v34; // [esp+134h] [ebp-4h]

    v1 = a1[5];
    v2 = *(_DWORD*)(v1 + 4);
    v3 = *(char**)v1;
    v24 = v1;
    v34 = v2;
    if (!v2)
    {
        if (!(*(unsigned __int8(__cdecl**)(_DWORD*))(v1 + 12))(a1))
            return 0;
        v33 = *(char**)v1;
        v3 = v33;
        v34 = *(_DWORD*)(v1 + 4);
    }
    --v34;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = *v3;
    v5 = v3 + 1;
    v32 = v4;
    if (v34)
        goto LABEL_7;
    if (!(*(unsigned __int8(__cdecl**)(_DWORD*))(v1 + 12))(a1))
        return 0;
    v33 = *(char**)v1;
    v5 = v33;
    v34 = *(_DWORD*)(v1 + 4);
LABEL_7:
    v6 = (unsigned __int8)*v5;
    --v34;
    v7 = v5 + 1;
    v32 = v6 + v32 - 2;
    while (v32 > 0)
    {
        if (!v34)
        {
            if (!(*(unsigned __int8(__cdecl**)(_DWORD*))(v1 + 12))(a1))
                return 0;
            v33 = *(char**)v1;
            v7 = v33;
            v34 = *(_DWORD*)(v1 + 4);
        }
        v8 = (unsigned __int8)*v7;
        v9 = *a1;
        --v34;
        *(_DWORD*)(v9 + 20) = 79;
        v10 = *a1;
        v23 = v8;
        *(_DWORD*)(v10 + 24) = v8;
        v11 = (unsigned __int8*)(v7 + 1);
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
        LOBYTE(v25) = 0;
        v30 = 0;
        v31 = 1;
        do
        {
            if (!v34)
            {
                if (!(*(unsigned __int8(__cdecl**)(_DWORD*))(v1 + 12))(a1))
                    return 0;
                v33 = *(char**)v1;
                v11 = (unsigned __int8*)v33;
                v34 = *(_DWORD*)(v1 + 4);
            }
            v12 = *v11;
            --v34;
            *((_BYTE*)&v25 + v31) = v12;
            v30 += v12;
            ++v11;
            ++v31;
            v33 = (char*)v11;
        } while (v31 <= 16);
        v13 = (_DWORD*)(*a1 + 24);
        *v13 = BYTE1(v25);
        v13[1] = BYTE2(v25);
        v13[2] = HIBYTE(v25);
        v32 -= 17;
        v13[3] = (unsigned __int8)v26;
        v13[4] = BYTE1(v26);
        v13[5] = BYTE2(v26);
        v13[6] = HIBYTE(v26);
        v13[7] = (unsigned __int8)v27;
        *(_DWORD*)(*a1 + 20) = 85;
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 2);
        v14 = (_DWORD*)(*a1 + 24);
        *v14 = BYTE1(v27);
        v14[1] = BYTE2(v27);
        v14[2] = HIBYTE(v27);
        v14[3] = (unsigned __int8)v28;
        v14[4] = BYTE1(v28);
        v14[5] = BYTE2(v28);
        v14[6] = HIBYTE(v28);
        v14[7] = v29;
        *(_DWORD*)(*a1 + 20) = 85;
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 2);
        if (v30 > 256 || v30 > v32)
        {
            *(_DWORD*)(*a1 + 20) = 28;
            (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
        }
        for (i = 0; i < v30; ++i)
        {
            if (!v34)
            {
                if (!(*(unsigned __int8(__cdecl**)(_DWORD*))(v1 + 12))(a1))
                    return 0;
                v33 = *(char**)v1;
                v34 = *(_DWORD*)(v1 + 4);
            }
            --v34;
            v16 = *v33++;
            v22[i] = v16;
        }
        v32 -= v30;
        v17 = v23;
        if ((v23 & 0x10) != 0)
        {
            v17 = v23 - 16;
            v18 = &a1[v23 + 28];
            v31 = (int)v18;
        }
        else
        {
            v31 = (int)&a1[v23 + 40];
            v18 = (int*)v31;
        }
        if (v17 >= 4)
        {
            *(_DWORD*)(*a1 + 20) = 29;
            *(_DWORD*)(*a1 + 24) = v17;
            (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
        }
        if (!*v18)
            *v18 = sub_47CD9E((int)a1);
        v19 = *v18;
        v20 = v31;
        *(_DWORD*)v19 = v25;
        v19 += 4;
        *(_DWORD*)v19 = v26;
        v19 += 4;
        *(_DWORD*)v19 = v27;
        v19 += 4;
        *(_DWORD*)v19 = v28;
        *(_BYTE*)(v19 + 4) = v29;
        qmemcpy((void*)(*(_DWORD*)v20 + 17), v22, 0x100u);
        v7 = v33;
        v1 = v24;
    }
    *(_DWORD*)(v1 + 4) = v34;
    *(_DWORD*)v1 = v7;
    return 1;
}

//----- (00477FCC) --------------------------------------------------------
char __usercall sub_477FCC@<al>(_DWORD* a1@<ebx>)
{
    unsigned __int8** v1; // edi
    unsigned __int8* v2; // esi
    unsigned __int16 v3; // ax
    unsigned __int8* v4; // esi
    unsigned __int8* v5; // esi
    int v6; // ecx
    int v7; // eax
    int v8; // ecx
    int v9; // eax
    int* v10; // eax
    __int16 v11; // ax
    int* v12; // eax
    unsigned __int16* v13; // ecx
    _DWORD* v14; // eax
    int v16; // [esp+8h] [ebp-18h]
    int v17; // [esp+Ch] [ebp-14h]
    int v18; // [esp+10h] [ebp-10h]
    int* v19; // [esp+10h] [ebp-10h]
    int* v20; // [esp+10h] [ebp-10h]
    unsigned __int16* v21; // [esp+10h] [ebp-10h]
    __int16 v22; // [esp+14h] [ebp-Ch]
    __int16 v23; // [esp+14h] [ebp-Ch]
    int v24; // [esp+14h] [ebp-Ch]
    int v25; // [esp+18h] [ebp-8h]
    int v26; // [esp+18h] [ebp-8h]
    int v27; // [esp+18h] [ebp-8h]
    unsigned __int8* v28; // [esp+1Ch] [ebp-4h]
    unsigned __int8* v29; // [esp+1Ch] [ebp-4h]
    unsigned __int8* v30; // [esp+1Ch] [ebp-4h]

    v1 = (unsigned __int8**)a1[5];
    v2 = *v1;
    v28 = v1[1];
    if (!v28)
    {
        if (!((unsigned __int8(__cdecl*)(_DWORD*))v1[3])(a1))
            return 0;
        v2 = *v1;
        v28 = v1[1];
    }
    v29 = v28 - 1;
    LOBYTE(v3) = 0;
    HIBYTE(v3) = *v2;
    v4 = v2 + 1;
    v25 = v3;
    if (v29)
        goto LABEL_7;
    if (!((unsigned __int8(__cdecl*)(_DWORD*))v1[3])(a1))
        return 0;
    v4 = *v1;
    v29 = v1[1];
LABEL_7:
    v30 = v29 - 1;
    v26 = *v4 + v25;
    v5 = v4 + 1;
    v27 = v26 - 2;
    while (v27 > 0)
    {
        if (!v30)
        {
            if (!((unsigned __int8(__cdecl*)(_DWORD*))v1[3])(a1))
                return 0;
            v5 = *v1;
            v30 = v1[1];
        }
        v6 = *v5;
        --v30;
        *(_DWORD*)(*a1 + 20) = 80;
        v7 = v6;
        v8 = v6 & 0xF;
        *(_DWORD*)(*a1 + 24) = v8;
        v18 = v8;
        v17 = v7 >> 4;
        *(_DWORD*)(*a1 + 28) = v7 >> 4;
        ++v5;
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
        v9 = v18;
        if (v18 >= 4)
        {
            *(_DWORD*)(*a1 + 20) = 30;
            *(_DWORD*)(*a1 + 24) = v18;
            (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
            v9 = v18;
        }
        v10 = &a1[v9 + 36];
        v19 = v10;
        if (!*v10)
        {
            *v10 = sub_47CD7F((int)a1);
            v10 = v19;
        }
        v16 = *v10;
        v20 = &dword_49C160;
        do
        {
            if (v17)
            {
                if (!v30)
                {
                    if (!((unsigned __int8(__cdecl*)(_DWORD*))v1[3])(a1))
                        return 0;
                    v5 = *v1;
                    v30 = v1[1];
                }
                --v30;
                LOBYTE(v11) = 0;
                HIBYTE(v11) = *v5++;
                v22 = v11;
                if (!v30)
                {
                    if (!((unsigned __int8(__cdecl*)(_DWORD*))v1[3])(a1))
                        return 0;
                    v5 = *v1;
                    v30 = v1[1];
                }
                v23 = *v5 + v22;
            }
            else
            {
                if (!v30)
                {
                    if (!((unsigned __int8(__cdecl*)(_DWORD*))v1[3])(a1))
                        return 0;
                    v5 = *v1;
                    v30 = v1[1];
                }
                v23 = *v5;
            }
            v12 = v20;
            --v30;
            ++v20;
            ++v5;
            *(_WORD*)(v16 + 2 * *v12) = v23;
        } while ((int)v20 < (int)dword_49C260);
        if (*(int*)(*a1 + 104) >= 2)
        {
            v13 = (unsigned __int16*)(v16 + 4);
            v21 = (unsigned __int16*)(v16 + 4);
            v24 = 8;
            while (1)
            {
                v14 = (_DWORD*)(*a1 + 24);
                *v14 = *(v13 - 2);
                v14[1] = *(v13 - 1);
                v14[2] = *v13;
                v14[3] = v13[1];
                v14[4] = v13[2];
                v14[5] = v13[3];
                v14[6] = v13[4];
                v14[7] = v13[5];
                *(_DWORD*)(*a1 + 20) = 92;
                (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 2);
                v21 += 8;
                if (!--v24)
                    break;
                v13 = v21;
            }
        }
        v27 -= 65;
        if (v17)
            v27 -= 64;
    }
    v1[1] = v30;
    *v1 = v5;
    return 1;
}
// 49C160: using guessed type int dword_49C160;
// 49C260: using guessed type int dword_49C260[16];

//----- (004781F5) --------------------------------------------------------
char __cdecl sub_4781F5(int a1)
{
    int v1; // eax
    unsigned __int8** v2; // esi
    unsigned __int8* v3; // ebx
    unsigned __int8* v4; // edi
    unsigned __int16 v5; // cx
    unsigned __int8* v6; // ebx
    unsigned __int8* v7; // edi
    unsigned __int8* v8; // ebx
    unsigned __int8* v9; // edi
    unsigned __int16 v10; // cx
    unsigned __int8* v11; // ebx
    unsigned __int8* v12; // edi
    int v14; // [esp+Ch] [ebp-4h]
    int v15; // [esp+Ch] [ebp-4h]
    int v16; // [esp+Ch] [ebp-4h]
    int v17; // [esp+Ch] [ebp-4h]

    v1 = a1;
    v2 = *(unsigned __int8***)(a1 + 20);
    v3 = v2[1];
    v4 = *v2;
    if (!v3)
    {
        if (!((unsigned __int8(__cdecl*)(int))v2[3])(a1))
            return 0;
        v4 = *v2;
        v3 = v2[1];
        v1 = a1;
    }
    LOBYTE(v5) = 0;
    HIBYTE(v5) = *v4;
    v6 = v3 - 1;
    v7 = v4 + 1;
    v14 = v5;
    if (!v6)
    {
        if (!((unsigned __int8(__cdecl*)(int))v2[3])(v1))
            return 0;
        v7 = *v2;
        v6 = v2[1];
        v1 = a1;
    }
    v15 = *v7 + v14;
    v8 = v6 - 1;
    v9 = v7 + 1;
    if (v15 != 4)
    {
        *(_DWORD*)(*(_DWORD*)v1 + 20) = 9;
        (**(void(__cdecl***)(int))v1)(v1);
        v1 = a1;
    }
    if (!v8)
    {
        if (((unsigned __int8(__cdecl*)(int))v2[3])(v1))
        {
            v9 = *v2;
            v8 = v2[1];
            v1 = a1;
            goto LABEL_12;
        }
        return 0;
    }
LABEL_12:
    LOBYTE(v10) = 0;
    HIBYTE(v10) = *v9;
    v11 = v8 - 1;
    v12 = v9 + 1;
    v16 = v10;
    if (!v11)
    {
        if (!((unsigned __int8(__cdecl*)(int))v2[3])(v1))
            return 0;
        v12 = *v2;
        v11 = v2[1];
        v1 = a1;
    }
    v17 = *v12 + v16;
    *(_DWORD*)(*(_DWORD*)v1 + 20) = 81;
    *(_DWORD*)(*(_DWORD*)v1 + 24) = v17;
    (*(void(__cdecl**)(int, int))(*(_DWORD*)v1 + 4))(v1, 1);
    *(_DWORD*)(a1 + 252) = v17;
    *v2 = v12 + 1;
    v2[1] = v11 - 1;
    return 1;
}

//----- (004782CC) --------------------------------------------------------
char __cdecl sub_4782CC(_DWORD* a1)
{
    unsigned __int8** v2; // edi
    unsigned __int8* v3; // ebx
    unsigned __int16 v4; // ax
    unsigned __int8* v5; // ebx
    int v7; // [esp+Ch] [ebp-4h]
    int v8; // [esp+Ch] [ebp-4h]
    unsigned __int8* v9; // [esp+18h] [ebp+8h]
    unsigned __int8* v10; // [esp+18h] [ebp+8h]

    v2 = (unsigned __int8**)a1[5];
    v3 = *v2;
    v9 = v2[1];
    if (!v9)
    {
        if (!((unsigned __int8(__cdecl*)(_DWORD*))v2[3])(a1))
            return 0;
        v3 = *v2;
        v9 = v2[1];
    }
    v10 = v9 - 1;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = *v3;
    v5 = v3 + 1;
    v7 = v4;
    if (!v10)
    {
        if (!((unsigned __int8(__cdecl*)(_DWORD*))v2[3])(a1))
            return 0;
        v5 = *v2;
        v10 = v2[1];
    }
    v8 = *v5 + v7;
    *(_DWORD*)(*a1 + 20) = 90;
    *(_DWORD*)(*a1 + 24) = a1[94];
    *(_DWORD*)(*a1 + 28) = v8;
    (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
    *v2 = v5 + 1;
    v2[1] = v10 - 1;
    (*(void(__cdecl**)(_DWORD*, int))(a1[5] + 16))(a1, v8 - 2);
    return 1;
}

//----- (00478368) --------------------------------------------------------
char __cdecl sub_478368(_DWORD* a1)
{
    _DWORD* v1; // eax
    unsigned __int8** v2; // esi
    unsigned __int8* v3; // ebx
    unsigned __int8* v4; // edi
    int v5; // ecx
    int v6; // ecx
    int v8; // [esp+Ch] [ebp-4h]

    v1 = a1;
    v2 = (unsigned __int8**)a1[5];
    v3 = v2[1];
    v4 = *v2;
    while (1)
    {
        if (!v3)
        {
            if (!((unsigned __int8(__cdecl*)(_DWORD*))v2[3])(v1))
                return 0;
            v1 = a1;
            v4 = *v2;
            v3 = v2[1];
        }
        v5 = *v4;
        --v3;
        ++v4;
        if (v5 != 255)
        {
            ++*(_DWORD*)(v1[100] + 88);
            goto LABEL_3;
        }
        do
        {
            if (!v3)
            {
                if (!((unsigned __int8(__cdecl*)(_DWORD*))v2[3])(v1))
                    return 0;
                v4 = *v2;
                v3 = v2[1];
                v1 = a1;
            }
            v6 = *v4;
            --v3;
            ++v4;
            v8 = v6;
        } while (v6 == 255);
        if (v6)
            break;
        *(_DWORD*)(v1[100] + 88) += 2;
    LABEL_3:
        *v2 = v4;
        v2[1] = v3;
    }
    if (*(_DWORD*)(v1[100] + 88))
    {
        *(_DWORD*)(*v1 + 20) = 112;
        *(_DWORD*)(*v1 + 24) = *(_DWORD*)(v1[100] + 88);
        *(_DWORD*)(*v1 + 28) = v6;
        (*(void(__cdecl**)(_DWORD*, int))(*v1 + 4))(v1, -1);
        *(_DWORD*)(a1[100] + 88) = 0;
        v1 = a1;
        v6 = v8;
    }
    v1[94] = v6;
    *v2 = v4;
    v2[1] = v3;
    return 1;
}

//----- (0047843F) --------------------------------------------------------
char __cdecl sub_47843F(_DWORD* a1)
{
    _DWORD* v1; // eax
    unsigned __int8** v2; // esi
    unsigned __int8* v3; // ebx
    unsigned __int8* v4; // edi
    int v5; // edx
    unsigned __int8* v6; // ebx
    unsigned __int8* v7; // edi
    int v9; // ecx
    unsigned __int8* v10; // ebx
    unsigned __int8* v11; // edi
    int v12; // [esp+Ch] [ebp-4h]
    int v13; // [esp+Ch] [ebp-4h]

    v1 = a1;
    v2 = (unsigned __int8**)a1[5];
    v3 = v2[1];
    v4 = *v2;
    if (!v3)
    {
        if (!((unsigned __int8(__cdecl*)(_DWORD*))v2[3])(a1))
            return 0;
        v4 = *v2;
        v3 = v2[1];
        v1 = a1;
    }
    v5 = *v4;
    v6 = v3 - 1;
    v7 = v4 + 1;
    v12 = v5;
    if (!v6)
    {
        if (!((unsigned __int8(__cdecl*)(_DWORD*))v2[3])(v1))
            return 0;
        v7 = *v2;
        v6 = v2[1];
        v1 = a1;
        v5 = v12;
    }
    v9 = *v7;
    v10 = v6 - 1;
    v11 = v7 + 1;
    v13 = v9;
    if (v5 != 255 || v9 != 216)
    {
        *(_DWORD*)(*v1 + 20) = 52;
        *(_DWORD*)(*v1 + 24) = v5;
        *(_DWORD*)(*v1 + 28) = v9;
        (*(void(__cdecl**)(_DWORD*)) * v1)(v1);
        v1 = a1;
        v9 = v13;
    }
    v1[94] = v9;
    *v2 = v11;
    v2[1] = v10;
    return 1;
}

//----- (004784D6) --------------------------------------------------------
int __cdecl sub_4784D6(_DWORD* a1)
{
    int v2; // eax
    char v3; // al
    int v4; // eax
    int v5; // eax
    int v6; // eax
    int result; // eax
    char v8; // [esp-4h] [ebp-10h]

    while (1)
    {
        if (!a1[94] && !(*(_BYTE*)(a1[100] + 80) ? sub_478368(a1) : sub_47843F(a1)))
            return 0;
        v2 = a1[94];
        if (v2 > 207)
            break;
        if (v2 >= 205)
            goto LABEL_26;
        if (v2 > 200)
        {
            v4 = v2 - 201;
            if (v4)
            {
                v5 = v4 - 1;
                if (v5)
                {
                    v6 = v5 - 1;
                    if (!v6)
                    {
                    LABEL_26:
                        *(_DWORD*)(*a1 + 20) = 59;
                    LABEL_34:
                        *(_DWORD*)(*a1 + 24) = a1[94];
                        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
                        goto LABEL_48;
                    }
                    if (v6 != 1)
                        goto LABEL_33;
                    v3 = sub_477BE1(a1);
                }
                else
                {
                    v3 = sub_47727E(1, (int)a1, 1);
                }
                goto LABEL_47;
            }
            v8 = 1;
        }
        else
        {
            if (v2 >= 197)
                goto LABEL_26;
            if (v2 == 1)
            {
            LABEL_36:
                *(_DWORD*)(*a1 + 20) = 91;
                *(_DWORD*)(*a1 + 24) = a1[94];
                (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
                goto LABEL_48;
            }
            if (v2 <= 191)
                goto LABEL_33;
            if (v2 > 193)
            {
                if (v2 == 194)
                {
                    v3 = sub_47727E(1, (int)a1, 0);
                }
                else
                {
                    if (v2 == 195)
                        goto LABEL_26;
                    v3 = sub_477D38(a1);
                }
                goto LABEL_47;
            }
            v8 = 0;
        }
        v3 = sub_47727E(0, (int)a1, v8);
    LABEL_47:
        if (!v3)
            return 0;
    LABEL_48:
        a1[94] = 0;
    }
    if (v2 > 219)
    {
        if (v2 == 220)
        {
            v3 = sub_4782CC(a1);
        }
        else if (v2 == 221)
        {
            v3 = sub_4781F5((int)a1);
        }
        else
        {
            if (v2 <= 223)
                goto LABEL_33;
            if (v2 <= 239)
            {
                v3 = (*(int(__cdecl**)(_DWORD*))(a1[100] + 4 * v2 - 880))(a1);
            }
            else
            {
                if (v2 != 254)
                {
                LABEL_33:
                    *(_DWORD*)(*a1 + 20) = 67;
                    goto LABEL_34;
                }
                v3 = (*(int(__cdecl**)(_DWORD*))(a1[100] + 12))(a1);
            }
        }
        goto LABEL_47;
    }
    if (v2 == 219)
    {
        v3 = sub_477FCC(a1);
        goto LABEL_47;
    }
    if (v2 <= 215)
        goto LABEL_36;
    if (v2 == 216)
    {
        v3 = sub_4771F0((int)a1);
        goto LABEL_47;
    }
    if (v2 == 217)
    {
        *(_DWORD*)(*a1 + 20) = 84;
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
        result = 2;
        goto LABEL_51;
    }
    if (sub_477579(a1))
    {
        result = 1;
    LABEL_51:
        a1[94] = 0;
        return result;
    }
    return 0;
}
// 478569: conditional instruction was optimized away because eax.4==C4
// 4785C1: conditional instruction was optimized away because eax.4 is in (D0..DA)
// 4785E1: conditional instruction was optimized away because eax.4==DA

//----- (004786C6) --------------------------------------------------------
char __cdecl sub_4786C6(_DWORD* a1)
{
    if (a1[94] || sub_478368(a1))
    {
        if (a1[94] == *(_DWORD*)(a1[100] + 84) + 208)
        {
            *(_DWORD*)(*a1 + 20) = 97;
            *(_DWORD*)(*a1 + 24) = *(_DWORD*)(a1[100] + 84);
            (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 3);
            a1[94] = 0;
        LABEL_5:
            *(_DWORD*)(a1[100] + 84) = ((unsigned __int8)*(_DWORD*)(a1[100] + 84) + 1) & 7;
            return 1;
        }
        if ((*(unsigned __int8(__cdecl**)(_DWORD*, _DWORD))(a1[5] + 20))(a1, *(_DWORD*)(a1[100] + 84)))
            goto LABEL_5;
    }
    return 0;
}

//----- (00478747) --------------------------------------------------------
char __cdecl sub_478747(_DWORD* a1, int a2)
{
    int v3; // ebx
    int v5; // [esp+14h] [ebp+8h]

    v3 = a1[94];
    *(_DWORD*)(*a1 + 20) = 117;
    *(_DWORD*)(*a1 + 24) = v3;
    *(_DWORD*)(*a1 + 28) = a2;
    (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, -1);
    while (1)
    {
        if (v3 < 192)
        {
        LABEL_3:
            v5 = 2;
            goto LABEL_12;
        }
        if (v3 < 208 || v3 > 215 || v3 == ((a2 + 1) & 7) + 208 || v3 == ((a2 + 2) & 7) + 208)
        {
            v5 = 3;
        }
        else
        {
            if (v3 == ((a2 - 1) & 7) + 208 || v3 == ((a2 - 2) & 7) + 208)
                goto LABEL_3;
            v5 = 1;
        }
    LABEL_12:
        *(_DWORD*)(*a1 + 20) = 96;
        *(_DWORD*)(*a1 + 24) = v3;
        *(_DWORD*)(*a1 + 28) = v5;
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 4);
        if (v5 == 1)
            break;
        if (v5 != 2)
            return 1;
        if (!sub_478368(a1))
            return 0;
        v3 = a1[94];
    }
    a1[94] = 0;
    return 1;
}
// 478804: conditional instruction was optimized away because %arg_0.4==3

//----- (00478834) --------------------------------------------------------
int __cdecl sub_478834(_DWORD* a1)
{
    _DWORD* v1; // eax
    int result; // eax

    a1[49] = 0;
    a1[31] = 0;
    a1[94] = 0;
    v1 = a1 + 100;
    *(_BYTE*)(*v1 + 80) = 0;
    *(_BYTE*)(*v1 + 81) = 0;
    result = a1[100];
    *(_DWORD*)(result + 88) = 0;
    return result;
}

//----- (00478861) --------------------------------------------------------
int __cdecl sub_478861(int a1)
{
    _DWORD* v1; // eax
    int i; // ecx

    v1 = (_DWORD*)(**(int(__cdecl***)(int, _DWORD, int))(a1 + 4))(a1, 0, 92);
    *(_DWORD*)(a1 + 400) = v1;
    *v1 = sub_478834;
    *(_DWORD*)(*(_DWORD*)(a1 + 400) + 4) = sub_4784D6;
    *(_DWORD*)(*(_DWORD*)(a1 + 400) + 8) = sub_4786C6;
    *(_DWORD*)(*(_DWORD*)(a1 + 400) + 12) = sub_4782CC;
    for (i = 16; i < 80; i += 4)
        *(_DWORD*)(i + *(_DWORD*)(a1 + 400)) = sub_4782CC;
    *(_DWORD*)(*(_DWORD*)(a1 + 400) + 16) = sub_47782B;
    *(_DWORD*)(*(_DWORD*)(a1 + 400) + 72) = sub_477A67;
    return sub_478834((_DWORD*)a1);
}

//----- (004788E1) --------------------------------------------------------
void __cdecl __noreturn sub_4788E1(int a1)
{
    (*(void(__cdecl**)(int))(*(_DWORD*)a1 + 8))(a1);
    sub_47CD61(a1);
    exit(1);
}

//----- (0047891B) --------------------------------------------------------
int __cdecl sub_47891B(int* a1, int a2)
{
    int result; // eax
    int v3; // esi

    result = (int)a1;
    v3 = *a1;
    if (a2 >= 0)
    {
        if (*(_DWORD*)(v3 + 104) >= a2)
            return (*(int(__cdecl**)(int*))(v3 + 8))(a1);
    }
    else
    {
        if (!*(_DWORD*)(v3 + 108) || *(int*)(v3 + 104) >= 3)
            result = (*(int(__cdecl**)(int*))(v3 + 8))(a1);
        ++*(_DWORD*)(v3 + 108);
    }
    return result;
}

//----- (0047894E) --------------------------------------------------------
int __cdecl sub_47894E(int a1, char* Buffer)
{
    _DWORD* v2; // eax
    int v3; // edx
    const char* v4; // ecx
    int v5; // ecx
    int v6; // esi
    const char** v7; // ecx
    char v8; // dl
    char* i; // esi

    v2 = *(_DWORD**)a1;
    v3 = *(_DWORD*)(*(_DWORD*)a1 + 20);
    if (v3 <= 0 || v3 > v2[29])
    {
        v5 = v2[30];
        if (!v5)
            goto LABEL_9;
        v6 = v2[31];
        if (v3 < v6 || v3 > v2[32])
            goto LABEL_9;
        v4 = *(const char**)(v5 + 4 * (v3 - v6));
    }
    else
    {
        v4 = *(const char**)(v2[28] + 4 * v3);
    }
    if (!v4)
    {
    LABEL_9:
        v7 = (const char**)v2[28];
        v2[6] = v3;
        v4 = *v7;
    }
    v8 = *v4;
    for (i = (char*)v4; ; v8 = *i)
    {
        if (!v8)
            return sprintf(Buffer, v4, v2[6], v2[7], v2[8], v2[9], v2[10], v2[11], v2[12], v2[13]);
        ++i;
        if (v8 == 37)
            break;
    }
    if (*i != 115)
        return sprintf(Buffer, v4, v2[6], v2[7], v2[8], v2[9], v2[10], v2[11], v2[12], v2[13]);
    return sprintf(Buffer, v4, v2 + 6);
}

//----- (004789E6) --------------------------------------------------------
int __cdecl sub_4789E6(int* a1)
{
    int result; // eax

    *(_DWORD*)(*a1 + 108) = 0;
    result = *a1;
    *(_DWORD*)(*a1 + 20) = 0;
    return result;
}

//----- (004789FA) --------------------------------------------------------
void(__cdecl __noreturn** __cdecl sub_4789FA(void(__cdecl __noreturn** a1)(int a1)))(int a1)
{
    void(__cdecl __noreturn** result)(int); // eax

    result = a1;
    *a1 = sub_4788E1;
    a1[1] = (void(__cdecl __noreturn*)(int))sub_47891B;
    a1[2] = (void(__cdecl __noreturn*)(int))sub_4788FE;
    a1[3] = (void(__cdecl __noreturn*)(int))sub_47894E;
    a1[4] = (void(__cdecl __noreturn*)(int))sub_4789E6;
    a1[26] = 0;
    a1[27] = 0;
    a1[5] = 0;
    a1[28] = (void(__cdecl __noreturn*)(int))off_49A990;
    a1[29] = (void(__cdecl __noreturn*)(int))119;
    a1[30] = 0;
    a1[31] = 0;
    a1[32] = 0;
    return result;
}
// 4788FE: using guessed type int sub_4788FE();
// 49A990: using guessed type char *off_49A990[120];

//----- (00478A49) --------------------------------------------------------
_BYTE* __cdecl sub_478A49(int a1, const void* a2)
{
    int v2; // ecx
    _BYTE* result; // eax
    int i; // esi
    int v5; // edx
    _BYTE* v6; // eax
    _BYTE* v7; // eax

    result = 0;
    for (i = 0; i < 4; ++i)
    {
        v5 = *(unsigned __int8*)(a1 + i + 268);
        if (v5 < 41 || v5 > 122 || v5 > 90 && v5 < 97)
        {
            result[v2] = 91;
            v6 = result + 1;
            v6[v2] = byte_49BD08[(v5 >> 4) & 0xF];
            (++v6)[v2] = byte_49BD08[v5 & 0xF];
            result = v6 + 1;
            result[v2] = 93;
        }
        else
        {
            result[v2] = v5;
        }
        ++result;
    }
    if (a2)
    {
        result[v2] = 58;
        v7 = result + 1;
        v7[v2] = 32;
        result = &v7[v2 + 1];
        qmemcpy(result, a2, 0x40u);
        result[63] = 0;
    }
    else
    {
        result[v2] = 0;
    }
    return result;
}
// 478A73: variable 'v2' is possibly undefined

//----- (00478AD1) --------------------------------------------------------
_DWORD* __cdecl sub_478AD1(_DWORD* a1, int a2, int a3, int a4)
{
    _DWORD* result; // eax

    result = a1;
    a1[18] = a2;
    a1[16] = a3;
    a1[17] = a4;
    return result;
}

//----- (00478AEB) --------------------------------------------------------
void __cdecl __noreturn sub_478AEB(jmp_buf Buf, int a2)
{
    void(__cdecl * v2)(int* __attribute__((__org_typedef(jmp_buf))), int); // eax

    v2 = (void(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int))Buf[16];
    if (v2)
        v2(Buf, a2);
    longjmp(Buf, 1);
}

//----- (00478B0A) --------------------------------------------------------
int(__cdecl* __cdecl sub_478B0A(int a1, int a2))(int, int)
{
    int(__cdecl * result)(int, int); // eax

    result = *(int(__cdecl**)(int, int))(a1 + 68);
    if (result)
        return (int(__cdecl*)(int, int))result(a1, a2);
    return result;
}

//----- (00478B21) --------------------------------------------------------
void __cdecl __noreturn sub_478B21(jmp_buf Buf, const void* a2)
{
    int v2[20]; // [esp+0h] [ebp-50h] BYREF

    sub_478A49((int)Buf, a2);
    sub_478AEB(Buf, (int)v2);
}

//----- (00478B46) --------------------------------------------------------
int(__cdecl* __cdecl sub_478B46(int a1, const void* a2))(int, _BYTE*)
{
    int(__cdecl * result)(int, _BYTE*); // eax
    _BYTE v3[80]; // [esp+4h] [ebp-50h] BYREF

    sub_478A49(a1, a2);
    result = *(int(__cdecl**)(int, _BYTE*))(a1 + 68);
    if (result)
        return (int(__cdecl*)(int, _BYTE*))result(a1, v3);
    return result;
}

//----- (00478B71) --------------------------------------------------------
jmp_buf __cdecl sub_478B71(_BYTE* a1, int a2, int a3, int a4)
{
    int* v4; // eax
    int v6; // eax
    int* __attribute__((__org_typedef(jmp_buf))) Buf; // [esp+4h] [ebp-4h]

    v4 = (int*)sub_47D8C7(1);
    Buf = v4;
    if (!v4)
        return 0;
    if (_setjmp3(v4, 0))
    {
        sub_47D953((int)Buf, (LPVOID)Buf[39]);
        sub_47D90B(Buf);
        return 0;
    }
    sub_478AD1(Buf, a2, a3, a4);
    if (!a1 || *a1 != 49)
        sub_478AEB(Buf, (int)"Incompatible libpng version in application and library");
    Buf[40] = 0x2000;
    Buf[39] = (int)sub_47D91C(Buf, 0x2000u);
    Buf[33] = (int)sub_47AEDA;
    Buf[34] = (int)sub_47AF2E;
    Buf[35] = (int)Buf;
    v6 = sub_47D53A(Buf + 25, "1.1.3", 56);
    if (v6 == -6)
        sub_478AEB(Buf, (int)"zlib version error");
    if (v6 == -4 || v6 == -2)
        sub_478AEB(Buf, (int)"zlib memory error");
    if (v6)
        sub_478AEB(Buf, (int)"Unknown zlib error");
    Buf[28] = Buf[39];
    Buf[29] = Buf[40];
    sub_47AE50(Buf, 0, 0);
    return Buf;
}
// 48B798: using guessed type int __cdecl _setjmp3(_DWORD, _DWORD);

//----- (00478C74) --------------------------------------------------------
int __cdecl sub_478C74(jmp_buf Buf, int a2)
{
    int* __attribute__((__org_typedef(jmp_buf))) v2; // esi
    unsigned __int8 v3; // al
    unsigned int v4; // ebx
    int v5; // edi
    _DWORD* v6; // ebx
    int v7; // edi
    int result; // eax
    int v9; // [esp-18h] [ebp-24h]

    v2 = Buf;
    v3 = *((_BYTE*)Buf + 284);
    if (v3 < 8u)
    {
        v4 = v3;
        v5 = 8 - v3;
        sub_47AE26(Buf, v3 + a2 + 32, v5);
        v9 = a2 + 32;
        *((_BYTE*)v2 + 284) = 8;
        if (sub_47AE90(v9, v4, v5))
        {
            if (v4 < 4)
            {
                if (sub_47AE90(a2 + 32, v4, v5 - 4))
                    sub_478AEB(v2, (int)"Not a PNG file");
            }
            sub_478AEB(v2, (int)"PNG file corrupted by ASCII conversion");
        }
    }
    v6 = v2 + 67;
    while (1)
    {
        while (1)
        {
            while (1)
            {
                while (1)
                {
                    sub_47AE26(v2, (int)&Buf, 4);
                    v7 = sub_47D9C3((unsigned __int8*)&Buf);
                    sub_47AF37((int)v2);
                    sub_47D9E9((int)v2, (_BYTE*)v2 + 268, 4u);
                    if (*v6 != *(_DWORD*)"IHDR")
                        break;
                    sub_47E34C(v2, a2, v7);
                }
                if (*v6 != *(_DWORD*)"PLTE")
                    break;
                sub_47E542(v2, a2, v7);
            }
            if (*v6 != *(_DWORD*)"IEND")
                break;
            sub_47E66C(v2, a2, v7);
        }
        if (*v6 == *(_DWORD*)"IDAT")
            break;
        if (*v6 == *(_DWORD*)"gAMA")
        {
            sub_47E6B6(v2, a2, v7);
        }
        else if (*v6 == *(_DWORD*)"sRGB")
        {
            sub_47E7C1(v2, a2, v7);
        }
        else if (*v6 == *(_DWORD*)"tRNS")
        {
            sub_47E8B0(v2, a2, v7);
        }
        else
        {
            sub_47EA58(v2, a2, v7);
        }
    }
    result = v2[22];
    if ((result & 1) == 0)
        sub_478AEB(v2, (int)"Missing IHDR before IDAT");
    if (*((_BYTE*)v2 + 278) == 3 && (result & 2) == 0)
        sub_478AEB(v2, (int)"Missing PLTE before IDAT");
    v2[22] |= 4u;
    v2[63] = v7;
    return result;
}

//----- (00478DE7) --------------------------------------------------------
unsigned int __cdecl sub_478DE7(jmp_buf Buf, int a2)
{
    if ((Buf[23] & 0x40) == 0)
        sub_47E11F(Buf);
    return sub_479754((int)Buf, a2);
}

//----- (00478E09) --------------------------------------------------------
int(__cdecl* __usercall sub_478E09@<eax>(int a1@<ebx>, jmp_buf Buf, char* a3, char* a4))(jmp_buf, int, _DWORD)
{
    int* __attribute__((__org_typedef(jmp_buf))) v4; // esi
    int(__cdecl * result)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD); // eax
    int v6; // eax
    bool v7; // zf
    int v8; // eax
    unsigned int v9; // eax
    unsigned int v10; // edx
    _BYTE* v11; // ecx
    int v12; // eax
    const char* v13; // eax
    char v14; // al
    unsigned __int8 v15; // cl
    int v16; // eax
    unsigned int v17; // ecx
    unsigned __int8* v18; // eax
    unsigned __int8 v19; // cl

    v4 = Buf;
    if ((Buf[23] & 0x40) == 0)
        sub_47E11F(Buf);
    if (!*((_BYTE*)v4 + 275) || (v4[24] & 2) == 0)
        goto LABEL_36;
    switch (*((_BYTE*)v4 + 276))
    {
    case 0:
        if ((v4[53] & 7) == 0)
            break;
        v7 = a4 == 0;
        goto LABEL_34;
    case 1:
        if ((v4[53] & 7) != 0 || (unsigned int)v4[46] < 5)
        {
            if (a4)
                sub_47DAC5((int)v4, a4, 15);
            return (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_47EAA3(a1, v4);
        }
        break;
    case 2:
        v8 = v4[53];
        if ((v8 & 7) == 4)
            break;
        if (!a4)
            return (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_47EAA3(a1, v4);
        v7 = (v8 & 4) == 0;
    LABEL_34:
        if (!v7)
            sub_47DAC5((int)v4, a4, 255);
        return (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_47EAA3(a1, v4);
    case 3:
        if ((v4[53] & 3) != 0 || (unsigned int)v4[46] < 3)
        {
            if (a4)
                sub_47DAC5((int)v4, a4, 51);
            return (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_47EAA3(a1, v4);
        }
        break;
    case 4:
        v6 = v4[53];
        if ((v6 & 3) == 2)
            break;
        if (a4)
        {
            v7 = (v6 & 2) == 0;
            goto LABEL_34;
        }
        return (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_47EAA3(a1, v4);
    case 5:
        if ((v4[53] & 1) != 0 || (unsigned int)v4[46] < 2)
        {
            if (a4)
                sub_47DAC5((int)v4, a4, 85);
            return (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_47EAA3(a1, v4);
        }
        break;
    default:
        if (*((_BYTE*)v4 + 276) == 6 && (v4[53] & 1) == 0)
            return (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_47EAA3(a1, v4);
        break;
    }
LABEL_36:
    if ((v4[22] & 4) == 0)
        sub_478AEB(v4, (int)"Invalid attempt to read row data");
    v4[28] = v4[55];
    v4[29] = v4[51];
    while (1)
    {
        if (!v4[26])
        {
            while (!v4[63])
            {
                sub_47E2BE(v4, 0);
                sub_47AE26(v4, (int)&Buf, 4);
                v4[63] = sub_47D9C3((unsigned __int8*)&Buf);
                sub_47AF37((int)v4);
                sub_47D9E9((int)v4, (_BYTE*)v4 + 268, 4u);
                if (v4[67] != *(_DWORD*)"IDAT")
                    sub_478AEB(v4, (int)"Not enough image data");
            }
            v9 = v4[40];
            v10 = v4[63];
            v11 = (_BYTE*)v4[39];
            v4[26] = v9;
            v4[25] = (int)v11;
            if (v9 > v10)
                v4[26] = v10;
            sub_47D9E9((int)v4, v11, v4[26]);
            v4[63] -= v4[26];
        }
        v12 = sub_47D552(v4 + 25, 1);
        if (v12 == 1)
            break;
        if (v12)
        {
            v13 = (const char*)v4[31];
            if (!v13)
                v13 = "Decompression error";
            sub_478AEB(v4, (int)v13);
        }
        if (!v4[29])
            goto LABEL_59;
    }
    if (v4[29] || v4[26] || v4[63])
        sub_478AEB(v4, (int)"Extra compressed data");
    v4[22] |= 8u;
    v4[23] |= 0x20u;
LABEL_59:
    v14 = *((_BYTE*)v4 + 278);
    *((_BYTE*)v4 + 250) = *((_BYTE*)v4 + 282);
    *((_BYTE*)v4 + 249) = *((_BYTE*)v4 + 279);
    v15 = *((_BYTE*)v4 + 281);
    *((_BYTE*)v4 + 251) = v15;
    *((_BYTE*)v4 + 248) = v14;
    v16 = v4[52];
    v17 = v16 * v15 + 7;
    v4[60] = v16;
    v18 = (unsigned __int8*)v4[55];
    v4[61] = v17 >> 3;
    sub_47DFA4((int)v4, (int)(v4 + 60), v18 + 1, (unsigned __int8*)(v4[54] + 1), *v18);
    sub_47D96D((int)v4, (void*)v4[54], (const void*)v4[55], v4[50] + 1);
    if (v4[24])
        sub_47AB10(v4);
    if (*((_BYTE*)v4 + 275) && (v4[24] & 2) != 0)
    {
        v19 = *((_BYTE*)v4 + 276);
        if (v19 < 6u)
            sub_47DCDB(v4 + 60, v4[55] + 1, v19);
        if (a4)
            sub_47DAC5((int)v4, a4, dword_49BD40[*((unsigned __int8*)v4 + 276)]);
        if (a3)
            sub_47DAC5((int)v4, a3, dword_49BD24[*((unsigned __int8*)v4 + 276)]);
    }
    else
    {
        if (a3)
            sub_47DAC5((int)v4, a3, 255);
        if (a4)
            sub_47DAC5((int)v4, a4, 255);
    }
    sub_47EAA3(0, v4);
    result = (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))v4[91];
    if (result)
        return (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))result(
            v4,
            v4[53],
            *((unsigned __int8*)v4 + 276));
    return result;
}
// 49BD24: using guessed type int dword_49BD24[7];
// 49BD40: using guessed type int dword_49BD40[7];

//----- (004791B0) --------------------------------------------------------
int(__cdecl* __cdecl sub_4791B0(jmp_buf Buf, char** a2))(jmp_buf, int, _DWORD)
{
    int(__cdecl * result)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD); // eax
    int v4; // edi
    char** v5; // ebx
    int(__cdecl * v6)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD); // [esp+8h] [ebp-4h]
    int* __attribute__((__org_typedef(jmp_buf))) Bufa; // [esp+14h] [ebp+8h]

    result = (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_4795DB((int)Buf);
    v4 = Buf[47];
    Buf[48] = v4;
    if ((int)result > 0)
    {
        v6 = result;
        do
        {
            v5 = a2;
            if (v4)
            {
                Bufa = (int*)v4;
                do
                {
                    result = sub_478E09((int)v5, Buf, *v5, 0);
                    ++v5;
                    Bufa = (int*)((char*)Bufa - 1);
                } while (Bufa);
            }
            v6 = (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))((char*)v6 - 1);
        } while (v6);
    }
    return result;
}

//----- (004791FD) --------------------------------------------------------
int __cdecl sub_4791FD(int a1, void* a2, void* a3)
{
    int v3; // edi
    int v4; // esi
    int result; // eax
    int v6; // edx
    int v7; // esi
    _BYTE v8[64]; // [esp+Ch] [ebp-40h] BYREF

    v3 = 0;
    if (a2)
        sub_47AF93(a1, a2);
    if (a3)
        sub_47AF93(a1, a3);
    sub_47D953(a1, *(LPVOID*)(a1 + 156));
    sub_47D953(a1, *(LPVOID*)(a1 + 220));
    sub_47D953(a1, *(LPVOID*)(a1 + 216));
    sub_47D953(a1, *(LPVOID*)(a1 + 372));
    sub_47D953(a1, *(LPVOID*)(a1 + 376));
    sub_47D953(a1, *(LPVOID*)(a1 + 312));
    if ((*(_BYTE*)(a1 + 93) & 0x10) != 0)
        sub_47AF2E(a1, *(LPVOID*)(a1 + 260));
    if ((*(_BYTE*)(a1 + 93) & 0x20) != 0)
        sub_47D953(a1, *(LPVOID*)(a1 + 348));
    if (*(_DWORD*)(a1 + 324))
    {
        v4 = 1 << (8 - *(_BYTE*)(a1 + 300));
        if (v4 > 0)
        {
            do
                sub_47D953(a1, *(LPVOID*)(*(_DWORD*)(a1 + 324) + 4 * v3++));
            while (v3 < v4);
        }
        sub_47D953(a1, *(LPVOID*)(a1 + 324));
    }
    sub_47D414((_DWORD*)(a1 + 100));
    result = *(_DWORD*)(a1 + 72);
    v6 = *(_DWORD*)(a1 + 64);
    qmemcpy(v8, (const void*)a1, sizeof(v8));
    v7 = *(_DWORD*)(a1 + 68);
    memset((void*)a1, 0, 0x19Cu);
    *(_DWORD*)(a1 + 68) = v7;
    qmemcpy((void*)a1, v8, 0x40u);
    *(_DWORD*)(a1 + 64) = v6;
    *(_DWORD*)(a1 + 72) = result;
    return result;
}

//----- (00479320) --------------------------------------------------------
void __cdecl sub_479320(void** a1, void** a2, void** a3)
{
    void* v3; // esi
    void* v4; // [esp+Ch] [ebp-8h]
    void* v5; // [esp+10h] [ebp-4h]

    v3 = 0;
    v5 = 0;
    v4 = 0;
    if (a1)
        v5 = *a1;
    if (a2)
        v3 = *a2;
    if (a3)
        v4 = *a3;
    if (v5)
        sub_4791FD((int)v5, v3, v4);
    if (v3)
    {
        sub_47D90B(v3);
        *a2 = 0;
    }
    if (v4)
    {
        sub_47D90B(v4);
        *a3 = 0;
    }
    if (v5)
    {
        sub_47D90B(v5);
        *a1 = 0;
    }
}

//----- (004793A1) --------------------------------------------------------
int __cdecl sub_4793A1(int a1, int a2, int a3)
{
    if (a1 && a2)
        return a3 & *(_DWORD*)(a2 + 8);
    else
        return 0;
}

//----- (004793BD) --------------------------------------------------------
int __cdecl sub_4793BD(int a1, int a2)
{
    if (a1 && a2)
        return *(_DWORD*)(a2 + 12);
    else
        return 0;
}

//----- (004793D6) --------------------------------------------------------
char __cdecl sub_4793D6(int a1, int a2)
{
    if (a1 && a2)
        return *(_BYTE*)(a2 + 29);
    else
        return 0;
}

//----- (004793EF) --------------------------------------------------------
int __cdecl sub_4793EF(int a1, int a2, double* a3)
{
    if (!a1 || !a2 || (*(_BYTE*)(a2 + 8) & 1) == 0 || !a3)
        return 0;
    *a3 = *(float*)(a2 + 40);
    return 1;
}

//----- (0047941A) --------------------------------------------------------
int __cdecl sub_47941A(int a1, int a2, _DWORD* a3)
{
    int result; // eax

    if (!a1)
        return 0;
    if (!a2)
        return 0;
    result = 2048;
    if ((*(_DWORD*)(a2 + 8) & 0x800) == 0 || !a3)
        return 0;
    *a3 = *(unsigned __int8*)(a2 + 44);
    return result;
}

//----- (00479447) --------------------------------------------------------
int __cdecl sub_479447(
    int a1,
    int a2,
    unsigned int* a3,
    _DWORD* a4,
    _DWORD* a5,
    _DWORD* a6,
    _DWORD* a7,
    _DWORD* a8,
    _DWORD* a9)
{
    int v9; // eax

    if (!a1 || !a2 || !a3 || !a4 || !a5 || !a6)
        return 0;
    *a3 = *(_DWORD*)a2;
    *a4 = *(_DWORD*)(a2 + 4);
    *a5 = *(unsigned __int8*)(a2 + 24);
    *a6 = *(unsigned __int8*)(a2 + 25);
    if (a8)
        *a8 = *(unsigned __int8*)(a2 + 26);
    if (a9)
        *a9 = *(unsigned __int8*)(a2 + 27);
    if (a7)
        *a7 = *(unsigned __int8*)(a2 + 28);
    if (*a6 == 3)
        v9 = 1;
    else
        v9 = *a6 & 2 | 1;
    if ((*a6 & 4) != 0)
        ++v9;
    if (*a3 > 0x7FFFFFFFu / ((v9 * *a5 + 7) >> 3))
        sub_478B0A(a1, (int)"Width too large for libpng to process image data.");
    return 1;
}

//----- (00479518) --------------------------------------------------------
int __cdecl sub_479518(int a1, int a2, _DWORD* a3, _DWORD* a4)
{
    if (!a1 || !a2 || (*(_BYTE*)(a2 + 8) & 8) == 0 || !a3)
        return 0;
    *a3 = *(_DWORD*)(a2 + 16);
    *a4 = *(unsigned __int16*)(a2 + 20);
    return 8;
}

//----- (0047954C) --------------------------------------------------------
int __cdecl sub_47954C(int a1, int a2, _DWORD* a3, _DWORD* a4, _DWORD* a5)
{
    int result; // eax

    result = 0;
    if (a1 && a2 && (*(_BYTE*)(a2 + 8) & 0x10) != 0)
    {
        if (*(_BYTE*)(a2 + 25) == 3)
        {
            if (a3)
            {
                *a3 = *(_DWORD*)(a2 + 48);
                result = 16;
            }
            if (a5)
                *a5 = a2 + 52;
        }
        else
        {
            if (a5)
            {
                *a5 = a2 + 52;
                result = 16;
            }
            if (a3)
                *a3 = 0;
        }
        if (a4)
        {
            *a4 = *(unsigned __int16*)(a2 + 22);
            return result | 0x10;
        }
    }
    return result;
}

//----- (004795B3) --------------------------------------------------------
int __cdecl sub_4795B3(int a1)
{
    int result; // eax

    result = a1;
    *(_DWORD*)(a1 + 96) |= 1u;
    return result;
}

//----- (004795BF) --------------------------------------------------------
int __cdecl sub_4795BF(int a1)
{
    int result; // eax

    result = a1;
    if (*(_BYTE*)(a1 + 279) < 8u)
    {
        *(_DWORD*)(a1 + 96) |= 4u;
        *(_BYTE*)(a1 + 280) = 8;
    }
    return result;
}

//----- (004795DB) --------------------------------------------------------
int __cdecl sub_4795DB(int a1)
{
    if (!*(_BYTE*)(a1 + 275))
        return 1;
    *(_DWORD*)(a1 + 96) |= 2u;
    return 7;
}

//----- (004795F8) --------------------------------------------------------
int __cdecl sub_4795F8(int a1, unsigned __int8 a2, int a3)
{
    int result; // eax
    char v4; // cl

    result = a1;
    *(_BYTE*)(a1 + 97) |= 0x80u;
    *(_WORD*)(a1 + 286) = a2;
    if (a3 == 1)
        *(_BYTE*)(a1 + 92) |= 0x80u;
    else
        *(_BYTE*)(a1 + 92) &= ~0x80u;
    v4 = *(_BYTE*)(a1 + 278);
    if (v4 == 2)
        *(_BYTE*)(a1 + 283) = 4;
    if (!v4 && *(_BYTE*)(a1 + 279) >= 8u)
        *(_BYTE*)(a1 + 283) = 2;
    return result;
}

//----- (00479646) --------------------------------------------------------
char __cdecl sub_479646(int* a1, char* a2)
{
    char* v2; // eax
    char v3; // dl
    int v4; // ecx
    int v5; // esi
    char v6; // dl
    int v7; // esi
    char v8; // dl
    int v9; // esi
    char v10; // cl
    char v11; // dl
    char v12; // cl
    int v13; // esi
    char v14; // cl
    char v15; // dl
    char v16; // cl

    LOBYTE(v2) = (_BYTE)a1;
    v3 = *((_BYTE*)a1 + 8);
    if ((v3 & 2) != 0)
    {
        v4 = *a1;
        LOBYTE(v2) = *((_BYTE*)a1 + 9);
        if ((_BYTE)v2 == 8)
        {
            if (v3 == 2)
            {
                v2 = a2;
                if (v4)
                {
                    v5 = *a1;
                    do
                    {
                        v6 = *v2;
                        *v2 = v2[2];
                        v2[2] = v6;
                        v2 += 3;
                        --v5;
                    } while (v5);
                }
            }
            else if (v3 == 6)
            {
                v2 = a2;
                if (v4)
                {
                    v7 = *a1;
                    do
                    {
                        v8 = *v2;
                        *v2 = v2[2];
                        v2[2] = v8;
                        v2 += 4;
                        --v7;
                    } while (v7);
                }
            }
        }
        else if ((_BYTE)v2 == 16)
        {
            if (v3 == 2)
            {
                if (v4)
                {
                    v2 = a2 + 1;
                    v9 = *a1;
                    do
                    {
                        v10 = *(v2 - 1);
                        *(v2 - 1) = v2[3];
                        v11 = v2[4];
                        v2[3] = v10;
                        v12 = *v2;
                        *v2 = v11;
                        v2[4] = v12;
                        v2 += 6;
                        --v9;
                    } while (v9);
                }
            }
            else if (v3 == 6 && v4)
            {
                v2 = a2 + 1;
                v13 = *a1;
                do
                {
                    v14 = *(v2 - 1);
                    *(v2 - 1) = v2[3];
                    v15 = v2[4];
                    v2[3] = v14;
                    v16 = *v2;
                    *v2 = v15;
                    v2[4] = v16;
                    v2 += 8;
                    --v13;
                } while (v13);
            }
        }
    }
    return (char)v2;
}

//----- (00479705) --------------------------------------------------------
int __cdecl sub_479705(int a1)
{
    int result; // eax

    result = a1;
    *(_BYTE*)(a1 + 97) |= 4u;
    return result;
}

//----- (00479711) --------------------------------------------------------
int __cdecl sub_479711(int a1, double a2, double a3)
{
    int result; // eax

    result = a1;
    if (fabs(a2 * a3 - 1.0) > 0.05)
        *(_BYTE*)(a1 + 97) |= 0x20u;
    *(float*)(a1 + 304) = a3;
    *(float*)(a1 + 308) = a2;
    return result;
}

//----- (00479748) --------------------------------------------------------
int __cdecl sub_479748(int a1)
{
    int result; // eax

    result = a1;
    *(_BYTE*)(a1 + 97) |= 0x10u;
    return result;
}

//----- (00479754) --------------------------------------------------------
unsigned int __cdecl sub_479754(int a1, int a2)
{
    char v2; // al
    char v3; // al
    char v4; // al
    unsigned __int8 v5; // al
    unsigned int result; // eax

    if ((*(_BYTE*)(a1 + 97) & 0x10) != 0)
    {
        v2 = *(_BYTE*)(a2 + 25);
        if (v2 == 3)
        {
            *(_BYTE*)(a2 + 25) = 4 * (*(_WORD*)(a1 + 266) != 0) + 2;
        }
        else
        {
            if (*(_WORD*)(a1 + 266))
                *(_BYTE*)(a2 + 25) = v2 | 4;
            if (*(_BYTE*)(a2 + 24) >= 8u)
                goto LABEL_8;
        }
        *(_BYTE*)(a2 + 24) = 8;
    LABEL_8:
        *(_WORD*)(a2 + 22) = 0;
    }
    if ((*(_BYTE*)(a1 + 97) & 0x20) != 0)
        *(_DWORD*)(a2 + 40) = *(_DWORD*)(a1 + 304);
    if ((*(_BYTE*)(a1 + 97) & 4) != 0 && *(_BYTE*)(a2 + 24) == 16)
        *(_BYTE*)(a2 + 24) = 8;
    if ((*(_BYTE*)(a1 + 96) & 0x40) != 0)
    {
        v3 = *(_BYTE*)(a2 + 25);
        if ((v3 == 2 || v3 == 6) && *(_DWORD*)(a1 + 372) && *(_BYTE*)(a2 + 24) == 8)
            *(_BYTE*)(a2 + 25) = 3;
    }
    if ((*(_BYTE*)(a1 + 96) & 4) != 0 && *(_BYTE*)(a2 + 24) < 8u)
        *(_BYTE*)(a2 + 24) = 8;
    v4 = *(_BYTE*)(a2 + 25);
    if (v4 == 3 || (v4 & 2) == 0)
        *(_BYTE*)(a2 + 29) = 1;
    else
        *(_BYTE*)(a2 + 29) = 3;
    if ((v4 & 4) != 0)
        ++*(_BYTE*)(a2 + 29);
    if (*(char*)(a1 + 97) < 0 && (v4 == 2 || !v4))
        ++*(_BYTE*)(a2 + 29);
    v5 = *(_BYTE*)(a2 + 29) * *(_BYTE*)(a2 + 24);
    *(_BYTE*)(a2 + 30) = v5;
    result = (*(_DWORD*)a2 * (unsigned int)v5 + 7) >> 3;
    *(_DWORD*)(a2 + 12) = result;
    return result;
}

//----- (00479839) --------------------------------------------------------
void __cdecl sub_479839(int* a1, int a2)
{
    int* v2; // ebx
    unsigned __int8 v3; // cl
    int v4; // eax
    int v5; // ecx
    int v6; // ecx
    _BYTE* v7; // esi
    _BYTE* v8; // edi
    int v9; // edx
    _BYTE* v10; // esi
    _BYTE* v11; // edi
    int v12; // edx
    _BYTE* v13; // esi
    _BYTE* v14; // edi
    int v15; // edx
    unsigned __int8 v16; // dl
    int v17; // [esp+4h] [ebp-4h]
    int v18; // [esp+4h] [ebp-4h]
    int v19; // [esp+4h] [ebp-4h]

    v2 = a1;
    v3 = *((_BYTE*)a1 + 9);
    if (v3 < 8u)
    {
        v4 = *a1;
        v5 = v3 - 1;
        if (v5)
        {
            v6 = v5 - 1;
            if (v6)
            {
                if (v6 != 2)
                    goto LABEL_26;
                v7 = (_BYTE*)(a2 + ((unsigned int)(v4 - 1) >> 1));
                v8 = (_BYTE*)(v4 + a2 - 1);
                v9 = 4 - 4 * ((v4 - 1) & 1);
                if (!v4)
                    goto LABEL_26;
                v17 = *a1;
                do
                {
                    *v8 = (*v7 >> v9) & 0xF;
                    if (v9 == 4)
                    {
                        v9 = 0;
                        --v7;
                    }
                    else
                    {
                        v9 = 4;
                    }
                    --v8;
                    --v17;
                } while (v17);
                goto LABEL_25;
            }
            v10 = (_BYTE*)(a2 + ((unsigned int)(v4 - 1) >> 2));
            v11 = (_BYTE*)(v4 + a2 - 1);
            v12 = 6 - 2 * ((v4 - 1) & 3);
            if (v4)
            {
                v18 = *a1;
                do
                {
                    *v11 = (*v10 >> v12) & 3;
                    if (v12 == 6)
                    {
                        v12 = 0;
                        --v10;
                    }
                    else
                    {
                        v12 += 2;
                    }
                    --v11;
                    --v18;
                } while (v18);
            LABEL_25:
                v2 = a1;
            }
        }
        else
        {
            v13 = (_BYTE*)(a2 + ((unsigned int)(v4 - 1) >> 3));
            v14 = (_BYTE*)(v4 + a2 - 1);
            v15 = 7 - ((v4 - 1) & 7);
            if (v4)
            {
                v19 = *a1;
                do
                {
                    *v14 = (*v13 >> v15) & 1;
                    if (v15 == 7)
                    {
                        v15 = 0;
                        --v13;
                    }
                    else
                    {
                        ++v15;
                    }
                    --v14;
                    --v19;
                } while (v19);
                goto LABEL_25;
            }
        }
    LABEL_26:
        v16 = *((_BYTE*)v2 + 10);
        *((_BYTE*)v2 + 9) = 8;
        *((_BYTE*)v2 + 11) = 8 * v16;
        v2[1] = v4 * v16;
    }
}

//----- (00479949) --------------------------------------------------------
char __cdecl sub_479949(int* a1, _BYTE* a2, unsigned __int8* a3)
{
    int i; // eax
    int v5; // edi
    bool v6; // zf
    int v7; // edx
    int v8; // ebx
    int v9; // ebx
    int v10; // ecx
    unsigned __int8* v11; // esi
    _BYTE* v12; // esi
    _BYTE* v13; // esi
    unsigned int j; // edi
    int v15; // esi
    _BYTE* v16; // edi
    int v17; // esi
    _DWORD v19[4]; // [esp+Ch] [ebp-14h] BYREF
    unsigned int v20; // [esp+1Ch] [ebp-4h]
    __int16 v21; // [esp+28h] [ebp+8h]
    unsigned int k; // [esp+28h] [ebp+8h]
    unsigned int v23; // [esp+28h] [ebp+8h]

    LOBYTE(i) = *((_BYTE*)a1 + 8);
    if ((_BYTE)i != 3)
    {
        v21 = 0;
        v5 = *a1;
        v6 = (i & 2) == 0;
        LOBYTE(i) = (_BYTE)a3;
        if (v6)
        {
            v7 = *((unsigned __int8*)a1 + 9) - a3[3];
            v9 = 1;
        }
        else
        {
            v7 = *((unsigned __int8*)a1 + 9) - *a3;
            v8 = a3[2];
            v19[1] = *((unsigned __int8*)a1 + 9) - a3[1];
            v19[2] = *((unsigned __int8*)a1 + 9) - v8;
            v9 = 3;
        }
        v6 = (a1[2] & 4) == 0;
        v19[0] = v7;
        if (!v6)
        {
            i = *((unsigned __int8*)a1 + 9) - a3[4];
            v19[v9] = i;
            LOBYTE(v7) = v19[0];
            ++v9;
        }
        v10 = 0;
        if (v9 > 0)
        {
            do
            {
                i = (int)&v19[v10];
                if (*(int*)i > 0)
                {
                    v21 = 1;
                }
                else
                {
                    *(_DWORD*)i = 0;
                    LOBYTE(v7) = v19[0];
                }
                ++v10;
            } while (v10 < v9);
            if (v21)
            {
                if (*((_BYTE*)a1 + 9) == 2)
                {
                    v17 = a1[1];
                    for (i = (int)a2; v17; --v17)
                    {
                        *(_BYTE*)i = (*(_BYTE*)i >> 1) & 0x55;
                        ++i;
                    }
                }
                else if (*((_BYTE*)a1 + 9) == 4)
                {
                    v15 = a1[1];
                    v16 = a2;
                    for (LOBYTE(i) = (15 >> v7) | (240 >> v7) & 0xF0; v15; --v15)
                    {
                        *v16 = i & (*v16 >> v7);
                        ++v16;
                    }
                }
                else
                {
                    LOBYTE(i) = *((_BYTE*)a1 + 9) - 8;
                    if (*((_BYTE*)a1 + 9) == 8)
                    {
                        v13 = a2;
                        v23 = v9 * v5;
                        for (j = 0; j < v23; ++j)
                        {
                            i = j / v9;
                            *v13++ >>= LOBYTE(v19[j % v9]);
                        }
                    }
                    else
                    {
                        LOBYTE(i) = *((_BYTE*)a1 + 9) - 16;
                        if (*((_BYTE*)a1 + 9) == 16)
                        {
                            v11 = a2;
                            v20 = v9 * v5;
                            for (k = 0; k < v20; LOBYTE(i) = k)
                            {
                                LOWORD(i) = (unsigned __int16)(v11[1] + (*v11 << 8)) >> LOWORD(v19[k % v9]);
                                *v11 = BYTE1(i);
                                v12 = v11 + 1;
                                *v12 = i;
                                v11 = v12 + 1;
                                ++k;
                            }
                        }
                    }
                }
            }
        }
    }
    return i;
}

//----- (00479AC0) --------------------------------------------------------
int __cdecl sub_479AC0(int a1, _BYTE* a2)
{
    int result; // eax
    _BYTE* v3; // esi
    char* v4; // edx
    int v5; // edi
    char v6; // cl
    unsigned __int8 v7; // dl
    int v8; // ecx

    result = a1;
    if (*(_BYTE*)(a1 + 9) == 16)
    {
        v3 = a2;
        v4 = a2;
        if (*(_DWORD*)a1 * *(unsigned __int8*)(a1 + 10))
        {
            v5 = *(_DWORD*)a1 * *(unsigned __int8*)(a1 + 10);
            do
            {
                v6 = *v4;
                v4 += 2;
                *v3++ = v6;
                --v5;
            } while (v5);
        }
        v7 = *(_BYTE*)(a1 + 10);
        v8 = *(_DWORD*)a1 * v7;
        *(_BYTE*)(a1 + 9) = 8;
        *(_BYTE*)(a1 + 11) = 8 * v7;
        *(_DWORD*)(a1 + 4) = v8;
    }
    return result;
}

//----- (00479B06) --------------------------------------------------------
unsigned int __cdecl sub_479B06(int a1, int a2, unsigned int a3, char a4)
{
    char v4; // dl
    char v6; // cl
    unsigned int result; // eax
    unsigned int v8; // ebx
    char v9; // cl
    _BYTE* v10; // ecx
    _BYTE* v11; // edi
    _BYTE* v12; // edi
    bool v13; // zf
    _BYTE* v14; // edi
    _BYTE* v15; // ecx
    _BYTE* v16; // edi
    _BYTE* v17; // ecx
    _BYTE* v18; // edi
    _BYTE* v19; // ecx
    char* v20; // edi
    char v21; // cl
    char* v22; // edi
    char v23; // cl
    _BYTE* v24; // ecx
    _BYTE* v25; // edi
    _BYTE* v26; // edi
    _BYTE* v27; // ecx
    char v28; // bl
    _BYTE* v29; // edi
    _BYTE* v30; // ecx
    _BYTE* v31; // edi
    _BYTE* v32; // ecx
    _BYTE* v33; // edi
    _BYTE* v34; // ecx
    _BYTE* v35; // ecx
    _BYTE* v36; // edi
    char v37; // bl
    _BYTE* v38; // ecx
    _BYTE* v39; // edi
    _BYTE* v40; // ecx
    unsigned int v41; // [esp+18h] [ebp+8h]
    unsigned int v42; // [esp+18h] [ebp+8h]
    char* v43; // [esp+18h] [ebp+8h]
    char* v44; // [esp+18h] [ebp+8h]
    unsigned int v45; // [esp+18h] [ebp+8h]
    unsigned int v46; // [esp+18h] [ebp+8h]
    char v47; // [esp+1Bh] [ebp+Bh]
    unsigned int v48; // [esp+20h] [ebp+10h]
    unsigned int v49; // [esp+20h] [ebp+10h]
    unsigned int v50; // [esp+20h] [ebp+10h]
    unsigned int v51; // [esp+20h] [ebp+10h]

    v4 = a3;
    v6 = *(_BYTE*)(a1 + 8);
    result = *(_DWORD*)a1;
    v8 = a3 >> 8;
    v47 = BYTE1(a3);
    if (v6)
    {
        if (v6 != 2)
            return result;
        v23 = *(_BYTE*)(a1 + 9);
        if (v23 == 8)
        {
            if (a4 >= 0)
            {
                v29 = (_BYTE*)(a2 + 2 * result + result);
                v30 = &v29[result];
                if (result)
                {
                    v46 = result;
                    do
                    {
                        v31 = v29 - 1;
                        v32 = v30 - 1;
                        *v32 = *v31--;
                        *--v32 = *v31;
                        v29 = v31 - 1;
                        *--v32 = *v29;
                        v30 = v32 - 1;
                        v13 = v46-- == 1;
                        *v30 = a3;
                    } while (!v13);
                }
            }
            else
            {
                v24 = (_BYTE*)(a2 + 2 * result + result);
                v25 = &v24[result];
                if (result > 1)
                {
                    v45 = result - 1;
                    do
                    {
                        v26 = v25 - 1;
                        *v26 = a3;
                        v27 = v24 - 1;
                        *--v26 = *v27;
                        v28 = *--v27;
                        --v26;
                        v24 = v27 - 1;
                        *v26 = v28;
                        v25 = v26 - 1;
                        v13 = v45-- == 1;
                        *v25 = *v24;
                    } while (!v13);
                }
                *(v25 - 1) = a3;
            }
            *(_BYTE*)(a1 + 11) = 32;
            result *= 4;
        }
        else
        {
            if (v23 != 16)
                return result;
            v33 = (_BYTE*)(a2 + 2 * result + result);
            v34 = &v33[result];
            if (a4 >= 0)
            {
                if (result)
                {
                    v51 = result;
                    do
                    {
                        v39 = v33 - 1;
                        v40 = v34 - 1;
                        *v40 = *v39--;
                        *--v40 = *v39--;
                        *--v40 = *v39--;
                        *--v40 = *v39--;
                        *--v40 = *v39;
                        v33 = v39 - 1;
                        *--v40 = *v33;
                        *--v40 = v47;
                        v34 = v40 - 1;
                        v13 = v51-- == 1;
                        *v34 = v4;
                    } while (!v13);
                }
            }
            else
            {
                if (result > 1)
                {
                    v50 = result - 1;
                    do
                    {
                        v35 = v34 - 1;
                        *v35-- = v47;
                        *v35 = v4;
                        v36 = v33 - 1;
                        *--v35 = *v36--;
                        *--v35 = *v36--;
                        *--v35 = *v36--;
                        *--v35 = *v36;
                        v37 = *--v36;
                        --v35;
                        v33 = v36 - 1;
                        *v35 = v37;
                        v34 = v35 - 1;
                        v13 = v50-- == 1;
                        *v34 = *v33;
                    } while (!v13);
                    LOBYTE(v8) = v47;
                }
                v38 = v34 - 1;
                *v38 = v8;
                *(v38 - 1) = v4;
            }
            *(_BYTE*)(a1 + 11) = 64;
            result *= 8;
        }
        *(_BYTE*)(a1 + 10) = 4;
    }
    else
    {
        v9 = *(_BYTE*)(a1 + 9);
        if (v9 == 8)
        {
            v10 = (_BYTE*)(result + a2);
            v11 = (_BYTE*)(result + a2 + result);
            if (a4 >= 0)
            {
                if (result)
                {
                    v42 = result;
                    do
                    {
                        --v10;
                        v14 = v11 - 1;
                        *v14 = *v10;
                        v11 = v14 - 1;
                        v13 = v42-- == 1;
                        *v11 = a3;
                    } while (!v13);
                }
            }
            else
            {
                if (result > 1)
                {
                    v41 = result - 1;
                    do
                    {
                        v12 = v11 - 1;
                        --v10;
                        *v12 = a3;
                        v11 = v12 - 1;
                        v13 = v41-- == 1;
                        *v11 = *v10;
                    } while (!v13);
                }
                *(v11 - 1) = a3;
            }
            *(_BYTE*)(a1 + 10) = 2;
            *(_BYTE*)(a1 + 11) = 16;
            result *= 2;
        }
        else
        {
            if (v9 != 16)
                return result;
            if (a4 >= 0)
            {
                v43 = (char*)(result + a2);
                v20 = (char*)(result + result + a2);
                if (result)
                {
                    v49 = result;
                    do
                    {
                        v44 = v43 - 1;
                        v21 = *v44;
                        v22 = v20 - 1;
                        v43 = v44 - 1;
                        *v22-- = v21;
                        *v22-- = *v43;
                        *v22 = v8;
                        v20 = v22 - 1;
                        v13 = v49-- == 1;
                        *v20 = v4;
                    } while (!v13);
                }
            }
            else
            {
                v15 = (_BYTE*)(result + result + a2);
                if (result > 1)
                {
                    v48 = result - 1;
                    v16 = (_BYTE*)(result + a2);
                    do
                    {
                        v17 = v15 - 1;
                        *v17-- = v8;
                        *v17 = v4;
                        v18 = v16 - 1;
                        *--v17 = *v18;
                        v16 = v18 - 1;
                        v15 = v17 - 1;
                        v13 = v48-- == 1;
                        *v15 = *v16;
                        LOBYTE(v8) = v47;
                    } while (!v13);
                }
                v19 = v15 - 1;
                *v19 = v8;
                *(v19 - 1) = v4;
            }
            *(_BYTE*)(a1 + 10) = 2;
            *(_BYTE*)(a1 + 11) = 32;
            result *= 4;
        }
    }
    *(_DWORD*)(a1 + 4) = result;
    return result;
}

//----- (00479D3E) --------------------------------------------------------
unsigned __int8* __cdecl sub_479D3E(int* a1, _BYTE* a2, unsigned __int8* a3, int a4, char a5)
{
    unsigned __int8* result; // eax
    int* v6; // edi
    unsigned __int8 v7; // cl
    int v8; // edx
    _BYTE* v9; // ecx
    int v10; // esi
    _BYTE* v11; // ecx
    __int16 v12; // cx
    unsigned __int8* v13; // eax
    __int16 v14; // cx
    __int16 v15; // cx
    _BYTE* v16; // ecx
    int v17; // esi
    __int16 v18; // cx
    _BYTE* v19; // ecx
    int v20; // esi
    _BYTE* v21; // ecx
    __int16 v22; // cx
    unsigned __int8* v23; // eax
    __int16 v24; // cx
    __int16 v25; // cx
    char v26; // cl
    int v27; // edx
    int v28; // edi
    char* v29; // ecx
    bool v30; // zf
    char v31; // cl
    _BYTE* v32; // esi
    unsigned int v33; // edi
    _BYTE* v34; // ecx
    int v35; // esi
    __int16 v36; // cx
    int v37; // [esp+8h] [ebp-14h]
    unsigned int v38; // [esp+14h] [ebp-8h]
    char* v39; // [esp+18h] [ebp-4h]
    int v40; // [esp+24h] [ebp+8h]
    int v41; // [esp+24h] [ebp+8h]

    result = a3;
    v6 = a1;
    v7 = *((_BYTE*)a1 + 9);
    v8 = *a1;
    v37 = *a1;
    if (v7 <= 8u && a3 || v7 == 16 && a4)
    {
        if (*((_BYTE*)a1 + 8))
        {
            switch (*((_BYTE*)a1 + 8))
            {
            case 2:
                if (v7 == 8)
                {
                    v19 = a2;
                    if (v8)
                    {
                        v20 = *a1;
                        do
                        {
                            *v19 = a3[(unsigned __int8)*v19];
                            v21 = v19 + 1;
                            *v21 = a3[(unsigned __int8)*v21];
                            ++v21;
                            *v21 = a3[(unsigned __int8)*v21];
                            v19 = v21 + 1;
                            --v20;
                        } while (v20);
                    }
                }
                else
                {
                    result = a2;
                    if (v8)
                    {
                        v41 = *a1;
                        do
                        {
                            v22 = *(_WORD*)(*(_DWORD*)(a4 + 4 * (result[1] >> a5)) + 2 * *result);
                            result[1] = v22;
                            *result = HIBYTE(v22);
                            v23 = result + 2;
                            v24 = *(_WORD*)(*(_DWORD*)(a4 + 4 * (v23[1] >> a5)) + 2 * *v23);
                            v23[1] = v24;
                            *v23 = HIBYTE(v24);
                            v23 += 2;
                            v25 = *(_WORD*)(*(_DWORD*)(a4 + 4 * (v23[1] >> a5)) + 2 * *v23);
                            *v23 = HIBYTE(v25);
                            v23[1] = v25;
                            result = v23 + 2;
                            --v41;
                        } while (v41);
                    }
                }
                break;
            case 4:
                if (v7 == 8)
                {
                    v16 = a2;
                    if (v8)
                    {
                        v17 = *a1;
                        do
                        {
                            *v16 = a3[(unsigned __int8)*v16];
                            v16 += 2;
                            --v17;
                        } while (v17);
                    }
                }
                else
                {
                    for (result = a2; v8; --v8)
                    {
                        v18 = *(_WORD*)(*(_DWORD*)(a4 + 4 * (result[1] >> a5)) + 2 * *result);
                        *result = HIBYTE(v18);
                        result[1] = v18;
                        result += 4;
                    }
                }
                break;
            case 6:
                if (v7 == 8)
                {
                    v9 = a2;
                    if (v8)
                    {
                        v10 = *a1;
                        do
                        {
                            *v9 = a3[(unsigned __int8)*v9];
                            v11 = v9 + 1;
                            *v11 = a3[(unsigned __int8)*v11];
                            ++v11;
                            *v11 = a3[(unsigned __int8)*v11];
                            v9 = v11 + 2;
                            --v10;
                        } while (v10);
                    }
                }
                else
                {
                    result = a2;
                    if (v8)
                    {
                        v40 = *a1;
                        do
                        {
                            v12 = *(_WORD*)(*(_DWORD*)(a4 + 4 * (result[1] >> a5)) + 2 * *result);
                            result[1] = v12;
                            *result = HIBYTE(v12);
                            v13 = result + 2;
                            v14 = *(_WORD*)(*(_DWORD*)(a4 + 4 * (v13[1] >> a5)) + 2 * *v13);
                            v13[1] = v14;
                            *v13 = HIBYTE(v14);
                            v13 += 2;
                            v15 = *(_WORD*)(*(_DWORD*)(a4 + 4 * (v13[1] >> a5)) + 2 * *v13);
                            *v13 = HIBYTE(v15);
                            v13[1] = v15;
                            result = v13 + 4;
                            --v40;
                        } while (v40);
                    }
                }
                break;
            }
        }
        else
        {
            if (v7 == 2)
            {
                v39 = a2;
                if (v8)
                {
                    v38 = ((unsigned int)(v8 - 1) >> 2) + 1;
                    do
                    {
                        v26 = *v39;
                        v27 = *v39 & 0xC;
                        v28 = *v39 & 0x30;
                        LOBYTE(v27) = a3[*v39 & 0xC0 | ((*v39 & 0xC0 | ((*v39 & 0xC0 | ((*v39 & 0xC0) >> 2)) >> 2)) >> 2)] & 0xC0
                            | ((unsigned __int8)(a3[v28 | (4 * v28) | ((v28 | (v28 >> 2)) >> 2)] & 0xC3
                                | ((unsigned __int8)((a3[v26 & 3
                                    | (4 * (v26 & 3 | (4 * (v26 & 3 | (4 * (v26 & 3))))))] >> 2)
                                    | a3[v27 | (v27 >> 2) | (4 * (v27 | (4 * (v26 & 0xC))))]
                                    & 0xCF) >> 2)) >> 2);
                        v29 = v39++;
                        v30 = v38-- == 1;
                        *v29 = v27;
                    } while (!v30);
                    v8 = v37;
                    v6 = a1;
                }
            }
            v31 = *((_BYTE*)v6 + 9);
            switch (v31)
            {
            case 4:
                v32 = a2;
                if (v8)
                {
                    v33 = ((unsigned int)(v8 - 1) >> 1) + 1;
                    do
                    {
                        *v32 = (a3[*v32 & 0xF | (16 * (*v32 & 0xF))] >> 4) | a3[*v32 & 0xF0 | ((*v32 & 0xF0) >> 4)] & 0xF0;
                        ++v32;
                        --v33;
                    } while (v33);
                }
                break;
            case 8:
                v34 = a2;
                if (v8)
                {
                    v35 = v8;
                    do
                    {
                        *v34 = a3[(unsigned __int8)*v34];
                        ++v34;
                        --v35;
                    } while (v35);
                }
                break;
            case 16:
                for (result = a2; v8; --v8)
                {
                    v36 = *(_WORD*)(*(_DWORD*)(a4 + 4 * (result[1] >> a5)) + 2 * *result);
                    *result = HIBYTE(v36);
                    result[1] = v36;
                    result += 2;
                }
                break;
            }
        }
    }
    return result;
}

//----- (0047A08C) --------------------------------------------------------
int __cdecl sub_47A08C(int* a1, int a2, int a3, int a4, int a5)
{
    int result; // eax
    unsigned __int8 v7; // cl
    int v8; // ecx
    int v9; // ecx
    int v10; // ecx
    _BYTE* v11; // edx
    bool v12; // zf
    int v13; // ecx
    _BYTE* v14; // edx
    int v15; // ecx
    _BYTE* v16; // edx
    unsigned __int8* v17; // edx
    int v18; // ebx
    _BYTE* v19; // ecx
    _BYTE* v20; // ecx
    _BYTE* v21; // ecx
    _BYTE* v22; // ecx
    int v23; // [esp+4h] [ebp-8h]
    int v24; // [esp+4h] [ebp-8h]
    int v25; // [esp+4h] [ebp-8h]
    int v26; // [esp+4h] [ebp-8h]
    int v27; // [esp+4h] [ebp-8h]
    _BYTE* v28; // [esp+8h] [ebp-4h]
    _BYTE* v29; // [esp+8h] [ebp-4h]
    _BYTE* v30; // [esp+8h] [ebp-4h]
    int v31; // [esp+14h] [ebp+8h]
    int v32; // [esp+14h] [ebp+8h]
    int v33; // [esp+14h] [ebp+8h]
    int v34; // [esp+14h] [ebp+8h]
    int v35; // [esp+14h] [ebp+8h]

    result = *a1;
    if (*((_BYTE*)a1 + 8) == 3)
    {
        v7 = *((_BYTE*)a1 + 9);
        if (v7 < 8u)
        {
            v8 = v7 - 1;
            if (v8)
            {
                v9 = v8 - 1;
                if (v9)
                {
                    if (v9 == 2)
                    {
                        v28 = (_BYTE*)(result + a2 - 1);
                        LOBYTE(v10) = 4 * (result & 1);
                        v11 = (_BYTE*)(a2 + ((unsigned int)(result - 1) >> 1));
                        v31 = 4 * (*a1 & 1);
                        if (result)
                        {
                            v23 = result;
                            do
                            {
                                *v28 = (*v11 >> v10) & 0xF;
                                if (v31 == 4)
                                {
                                    v10 = 0;
                                    --v11;
                                }
                                else
                                {
                                    v10 = v31 + 4;
                                }
                                --v28;
                                v12 = v23-- == 1;
                                v31 = v10;
                            } while (!v12);
                        }
                    }
                }
                else
                {
                    v29 = (_BYTE*)(result + a2 - 1);
                    LOBYTE(v13) = 2 * (3 - ((result - 1) & 3));
                    v14 = (_BYTE*)(a2 + ((unsigned int)(result - 1) >> 2));
                    v32 = 2 * (3 - (((_BYTE)result - 1) & 3));
                    if (result)
                    {
                        v24 = result;
                        do
                        {
                            *v29 = (*v14 >> v13) & 3;
                            if (v32 == 6)
                            {
                                v13 = 0;
                                --v14;
                            }
                            else
                            {
                                v13 = v32 + 2;
                            }
                            --v29;
                            v12 = v24-- == 1;
                            v32 = v13;
                        } while (!v12);
                    }
                }
            }
            else
            {
                v30 = (_BYTE*)(result + a2 - 1);
                LOBYTE(v15) = 7 - ((result - 1) & 7);
                v16 = (_BYTE*)(a2 + ((unsigned int)(result - 1) >> 3));
                v33 = 7 - (((_BYTE)result - 1) & 7);
                if (result)
                {
                    v25 = result;
                    do
                    {
                        *v30 = (*v16 >> v15) & 1;
                        if (v33 == 7)
                        {
                            v15 = 0;
                            --v16;
                        }
                        else
                        {
                            v15 = v33 + 1;
                        }
                        --v30;
                        v12 = v25-- == 1;
                        v33 = v15;
                    } while (!v12);
                }
            }
            *((_BYTE*)a1 + 9) = 8;
            *((_BYTE*)a1 + 11) = 8;
            a1[1] = result;
        }
        if (*((_BYTE*)a1 + 9) == 8)
        {
            v17 = (unsigned __int8*)(result + a2 - 1);
            if (a4)
            {
                v18 = 4 * result;
                v26 = 4 * result;
                v19 = (_BYTE*)(4 * result + a2 - 1);
                if (result)
                {
                    v34 = result;
                    result = a3;
                    do
                    {
                        if (*v17 < a5)
                            *v19 = *(_BYTE*)(*v17 + a4);
                        else
                            *v19 = -1;
                        v20 = v19 - 1;
                        *v20-- = *(_BYTE*)(*v17 + a3 + 2 * *v17 + 2);
                        *v20-- = *(_BYTE*)(*v17 + a3 + 2 * *v17 + 1);
                        *v20 = *(_BYTE*)(*v17 + a3 + 2 * *v17);
                        v19 = v20 - 1;
                        --v17;
                        --v34;
                    } while (v34);
                    v18 = v26;
                }
                *((_BYTE*)a1 + 11) = 32;
                *((_BYTE*)a1 + 8) = 6;
                *((_BYTE*)a1 + 10) = 4;
            }
            else
            {
                v18 = 3 * result;
                v27 = 3 * result;
                v21 = (_BYTE*)(3 * result + a2 - 1);
                if (result)
                {
                    v35 = result;
                    result = a3;
                    do
                    {
                        *v21 = *(_BYTE*)(*v17 + a3 + 2 * *v17 + 2);
                        v22 = v21 - 1;
                        *v22-- = *(_BYTE*)(*v17 + a3 + 2 * *v17 + 1);
                        *v22 = *(_BYTE*)(*v17 + a3 + 2 * *v17);
                        v21 = v22 - 1;
                        --v17;
                        --v35;
                    } while (v35);
                    v18 = v27;
                }
                *((_BYTE*)a1 + 11) = 24;
                *((_BYTE*)a1 + 8) = 2;
                *((_BYTE*)a1 + 10) = 3;
            }
            *((_BYTE*)a1 + 9) = 8;
            a1[1] = v18;
        }
    }
    return result;
}

//----- (0047A294) --------------------------------------------------------
int __cdecl sub_47A294(int* a1, int a2, _WORD* a3)
{
    char v4; // cl
    int result; // eax
    unsigned __int16 v6; // bx
    unsigned __int8 v7; // cl
    int v8; // ecx
    int v9; // ecx
    int v10; // ecx
    unsigned __int8* v11; // edx
    bool v12; // zf
    int v13; // ecx
    unsigned __int8* v14; // edx
    char v15; // bl
    int v16; // ecx
    _BYTE* v17; // edx
    char v18; // cl
    _BYTE* v19; // ecx
    _BYTE* v20; // edi
    int v21; // edx
    _BYTE* v22; // edi
    int v23; // edx
    _BYTE* v24; // ecx
    _BYTE* v25; // edi
    unsigned __int16 v26; // bx
    _BYTE* v27; // edi
    _BYTE* v28; // edi
    char v29; // cl
    unsigned __int8 v30; // cl
    _WORD* v31; // edx
    char v32; // cl
    _BYTE* v33; // ecx
    _BYTE* v34; // edi
    _BYTE* v35; // edi
    _BYTE* v36; // ecx
    _BYTE* v37; // ecx
    _BYTE* v38; // edi
    __int16 v39; // bx
    __int16 v40; // dx
    __int16 v41; // dx
    _BYTE* v42; // edi
    _BYTE* v43; // edi
    _BYTE* v44; // ecx
    char v45; // cl
    int v46; // [esp+Ch] [ebp-Ch]
    int v47; // [esp+Ch] [ebp-Ch]
    int v48; // [esp+Ch] [ebp-Ch]
    int v49; // [esp+Ch] [ebp-Ch]
    unsigned __int16 v50; // [esp+10h] [ebp-8h]
    _BYTE* v51; // [esp+14h] [ebp-4h]
    _BYTE* v52; // [esp+14h] [ebp-4h]
    _BYTE* v53; // [esp+14h] [ebp-4h]
    int v54; // [esp+20h] [ebp+8h]
    int v55; // [esp+20h] [ebp+8h]
    int v56; // [esp+20h] [ebp+8h]
    int v57; // [esp+20h] [ebp+8h]
    int v58; // [esp+20h] [ebp+8h]
    int v59; // [esp+20h] [ebp+8h]

    v4 = *((_BYTE*)a1 + 8);
    result = *a1;
    if (v4)
    {
        if (v4 == 2)
        {
            v31 = a3;
            if (a3)
            {
                v32 = *((_BYTE*)a1 + 9);
                if (v32 == 8)
                {
                    v33 = (_BYTE*)(a1[1] + a2 - 1);
                    v34 = (_BYTE*)(a2 + 4 * result - 1);
                    if (result)
                    {
                        v58 = *a1;
                        do
                        {
                            if ((unsigned __int8)*(v33 - 2) == a3[1]
                                && (unsigned __int8)*(v33 - 1) == a3[2]
                                && (unsigned __int8)*v33 == a3[3])
                            {
                                *v34 = 0;
                            }
                            else
                            {
                                *v34 = -1;
                            }
                            v35 = v34 - 1;
                            *v35-- = *v33;
                            v36 = v33 - 1;
                            *v35-- = *v36;
                            *v35 = *--v36;
                            v34 = v35 - 1;
                            v33 = v36 - 1;
                            --v58;
                        } while (v58);
                    }
                }
                else if (v32 == 16)
                {
                    v37 = (_BYTE*)(a1[1] + a2 - 1);
                    v38 = (_BYTE*)(a2 + 8 * result - 1);
                    if (result)
                    {
                        v59 = *a1;
                        while (1)
                        {
                            HIBYTE(v39) = *(v37 - 5);
                            LOBYTE(v39) = *(v37 - 4);
                            if (v39 == v31[1]
                                && (HIBYTE(v40) = *(v37 - 3), LOBYTE(v40) = *(v37 - 2), v40 == a3[2])
                                && (HIBYTE(v41) = *(v37 - 1), LOBYTE(v41) = *v37, v41 == a3[3]))
                            {
                                *v38 = 0;
                                v42 = v38 - 1;
                                *v42 = 0;
                            }
                            else
                            {
                                *v38 = -1;
                                v42 = v38 - 1;
                                *v42 = -1;
                            }
                            v43 = v42 - 1;
                            *v43-- = *v37;
                            v44 = v37 - 1;
                            *v43-- = *v44;
                            *v43-- = *--v44;
                            *v43-- = *--v44;
                            *v43-- = *--v44;
                            *v43 = *--v44;
                            v38 = v43 - 1;
                            v37 = v44 - 1;
                            if (!--v59)
                                break;
                            v31 = a3;
                        }
                    }
                }
                v45 = *((_BYTE*)a1 + 9);
                *((_BYTE*)a1 + 8) = 6;
                *((_BYTE*)a1 + 10) = 4;
                v30 = 4 * v45;
                goto LABEL_68;
            }
        }
    }
    else
    {
        v6 = 0;
        if (a3)
            v6 = a3[4];
        v7 = *((_BYTE*)a1 + 9);
        v50 = v6;
        if (v7 < 8u)
        {
            v8 = v7 - 1;
            if (v8)
            {
                v9 = v8 - 1;
                if (v9)
                {
                    if (v9 == 2)
                    {
                        v51 = (_BYTE*)(result + a2 - 1);
                        v50 = 17 * v6;
                        LOBYTE(v10) = 4 - 4 * ((result - 1) & 1);
                        v11 = (unsigned __int8*)(a2 + ((unsigned int)(result - 1) >> 1));
                        v54 = 4 - 4 * (((_BYTE)result - 1) & 1);
                        if (result)
                        {
                            v46 = result;
                            do
                            {
                                *v51 = (*v11 >> v10) & 0xF | (16 * ((*v11 >> v10) & 0xF));
                                v10 = 4;
                                if (v54 == 4)
                                {
                                    v10 = 0;
                                    --v11;
                                }
                                --v51;
                                v12 = v46-- == 1;
                                v54 = v10;
                            } while (!v12);
                        }
                    }
                }
                else
                {
                    v50 = 85 * v6;
                    v52 = (_BYTE*)(result + a2 - 1);
                    v13 = (unsigned __int8)(2 * (3 - ((result - 1) & 3)));
                    v14 = (unsigned __int8*)(a2 + ((unsigned int)(result - 1) >> 2));
                    v55 = 2 * (3 - (((_BYTE)result - 1) & 3));
                    if (result)
                    {
                        v47 = result;
                        do
                        {
                            v15 = (*v14 >> v13) & 3;
                            *v52 = v15 | (4 * (v15 | (4 * (v15 | (4 * v15)))));
                            if (v55 == 6)
                            {
                                v13 = 0;
                                --v14;
                            }
                            else
                            {
                                v13 = v55 + 2;
                            }
                            --v52;
                            v12 = v47-- == 1;
                            v55 = v13;
                        } while (!v12);
                    }
                }
            }
            else
            {
                v50 = 255 * v6;
                v53 = (_BYTE*)(result + a2 - 1);
                v16 = (unsigned __int8)(7 - ((result - 1) & 7));
                v17 = (_BYTE*)(a2 + ((unsigned int)(result - 1) >> 3));
                v56 = 7 - (((_BYTE)result - 1) & 7);
                if (result)
                {
                    v48 = result;
                    do
                    {
                        *v53 = -(((*v17 >> v16) & 1) != 0);
                        if (v56 == 7)
                        {
                            v16 = 0;
                            --v17;
                        }
                        else
                        {
                            v16 = v56 + 1;
                        }
                        --v53;
                        v12 = v48-- == 1;
                        v56 = v16;
                    } while (!v12);
                }
            }
            v6 = v50;
            *((_BYTE*)a1 + 9) = 8;
            *((_BYTE*)a1 + 11) = 8;
            a1[1] = result;
        }
        if (a3)
        {
            v18 = *((_BYTE*)a1 + 9);
            if (v18 == 8)
            {
                v19 = (_BYTE*)(result + a2 - 1);
                v20 = (_BYTE*)(a2 + 2 * result - 1);
                if (result)
                {
                    v21 = result;
                    do
                    {
                        if ((unsigned __int8)*v19 == v50)
                            *v20 = 0;
                        else
                            *v20 = -1;
                        v22 = v20 - 1;
                        *v22 = *v19;
                        v20 = v22 - 1;
                        --v19;
                        --v21;
                    } while (v21);
                }
            }
            else if (v18 == 16)
            {
                v23 = a1[1];
                v24 = (_BYTE*)(v23 + a2 - 1);
                v25 = (_BYTE*)(a2 + 2 * v23 - 1);
                if (result)
                {
                    v49 = v6;
                    v57 = result;
                    do
                    {
                        HIBYTE(v26) = *(v24 - 1);
                        LOBYTE(v26) = *v24;
                        if (v26 == v49)
                        {
                            *v25 = 0;
                            v27 = v25 - 1;
                            *v27 = 0;
                        }
                        else
                        {
                            *v25 = -1;
                            v27 = v25 - 1;
                            *v27 = -1;
                        }
                        v28 = v27 - 1;
                        *v28-- = *v24;
                        *v28 = *(v24 - 1);
                        v25 = v28 - 1;
                        v24 -= 2;
                        --v57;
                    } while (v57);
                }
            }
            v29 = *((_BYTE*)a1 + 9);
            *((_BYTE*)a1 + 8) = 4;
            *((_BYTE*)a1 + 10) = 2;
            v30 = 2 * v29;
        LABEL_68:
            *((_BYTE*)a1 + 11) = v30;
            a1[1] = (result * (unsigned int)v30) >> 3;
        }
    }
    return result;
}

//----- (0047A5E6) --------------------------------------------------------
int __cdecl sub_47A5E6(int* a1, char* a2, int a3, int a4)
{
    char v5; // cl
    int result; // eax
    char* v7; // edx
    char v8; // al
    char* v9; // edx
    char v10; // bl
    char v11; // al
    char* v12; // esi
    bool v13; // zf
    unsigned __int8 v14; // cl
    char* v15; // edx
    char v16; // al
    char* v17; // edx
    char v18; // bl
    char v19; // al
    char* v20; // esi
    char* i; // ecx
    int v22; // [esp+Ch] [ebp-8h]
    int v23; // [esp+10h] [ebp-4h]
    int v24; // [esp+10h] [ebp-4h]
    char* v25; // [esp+1Ch] [ebp+8h]
    char* v26; // [esp+1Ch] [ebp+8h]

    v5 = *((_BYTE*)a1 + 8);
    result = *a1;
    v22 = *a1;
    if (v5 == 2 && a3 && *((_BYTE*)a1 + 9) == 8)
    {
        v7 = a2;
        v25 = a2;
        if (!result)
        {
        LABEL_8:
            v14 = *((_BYTE*)a1 + 9);
            *((_BYTE*)a1 + 11) = v14;
            *((_BYTE*)a1 + 8) = 3;
            *((_BYTE*)a1 + 10) = 1;
            a1[1] = (result * (unsigned int)v14 + 7) >> 3;
            return result;
        }
        v23 = result;
        do
        {
            v8 = *v7;
            v9 = v7 + 1;
            v10 = *v9++;
            v11 = *(_BYTE*)((((int)(unsigned __int8)*v9 >> 3) & 0x1F | (4 * (v10 & 0xF8 | (32 * (v8 & 0xF8))))) + a3);
            v12 = v25;
            v7 = v9 + 1;
            ++v25;
            v13 = v23-- == 1;
            *v12 = v11;
        } while (!v13);
    LABEL_7:
        result = v22;
        goto LABEL_8;
    }
    if (v5 == 6 && a3 && *((_BYTE*)a1 + 9) == 8)
    {
        v15 = a2;
        v26 = a2;
        if (!result)
            goto LABEL_8;
        v24 = result;
        do
        {
            v16 = *v15;
            v17 = v15 + 1;
            v18 = *v17++;
            v19 = *(_BYTE*)((((int)(unsigned __int8)*v17 >> 3) & 0x1F | (4 * (v18 & 0xF8 | (32 * (v16 & 0xF8))))) + a3);
            v20 = v26;
            v15 = v17 + 2;
            ++v26;
            v13 = v24-- == 1;
            *v20 = v19;
        } while (!v13);
        goto LABEL_7;
    }
    if (v5 == 3)
    {
        if (a4)
        {
            if (*((_BYTE*)a1 + 9) == 8)
            {
                for (i = a2; result; --result)
                {
                    *i = *(_BYTE*)((unsigned __int8)*i + a4);
                    ++i;
                }
            }
        }
    }
    return result;
}

//----- (0047A6F4) --------------------------------------------------------
void __cdecl sub_47A6F4(jmp_buf Buf)
{
    long double v2; // st7
    void* v3; // eax
    __int64 v4; // rax
    int v5; // eax
    unsigned int v6; // edi
    int v7; // ebx
    long double v8; // st7
    void* v9; // eax
    bool v10; // zf
    void* v11; // eax
    int* __attribute__((__org_typedef(jmp_buf))) v12; // edx
    __int16 v13; // cx
    unsigned int v14; // ebx
    int v15; // eax
    int v16; // ebx
    __int64 v17; // rax
    double v18; // [esp+4h] [ebp-28h]
    unsigned int v19; // [esp+14h] [ebp-18h]
    unsigned int v20; // [esp+18h] [ebp-14h]
    char v21; // [esp+1Ch] [ebp-10h]
    unsigned int v22; // [esp+20h] [ebp-Ch]
    int v23; // [esp+28h] [ebp-4h]
    int* __attribute__((__org_typedef(jmp_buf))) Bufa; // [esp+34h] [ebp+8h]
    int* __attribute__((__org_typedef(jmp_buf))) Bufb; // [esp+34h] [ebp+8h]
    int* __attribute__((__org_typedef(jmp_buf))) Bufc; // [esp+34h] [ebp+8h]

    if (*((float*)Buf + 76) != 0.0)
    {
        if (*((_BYTE*)Buf + 279) > 8u)
        {
            if ((*((_BYTE*)Buf + 278) & 2) != 0)
            {
                v5 = *((unsigned __int8*)Buf + 336);
                if (*((unsigned __int8*)Buf + 337) > v5)
                    v5 = *((unsigned __int8*)Buf + 337);
                if (*((unsigned __int8*)Buf + 338) > v5)
                    v5 = *((unsigned __int8*)Buf + 338);
            }
            else
            {
                v5 = *((unsigned __int8*)Buf + 339);
            }
            v6 = 0;
            if (v5 <= 0)
                v23 = 0;
            else
                v23 = 16 - v5;
            if ((*((_BYTE*)Buf + 97) & 4) != 0 && v23 < 5)
                v23 = 5;
            if (v23 > 8)
                v23 = 8;
            if (v23 < 0)
                v23 = 0;
            v7 = 1 << (8 - v23);
            v21 = 8 - v23;
            Buf[75] = (unsigned __int8)v23;
            if (*((float*)Buf + 77) <= 0.000001)
                v8 = 1.0;
            else
                v8 = 1.0 / (*((float*)Buf + 77) * *((float*)Buf + 76));
            v9 = sub_47D91C(Buf, 4 * v7);
            v10 = (Buf[24] & 0x480) == 0;
            Buf[81] = (int)v9;
            Bufb = 0;
            if (v10)
            {
                if (v7 > 0)
                {
                    do
                    {
                        *(_DWORD*)(Buf[81] + 4 * (_DWORD)Bufb) = sub_47D91C(Buf, 0x200u);
                        v16 = 0;
                        v22 = (unsigned int)((_DWORD)Bufb * dword_4B1560[v23]) >> 4;
                        do
                        {
                            v17 = (__int64)(pow((double)v22 * 0.00001525902189669642, v8) * 65535.0 + 0.5);
                            v22 += 256;
                            *(_WORD*)(v16 + *(_DWORD*)(Buf[81] + 4 * (_DWORD)Bufb)) = v17;
                            v16 += 2;
                        } while (v16 < 512);
                        Bufb = (int*)((char*)Bufb + 1);
                    } while ((int)Bufb < 1 << (8 - v23));
                }
            }
            else
            {
                if (v7 > 0)
                {
                    do
                    {
                        v11 = sub_47D91C(Buf, 0x200u);
                        v12 = Bufb;
                        Bufb = (int*)((char*)Bufb + 1);
                        *(_DWORD*)(Buf[81] + 4 * (_DWORD)v12) = v11;
                    } while ((int)Bufb < v7);
                    v6 = 0;
                }
                Bufc = 0;
                v20 = v7 << 8;
                v18 = (double)(unsigned int)(v7 << 8);
                do
                {
                    v19 = (__int64)(pow(((double)(int)Bufc + 0.5) * 0.00390625, 1.0 / v8) * v18);
                    if (v6 <= v19)
                    {
                        LOBYTE(v13) = 0;
                        HIBYTE(v13) = (_BYTE)Bufc;
                        do
                        {
                            v14 = v6 >> v21;
                            v15 = *(_DWORD*)(Buf[81] + 4 * (v6++ & (255 >> v23)));
                            *(_WORD*)(v15 + 2 * v14) = (unsigned __int16)Bufc | v13;
                        } while (v6 <= v19);
                    }
                    Bufc = (int*)((char*)Bufc + 1);
                } while ((int)Bufc < 256);
                for (; v6 < v20; ++v6)
                    *(_WORD*)(*(_DWORD*)(Buf[81] + 4 * (v6 & (255 >> v23))) + 2 * (v6 >> v21)) = -1;
            }
        }
        else
        {
            if (*((float*)Buf + 77) <= 0.000001)
                v2 = 1.0;
            else
                v2 = 1.0 / (*((float*)Buf + 77) * *((float*)Buf + 76));
            v3 = sub_47D91C(Buf, 0x100u);
            Bufa = 0;
            Buf[78] = (int)v3;
            do
            {
                v4 = (__int64)(pow((double)(int)Bufa * 0.00392156862745098, v2) * 255.0 + 0.5);
                HIDWORD(v4) = Bufa;
                Bufa = (int*)((char*)Bufa + 1);
                *(_BYTE*)(HIDWORD(v4) + Buf[78]) = v4;
            } while ((int)Bufa < 256);
        }
    }
}
// 4B1560: using guessed type _DWORD dword_4B1560[8];

//----- (0047A9FD) --------------------------------------------------------
void __cdecl sub_47A9FD(jmp_buf Buf)
{
    int v2; // edi
    int v3; // ecx
    _BYTE* v4; // eax
    unsigned int v5; // ebx
    unsigned int v6; // eax
    unsigned int v7; // ecx
    unsigned __int16 v8; // cx
    int v9; // eax
    int v10; // edi
    char v11; // [esp+Ch] [ebp-4h]
    char Bufa; // [esp+18h] [ebp+8h]

    v2 = *((unsigned __int8*)Buf + 278);
    if ((Buf[24] & 0x602000) != 0)
    {
        sub_47A6F4(Buf);
        if (v2 == 3)
        {
            v3 = *((unsigned __int16*)Buf + 132);
            if (*((_WORD*)Buf + 132))
            {
                v4 = (_BYTE*)(Buf[65] + 2);
                do
                {
                    *(v4 - 2) = *(_BYTE*)((unsigned __int8)*(v4 - 2) + Buf[78]);
                    *(v4 - 1) = *(_BYTE*)((unsigned __int8)*(v4 - 1) + Buf[78]);
                    *v4 = *(_BYTE*)((unsigned __int8)*v4 + Buf[78]);
                    v4 += 3;
                    --v3;
                } while (v3);
            }
        }
    }
    if ((Buf[24] & 8) != 0 && v2 == 3)
    {
        v5 = 8 - *((unsigned __int8*)Buf + 336);
        v6 = 8 - *((unsigned __int8*)Buf + 337);
        v7 = 8 - *((unsigned __int8*)Buf + 338);
        Bufa = 8 - *((_BYTE*)Buf + 337);
        v11 = 8 - *((_BYTE*)Buf + 338);
        if (v5 > 8)
            LOBYTE(v5) = 0;
        if (v6 > 8)
            Bufa = 0;
        if (v7 > 8)
            v11 = 0;
        v8 = *((_WORD*)Buf + 132);
        if (v8)
        {
            v9 = 0;
            v10 = v8;
            do
            {
                *(_BYTE*)(v9 + Buf[65]) >>= v5;
                *(_BYTE*)(v9 + Buf[65] + 1) >>= Bufa;
                *(_BYTE*)(v9 + Buf[65] + 2) >>= v11;
                v9 += 3;
                --v10;
            } while (v10);
        }
    }
}

//----- (0047AB10) --------------------------------------------------------
void __cdecl sub_47AB10(jmp_buf Buf)
{
    if (!Buf[55])
        sub_478AEB(Buf, (int)"NULL row buffer");
    if ((*((_BYTE*)Buf + 97) & 0x10) != 0)
    {
        if (*((_BYTE*)Buf + 248) == 3)
        {
            sub_47A08C(Buf + 60, Buf[55] + 1, Buf[65], Buf[87], *((unsigned __int16*)Buf + 133));
        }
        else if (*((_WORD*)Buf + 133))
        {
            sub_47A294(Buf + 60, Buf[55] + 1, (_WORD*)Buf + 176);
        }
        else
        {
            sub_47A294(Buf + 60, Buf[55] + 1, 0);
        }
    }
    if ((*((_BYTE*)Buf + 97) & 0x20) != 0 && *((_BYTE*)Buf + 278) != 3)
        sub_479D3E(Buf + 60, (_BYTE*)(Buf[55] + 1), (unsigned __int8*)Buf[78], Buf[81], Buf[75]);
    if ((*((_BYTE*)Buf + 97) & 4) != 0)
        sub_479AC0((int)(Buf + 60), (_BYTE*)(Buf[55] + 1));
    if ((Buf[24] & 0x40) != 0)
    {
        sub_47A5E6(Buf + 60, (char*)(Buf[55] + 1), Buf[93], Buf[94]);
        if (!Buf[61])
            sub_478AEB(Buf, (int)"png_do_dither returned rowbytes=0");
    }
    if ((Buf[24] & 8) != 0)
        sub_479949(Buf + 60, (_BYTE*)(Buf[55] + 1), (unsigned __int8*)Buf + 341);
    if ((Buf[24] & 4) != 0)
        sub_479839(Buf + 60, Buf[55] + 1);
    if ((Buf[24] & 1) != 0)
        sub_479646(Buf + 60, (char*)(Buf[55] + 1));
    if (*((char*)Buf + 97) < 0)
        sub_479B06((int)(Buf + 60), Buf[55] + 1, *((unsigned __int16*)Buf + 143), Buf[23]);
}

//----- (0047ACAF) --------------------------------------------------------
void __cdecl sub_47ACAF(int a1, int a2, double a3)
{
    if (a1)
    {
        if (a2)
        {
            *(_DWORD*)(a2 + 8) |= 1u;
            *(float*)(a2 + 40) = a3;
        }
    }
}

//----- (0047ACCB) --------------------------------------------------------
void __cdecl sub_47ACCB(int a1, int a2, unsigned int a3, int a4, char a5, char a6, char a7, char a8, char a9)
{
    unsigned __int8 v9; // al

    if (a1 && a2)
    {
        *(_BYTE*)(a2 + 26) = a8;
        *(_DWORD*)(a2 + 4) = a4;
        *(_BYTE*)(a2 + 27) = a9;
        *(_DWORD*)a2 = a3;
        *(_BYTE*)(a2 + 24) = a5;
        *(_BYTE*)(a2 + 25) = a6;
        *(_BYTE*)(a2 + 28) = a7;
        if (a6 == 3 || (a6 & 2) == 0)
            *(_BYTE*)(a2 + 29) = 1;
        else
            *(_BYTE*)(a2 + 29) = 3;
        if ((a6 & 4) != 0)
            ++*(_BYTE*)(a2 + 29);
        v9 = a5 * *(_BYTE*)(a2 + 29);
        *(_BYTE*)(a2 + 30) = v9;
        if (a3 <= 0x7FFFFFFFu / ((v9 + 7) >> 3))
        {
            *(_DWORD*)(a2 + 12) = (a3 * v9 + 7) >> 3;
        }
        else
        {
            sub_478B0A(a1, (int)"Width too large to process image data; rowbytes will overflow.");
            *(_DWORD*)(a2 + 12) = 0;
        }
    }
}

//----- (0047AD6C) --------------------------------------------------------
void __cdecl sub_47AD6C(int a1, int a2, int a3, __int16 a4)
{
    if (a1)
    {
        if (a2)
        {
            *(_DWORD*)(a2 + 8) |= 8u;
            *(_DWORD*)(a2 + 16) = a3;
            *(_WORD*)(a2 + 20) = a4;
        }
    }
}

//----- (0047AD90) --------------------------------------------------------
void __cdecl sub_47AD90(int a1, int a2, char a3)
{
    if (a1)
    {
        if (a2)
        {
            *(_BYTE*)(a2 + 9) |= 8u;
            *(_BYTE*)(a2 + 44) = a3;
        }
    }
}

//----- (0047ADAC) --------------------------------------------------------
void __cdecl sub_47ADAC(int a1, int a2, char a3)
{
    if (a1)
    {
        if (a2)
        {
            *(_BYTE*)(a2 + 9) |= 8u;
            *(_BYTE*)(a2 + 44) = a3;
            sub_47ACAF(a1, a2, 0.4545499980449677);
        }
    }
}

//----- (0047ADDF) --------------------------------------------------------
void __cdecl sub_47ADDF(int a1, int a2, int a3, int a4, int a5)
{
    if (a1 && a2)
    {
        if (a3)
            *(_DWORD*)(a2 + 48) = a3;
        if (a5)
        {
            *(_DWORD*)(a2 + 52) = *(_DWORD*)a5;
            *(_DWORD*)(a2 + 56) = *(_DWORD*)(a5 + 4);
            *(_WORD*)(a2 + 60) = *(_WORD*)(a5 + 8);
            if (!a4)
                LOWORD(a4) = 1;
        }
        *(_DWORD*)(a2 + 8) |= 0x10u;
        *(_WORD*)(a2 + 22) = a4;
    }
}

//----- (0047AE26) --------------------------------------------------------
int __cdecl sub_47AE26(jmp_buf Buf, int a2, int a3)
{
    int(__cdecl * v3)(int* __attribute__((__org_typedef(jmp_buf))), int, int); // eax

    v3 = (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, int))Buf[20];
    if (!v3)
        sub_478AEB(Buf, (int)"Call to NULL read function");
    return v3(Buf, a2, a3);
}

//----- (0047AE50) --------------------------------------------------------
int(__cdecl* __cdecl sub_47AE50(_DWORD* a1, int a2, int(__cdecl* a3)(int, int)))(int, int)
{
    bool v3; // zf
    int(__cdecl* result)(int, int); // eax

    v3 = a1[19] == 0;
    a1[21] = a2;
    result = a3;
    a1[20] = a3;
    if (!v3)
    {
        a1[19] = 0;
        sub_478B0A((int)a1, (int)"It's an error to set both read_data_fn and write_data_fn in the ");
        result = sub_478B0A((int)a1, (int)"same structure.  Resetting write_data_fn to NULL.");
    }
    a1[72] = 0;
    return result;
}

//----- (0047AE90) --------------------------------------------------------
int __cdecl sub_47AE90(int a1, unsigned int a2, unsigned int a3)
{
    int v3; // ecx

    v3 = a3;
    if (a3 <= 8)
    {
        if (!a3)
            return 0;
    }
    else
    {
        v3 = 8;
    }
    if (a2 > 7)
        return 0;
    if (a2 + v3 > 8)
        v3 = 8 - a2;
    return memcmp((const char*)(a1 + a2), &byte_49C054[a2], v3);
}

//----- (0047AEDA) --------------------------------------------------------
char* __cdecl sub_47AEDA(jmp_buf Buf, int a2, int a3)
{
    unsigned int v3; // esi
    char* v4; // edx
    char* result; // eax
    void* v6; // edi
    unsigned int v7; // ecx

    v3 = a3 * a2;
    v4 = (char*)sub_47D91C(Buf, a3 * a2);
    result = 0;
    if (v4)
    {
        v6 = v4;
        if (v3 <= 0x8000)
        {
            v7 = a3 * a2;
        }
        else
        {
            memset(v4, 0, 0x8000u);
            v7 = v3 - 0x8000;
            v6 = v4 + 0x8000;
        }
        memset(v6, 0, v7);
        return v4;
    }
    return result;
}

//----- (0047AF2E) --------------------------------------------------------
void __cdecl sub_47AF2E(int a1, LPVOID lpMem)
{
    sub_47D953(a1, lpMem);
}

//----- (0047AF37) --------------------------------------------------------
int __cdecl sub_47AF37(int a1)
{
    int result; // eax

    result = sub_47ECCF(0, 0, 0);
    *(_DWORD*)(a1 + 256) = result;
    return result;
}

//----- (0047AF52) --------------------------------------------------------
int __cdecl sub_47AF52(int a1, _BYTE* a2, unsigned int a3)
{
    int result; // eax

    result = a1;
    if ((*(_BYTE*)(a1 + 268) & 0x20) == 0)
    {
        if ((*(_BYTE*)(a1 + 93) & 8) != 0)
            return result;
        goto LABEL_5;
    }
    if ((*(_DWORD*)(a1 + 92) & 0x300) != 0x300)
    {
    LABEL_5:
        result = sub_47ECCF(*(_DWORD*)(a1 + 256), a2, a3);
        *(_DWORD*)(a1 + 256) = result;
    }
    return result;
}

//----- (0047AF93) --------------------------------------------------------
int __cdecl sub_47AF93(int a1, void* a2)
{
    int result; // eax

    result = 0;
    memset(a2, 0, 0x40u);
    return result;
}

//----- (0047AFA4) --------------------------------------------------------
void* __cdecl sub_47AFA4(int a1)
{
    void* v2; // edx

    if (!a1)
        return 0;
    v2 = sub_47D8C7(2);
    if (v2)
        memset(v2, 0, 0x40u);
    return v2;
}

//----- (0047AFCE) --------------------------------------------------------
__int16 __cdecl sub_47AFCE(_BYTE* a1, int a2)
{
    int i; // eax
    int j; // esi
    int k; // ecx
    int v6; // eax
    int m; // eax

    for (i = 0; i < 16; ++i)
    {
        if (*(int*)&a1[4 * i] >= 0)
            break;
    }
    if (i == 16)
        return sub_47BAF1(a1, a2);
    for (j = 0; ; ++j)
    {
        for (k = 0; k < 16; ++k)
        {
            v6 = *(_DWORD*)&a1[4 * k];
            if (v6 < 0 && (v6 & 0xFFFFFF) == j)
                break;
        }
        if (k == 16)
            break;
    }
    for (m = 0; m < 16; ++m)
    {
        if (*(int*)&a1[4 * m] >= 0)
            *(_DWORD*)&a1[4 * m] = j;
    }
    return sub_47B421(a1, a2, j, j);
}

//----- (0047B039) --------------------------------------------------------
int __cdecl sub_47B039(unsigned __int16* a1, char* a2)
{
    int result; // eax

    sub_47B8BE(a1, a2);
    for (result = 0; result < 16; ++result)
    {
        if (!a2[4 * result + 3])
            *(_DWORD*)&a2[4 * result] = 0;
    }
    return result;
}

//----- (0047B061) --------------------------------------------------------
float* __usercall sub_47B061@<eax>(float* result@<eax>, int a2)
{
    int v2; // ecx
    char* v3; // edx
    int v4; // [esp+4h] [ebp-4h]

    v2 = 0;
    v3 = (char*)((char*)&flt_4B1580 - (char*)result);
    do
    {
        v4 = *(unsigned __int8*)(v2 + a2);
        ++v2;
        *result = (double)v4 * *(float*)((char*)result + (_DWORD)v3) * 0.0039215689;
        ++result;
    } while (v2 < 3);
    return result;
}
// 4B1580: using guessed type float flt_4B1580;

//----- (0047B093) --------------------------------------------------------
_WORD* __usercall sub_47B093@<eax>(_BYTE* a1@<eax>, _WORD* a2)
{
    __int16 v2; // cx
    _WORD* result; // eax

    v2 = (*a1 >> 3) | (32 * ((a1[1] >> 2) | (a1[2] >> 3 << 6)));
    result = a2;
    *a2 = v2;
    return result;
}

//----- (0047B0C6) --------------------------------------------------------
unsigned int __usercall sub_47B0C6@<eax>(unsigned __int16* a1@<eax>, unsigned int* a2)
{
    int v2; // eax
    unsigned __int8 v3; // dl
    char v4; // cl
    unsigned int v5; // eax
    unsigned int result; // eax
    unsigned int v7; // [esp+4h] [ebp-4h]

    v2 = *a1;
    v3 = 8 * v2;
    HIWORD(v7) = HIWORD(v2);
    LOWORD(v7) = (unsigned __int16)v2 >> 5;
    v4 = (unsigned __int16)v2 >> 5;
    v5 = v7;
    LOBYTE(v7) = (v3 >> 5) | v3;
    BYTE1(v7) = ((unsigned __int8)(4 * v4) >> 6) | (4 * v4);
    BYTE2(v7) = ((unsigned __int8)(8 * (v5 >> 6)) >> 5) | (8 * (v5 >> 6));
    result = v7;
    *a2 = v7;
    return result;
}

//----- (0047B113) --------------------------------------------------------
float* __usercall sub_47B113@<eax>(float* result@<eax>, float* a2@<ecx>)
{
    *a2 = *result * *result + result[1] * result[1] + result[2] * result[2];
    a2[1] = (result[4] + *result) * result[1] + result[5] * result[2];
    a2[2] = (result[8] + *result) * result[2] + result[5] * result[1];
    a2[4] = result[5] * result[5] + result[4] * result[4] + result[1] * result[1];
    a2[5] = (result[8] + result[4]) * result[5] + result[2] * result[1];
    a2[8] = result[8] * result[8] + result[5] * result[5] + result[2] * result[2];
    return result;
}

//----- (0047B1B2) --------------------------------------------------------
float* __usercall sub_47B1B2@<eax>(unsigned __int16* a1@<edi>, float* a2, float* a3, int a4)
{
    int v4; // ebx
    int i; // eax
    int v6; // ebx
    int j; // eax
    unsigned __int16 v8; // ax
    unsigned int v10; // [esp+Ch] [ebp-4h] BYREF

    v4 = 0;
    for (i = (char*)a2 - (char*)flt_4B1580; ; i = (char*)a2 - (char*)flt_4B1580)
    {
        *((_BYTE*)&v10 + v4) = (__int64)(*(float*)((char*)&flt_4B1580[v4] + i) / flt_4B1580[v4] * 255.0);
        if (++v4 >= 3)
            break;
    }
    sub_47B093(&v10, a1);
    v6 = 0;
    for (j = (char*)a3 - (char*)flt_4B1580; ; j = (char*)a3 - (char*)flt_4B1580)
    {
        *((_BYTE*)&v10 + v6) = (__int64)(*(float*)((char*)&flt_4B1580[v6] + j) / flt_4B1580[v6] * 255.0);
        if (++v6 >= 3)
            break;
    }
    sub_47B093(&v10, a1 + 1);
    v8 = *a1;
    if ((a4 == 16) != a1[1] < *a1)
    {
        *a1 = a1[1];
        a1[1] = v8;
    }
    sub_47B0C6(a1, &v10);
    sub_47B061(a2, (int)&v10);
    sub_47B0C6(a1 + 1, &v10);
    return sub_47B061(a3, (int)&v10);
}
// 4B1580: using guessed type float flt_4B1580[3];

//----- (0047B28E) --------------------------------------------------------
float* __usercall sub_47B28E@<eax>(float* a1@<edx>, float* a2@<edi>)
{
    int v2; // ebx
    float* v3; // ecx
    double v4; // st5
    float* v5; // eax
    float* v6; // esi
    float* result; // eax
    double v8; // st5
    int v9; // [esp+8h] [ebp-10h]
    char* v10; // [esp+14h] [ebp-4h]

    v2 = (char*)a2 - (char*)a1;
    v10 = (char*)((char*)&flt_4B1580 - (char*)a1);
    v3 = a1;
    v9 = 3;
    do
    {
        if (*v3 < 0.0 != *(float*)((char*)v3 + v2) < 0.0)
        {
            v4 = -(*v3 / (*(float*)((char*)v3 + v2) - *v3));
            if (*v3 >= 0.0)
            {
                v5 = a2;
                v4 = v4 - 1.0;
            }
            else
            {
                v5 = a1;
            }
            v5[2] = (a2[2] - a1[2]) * v4 + v5[2];
            v5[1] = (a2[1] - a1[1]) * v4 + v5[1];
            *v5 = (*a2 - *a1) * v4 + *v5;
        }
        v6 = (float*)((int)v3 + (_DWORD)v10);
        result = (float*)((*v3 > (double)*(float*)((char*)v3 + (_DWORD)v10))
            ^ (*(float*)((char*)v3 + v2) > (double)*(float*)((char*)v3 + (_DWORD)v10)));
        v2 = (char*)a2 - (char*)a1;
        if (result)
        {
            v8 = (*v6 - *v3) / (*(float*)((char*)v3 + (char*)a2 - (char*)a1) - *v3);
            if (*v3 <= (double)*v6)
            {
                result = a2;
                v8 = v8 - 1.0;
            }
            else
            {
                result = a1;
            }
            result[2] = (a2[2] - a1[2]) * v8 + result[2];
            result[1] = (a2[1] - a1[1]) * v8 + result[1];
            *result = (*a2 - *a1) * v8 + *result;
        }
        ++v3;
        --v9;
    } while (v9);
    return result;
}
// 4B1580: using guessed type float flt_4B1580;

//----- (0047B3C0) --------------------------------------------------------
__int16 __usercall sub_47B3C0@<ax>(_BYTE* a1@<edi>, int a2@<esi>, unsigned __int16 a3)
{
    int v3; // eax
    int v4; // ecx
    __int16 v5; // dx
    _WORD* v7; // [esp+0h] [ebp-8h]
    int v8; // [esp+4h] [ebp-4h] BYREF

    v8 = *(_DWORD*)a1;
    sub_47B093(a1, v7);
    *(_WORD*)(a2 + 2) = *(_WORD*)a2;
    v3 = 0;
    *(_DWORD*)(a2 + 4) = 0;
    if (a3 != 0xFFFF)
    {
        v4 = 3;
        v5 = 1;
        do
        {
            if ((a3 & (unsigned __int16)v5) != 0)
                v8 = *(_DWORD*)&a1[4 * v3];
            else
                *(_DWORD*)(a2 + 4) |= v4;
            ++v3;
            v5 *= 2;
            v4 *= 4;
        } while (v3 < 16);
        sub_47B093(&v8, (_WORD*)a2);
        LOWORD(v3) = *(_WORD*)a2;
        *(_WORD*)(a2 + 2) = *(_WORD*)a2;
    }
    return v3;
}
// 47B3CC: variable 'v7' is possibly undefined

//----- (0047B421) --------------------------------------------------------
__int16 __cdecl sub_47B421(_BYTE* a1, int a2, int a3, int a4)
{
    int v4; // eax
    _BYTE* v5; // edi
    _BYTE* v6; // eax
    int v7; // edx
    int v8; // esi
    unsigned __int8 v9; // cl
    unsigned __int8 v10; // cl
    int v11; // ecx
    _BYTE* v12; // eax
    int v13; // esi
    int v14; // esi
    float* v15; // edi
    int v16; // ebx
    int v17; // ecx
    double v18; // st7
    float* v19; // eax
    __int16 v20; // si
    float* v21; // edx
    int v22; // edi
    int i; // ecx
    double v24; // st7
    float* v25; // eax
    int v26; // edx
    float* v27; // esi
    float* v28; // eax
    int v29; // ecx
    float* v30; // edx
    float* v31; // edi
    int j; // ebx
    double v33; // st7
    double v34; // st7
    int v35; // edx
    float* v36; // esi
    float* v37; // ecx
    int v38; // eax
    long double v39; // st7
    int v40; // esi
    int v41; // edx
    float* v42; // ecx
    int v43; // ecx
    float* v44; // eax
    long double v45; // st7
    long double v46; // st6
    int v47; // eax
    double v48; // st7
    double v49; // st6
    __int16 v50; // si
    float* v51; // edx
    int v52; // ebx
    double v53; // st6
    int v54; // eax
    float* v55; // ecx
    double v56; // st5
    double v57; // st5
    double v58; // st6
    int k; // eax
    float* v60; // ecx
    float* v61; // edx
    double v62; // st7
    int m; // eax
    double v64; // st6
    __int16 v65; // ax
    float* v66; // ebx
    double v67; // st3
    float* v68; // edx
    int n; // eax
    float* v70; // ecx
    double v71; // st2
    double v72; // st3
    double v73; // st3
    int v74; // edi
    int v75; // eax
    double v76; // st3
    bool v77; // zf
    _BYTE v79[240]; // [esp+0h] [ebp-1A4h] BYREF
    char v80; // [esp+F0h] [ebp-B4h] BYREF
    float v81[17]; // [esp+100h] [ebp-A4h] BYREF
    float v82[4]; // [esp+144h] [ebp-60h] BYREF
    float v83[4]; // [esp+154h] [ebp-50h] BYREF
    float v84[9]; // [esp+164h] [ebp-40h] BYREF
    int v85; // [esp+188h] [ebp-1Ch]
    int v86; // [esp+18Ch] [ebp-18h]
    float v87; // [esp+190h] [ebp-14h]
    int v88; // [esp+194h] [ebp-10h]
    float v89; // [esp+198h] [ebp-Ch]
    int v90; // [esp+19Ch] [ebp-8h]
    int v91; // [esp+1A0h] [ebp-4h]

    LOWORD(v4) = 0;
    v91 = 0;
    if (!a2)
        return v4;
    v5 = a1;
    v88 = 0;
    v6 = a1 + 61;
    v7 = 16;
    v8 = 1;
    do
    {
        v9 = v6[1];
        v91 *= 2;
        if (BYTE2(a3) > v9
            || v9 > BYTE2(a4)
            || BYTE1(a3) > *v6
            || *v6 > BYTE1(a4)
            || (v10 = *(v6 - 1), (unsigned __int8)a3 > v10)
            || v10 > (unsigned __int8)a4)
        {
            v91 |= 1u;
            ++v88;
        }
        else
        {
            v91 &= 0xFFFEu;
        }
        v6 -= 4;
        --v7;
    } while (v7);
    if (!v88)
    {
        LOWORD(v4) = a2;
        *(_WORD*)a2 = 0;
        *(_WORD*)(a2 + 2) = -1;
        *(_DWORD*)(a2 + 4) = -1;
        return v4;
    }
    v11 = 0;
    v12 = a1 + 2;
    do
    {
        if (v8 && v11 > 0 && (*v12 != *(v12 - 4) || *(v12 - 1) != *(v12 - 5) || *(v12 - 2) != *(v12 - 6)))
            v8 = 0;
        ++v11;
        v12 += 4;
    } while (v11 < 16);
    if (!v8)
    {
        v14 = (int)a1;
        v15 = (float*)v79;
        v16 = 16;
        do
        {
            sub_47B061(v15, v14);
            v15 += 4;
            v14 += 4;
            --v16;
        } while (v16);
        v17 = 0;
        v18 = 1.0 / (double)v88;
        do
        {
            v19 = &v81[v17 + 9];
            v81[v17 + 9] = 0.0;
            v20 = 1;
            v21 = (float*)&v79[v17 * 4];
            v22 = 16;
            do
            {
                if (((unsigned __int16)v91 & (unsigned __int16)v20) != 0)
                    *v19 = *v21 + *v19;
                v20 *= 2;
                v21 += 4;
                --v22;
            } while (v22);
            ++v17;
            *v19 = v18 * *v19;
        } while (v17 < 3);
        for (i = 0; i < 3; ++i)
        {
            v24 = v81[i + 9];
            v25 = (float*)&v79[i * 4];
            v26 = 16;
            do
            {
                *v25 = *v25 - v24;
                v25 += 4;
                --v26;
            } while (v26);
        }
        v85 = 0;
        v87 = COERCE_FLOAT(v84);
        v27 = (float*)v79;
        do
        {
            v28 = (float*)LODWORD(v87);
            v29 = 3 - v85;
            v89 = *(float*)&v27;
            do
            {
                v30 = (float*)LODWORD(v89);
                *v28 = 0.0;
                v90 = 1;
                v31 = v27;
                v86 = 16;
                do
                {
                    if (((unsigned __int16)v91 & (unsigned __int16)v90) != 0)
                        *v28 = *v30 * *v31 + *v28;
                    v90 *= 2;
                    v30 += 4;
                    v31 += 4;
                    --v86;
                } while (v86);
                LODWORD(v89) += 4;
                ++v28;
                --v29;
            } while (v29);
            ++v85;
            LODWORD(v87) += 16;
            ++v27;
        } while (v85 < 3);
        for (j = 0; j < 9; ++j)
        {
            sub_47B113(v84, v81);
            sub_47B113(v81, v84);
            v33 = v84[8] + v84[4] + v84[0];
            if (v33 == 0.0)
                goto LABEL_61;
            v34 = 3.0 / v33;
            v35 = 0;
            v36 = v84;
            do
            {
                v37 = v36;
                v38 = 3 - v35;
                do
                {
                    *v37 = v34 * *v37;
                    ++v37;
                    --v38;
                } while (v38);
                ++v35;
                v36 += 4;
            } while (v35 < 3);
        }
        v39 = 0.0;
        v40 = a2;
        v84[3] = v84[1];
        v84[6] = v84[2];
        v84[7] = v84[5];
        v41 = 0;
        v42 = v84;
        do
        {
            if (v39 < *v42)
            {
                v40 = v41;
                v39 = *v42;
            }
            ++v41;
            v42 += 4;
        } while (v41 < 3);
        v43 = 0;
        v44 = &v84[v40];
        v45 = 1.0 / sqrt(v39);
        do
        {
            ++v43;
            v46 = v45 * *v44;
            v44 += 3;
            v81[v43 + 12] = v46;
        } while (v43 < 3);
        v47 = 0;
        v48 = 0.0;
        do
        {
            v49 = v81[v47++ + 13];
            v48 = v48 + v49 * v49;
        } while (v47 < 3);
        if (v48 == 0.0)
        {
        LABEL_61:
            v13 = a2;
        }
        else
        {
            v50 = 1;
            v89 = -99999.0;
            v87 = 99999.0;
            v51 = (float*)v79;
            v52 = 16;
            do
            {
                if (((unsigned __int16)v91 & (unsigned __int16)v50) != 0)
                {
                    v53 = 0.0;
                    v54 = 0;
                    v55 = v51;
                    do
                    {
                        v56 = v81[v54++ + 13];
                        v57 = v56 * *v55++;
                        v53 = v53 + v57;
                    } while (v54 < 3);
                    v58 = v53 / v48;
                    if (v58 < v87)
                        v87 = v58;
                    if (v58 > v89)
                        v89 = v58;
                }
                v50 *= 2;
                v51 += 4;
                --v52;
            } while (v52);
            for (k = 0; k < 3; v81[k + 16] = v89 * *v60 + *v61)
            {
                v60 = &v81[k + 13];
                v61 = &v81[k + 9];
                v82[++k + 3] = v87 * *v60 + *v61;
            }
            sub_47B28E(v83, v82);
            v13 = a2;
            sub_47B1B2((unsigned __int16*)a2, v83, v82, v88);
            v62 = 0.0;
            for (m = 0; m < 3; v62 = v62 + (v64 - v82[m + 3]) * (v64 - v82[m + 3]))
                v64 = v82[m++];
            if (v62 != 0.0 || v88 != 16)
            {
                v65 = 0x8000;
                v90 = 0x8000;
                v66 = (float*)&v80;
                v86 = 16;
                while (1)
                {
                    if (((unsigned __int16)v91 & (unsigned __int16)v65) != 0)
                    {
                        v67 = 0.0;
                        v68 = v66;
                        for (n = 0; n < 3; v67 = v67 + (v81[n + 16] - *v70) * (v71 - *v70))
                        {
                            v70 = &v83[n];
                            v71 = v81[n + 9] + *v68;
                            ++n;
                            *v68++ = v71;
                        }
                        v72 = v67 / v62;
                        if (v88 == 16)
                        {
                            v73 = v72 * 4.0;
                            if (v73 >= 0.0)
                            {
                                if (v73 >= 4.0)
                                    v73 = 3.0;
                            }
                            else
                            {
                                v73 = 0.0;
                            }
                            *(_DWORD*)(a2 + 4) *= 4;
                            v74 = *(_DWORD*)(a2 + 4);
                            v75 = dword_4B158C[(unsigned int)(__int64)v73];
                        }
                        else
                        {
                            v76 = v72 * 3.0;
                            if (v76 >= 0.0)
                            {
                                if (v76 >= 3.0)
                                    v76 = 2.0;
                            }
                            else
                            {
                                v76 = 0.0;
                            }
                            *(_DWORD*)(a2 + 4) *= 4;
                            v74 = *(_DWORD*)(a2 + 4);
                            v75 = dword_4B159C[(unsigned int)(__int64)v76];
                        }
                        v4 = v74 | v75;
                    }
                    else
                    {
                        v4 = (4 * *(_DWORD*)(a2 + 4)) | 3;
                    }
                    LOWORD(v90) = (unsigned __int16)v90 >> 1;
                    v66 -= 4;
                    v77 = v86-- == 1;
                    *(_DWORD*)(a2 + 4) = v4;
                    if (v77)
                        break;
                    v65 = v90;
                }
                return v4;
            }
        }
        v5 = a1;
        goto LABEL_24;
    }
    v13 = a2;
LABEL_24:
    LOWORD(v4) = sub_47B3C0(v5, v13, v91);
    return v4;
}
// 4B158C: using guessed type int dword_4B158C[4];
// 4B159C: using guessed type int dword_4B159C[4];

//----- (0047B8BE) --------------------------------------------------------
char __cdecl sub_47B8BE(unsigned __int16* a1, char* a2)
{
    unsigned __int16* v2; // esi
    char result; // al
    unsigned __int16 v4; // ax
    char* v5; // ecx
    int v6; // esi
    int v7; // edi
    bool v8; // cc
    int i; // edi
    unsigned __int8* v10; // ecx
    unsigned int v11; // edx
    char* v12; // ecx
    int v13; // ebx
    unsigned int* v14; // esi
    unsigned int v15; // [esp+Ch] [ebp-14h] BYREF
    unsigned int v16; // [esp+10h] [ebp-10h] BYREF
    char v17; // [esp+17h] [ebp-9h]
    char v18; // [esp+1Bh] [ebp-5h]
    int v19; // [esp+1Ch] [ebp-4h]

    v2 = a1;
    if (a1)
    {
        sub_47B0C6(a1, &v15);
        sub_47B0C6(a1 + 1, &v16);
        v4 = *a1;
        v17 = -1;
        HIBYTE(v16) = -1;
        HIBYTE(v15) = -1;
        if (v4 <= a1[1])
        {
            for (i = 0; i < 3; ++i)
            {
                v10 = (unsigned __int8*)&v15 + i;
                v10[8] = (*v10 + v10[4]) / 2;
                v10[12] = 0;
            }
            v18 = 0;
        }
        else
        {
            v19 = 0;
            do
            {
                v5 = (char*)&v16 + v19;
                v6 = *((unsigned __int8*)&v15 + v19);
                v7 = *((unsigned __int8*)&v16 + v19);
                v5[4] = (v7 + 2 * v6 + 1) / 3;
                v8 = ++v19 < 3;
                v5[8] = (v6 + 2 * v7 + 1) / 3;
            } while (v8);
            v18 = -1;
            v2 = a1;
        }
        v11 = *((_DWORD*)v2 + 1);
        v12 = a2;
        v13 = 16;
        do
        {
            v14 = &v15 + (v11 & 3);
            result = *((_BYTE*)&v15 + 4 * (v11 & 3) + 3);
            *(_WORD*)v12 = *(_WORD*)v14;
            v12[2] = *((_BYTE*)v14 + 2);
            v12[3] = result;
            v11 >>= 2;
            v12 += 4;
            --v13;
        } while (v13);
    }
    else
    {
        result = 0;
        memset(a2, 0, 0x40u);
    }
    return result;
}

//----- (0047B9A3) --------------------------------------------------------
int __cdecl sub_47B9A3(int a1, char* a2)
{
    int v3; // esi
    _BYTE* v4; // ecx
    int result; // eax
    int v6; // edx
    char v7; // al
    char v8; // bl
    unsigned __int16 v9; // [esp+14h] [ebp+8h]

    sub_47B8BE((unsigned __int16*)(a1 + 8), a2);
    v3 = 0;
    v4 = a2 + 3;
    do
    {
        result = *(unsigned __int16*)(a1 + 2 * v3);
        v6 = 4;
        v9 = *(_WORD*)(a1 + 2 * v3);
        do
        {
            v7 = v9;
            v9 >>= 4;
            v8 = v7 & 0xF;
            LOBYTE(result) = 16 * v7;
            *v4 = result | v8;
            v4 += 4;
            --v6;
        } while (v6);
        ++v3;
    } while (v3 < 4);
    return result;
}

//----- (0047B9F1) --------------------------------------------------------
int __cdecl sub_47B9F1(unsigned __int16* a1, char* a2)
{
    int v2; // esi
    int v3; // ecx
    unsigned int v4; // ecx
    int result; // eax
    int v6; // ecx
    int v7; // edx
    char v8; // dl
    _DWORD v9[2]; // [esp+Ch] [ebp-24h]
    int v10; // [esp+14h] [ebp-1Ch]
    int v11; // [esp+18h] [ebp-18h]
    int v12; // [esp+1Ch] [ebp-14h]
    int v13; // [esp+20h] [ebp-10h]
    int v14; // [esp+24h] [ebp-Ch]
    int v15; // [esp+28h] [ebp-8h]
    unsigned int v16; // [esp+2Ch] [ebp-4h]

    v16 = 0;
    sub_47B8BE(a1 + 4, a2);
    v2 = *((unsigned __int8*)a1 + 1);
    v3 = *(unsigned __int8*)a1;
    v9[0] = v3;
    v9[1] = v2;
    if (v3 <= v2)
    {
        v15 = 255;
        v10 = (v2 + 4 * v3) / 5;
        v11 = (3 * v3 + 2 * v2) / 5;
        v12 = (3 * v2 + 2 * v3) / 5;
        v14 = 0;
        v13 = (v3 + 4 * v2) / 5;
    }
    else
    {
        v10 = (v2 + 6 * v3) / 7;
        v11 = (5 * v3 + 2 * v2) / 7;
        v12 = (3 * v2 + 4 * v3) / 7;
        v13 = (3 * v3 + 4 * v2) / 7;
        v14 = (5 * v2 + 2 * v3) / 7;
        v15 = (v3 + 6 * v2) / 7;
    }
    v4 = v16;
    for (result = 0; result < 16; ++result)
    {
        if ((result & 7) == 0)
        {
            HIWORD(v6) = 0;
            if (result)
            {
                BYTE1(v6) = *((_BYTE*)a1 + 7);
                v7 = *((unsigned __int8*)a1 + 5);
                LOBYTE(v6) = *((_BYTE*)a1 + 6);
            }
            else
            {
                BYTE1(v6) = *((_BYTE*)a1 + 4);
                v7 = *((unsigned __int8*)a1 + 2);
                LOBYTE(v6) = *((_BYTE*)a1 + 3);
            }
            v4 = v7 | (v6 << 8);
        }
        v8 = v9[v4 & 7];
        v4 >>= 3;
        a2[4 * result + 3] = v8;
    }
    return result;
}

//----- (0047BAF1) --------------------------------------------------------
__int16 __cdecl sub_47BAF1(_BYTE* a1, int a2)
{
    int v3; // [esp+0h] [ebp-8h]
    int v4; // [esp+4h] [ebp-4h]

    LOWORD(v3) = -1;
    BYTE2(v3) = -1;
    LOWORD(v4) = 0;
    BYTE2(v4) = 0;
    return sub_47B421(a1, a2, v3, v4);
}
// 47BB19: variable 'v3' is possibly undefined
// 47BB19: variable 'v4' is possibly undefined

//----- (0047BB23) --------------------------------------------------------
__int16 __cdecl sub_47BB23(_BYTE* a1, _WORD* a2)
{
    _WORD* v2; // eax
    _BYTE* v3; // esi
    _BYTE* v4; // ecx
    int v5; // edx
    __int16 v6; // bx
    int v8; // [esp+Ch] [ebp-4h]

    v2 = a2;
    v3 = a1 + 15;
    v8 = 4;
    do
    {
        v4 = v3;
        v5 = 4;
        do
        {
            *v2 *= 16;
            v6 = *v4 >> 4;
            v4 -= 4;
            --v5;
            *v2 |= v6;
        } while (v5);
        ++v2;
        v3 += 16;
        --v8;
    } while (v8);
    return sub_47BAF1(a1, (int)(a2 + 4));
}

//----- (0047BB7C) --------------------------------------------------------
__int16 __cdecl sub_47BB7C(_BYTE* a1, int a2)
{
    _BYTE* v2; // edx
    unsigned __int8* v3; // esi
    unsigned __int8 v4; // al
    unsigned __int8 v5; // cl
    unsigned __int8* v6; // edi
    int v7; // edi
    unsigned __int8 v8; // bl
    int v10; // ecx
    int v11; // ebx
    char v12; // al
    int v13; // eax
    unsigned int v14; // eax
    int v16; // [esp+Ch] [ebp-Ch]
    int v17; // [esp+10h] [ebp-8h]
    int v18; // [esp+10h] [ebp-8h]
    unsigned int v19; // [esp+14h] [ebp-4h]
    int v20; // [esp+24h] [ebp+Ch]

    v2 = a1;
    v19 = 0;
    v3 = a1 + 3;
    v4 = a1[3];
    v5 = v4;
    v6 = a1 + 7;
    v17 = 15;
    do
    {
        if (*v6 > v5)
            v5 = *v6;
        if (*v6 < v4)
            v4 = *v6;
        v6 += 4;
        --v17;
    } while (v17);
    if (v5 != 0xFF || v4)
    {
        v18 = 0;
    }
    else
    {
        v7 = 16;
        do
        {
            v8 = *v3;
            if (*v3 < v5 && v8)
                v5 = *v3;
            if (v8 > v4 && v8 != 0xFF)
                v4 = *v3;
            v3 += 4;
            --v7;
        } while (v7);
        if (v5 >= v4)
        {
            v18 = 0;
            v5 = -1;
            v4 = 0;
        }
        else
        {
            v18 = 1;
        }
    }
    *(_BYTE*)a2 = v5;
    *(_BYTE*)(a2 + 1) = v4;
    if (v5 != v4)
    {
        v16 = v5;
        v10 = v5 - v4;
        v11 = 15;
        v20 = 2 * (v18 == 0) + 5;
        while (1)
        {
            v19 *= 8;
            if (!v18)
                break;
            v12 = v2[4 * v11 + 3];
            if (v12)
            {
                if (v12 != -1)
                    break;
                v19 |= 7u;
            }
            else
            {
                v19 |= 6u;
            }
        LABEL_33:
            if ((v11 & 7) == 0)
            {
                if (v11 == 8)
                {
                    *(_WORD*)(a2 + 5) = v19;
                    v14 = HIWORD(v19);
                    *(_BYTE*)(a2 + 7) = BYTE2(v19);
                }
                else
                {
                    *(_WORD*)(a2 + 2) = v19;
                    v14 = HIWORD(v19);
                    *(_BYTE*)(a2 + 4) = BYTE2(v19);
                }
                v19 = v14;
            }
            if (--v11 < 0)
                return sub_47BAF1(v2, a2 + 8);
        }
        v13 = ((v10 >> 1) + v20 * (v16 - (unsigned __int8)v2[4 * v11 + 3])) / v10;
        if (v13 < v20)
        {
            if (v13 > 0)
                v19 |= v13 + 1;
        }
        else
        {
            v19 |= 1u;
        }
        v2 = a1;
        goto LABEL_33;
    }
    *(_BYTE*)(a2 + 7) = 0;
    *(_BYTE*)(a2 + 6) = 0;
    *(_BYTE*)(a2 + 5) = 0;
    *(_BYTE*)(a2 + 4) = 0;
    *(_BYTE*)(a2 + 3) = 0;
    *(_BYTE*)(a2 + 2) = 0;
    return sub_47BAF1(v2, a2 + 8);
}

//----- (0047BCD2) --------------------------------------------------------
int __cdecl sub_47BCD2(int a1, int a2)
{
    return (a1 + a2 - 1) / a2;
}

//----- (0047BCE4) --------------------------------------------------------
int __cdecl sub_47BCE4(int a1, int a2)
{
    return a1 + a2 - 1 - (a1 + a2 - 1) % a2;
}

//----- (0047BCFE) --------------------------------------------------------
const void** __cdecl sub_47BCFE(int a1, int a2, int a3, int a4, int a5, unsigned int a6)
{
    const void** result; // eax
    void** v7; // edx
    int v8; // [esp+Ch] [ebp+Ch]

    result = (const void**)(a1 + 4 * a2);
    v7 = (void**)(a3 + 4 * a4);
    if (a5 > 0)
    {
        v8 = a5;
        do
        {
            qmemcpy(*v7++, *result++, a6);
            --v8;
        } while (v8);
    }
    return result;
}

//----- (0047BD45) --------------------------------------------------------
int __cdecl sub_47BD45(const void* a1, void* a2, int a3)
{
    int result; // eax

    result = a3 << 7;
    qmemcpy(a2, a1, 4 * ((unsigned int)(a3 << 7) >> 2));
    return result;
}

//----- (0047BD68) --------------------------------------------------------
int __cdecl sub_47BD68(void* a1, unsigned int a2)
{
    int result; // eax

    result = 0;
    memset(a1, 0, a2);
    return result;
}

//----- (0047BD85) --------------------------------------------------------
unsigned int sub_47BD85()
{
    unsigned int v0; // kr00_4
    unsigned int v1; // kr04_4
    int v2; // edx

    v0 = __readeflags();
    __writeeflags(v0 ^ 0x200000);
    v1 = __readeflags();
    v2 = v0 ^ v1;
    if (v0 != v1)
    {
        _EAX = 1;
        __asm { cpuid }
        return (_EDX & 0x800000u) >> 23;
    }
    return v2;
}

//----- (0047BDB7) --------------------------------------------------------
int __usercall sub_47BDB7@<eax>(int a1@<esi>)
{
    int v1; // ebx
    bool v2; // cc
    int v3; // edi
    int* v4; // edi
    int v5; // eax
    int v6; // eax
    int v7; // eax
    int v8; // eax
    int v9; // ebx
    int v10; // edi
    int v11; // eax
    int result; // eax

    if (*(int*)(a1 + 28) > 65500 || *(int*)(a1 + 24) > 65500)
    {
        *(_DWORD*)(*(_DWORD*)a1 + 20) = 40;
        *(_DWORD*)(*(_DWORD*)a1 + 24) = 65500;
        (**(void(__cdecl***)(int))a1)(a1);
    }
    if (*(_DWORD*)(a1 + 192) != 8)
    {
        *(_DWORD*)(*(_DWORD*)a1 + 20) = 13;
        *(_DWORD*)(*(_DWORD*)a1 + 24) = *(_DWORD*)(a1 + 192);
        (**(void(__cdecl***)(int))a1)(a1);
    }
    if (*(int*)(a1 + 32) > 10)
    {
        *(_DWORD*)(*(_DWORD*)a1 + 20) = 24;
        *(_DWORD*)(*(_DWORD*)a1 + 24) = *(_DWORD*)(a1 + 32);
        *(_DWORD*)(*(_DWORD*)a1 + 28) = 10;
        (**(void(__cdecl***)(int))a1)(a1);
    }
    v1 = 0;
    v2 = *(_DWORD*)(a1 + 32) <= 0;
    v3 = *(_DWORD*)(a1 + 196);
    *(_DWORD*)(a1 + 268) = 1;
    *(_DWORD*)(a1 + 272) = 1;
    if (!v2)
    {
        v4 = (int*)(v3 + 12);
        do
        {
            v5 = *(v4 - 1);
            if (v5 <= 0 || v5 > 4 || *v4 <= 0 || *v4 > 4)
            {
                *(_DWORD*)(*(_DWORD*)a1 + 20) = 16;
                (**(void(__cdecl***)(int))a1)(a1);
            }
            v6 = *(_DWORD*)(a1 + 268);
            if (v6 <= *(v4 - 1))
                v6 = *(v4 - 1);
            *(_DWORD*)(a1 + 268) = v6;
            v7 = *(_DWORD*)(a1 + 272);
            if (v7 <= *v4)
                v7 = *v4;
            ++v1;
            *(_DWORD*)(a1 + 272) = v7;
            v4 += 21;
        } while (v1 < *(_DWORD*)(a1 + 32));
    }
    v8 = *(_DWORD*)(a1 + 196);
    v9 = 0;
    v2 = *(_DWORD*)(a1 + 32) <= 0;
    *(_DWORD*)(a1 + 276) = 8;
    if (!v2)
    {
        v10 = v8 + 28;
        do
        {
            *(_DWORD*)(v10 + 8) = 8;
            *(_DWORD*)v10 = sub_47BCD2(*(_DWORD*)(a1 + 24) * *(_DWORD*)(v10 - 20), 8 * *(_DWORD*)(a1 + 268));
            *(_DWORD*)(v10 + 4) = sub_47BCD2(*(_DWORD*)(a1 + 28) * *(_DWORD*)(v10 - 16), 8 * *(_DWORD*)(a1 + 272));
            *(_DWORD*)(v10 + 12) = sub_47BCD2(*(_DWORD*)(a1 + 24) * *(_DWORD*)(v10 - 20), *(_DWORD*)(a1 + 268));
            v11 = sub_47BCD2(*(_DWORD*)(a1 + 28) * *(_DWORD*)(v10 - 16), *(_DWORD*)(a1 + 272));
            *(_DWORD*)(v10 + 48) = 0;
            *(_DWORD*)(v10 + 16) = v11;
            *(_BYTE*)(v10 + 20) = 1;
            ++v9;
            v10 += 84;
        } while (v9 < *(_DWORD*)(a1 + 32));
    }
    *(_DWORD*)(a1 + 280) = sub_47BCD2(*(_DWORD*)(a1 + 28), 8 * *(_DWORD*)(a1 + 272));
    if (*(_DWORD*)(a1 + 288) < *(_DWORD*)(a1 + 32) || *(_BYTE*)(a1 + 200))
    {
        result = *(_DWORD*)(a1 + 396);
        *(_BYTE*)(result + 16) = 1;
    }
    else
    {
        result = *(_DWORD*)(a1 + 396);
        *(_BYTE*)(result + 16) = 0;
    }
    return result;
}

//----- (0047BF72) --------------------------------------------------------
int __usercall sub_47BF72@<eax>(int* a1@<esi>)
{
    int v1; // eax
    _DWORD* v2; // ecx
    unsigned int v3; // ebx
    int result; // eax
    int v5; // edx
    bool v6; // cc
    _DWORD* v7; // ecx
    unsigned int v8; // ebx
    int v9; // edi
    int v10; // edx
    int v11; // edi
    unsigned int v12; // eax
    unsigned int v13; // ebx
    int v14; // edx
    int* v15; // [esp+8h] [ebp-8h]
    int v16; // [esp+Ch] [ebp-4h]

    v1 = a1[72];
    if (v1 == 1)
    {
        v2 = (_DWORD*)a1[73];
        a1[77] = v2[7];
        a1[78] = v2[8];
        v3 = v2[3];
        v2[16] = v2[9];
        result = v2[8] / v3;
        v5 = v2[8] % v3;
        v2[13] = 1;
        v2[14] = 1;
        v2[15] = 1;
        v2[17] = 1;
        if (!v5)
            v5 = v3;
        v2[18] = v5;
        a1[80] = 0;
        a1[79] = 1;
    }
    else
    {
        if (v1 <= 0 || v1 > 4)
        {
            *(_DWORD*)(*a1 + 20) = 24;
            *(_DWORD*)(*a1 + 24) = a1[72];
            *(_DWORD*)(*a1 + 28) = 4;
            (*(void(__cdecl**)(int*)) * a1)(a1);
        }
        a1[77] = sub_47BCD2(a1[6], 8 * a1[67]);
        result = sub_47BCD2(a1[7], 8 * a1[68]);
        v6 = a1[72] <= 0;
        a1[78] = result;
        a1[79] = 0;
        v16 = 0;
        if (!v6)
        {
            v15 = a1 + 73;
            do
            {
                v7 = (_DWORD*)*v15;
                v8 = *(_DWORD*)(*v15 + 8);
                v9 = *(_DWORD*)(*v15 + 12);
                v7[16] = v8 * *(_DWORD*)(*v15 + 36);
                v10 = v7[7] % v8;
                v7[14] = v9;
                v11 = v8 * v9;
                v7[13] = v8;
                v7[15] = v11;
                if (!v10)
                    v10 = v8;
                v12 = v7[8];
                v13 = v7[3];
                v7[17] = v10;
                v14 = v12 % v13;
                if (!(v12 % v13))
                    v14 = v13;
                v7[18] = v14;
                if (v11 + a1[79] > 10)
                {
                    *(_DWORD*)(*a1 + 20) = 11;
                    (*(void(__cdecl**)(int*)) * a1)(a1);
                }
                if (v11 > 0)
                {
                    do
                    {
                        a1[a1[79]++ + 80] = v16;
                        --v11;
                    } while (v11);
                }
                result = ++v16;
                ++v15;
            } while (v16 < a1[72]);
        }
    }
    return result;
}

//----- (0047C0E8) --------------------------------------------------------
void __usercall sub_47C0E8(int a1@<ebx>)
{
    unsigned int v1; // esi
    void* v2; // eax
    int v3; // [esp+0h] [ebp-Ch]
    int v4; // [esp+4h] [ebp-8h]
    int* v5; // [esp+8h] [ebp-4h]

    v4 = 0;
    if (*(int*)(a1 + 288) > 0)
    {
        v5 = (int*)(a1 + 292);
        do
        {
            v3 = *v5;
            if (!*(_DWORD*)(*v5 + 76))
            {
                v1 = *(_DWORD*)(*v5 + 16);
                if (v1 >= 4 || !*(_DWORD*)(a1 + 4 * v1 + 144))
                {
                    *(_DWORD*)(*(_DWORD*)a1 + 20) = 51;
                    *(_DWORD*)(*(_DWORD*)a1 + 24) = v1;
                    (**(void(__cdecl***)(int))a1)(a1);
                }
                v2 = (void*)(**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 130);
                qmemcpy(v2, *(const void**)(a1 + 4 * v1 + 144), 0x82u);
                *(_DWORD*)(v3 + 76) = v2;
            }
            ++v4;
            ++v5;
        } while (v4 < *(_DWORD*)(a1 + 288));
    }
}

//----- (0047C17A) --------------------------------------------------------
int __cdecl sub_47C17A(int a1)
{
    int result; // eax

    sub_47BF72((int*)a1);
    sub_47C0E8(a1);
    (**(void(__cdecl***)(int))(a1 + 404))(a1);
    (**(void(__cdecl***)(int))(a1 + 388))(a1);
    result = *(_DWORD*)(*(_DWORD*)(a1 + 388) + 4);
    **(_DWORD**)(a1 + 396) = result;
    return result;
}

//----- (0047C1B7) --------------------------------------------------------
int __cdecl sub_47C1B7(_DWORD* a1)
{
    _BYTE* v2; // edi
    bool v4; // zf
    _DWORD* v5; // eax
    int v6; // esi
    int v7; // [esp+14h] [ebp+8h]

    v2 = (_BYTE*)a1[99];
    if (v2[17])
        return 2;
    v7 = (*(int(__cdecl**)(_DWORD*))(a1[100] + 4))(a1);
    if (v7 == 1)
    {
        if (v2[20])
        {
            sub_47BDB7((int)a1);
            v2[20] = 0;
        }
        else
        {
            if (!v2[16])
            {
                *(_DWORD*)(*a1 + 20) = 34;
                (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
            }
            sub_47C17A((int)a1);
        }
    }
    else if (v7 == 2)
    {
        v4 = v2[20] == 0;
        v2[17] = 1;
        if (v4)
        {
            v5 = a1 + 33;
            v6 = a1[31];
            if (*v5 > v6)
                *v5 = v6;
        }
        else if (*(_BYTE*)(a1[100] + 81))
        {
            *(_DWORD*)(*a1 + 20) = 58;
            (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
        }
    }
    return v7;
}

//----- (0047C24D) --------------------------------------------------------
int __cdecl sub_47C24D(int a1)
{
    int v1; // eax
    int result; // eax

    v1 = *(_DWORD*)(a1 + 396);
    *(_BYTE*)(v1 + 16) = 0;
    *(_BYTE*)(v1 + 17) = 0;
    *(_DWORD*)v1 = sub_47C1B7;
    *(_BYTE*)(v1 + 20) = 1;
    (*(void(__cdecl**)(int))(*(_DWORD*)a1 + 16))(a1);
    result = (**(int(__cdecl***)(int))(a1 + 400))(a1);
    *(_DWORD*)(a1 + 140) = 0;
    return result;
}

//----- (0047C287) --------------------------------------------------------
_DWORD* __cdecl sub_47C287(int a1)
{
    _DWORD* result; // eax

    result = *(_DWORD**)(a1 + 396);
    *result = sub_47C1B7;
    return result;
}

//----- (0047C29B) --------------------------------------------------------
int __cdecl sub_47C29B(int a1)
{
    int result; // eax

    result = (**(int(__cdecl***)(int, _DWORD, int))(a1 + 4))(a1, 0, 24);
    *(_DWORD*)(a1 + 396) = result;
    *(_BYTE*)(result + 16) = 0;
    *(_BYTE*)(result + 17) = 0;
    *(_DWORD*)result = sub_47C1B7;
    *(_DWORD*)(result + 4) = sub_47C24D;
    *(_DWORD*)(result + 8) = sub_47C17A;
    *(_DWORD*)(result + 12) = sub_47C287;
    *(_BYTE*)(result + 20) = 1;
    return result;
}

//----- (0047C2DF) --------------------------------------------------------
int __cdecl sub_47C2DF(_DWORD* a1, unsigned int a2, unsigned int a3)
{
    unsigned int v4; // edi
    _DWORD* v6; // eax
    unsigned int v7; // edi
    unsigned int v8; // esi
    _DWORD* v9; // ecx
    int v10; // ecx
    int v12; // [esp+Ch] [ebp-4h]
    int v13; // [esp+18h] [ebp+8h]
    _DWORD* v14; // [esp+1Ch] [ebp+Ch]

    v4 = a3;
    v12 = a1[1];
    if (a3 > 0x3B9AC9F0)
    {
        *(_DWORD*)(*a1 + 20) = 53;
        *(_DWORD*)(*a1 + 24) = 1;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    if ((a3 & 7) != 0)
    {
        v4 = 8 - (a3 & 7) + a3;
        a3 = v4;
    }
    if (a2 >= 2)
    {
        *(_DWORD*)(*a1 + 20) = 12;
        *(_DWORD*)(*a1 + 24) = a2;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    v13 = 0;
    v14 = (_DWORD*)(v12 + 4 * a2 + 48);
    v6 = (_DWORD*)*v14;
    if (!*v14)
        goto LABEL_11;
    do
    {
        if (v6[2] >= v4)
            break;
        v13 = (int)v6;
        v6 = (_DWORD*)*v6;
    } while (v6);
    if (!v6)
    {
    LABEL_11:
        v7 = v4 + 16;
        if (v13)
            v8 = dword_49C2A8[a2];
        else
            v8 = dword_49C2A0[a2];
        if (v8 > 1000000000 - v7)
            v8 = 1000000000 - v7;
        while (1)
        {
            v6 = sub_47EDD8((int)a1, v8 + v7);
            if (v6)
                break;
            v8 >>= 1;
            if (v8 < 0x32)
            {
                *(_DWORD*)(*a1 + 20) = 53;
                *(_DWORD*)(*a1 + 24) = 2;
                (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
            }
        }
        *(_DWORD*)(v12 + 72) += v8 + v7;
        *v6 = 0;
        v6[1] = 0;
        v4 = a3;
        v9 = (_DWORD*)v13;
        v6[2] = a3 + v8;
        if (!v13)
            v9 = v14;
        *v9 = v6;
    }
    v10 = v6[1];
    v6[2] -= v4;
    v6[1] = v4 + v10;
    return (int)v6 + v10 + 16;
}
// 49C2A0: using guessed type int dword_49C2A0[];
// 49C2A8: using guessed type int dword_49C2A8[];

//----- (0047C3FD) --------------------------------------------------------
_DWORD* __cdecl sub_47C3FD(_DWORD* a1, unsigned int a2, unsigned int a3)
{
    int v3; // ebx
    _DWORD* v4; // esi
    int* v5; // eax
    int v6; // edx

    v3 = a1[1];
    if (a3 > 0x3B9AC9F0)
    {
        *(_DWORD*)(*a1 + 20) = 53;
        *(_DWORD*)(*a1 + 24) = 3;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    if ((a3 & 7) != 0)
        a3 += 8 - (a3 & 7);
    if (a2 >= 2)
    {
        *(_DWORD*)(*a1 + 20) = 12;
        *(_DWORD*)(*a1 + 24) = a2;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    v4 = sub_47EDD8((int)a1, a3 + 16);
    if (!v4)
    {
        *(_DWORD*)(*a1 + 20) = 53;
        *(_DWORD*)(*a1 + 24) = 4;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    *(_DWORD*)(v3 + 72) += a3 + 16;
    v5 = (int*)(v3 + 4 * a2 + 56);
    v6 = *v5;
    v4[2] = 0;
    *v4 = v6;
    v4[1] = a3;
    *v5 = (int)v4;
    return v4 + 4;
}

//----- (0047C4AC) --------------------------------------------------------
int __cdecl sub_47C4AC(_DWORD* a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
    int v4; // edi
    unsigned int v5; // esi
    unsigned int v7; // edi
    _DWORD* v8; // eax
    unsigned int v9; // ecx
    int v11; // [esp+20h] [ebp+14h]

    v4 = a1[1];
    v5 = 0x3B9AC9F0 / a3;
    if ((int)(0x3B9AC9F0 / a3) <= 0)
    {
        *(_DWORD*)(*a1 + 20) = 69;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    if ((int)v5 >= (int)a4)
        v5 = a4;
    *(_DWORD*)(v4 + 76) = v5;
    v7 = 0;
    v11 = sub_47C2DF(a1, a2, 4 * a4);
    while (v7 < a4)
    {
        if (v5 >= a4 - v7)
            v5 = a4 - v7;
        v8 = sub_47C3FD(a1, a2, a3 * v5);
        if (v5)
        {
            v9 = v5;
            do
            {
                *(_DWORD*)(v11 + 4 * v7) = v8;
                v8 = (_DWORD*)((char*)v8 + a3);
                ++v7;
                --v9;
            } while (v9);
        }
    }
    return v11;
}

//----- (0047C53E) --------------------------------------------------------
int __cdecl sub_47C53E(_DWORD* a1, unsigned int a2, int a3, signed int a4)
{
    int v4; // edi
    signed int v5; // esi
    unsigned int v7; // edi
    _DWORD* v8; // eax
    signed int v9; // ecx
    int v11; // [esp+24h] [ebp+14h]

    v4 = a1[1];
    v5 = 0x3B9AC9F0u / (a3 << 7);
    if (v5 <= 0)
    {
        *(_DWORD*)(*a1 + 20) = 69;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    if (v5 >= a4)
        v5 = a4;
    *(_DWORD*)(v4 + 76) = v5;
    v7 = 0;
    v11 = sub_47C2DF(a1, a2, 4 * a4);
    while (v7 < a4)
    {
        if (v5 >= a4 - v7)
            v5 = a4 - v7;
        v8 = sub_47C3FD(a1, a2, (a3 * v5) << 7);
        if (v5)
        {
            v9 = v5;
            do
            {
                *(_DWORD*)(v11 + 4 * v7) = v8;
                v8 += 32 * a3;
                ++v7;
                --v9;
            } while (v9);
        }
    }
    return v11;
}

//----- (0047C5DC) --------------------------------------------------------
int __cdecl sub_47C5DC(_DWORD* a1, unsigned int a2, char a3, int a4, int a5, int a6)
{
    int v6; // esi
    int result; // eax

    v6 = a1[1];
    if (a2 != 1)
    {
        *(_DWORD*)(*a1 + 20) = 12;
        *(_DWORD*)(*a1 + 24) = a2;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    result = sub_47C2DF(a1, a2, 0x78u);
    *(_DWORD*)result = 0;
    *(_DWORD*)(result + 4) = a5;
    *(_DWORD*)(result + 8) = a4;
    *(_DWORD*)(result + 12) = a6;
    *(_BYTE*)(result + 34) = 0;
    *(_BYTE*)(result + 32) = a3;
    *(_DWORD*)(result + 36) = *(_DWORD*)(v6 + 64);
    *(_DWORD*)(v6 + 64) = result;
    return result;
}

//----- (0047C63D) --------------------------------------------------------
int __cdecl sub_47C63D(_DWORD* a1, unsigned int a2, char a3, int a4, int a5, int a6)
{
    int v6; // esi
    int result; // eax

    v6 = a1[1];
    if (a2 != 1)
    {
        *(_DWORD*)(*a1 + 20) = 12;
        *(_DWORD*)(*a1 + 24) = a2;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    result = sub_47C2DF(a1, a2, 0x78u);
    *(_DWORD*)result = 0;
    *(_DWORD*)(result + 4) = a5;
    *(_DWORD*)(result + 8) = a4;
    *(_DWORD*)(result + 12) = a6;
    *(_BYTE*)(result + 34) = 0;
    *(_BYTE*)(result + 32) = a3;
    *(_DWORD*)(result + 36) = *(_DWORD*)(v6 + 68);
    *(_DWORD*)(v6 + 68) = result;
    return result;
}

//----- (0047C69E) --------------------------------------------------------
int __cdecl sub_47C69E(_DWORD* a1)
{
    _DWORD* v1; // edi
    _DWORD* v2; // eax
    int v3; // esi
    int v4; // ebx
    int v5; // ecx
    int result; // eax
    int v7; // ecx
    int i; // esi
    int v9; // ebx
    unsigned int v10; // ecx
    int j; // esi
    int v12; // ebx
    unsigned int v13; // ecx
    signed int v14; // [esp+Ch] [ebp-4h]

    v1 = (_DWORD*)a1[1];
    v2 = (_DWORD*)v1[16];
    v3 = 0;
    v4 = 0;
    while (v2)
    {
        if (!*v2)
        {
            v5 = v2[2];
            v3 += v5 * v2[3];
            v4 += v5 * v2[1];
        }
        v2 = (_DWORD*)v2[9];
    }
    for (result = v1[17]; result; result = *(_DWORD*)(result + 36))
    {
        if (!*(_DWORD*)result)
        {
            v7 = *(_DWORD*)(result + 8);
            v3 += (v7 * *(_DWORD*)(result + 12)) << 7;
            v4 += (v7 * *(_DWORD*)(result + 4)) << 7;
        }
    }
    if (v3 > 0)
    {
        result = ((int(__cdecl*)(_DWORD*, int, int, _DWORD))std::_Unchecked<std::_Vector_val<std::_Simple_types<void*>>>)(
            a1,
            v3,
            v4,
            v1[18]);
        if (result < v4)
        {
            result /= v3;
            v14 = result;
            if (result <= 0)
                v14 = 1;
        }
        else
        {
            v14 = 1000000000;
        }
        for (i = v1[16]; i; i = *(_DWORD*)(i + 36))
        {
            if (!*(_DWORD*)i)
            {
                v9 = *(_DWORD*)(i + 4);
                v10 = *(_DWORD*)(i + 12);
                if ((int)((v9 - 1) / v10 + 1) > v14)
                {
                    *(_DWORD*)(i + 16) = v14 * v10;
                    sub_47EDFC((int)a1);
                    *(_BYTE*)(i + 34) = 1;
                }
                else
                {
                    *(_DWORD*)(i + 16) = v9;
                }
                *(_DWORD*)i = sub_47C4AC(a1, 1u, *(_DWORD*)(i + 8), *(_DWORD*)(i + 16));
                result = v1[19];
                *(_DWORD*)(i + 24) = 0;
                *(_DWORD*)(i + 28) = 0;
                *(_BYTE*)(i + 33) = 0;
                *(_DWORD*)(i + 20) = result;
            }
        }
        for (j = v1[17]; j; j = *(_DWORD*)(j + 36))
        {
            if (!*(_DWORD*)j)
            {
                v12 = *(_DWORD*)(j + 4);
                v13 = *(_DWORD*)(j + 12);
                if ((int)((v12 - 1) / v13 + 1) > v14)
                {
                    *(_DWORD*)(j + 16) = v14 * v13;
                    sub_47EDFC((int)a1);
                    *(_BYTE*)(j + 34) = 1;
                }
                else
                {
                    *(_DWORD*)(j + 16) = v12;
                }
                *(_DWORD*)j = sub_47C53E(a1, 1u, *(_DWORD*)(j + 8), *(_DWORD*)(j + 16));
                result = v1[19];
                *(_DWORD*)(j + 24) = 0;
                *(_DWORD*)(j + 28) = 0;
                *(_BYTE*)(j + 33) = 0;
                *(_DWORD*)(j + 20) = result;
            }
        }
    }
    return result;
}
// 47EDF4: using guessed type int std::_Unchecked<std::_Vector_val<std::_Simple_types<void *>>>();

//----- (0047C81D) --------------------------------------------------------
int __usercall sub_47C81D@<eax>(int a1@<esi>, int a2, char a3)
{
    int v3; // ebx
    int result; // eax
    int i; // edi
    int v6; // ecx
    int v7; // [esp-4h] [ebp-14h]
    int v8; // [esp+8h] [ebp-8h]
    int v9; // [esp+Ch] [ebp-4h]

    v3 = *(_DWORD*)(a1 + 8) * *(_DWORD*)(a1 + 24);
    v8 = *(_DWORD*)(a1 + 8);
    result = *(_DWORD*)(a1 + 16);
    for (i = 0; i < result; v3 += v9)
    {
        result -= i;
        if (*(_DWORD*)(a1 + 20) < result)
            result = *(_DWORD*)(a1 + 20);
        v6 = i + *(_DWORD*)(a1 + 24);
        if (result >= *(_DWORD*)(a1 + 28) - v6)
            result = *(_DWORD*)(a1 + 28) - v6;
        if (result >= *(_DWORD*)(a1 + 4) - v6)
            result = *(_DWORD*)(a1 + 4) - v6;
        if (result <= 0)
            break;
        v7 = v8 * result;
        v9 = v8 * result;
        if (a3)
            (*(void(__cdecl**)(int, int, _DWORD, int, int))(a1 + 44))(
                a2,
                a1 + 40,
                *(_DWORD*)(*(_DWORD*)a1 + 4 * i),
                v3,
                v7);
        else
            (*(void(__cdecl**)(int, int, _DWORD, int, int))(a1 + 40))(
                a2,
                a1 + 40,
                *(_DWORD*)(*(_DWORD*)a1 + 4 * i),
                v3,
                v7);
        i += *(_DWORD*)(a1 + 20);
        result = *(_DWORD*)(a1 + 16);
    }
    return result;
}

//----- (0047C8A5) --------------------------------------------------------
int __usercall sub_47C8A5@<eax>(int a1@<esi>, int a2, char a3)
{
    int v3; // ebx
    int result; // eax
    int i; // edi
    int v6; // ecx
    int v7; // [esp-4h] [ebp-14h]
    int v8; // [esp+8h] [ebp-8h]
    int v9; // [esp+Ch] [ebp-4h]

    v3 = (*(_DWORD*)(a1 + 8) << 7) * *(_DWORD*)(a1 + 24);
    v8 = *(_DWORD*)(a1 + 8) << 7;
    result = *(_DWORD*)(a1 + 16);
    for (i = 0; i < result; v3 += v9)
    {
        result -= i;
        if (*(_DWORD*)(a1 + 20) < result)
            result = *(_DWORD*)(a1 + 20);
        v6 = i + *(_DWORD*)(a1 + 24);
        if (result >= *(_DWORD*)(a1 + 28) - v6)
            result = *(_DWORD*)(a1 + 28) - v6;
        if (result >= *(_DWORD*)(a1 + 4) - v6)
            result = *(_DWORD*)(a1 + 4) - v6;
        if (result <= 0)
            break;
        v7 = v8 * result;
        v9 = v8 * result;
        if (a3)
            (*(void(__cdecl**)(int, int, _DWORD, int, int))(a1 + 44))(
                a2,
                a1 + 40,
                *(_DWORD*)(*(_DWORD*)a1 + 4 * i),
                v3,
                v7);
        else
            (*(void(__cdecl**)(int, int, _DWORD, int, int))(a1 + 40))(
                a2,
                a1 + 40,
                *(_DWORD*)(*(_DWORD*)a1 + 4 * i),
                v3,
                v7);
        i += *(_DWORD*)(a1 + 20);
        result = *(_DWORD*)(a1 + 16);
    }
    return result;
}

//----- (0047C930) --------------------------------------------------------
int __cdecl sub_47C930(int a1, int a2, unsigned int a3, unsigned int a4, char a5)
{
    unsigned int v5; // ebx
    int v6; // edi
    unsigned int v7; // eax
    int v8; // eax
    unsigned int v9; // eax
    unsigned int v10; // edi
    int v11; // eax
    unsigned int v12; // edi
    unsigned int v13; // ebx
    unsigned int v15; // [esp+20h] [ebp+14h]

    v5 = a3 + a4;
    if (a3 + a4 <= *(_DWORD*)(a2 + 4) && a4 <= *(_DWORD*)(a2 + 12) && *(_DWORD*)a2)
    {
        v6 = a1;
    }
    else
    {
        v6 = a1;
        *(_DWORD*)(*(_DWORD*)a1 + 20) = 20;
        (**(void(__cdecl***)(int))a1)(a1);
    }
    v7 = *(_DWORD*)(a2 + 24);
    if (a3 < v7 || v5 > v7 + *(_DWORD*)(a2 + 16))
    {
        if (!*(_BYTE*)(a2 + 34))
        {
            *(_DWORD*)(*(_DWORD*)v6 + 20) = 68;
            (**(void(__cdecl***)(int))v6)(v6);
        }
        if (*(_BYTE*)(a2 + 33))
        {
            sub_47C81D(a2, v6, 1);
            *(_BYTE*)(a2 + 33) = 0;
        }
        v8 = a3;
        if (a3 <= *(_DWORD*)(a2 + 24))
        {
            v8 = v5 - *(_DWORD*)(a2 + 16);
            if (v8 < 0)
                v8 = 0;
        }
        *(_DWORD*)(a2 + 24) = v8;
        sub_47C81D(a2, v6, 0);
    }
    v9 = *(_DWORD*)(a2 + 28);
    if (v9 < v5)
    {
        if (v9 >= a3)
        {
            v10 = *(_DWORD*)(a2 + 28);
        }
        else
        {
            if (a5)
            {
                *(_DWORD*)(*(_DWORD*)v6 + 20) = 20;
                (**(void(__cdecl***)(int))v6)(v6);
            }
            v10 = a3;
        }
        if (a5)
            *(_DWORD*)(a2 + 28) = v5;
        if (*(_BYTE*)(a2 + 32))
        {
            v15 = *(_DWORD*)(a2 + 8);
            v11 = *(_DWORD*)(a2 + 24);
            v12 = v10 - v11;
            v13 = v5 - v11;
            while (v12 < v13)
                sub_47BD68(*(void**)(*(_DWORD*)a2 + 4 * v12++), v15);
        }
        else
        {
            if (a5)
            {
            LABEL_32:
                *(_BYTE*)(a2 + 33) = 1;
                return *(_DWORD*)a2 + 4 * (a3 - *(_DWORD*)(a2 + 24));
            }
            *(_DWORD*)(*(_DWORD*)a1 + 20) = 20;
            (**(void(__cdecl***)(int))a1)(a1);
        }
    }
    if (a5)
        goto LABEL_32;
    return *(_DWORD*)a2 + 4 * (a3 - *(_DWORD*)(a2 + 24));
}

//----- (0047CA4E) --------------------------------------------------------
int __cdecl sub_47CA4E(int a1, int a2, unsigned int a3, unsigned int a4, char a5)
{
    unsigned int v6; // edi
    unsigned int v7; // eax
    int v8; // eax
    unsigned int v9; // ebx
    int v10; // eax
    unsigned int v11; // edi
    unsigned int v12; // ebx
    unsigned int v14; // [esp+20h] [ebp+14h]
    unsigned int v15; // [esp+20h] [ebp+14h]

    v6 = a3 + a4;
    v14 = a3 + a4;
    if (v14 > *(_DWORD*)(a2 + 4) || a4 > *(_DWORD*)(a2 + 12) || !*(_DWORD*)a2)
    {
        *(_DWORD*)(*(_DWORD*)a1 + 20) = 20;
        (**(void(__cdecl***)(int))a1)(a1);
    }
    v7 = *(_DWORD*)(a2 + 24);
    if (a3 < v7 || v6 > v7 + *(_DWORD*)(a2 + 16))
    {
        if (!*(_BYTE*)(a2 + 34))
        {
            *(_DWORD*)(*(_DWORD*)a1 + 20) = 68;
            (**(void(__cdecl***)(int))a1)(a1);
        }
        if (*(_BYTE*)(a2 + 33))
        {
            sub_47C8A5(a2, a1, 1);
            *(_BYTE*)(a2 + 33) = 0;
        }
        if (a3 <= *(_DWORD*)(a2 + 24))
        {
            v8 = v6 - *(_DWORD*)(a2 + 16);
            if (v8 < 0)
                v8 = 0;
            *(_DWORD*)(a2 + 24) = v8;
        }
        else
        {
            *(_DWORD*)(a2 + 24) = a3;
        }
        sub_47C8A5(a2, a1, 0);
    }
    v9 = *(_DWORD*)(a2 + 28);
    if (v9 < v6)
    {
        if (v9 < a3)
        {
            if (a5)
            {
                *(_DWORD*)(*(_DWORD*)a1 + 20) = 20;
                (**(void(__cdecl***)(int))a1)(a1);
            }
            v9 = a3;
        }
        if (a5)
            *(_DWORD*)(a2 + 28) = v6;
        if (*(_BYTE*)(a2 + 32))
        {
            v10 = *(_DWORD*)(a2 + 24);
            v11 = *(_DWORD*)(a2 + 8) << 7;
            v12 = v9 - v10;
            v15 = v14 - v10;
            while (v12 < v15)
                sub_47BD68(*(void**)(*(_DWORD*)a2 + 4 * v12++), v11);
        }
        else
        {
            if (a5)
            {
            LABEL_32:
                *(_BYTE*)(a2 + 33) = 1;
                return *(_DWORD*)a2 + 4 * (a3 - *(_DWORD*)(a2 + 24));
            }
            *(_DWORD*)(*(_DWORD*)a1 + 20) = 20;
            (**(void(__cdecl***)(int))a1)(a1);
        }
    }
    if (a5)
        goto LABEL_32;
    return *(_DWORD*)a2 + 4 * (a3 - *(_DWORD*)(a2 + 24));
}

//----- (0047CB71) --------------------------------------------------------
_DWORD* __cdecl sub_47CB71(_DWORD* a1, unsigned int a2)
{
    unsigned int v2; // ebx
    _DWORD* v3; // esi
    int i; // edi
    int j; // edi
    _DWORD* v6; // eax
    _DWORD* v7; // ebx
    int v8; // edi
    _DWORD** v9; // ecx
    _DWORD* result; // eax
    _DWORD* v11; // ebx
    int v12; // edi

    v2 = a2;
    v3 = (_DWORD*)a1[1];
    if (a2 >= 2)
    {
        *(_DWORD*)(*a1 + 20) = 12;
        *(_DWORD*)(*a1 + 24) = a2;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    if (a2 == 1)
    {
        for (i = v3[16]; i; i = *(_DWORD*)(i + 36))
        {
            if (*(_BYTE*)(i + 34))
            {
                *(_BYTE*)(i + 34) = 0;
                (*(void(__cdecl**)(_DWORD*, int))(i + 48))(a1, i + 40);
            }
        }
        v3[16] = 0;
        for (j = v3[17]; j; j = *(_DWORD*)(j + 36))
        {
            if (*(_BYTE*)(j + 34))
            {
                *(_BYTE*)(j + 34) = 0;
                (*(void(__cdecl**)(_DWORD*, int))(j + 48))(a1, j + 40);
            }
        }
        v3[17] = 0;
    }
    v6 = (_DWORD*)v3[a2 + 14];
    v3[a2 + 14] = 0;
    if (v6)
    {
        do
        {
            v7 = (_DWORD*)*v6;
            v8 = v6[2] + v6[1] + 16;
            sub_47EDE6((int)a1, v6);
            v3[18] -= v8;
            v6 = v7;
        } while (v7);
        v2 = a2;
    }
    v9 = (_DWORD**)&v3[v2 + 12];
    result = *v9;
    *v9 = 0;
    if (result)
    {
        do
        {
            v11 = (_DWORD*)*result;
            v12 = result[2] + result[1] + 16;
            sub_47EDE6((int)a1, result);
            v3[18] -= v12;
            result = v11;
        } while (v11);
    }
    return result;
}

//----- (0047CC52) --------------------------------------------------------
int __cdecl sub_47CC52(int a1)
{
    signed int i; // edi

    for (i = 1; i >= 0; --i)
        sub_47CB71((_DWORD*)a1, i);
    sub_47EDE6(a1, *(LPVOID*)(a1 + 4));
    *(_DWORD*)(a1 + 4) = 0;
    return ((int(__cdecl*)(int))nullsub_3)(a1);
}
// 47EE16: using guessed type int nullsub_3();

//----- (0047CC85) --------------------------------------------------------
_DWORD* __cdecl sub_47CC85(_DWORD* a1)
{
    int v1; // edi
    _DWORD* result; // eax
    _DWORD* v3; // ecx
    int v4; // edx

    a1[1] = 0;
    v1 = sub_47EE13();
    result = sub_47EDD8((int)a1, 0x50u);
    if (result)
    {
        *result = sub_47C2DF;
        result[1] = sub_47C3FD;
        result[2] = sub_47C4AC;
        result[3] = sub_47C53E;
        result[4] = sub_47C5DC;
        result[5] = sub_47C63D;
        result[6] = sub_47C69E;
        result[7] = sub_47C930;
        result[8] = sub_47CA4E;
        result[9] = sub_47CB71;
        result[10] = sub_47CC52;
        result[11] = v1;
        v3 = result + 15;
        v4 = 2;
        do
        {
            *(v3 - 2) = 0;
            *v3-- = 0;
            --v4;
        } while (v4);
        result[16] = 0;
        result[17] = 0;
        result[18] = 80;
        a1[1] = result;
    }
    else
    {
        nullsub_3(a1);
        *(_DWORD*)(*a1 + 20) = 53;
        *(_DWORD*)(*a1 + 24) = 0;
        return (_DWORD*)(*(int(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    return result;
}
// 47EE16: using guessed type int __cdecl nullsub_3(_DWORD);

//----- (0047CD3C) --------------------------------------------------------
int __cdecl sub_47CD3C(int a1)
{
    int result; // eax

    (*(void(__cdecl**)(int, int))(*(_DWORD*)(a1 + 4) + 36))(a1, 1);
    result = *(_BYTE*)(a1 + 12) != 0 ? 200 : 100;
    *(_DWORD*)(a1 + 16) = result;
    return result;
}

//----- (0047CD61) --------------------------------------------------------
int __cdecl sub_47CD61(int a1)
{
    int result; // eax

    result = *(_DWORD*)(a1 + 4);
    if (result)
        result = (*(int(__cdecl**)(int))(result + 40))(a1);
    *(_DWORD*)(a1 + 4) = 0;
    *(_DWORD*)(a1 + 16) = 0;
    return result;
}

//----- (0047CD7F) --------------------------------------------------------
int __cdecl sub_47CD7F(int a1)
{
    int result; // eax

    result = (**(int(__cdecl***)(int, _DWORD, int))(a1 + 4))(a1, 0, 130);
    *(_BYTE*)(result + 128) = 0;
    return result;
}

//----- (0047CD9E) --------------------------------------------------------
int __cdecl sub_47CD9E(int a1)
{
    int result; // eax

    result = (**(int(__cdecl***)(int, _DWORD, int))(a1 + 4))(a1, 0, 274);
    *(_BYTE*)(result + 273) = 0;
    return result;
}

//----- (0047CDBD) --------------------------------------------------------
char __fastcall sub_47CDBD(int a1, int a2)
{
    _DWORD* v2; // ecx
    char result; // al
    int v4; // edx

    if (*(_BYTE*)(a2 + 72))
        return 0;
    if (*(_BYTE*)(a2 + 264))
        return 0;
    if (*(_DWORD*)(a2 + 36) != 3)
        return 0;
    if (*(_DWORD*)(a2 + 32) != 3)
        return 0;
    if (*(_DWORD*)(a2 + 40) != 2)
        return 0;
    if (*(_DWORD*)(a2 + 100) != 3)
        return 0;
    v2 = *(_DWORD**)(a2 + 196);
    if (v2[2] != 2)
        return 0;
    result = 1;
    if (v2[23] != 1)
        return 0;
    if (v2[44] != 1)
        return 0;
    if ((int)v2[3] > 2)
        return 0;
    if (v2[24] != 1)
        return 0;
    if (v2[45] != 1)
        return 0;
    v4 = *(_DWORD*)(a2 + 276);
    if (v2[9] != v4 || v2[30] != v4 || v2[51] != v4)
        return 0;
    return result;
}

//----- (0047CE2E) --------------------------------------------------------
char __cdecl sub_47CE2E(int a1)
{
    int v2; // eax
    unsigned int v3; // ecx
    int v4; // eax
    int v5; // eax
    int v6; // eax
    int v7; // eax
    bool v8; // cc
    _DWORD* v9; // eax
    int v10; // edx
    int v11; // ebx
    _DWORD* v12; // edi
    int v13; // eax
    int v14; // ecx
    int v15; // eax
    int v16; // eax
    int v18; // [esp-18h] [ebp-20h]
    int v19; // [esp-18h] [ebp-20h]
    int v20; // [esp-18h] [ebp-20h]
    int v21; // [esp+4h] [ebp-4h]
    int i; // [esp+10h] [ebp+8h]

    if (*(_DWORD*)(a1 + 16) != 202)
    {
        *(_DWORD*)(*(_DWORD*)a1 + 20) = 18;
        *(_DWORD*)(*(_DWORD*)a1 + 24) = *(_DWORD*)(a1 + 16);
        (**(void(__cdecl***)(int))a1)(a1);
    }
    v2 = *(_DWORD*)(a1 + 44);
    v3 = *(_DWORD*)(a1 + 48);
    if (8 * v2 > v3)
    {
        if (4 * v2 > v3)
        {
            if (2 * v2 > v3)
            {
                *(_DWORD*)(a1 + 92) = *(_DWORD*)(a1 + 24);
                v5 = *(_DWORD*)(a1 + 28);
                *(_DWORD*)(a1 + 276) = 8;
            }
            else
            {
                v7 = sub_47BCD2(*(_DWORD*)(a1 + 24), 2);
                v20 = *(_DWORD*)(a1 + 28);
                *(_DWORD*)(a1 + 92) = v7;
                v5 = sub_47BCD2(v20, 2);
                *(_DWORD*)(a1 + 276) = 4;
            }
        }
        else
        {
            v6 = sub_47BCD2(*(_DWORD*)(a1 + 24), 4);
            v19 = *(_DWORD*)(a1 + 28);
            *(_DWORD*)(a1 + 92) = v6;
            v5 = sub_47BCD2(v19, 4);
            *(_DWORD*)(a1 + 276) = 2;
        }
    }
    else
    {
        v4 = sub_47BCD2(*(_DWORD*)(a1 + 24), 8);
        v18 = *(_DWORD*)(a1 + 28);
        *(_DWORD*)(a1 + 92) = v4;
        v5 = sub_47BCD2(v18, 8);
        *(_DWORD*)(a1 + 276) = 1;
    }
    v21 = 0;
    v8 = *(_DWORD*)(a1 + 32) <= 0;
    *(_DWORD*)(a1 + 96) = v5;
    if (!v8)
    {
        v9 = (_DWORD*)(*(_DWORD*)(a1 + 196) + 12);
        do
        {
            v10 = *(_DWORD*)(a1 + 276);
            for (i = v10; i < 8; i *= 2)
            {
                if (2 * i * *(v9 - 1) > v10 * *(_DWORD*)(a1 + 268))
                    break;
                if (2 * i * *v9 > v10 * *(_DWORD*)(a1 + 272))
                    break;
            }
            ++v21;
            v9[6] = i;
            v9 += 21;
        } while (v21 < *(_DWORD*)(a1 + 32));
    }
    v11 = 0;
    if (*(int*)(a1 + 32) > 0)
    {
        v12 = (_DWORD*)(*(_DWORD*)(a1 + 196) + 36);
        do
        {
            v12[1] = sub_47BCD2(*(_DWORD*)(a1 + 24) * *v12 * *(v12 - 7), 8 * *(_DWORD*)(a1 + 268));
            v12[2] = sub_47BCD2(*v12 * *(_DWORD*)(a1 + 28) * *(v12 - 6), 8 * *(_DWORD*)(a1 + 272));
            ++v11;
            v12 += 21;
        } while (v11 < *(_DWORD*)(a1 + 32));
    }
    v13 = *(_DWORD*)(a1 + 40);
    v14 = 1;
    if (v13 != 1)
    {
        if (v13 <= 1)
        {
        LABEL_25:
            *(_DWORD*)(a1 + 100) = *(_DWORD*)(a1 + 32);
            goto LABEL_27;
        }
        v14 = 3;
        if (v13 > 3)
        {
            if (v13 <= 5)
            {
                *(_DWORD*)(a1 + 100) = 4;
                goto LABEL_27;
            }
            goto LABEL_25;
        }
    }
    *(_DWORD*)(a1 + 100) = v14;
LABEL_27:
    if (*(_BYTE*)(a1 + 74))
        v15 = 1;
    else
        v15 = *(_DWORD*)(a1 + 100);
    *(_DWORD*)(a1 + 104) = v15;
    LOBYTE(v16) = sub_47CDBD(v14, a1);
    if ((_BYTE)v16)
    {
        v16 = *(_DWORD*)(a1 + 272);
        *(_DWORD*)(a1 + 108) = v16;
    }
    else
    {
        *(_DWORD*)(a1 + 108) = 1;
    }
    return v16;
}

//----- (0047D01D) --------------------------------------------------------
int __usercall sub_47D01D@<eax>(int a1@<ebx>)
{
    int v1; // edx
    int v2; // eax
    int v3; // edx
    char v4; // al
    int result; // eax
    int v6; // ecx
    int v7; // eax
    int v8; // [esp+0h] [ebp-10h]
    int v9; // [esp+Ch] [ebp-4h]

    v9 = *(_DWORD*)(a1 + 380);
    sub_47CE2E(v8);
    v1 = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1408) + 256;
    v2 = 0;
    *(_DWORD*)(a1 + 284) = v1;
    memset((void*)(v1 - 256), 0, 0x100u);
    do
    {
        *(_BYTE*)(v2 + v1) = v2;
        ++v2;
    } while (v2 <= 255);
    v3 = v1 + 128;
    memset((void*)(v3 + 128), 0xFFu, 0x180u);
    memset((void*)(v3 + 512), 0, 0x180u);
    qmemcpy((void*)(v3 + 896), *(const void**)(a1 + 284), 0x80u);
    *(_DWORD*)(v9 + 12) = 0;
    *(_BYTE*)(v9 + 16) = sub_47CDBD(0, a1);
    *(_DWORD*)(v9 + 20) = 0;
    *(_DWORD*)(v9 + 24) = 0;
    v4 = *(_BYTE*)(a1 + 74);
    if (!v4 || !*(_BYTE*)(a1 + 64))
    {
        *(_BYTE*)(a1 + 88) = 0;
        *(_BYTE*)(a1 + 89) = 0;
        *(_BYTE*)(a1 + 90) = 0;
    }
    if (v4)
    {
        if (*(_BYTE*)(a1 + 65))
        {
            *(_DWORD*)(*(_DWORD*)a1 + 20) = 46;
            (**(void(__cdecl***)(int))a1)(a1);
        }
        if (*(_DWORD*)(a1 + 100) == 3)
        {
            if (*(_DWORD*)(a1 + 116))
            {
                *(_BYTE*)(a1 + 89) = 1;
                goto LABEL_12;
            }
            if (*(_BYTE*)(a1 + 80))
            {
                *(_BYTE*)(a1 + 90) = 1;
                goto LABEL_12;
            }
        }
        else
        {
            *(_BYTE*)(a1 + 89) = 0;
            *(_BYTE*)(a1 + 90) = 0;
            *(_DWORD*)(a1 + 116) = 0;
        }
        *(_BYTE*)(a1 + 88) = 1;
    LABEL_12:
        if (*(_BYTE*)(a1 + 88))
        {
            sub_484647((_DWORD*)a1);
            *(_DWORD*)(v9 + 20) = *(_DWORD*)(a1 + 420);
        }
        if (*(_BYTE*)(a1 + 90) || *(_BYTE*)(a1 + 89))
        {
            sub_483B99(a1);
            *(_DWORD*)(v9 + 24) = *(_DWORD*)(a1 + 420);
        }
    }
    if (!*(_BYTE*)(a1 + 65))
    {
        if (*(_BYTE*)(v9 + 16))
        {
            sub_482C1B(a1);
        }
        else
        {
            sub_48261E(a1);
            sub_481EA9(a1);
        }
        sub_4819E1(a1, *(_BYTE*)(a1 + 90));
    }
    sub_481744(a1);
    if (*(_BYTE*)(a1 + 201))
    {
        *(_DWORD*)(*(_DWORD*)a1 + 20) = 1;
        (**(void(__cdecl***)(int))a1)(a1);
    }
    else if (*(_BYTE*)(a1 + 200))
    {
        sub_481529(a1);
    }
    else
    {
        sub_48097A(a1);
    }
    if (*(_BYTE*)(*(_DWORD*)(a1 + 396) + 16) || *(_BYTE*)(a1 + 64))
        sub_47FFA9(a1, 1);
    else
        sub_47FFA9(a1, 0);
    if (!*(_BYTE*)(a1 + 65))
        sub_47F357(a1, 0);
    (*(void(__cdecl**)(int))(*(_DWORD*)(a1 + 4) + 24))(a1);
    result = (*(int(__cdecl**)(int))(*(_DWORD*)(a1 + 396) + 8))(a1);
    v6 = *(_DWORD*)(a1 + 8);
    if (v6)
    {
        if (!*(_BYTE*)(a1 + 64))
        {
            result = *(_DWORD*)(a1 + 396);
            if (*(_BYTE*)(result + 16))
            {
                v7 = *(_DWORD*)(a1 + 32);
                if (*(_BYTE*)(a1 + 200))
                    v7 = 3 * v7 + 2;
                *(_DWORD*)(v6 + 4) = 0;
                *(_DWORD*)(*(_DWORD*)(a1 + 8) + 8) = v7 * *(_DWORD*)(a1 + 280);
                *(_DWORD*)(*(_DWORD*)(a1 + 8) + 12) = 0;
                result = (*(_BYTE*)(a1 + 90) != 0) + 2;
                *(_DWORD*)(*(_DWORD*)(a1 + 8) + 16) = result;
                ++*(_DWORD*)(v9 + 12);
            }
        }
    }
    return result;
}
// 47D02D: variable 'v8' is possibly undefined

//----- (0047D24A) --------------------------------------------------------
int __cdecl sub_47D24A(int a1)
{
    int v1; // edi
    int result; // eax

    v1 = *(_DWORD*)(a1 + 380);
    if (*(_BYTE*)(v1 + 8))
    {
        *(_BYTE*)(v1 + 8) = 0;
        (**(void(__cdecl***)(int, _DWORD))(a1 + 420))(a1, 0);
        (**(void(__cdecl***)(int, int))(a1 + 392))(a1, 2);
        (**(void(__cdecl***)(int, int))(a1 + 384))(a1, 2);
    }
    else
    {
        if (*(_BYTE*)(a1 + 74) && !*(_DWORD*)(a1 + 116))
        {
            if (*(_BYTE*)(a1 + 80) && *(_BYTE*)(a1 + 90))
            {
                *(_DWORD*)(a1 + 420) = *(_DWORD*)(v1 + 24);
                *(_BYTE*)(v1 + 8) = 1;
            }
            else if (*(_BYTE*)(a1 + 88))
            {
                *(_DWORD*)(a1 + 420) = *(_DWORD*)(v1 + 20);
            }
            else
            {
                *(_DWORD*)(*(_DWORD*)a1 + 20) = 45;
                (**(void(__cdecl***)(int))a1)(a1);
            }
        }
        (**(void(__cdecl***)(int))(a1 + 408))(a1);
        (*(void(__cdecl**)(int))(*(_DWORD*)(a1 + 388) + 8))(a1);
        if (!*(_BYTE*)(a1 + 65))
        {
            if (!*(_BYTE*)(v1 + 16))
                (**(void(__cdecl***)(int))(a1 + 416))(a1);
            (**(void(__cdecl***)(int))(a1 + 412))(a1);
            if (*(_BYTE*)(a1 + 74))
                (**(void(__cdecl***)(int, _DWORD))(a1 + 420))(a1, *(unsigned __int8*)(v1 + 8));
            (**(void(__cdecl***)(int, int))(a1 + 392))(a1, *(_BYTE*)(v1 + 8) != 0 ? 3 : 0);
            (**(void(__cdecl***)(int, _DWORD))(a1 + 384))(a1, 0);
        }
    }
    result = *(_DWORD*)(a1 + 8);
    if (result)
    {
        *(_DWORD*)(result + 12) = *(_DWORD*)(v1 + 12);
        result = *(_DWORD*)(v1 + 12) + (*(_BYTE*)(v1 + 8) != 0) + 1;
        *(_DWORD*)(*(_DWORD*)(a1 + 8) + 16) = result;
        if (*(_BYTE*)(a1 + 64))
        {
            result = *(_DWORD*)(a1 + 396);
            if (!*(_BYTE*)(result + 17))
            {
                result = *(_DWORD*)(a1 + 8);
                *(_DWORD*)(result + 16) += (*(_BYTE*)(a1 + 90) != 0) + 1;
            }
        }
    }
    return result;
}

//----- (0047D37A) --------------------------------------------------------
int __cdecl sub_47D37A(int a1)
{
    int result; // eax
    int v2; // esi

    result = a1;
    v2 = *(_DWORD*)(a1 + 380);
    if (*(_BYTE*)(a1 + 74))
        result = (*(int(__cdecl**)(int))(*(_DWORD*)(a1 + 420) + 8))(a1);
    ++*(_DWORD*)(v2 + 12);
    return result;
}

//----- (0047D39E) --------------------------------------------------------
int __cdecl sub_47D39E(int a1)
{
    int v1; // eax

    v1 = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 28);
    *(_DWORD*)(a1 + 380) = v1;
    *(_BYTE*)(v1 + 8) = 0;
    *(_DWORD*)v1 = sub_47D24A;
    *(_DWORD*)(v1 + 4) = sub_47D37A;
    return sub_47D01D(a1);
}

//----- (0047D3D1) --------------------------------------------------------
int __cdecl sub_47D3D1(_DWORD* a1)
{
    _DWORD* v1; // ecx

    if (!a1)
        return -2;
    v1 = (_DWORD*)a1[7];
    if (!v1)
        return -2;
    a1[5] = 0;
    a1[2] = 0;
    a1[6] = 0;
    *v1 = v1[3] != 0 ? 7 : 0;
    sub_4846D1(*(_DWORD**)(a1[7] + 20), (int)a1, 0);
    return 0;
}

//----- (0047D414) --------------------------------------------------------
int __cdecl sub_47D414(_DWORD* a1)
{
    int v1; // eax
    _DWORD* v2; // eax

    if (!a1)
        return -2;
    v1 = a1[7];
    if (!v1 || !a1[9])
        return -2;
    v2 = *(_DWORD**)(v1 + 20);
    if (v2)
        sub_484F66(v2, (int)a1);
    ((void(__cdecl*)(_DWORD, _DWORD))a1[9])(a1[10], a1[7]);
    a1[7] = 0;
    return 0;
}

//----- (0047D455) --------------------------------------------------------
int __cdecl sub_47D455(_DWORD* a1, int a2, _BYTE* a3, int a4)
{
    bool v4; // zf
    int v5; // eax
    int v6; // ecx
    int v7; // edi
    int v10; // [esp-4h] [ebp-10h]

    if (!a3 || *a3 != 49 || a4 != 56)
        return -6;
    if (!a1)
        return -2;
    v4 = a1[8] == 0;
    a1[6] = 0;
    if (v4)
    {
        a1[8] = sub_4850B5;
        a1[10] = 0;
    }
    if (!a1[9])
        a1[9] = sub_47EDE6;
    v5 = ((int(__cdecl*)(_DWORD, int, int))a1[8])(a1[10], 1, 24);
    a1[7] = v5;
    if (v5)
    {
        v6 = a2;
        *(_DWORD*)(v5 + 20) = 0;
        *(_DWORD*)(a1[7] + 12) = 0;
        if (a2 < 0)
        {
            v6 = -a2;
            *(_DWORD*)(a1[7] + 12) = 1;
        }
        if (v6 < 8 || v6 > 15)
        {
            v10 = -2;
        }
        else
        {
            *(_DWORD*)(a1[7] + 16) = v6;
            *(_DWORD*)(a1[7] + 20) = sub_48473D(
                (int)a1,
                *(_DWORD*)(a1[7] + 12) == 0 ? (unsigned int)sub_484F9C : 0,
                1 << v6);
            if (*(_DWORD*)(a1[7] + 20))
            {
                sub_47D3D1(a1);
                return 0;
            }
            v10 = -4;
        }
        v7 = v10;
        sub_47D414(a1);
        return v7;
    }
    return -4;
}

//----- (0047D53A) --------------------------------------------------------
int __cdecl sub_47D53A(_DWORD* a1, _BYTE* a2, int a3)
{
    return sub_47D455(a1, 15, a2, a3);
}

//----- (0047D552) --------------------------------------------------------
int __cdecl sub_47D552(int* a1, int a2)
{
    _DWORD* v2; // eax
    int v3; // ebx
    int v4; // eax
    int v5; // ecx
    _DWORD* v6; // eax
    int v7; // eax
    int v8; // ebx
    _DWORD* v9; // ecx
    bool v10; // zf
    int v11; // eax
    _DWORD* v12; // eax
    int v13; // eax
    int v14; // ecx
    _DWORD* v15; // eax
    int v16; // eax
    unsigned __int8* v17; // ecx
    _DWORD* v18; // eax
    int v19; // eax
    unsigned __int8* v20; // ecx
    _DWORD* v21; // eax
    int v22; // eax
    unsigned __int8* v23; // ecx
    _DWORD* v24; // eax
    int v26; // eax
    int v27; // ecx
    _DWORD* v28; // eax
    int v29; // eax
    unsigned __int8* v30; // ecx
    _DWORD* v31; // eax
    int v32; // eax
    unsigned __int8* v33; // ecx
    _DWORD* v34; // eax
    int v35; // eax
    unsigned __int8* v36; // ecx
    _DWORD* v37; // eax
    int v38; // eax
    int v40; // [esp+18h] [ebp+Ch]

    if (!a1)
        return -2;
    v2 = (_DWORD*)a1[7];
    if (!v2 || !*a1)
        return -2;
    v3 = -5;
    if (a2 == 4)
        v40 = -5;
    else
        v40 = 0;
    while (1)
    {
        switch (*v2)
        {
        case 0:
            v4 = a1[1];
            if (!v4)
                return v3;
            v5 = a1[7];
            v3 = v40;
            ++a1[2];
            a1[1] = v4 - 1;
            *(_DWORD*)(v5 + 4) = *(unsigned __int8*)*a1;
            v6 = (_DWORD*)a1[7];
            LOBYTE(v5) = v6[1] & 0xF;
            ++*a1;
            if ((_BYTE)v5 == 8)
            {
                if ((unsigned int)((v6[1] >> 4) + 8) <= v6[4])
                {
                    *v6 = 1;
                LABEL_14:
                    v7 = a1[1];
                    if (!v7)
                        return v3;
                    ++a1[2];
                    a1[1] = v7 - 1;
                    v8 = *(unsigned __int8*)(*a1)++;
                    v9 = (_DWORD*)a1[7];
                    if (!((v8 + (v9[1] << 8)) % 0x1Fu))
                    {
                        v10 = (v8 & 0x20) == 0;
                        v3 = v40;
                        if (v10)
                        {
                            *v9 = 7;
                            goto LABEL_37;
                        }
                        *(_DWORD*)a1[7] = 2;
                    LABEL_42:
                        v26 = a1[1];
                        if (!v26)
                            return v3;
                        v27 = a1[7];
                        v3 = v40;
                        ++a1[2];
                        a1[1] = v26 - 1;
                        *(_DWORD*)(v27 + 8) = *(unsigned __int8*)*a1 << 24;
                        v28 = (_DWORD*)a1[7];
                        ++*a1;
                        *v28 = 3;
                    LABEL_44:
                        v29 = a1[1];
                        if (!v29)
                            return v3;
                        v30 = (unsigned __int8*)*a1;
                        v3 = v40;
                        ++a1[2];
                        a1[1] = v29 - 1;
                        *(_DWORD*)(a1[7] + 8) += *v30 << 16;
                        v31 = (_DWORD*)a1[7];
                        ++*a1;
                        *v31 = 4;
                    LABEL_46:
                        v32 = a1[1];
                        if (!v32)
                            return v3;
                        v33 = (unsigned __int8*)*a1;
                        v3 = v40;
                        ++a1[2];
                        a1[1] = v32 - 1;
                        *(_DWORD*)(a1[7] + 8) += *v33 << 8;
                        v34 = (_DWORD*)a1[7];
                        ++*a1;
                        *v34 = 5;
                    LABEL_48:
                        v35 = a1[1];
                        if (!v35)
                            return v3;
                        v36 = (unsigned __int8*)*a1;
                        ++a1[2];
                        a1[1] = v35 - 1;
                        *(_DWORD*)(a1[7] + 8) += *v36;
                        v37 = (_DWORD*)a1[7];
                        ++*a1;
                        a1[12] = v37[2];
                        *v37 = 6;
                        return 2;
                    }
                    v3 = v40;
                    *v9 = 13;
                    a1[6] = (int)"incorrect header check";
                }
                else
                {
                    *v6 = 13;
                    a1[6] = (int)"invalid window size";
                }
            }
            else
            {
                *v6 = 13;
                a1[6] = (int)"unknown compression method";
            }
        LABEL_36:
            *(_DWORD*)(a1[7] + 4) = 5;
        LABEL_37:
            v2 = (_DWORD*)a1[7];
            break;
        case 1:
            goto LABEL_14;
        case 2:
            goto LABEL_42;
        case 3:
            goto LABEL_44;
        case 4:
            goto LABEL_46;
        case 5:
            goto LABEL_48;
        case 6:
            *(_DWORD*)a1[7] = 13;
            v38 = a1[7];
            a1[6] = (int)"need dictionary";
            *(_DWORD*)(v38 + 4) = 0;
            return -2;
        case 7:
            v11 = sub_4847CB(*(int**)(a1[7] + 20), a1, v3);
            v3 = v11;
            if (v11 == -3)
            {
                *(_DWORD*)a1[7] = 13;
                *(_DWORD*)(a1[7] + 4) = 0;
                goto LABEL_37;
            }
            if (!v11)
                v3 = v40;
            if (v3 != 1)
                return v3;
            v3 = v40;
            sub_4846D1(*(_DWORD**)(a1[7] + 20), (int)a1, (_DWORD*)(a1[7] + 4));
            v12 = (_DWORD*)a1[7];
            if (v12[3])
            {
                *v12 = 12;
                goto LABEL_37;
            }
            *v12 = 8;
        LABEL_27:
            v13 = a1[1];
            if (!v13)
                return v3;
            v14 = a1[7];
            v3 = v40;
            ++a1[2];
            a1[1] = v13 - 1;
            *(_DWORD*)(v14 + 8) = *(unsigned __int8*)*a1 << 24;
            v15 = (_DWORD*)a1[7];
            ++*a1;
            *v15 = 9;
        LABEL_29:
            v16 = a1[1];
            if (!v16)
                return v3;
            v17 = (unsigned __int8*)*a1;
            v3 = v40;
            ++a1[2];
            a1[1] = v16 - 1;
            *(_DWORD*)(a1[7] + 8) += *v17 << 16;
            v18 = (_DWORD*)a1[7];
            ++*a1;
            *v18 = 10;
        LABEL_31:
            v19 = a1[1];
            if (!v19)
                return v3;
            v20 = (unsigned __int8*)*a1;
            v3 = v40;
            ++a1[2];
            a1[1] = v19 - 1;
            *(_DWORD*)(a1[7] + 8) += *v20 << 8;
            v21 = (_DWORD*)a1[7];
            ++*a1;
            *v21 = 11;
        LABEL_33:
            v22 = a1[1];
            if (!v22)
                return v3;
            v23 = (unsigned __int8*)*a1;
            v3 = v40;
            ++a1[2];
            a1[1] = v22 - 1;
            *(_DWORD*)(a1[7] + 8) += *v23;
            v24 = (_DWORD*)a1[7];
            ++*a1;
            if (v24[1] != v24[2])
            {
                *v24 = 13;
                a1[6] = (int)"incorrect data check";
                goto LABEL_36;
            }
            *(_DWORD*)a1[7] = 12;
            return 1;
        case 8:
            goto LABEL_27;
        case 9:
            goto LABEL_29;
        case 0xA:
            goto LABEL_31;
        case 0xB:
            goto LABEL_33;
        case 0xC:
            return 1;
        case 0xD:
            return -3;
        default:
            return -2;
        }
    }
}

//----- (0047D8C7) --------------------------------------------------------
void* __cdecl sub_47D8C7(int a1)
{
    size_t v1; // esi
    void* v2; // edx

    if (a1 == 2)
    {
        v1 = 64;
    }
    else
    {
        if (a1 != 1)
            return 0;
        v1 = 412;
    }
    v2 = malloc(v1);
    if (v2)
        memset(v2, 0, v1);
    return v2;
}

//----- (0047D90B) --------------------------------------------------------
void __cdecl sub_47D90B(LPVOID lpMem)
{
    if (lpMem)
        sub_488CEE(lpMem);
}

//----- (0047D91C) --------------------------------------------------------
void* __cdecl sub_47D91C(jmp_buf Buf, size_t Size)
{
    void* result; // eax

    if (!Buf || !Size)
        return 0;
    result = malloc(Size);
    if (!result)
        sub_478AEB(Buf, (int)"Out of Memory");
    return result;
}

//----- (0047D953) --------------------------------------------------------
void __cdecl sub_47D953(int a1, LPVOID lpMem)
{
    if (a1)
    {
        if (lpMem)
            sub_488CEE(lpMem);
    }
}

//----- (0047D96D) --------------------------------------------------------
void* __cdecl sub_47D96D(int a1, void* a2, const void* a3, unsigned int a4)
{
    qmemcpy(a2, a3, a4);
    return a2;
}

//----- (0047D991) --------------------------------------------------------
char* __usercall sub_47D991@<eax>(int a1@<ebx>, int a2, char* a3, char a4, unsigned int a5)
{
    int v5; // eax

    LOBYTE(a1) = a4;
    BYTE1(a1) = a4;
    v5 = a1 << 16;
    LOWORD(v5) = a1;
    memset32(a3, v5, a5 >> 2);
    memset(&a3[4 * (a5 >> 2)], a4, a5 & 3);
    return a3;
}

//----- (0047D9C3) --------------------------------------------------------
int __cdecl sub_47D9C3(unsigned __int8* a1)
{
    return a1[3] + ((a1[2] + ((a1[1] + (*a1 << 8)) << 8)) << 8);
}

//----- (0047D9E9) --------------------------------------------------------
int __cdecl sub_47D9E9(int Buf, _BYTE* a2, unsigned int a3)
{
    sub_47AE26((int*)Buf, (int)a2, a3);
    return sub_47AF52(Buf, a2, a3);
}

//----- (0047DA03) --------------------------------------------------------
BOOL __cdecl sub_47DA03(jmp_buf Buf)
{
    int* __attribute__((__org_typedef(jmp_buf))) v1; // esi
    int v2; // edi

    v1 = Buf;
    v2 = 1;
    if ((Buf[67] & 0x20) != 0)
    {
        if ((Buf[23] & 0x300) != 0x300)
            goto LABEL_6;
    }
    else if ((*((_BYTE*)Buf + 93) & 8) == 0)
    {
        goto LABEL_6;
    }
    v2 = 0;
LABEL_6:
    sub_47AE26(Buf, (int)&Buf, 4);
    return v2 && sub_47D9C3((unsigned __int8*)&Buf) != v1[64];
}

//----- (0047DA61) --------------------------------------------------------
unsigned __int8 __cdecl sub_47DA61(jmp_buf Buf, unsigned __int8* a2)
{
    unsigned __int8 v2; // al
    unsigned __int8 v3; // al
    unsigned __int8 v4; // al
    unsigned __int8 result; // al

    v2 = *a2;
    if (*a2 < 0x29u
        || v2 > 0x7Au
        || v2 > 0x5Au && v2 < 0x61u
        || (v3 = a2[1], v3 < 0x29u)
        || v3 > 0x7Au
        || v3 > 0x5Au && v3 < 0x61u
        || (v4 = a2[2], v4 < 0x29u)
        || v4 > 0x7Au
        || v4 > 0x5Au && v4 < 0x61u
        || (result = a2[3], result < 0x29u)
        || result > 0x7Au
        || result > 0x5Au && result < 0x61u)
    {
        sub_478B21(Buf, "invalid chunk type");
    }
    return result;
}

//----- (0047DAC5) --------------------------------------------------------
char __cdecl sub_47DAC5(int a1, char* a2, int a3)
{
    unsigned int v3; // ecx
    unsigned int v4; // eax
    char* v5; // ebx
    char* v6; // edx
    _BYTE* v7; // edi
    unsigned __int8* v8; // esi
    int v9; // edx
    _BYTE* v10; // edi
    unsigned __int8* v11; // esi
    int v12; // edx
    _BYTE* v13; // edi
    unsigned __int8* v14; // esi
    int v15; // edx
    int v17; // [esp+8h] [ebp-Ch]
    int v18; // [esp+8h] [ebp-Ch]
    int v19; // [esp+8h] [ebp-Ch]
    int v20; // [esp+8h] [ebp-Ch]
    unsigned int v21; // [esp+Ch] [ebp-8h]
    int v22; // [esp+Ch] [ebp-8h]
    int v23; // [esp+Ch] [ebp-8h]
    int v24; // [esp+Ch] [ebp-8h]
    unsigned __int8 v25; // [esp+13h] [ebp-1h]

    v3 = *(unsigned __int8*)(a1 + 251);
    if (a3 == 255)
    {
        v4 = (*(_DWORD*)(a1 + 184) * v3 + 7) >> 3;
        qmemcpy(a2, (const void*)(*(_DWORD*)(a1 + 220) + 1), 4 * ((*(_DWORD*)(a1 + 184) * v3 + 7) >> 5) + (v4 & 3));
    }
    else
    {
        switch (v3)
        {
        case 1u:
            v4 = *(_DWORD*)(a1 + 184);
            v13 = a2;
            v14 = (unsigned __int8*)(*(_DWORD*)(a1 + 220) + 1);
            v24 = 128;
            v15 = 7;
            if (v4)
            {
                v20 = *(_DWORD*)(a1 + 184);
                do
                {
                    LOBYTE(v4) = a3;
                    if ((a3 & v24) != 0)
                    {
                        LOBYTE(v4) = ((*v14 >> v15) & 1) << v15;
                        *v13 = v4 | *v13 & (32639 >> (7 - v15));
                    }
                    if (v15)
                    {
                        --v15;
                    }
                    else
                    {
                        ++v14;
                        v15 = 7;
                        ++v13;
                    }
                    if (v24 == 1)
                        v24 = 128;
                    else
                        v24 >>= 1;
                    --v20;
                } while (v20);
            }
            break;
        case 2u:
            v4 = *(_DWORD*)(a1 + 184);
            v10 = a2;
            v11 = (unsigned __int8*)(*(_DWORD*)(a1 + 220) + 1);
            v23 = 128;
            v12 = 6;
            if (v4)
            {
                v19 = *(_DWORD*)(a1 + 184);
                do
                {
                    LOBYTE(v4) = a3;
                    if ((a3 & v23) != 0)
                    {
                        LOBYTE(v4) = ((*v11 >> v12) & 3) << v12;
                        *v10 = v4 | *v10 & (16191 >> (6 - v12));
                    }
                    if (v12)
                    {
                        v12 -= 2;
                    }
                    else
                    {
                        ++v11;
                        v12 = 6;
                        ++v10;
                    }
                    if (v23 == 1)
                        v23 = 128;
                    else
                        v23 >>= 1;
                    --v19;
                } while (v19);
            }
            break;
        case 4u:
            v4 = *(_DWORD*)(a1 + 184);
            v7 = a2;
            v8 = (unsigned __int8*)(*(_DWORD*)(a1 + 220) + 1);
            v22 = 128;
            v9 = 4;
            if (v4)
            {
                v18 = *(_DWORD*)(a1 + 184);
                do
                {
                    LOBYTE(v4) = a3;
                    if ((a3 & v22) != 0)
                    {
                        LOBYTE(v4) = ((*v8 >> v9) & 0xF) << v9;
                        *v7 = v4 | *v7 & (3855 >> (4 - v9));
                    }
                    if (v9)
                    {
                        v9 -= 4;
                    }
                    else
                    {
                        ++v8;
                        v9 = 4;
                        ++v7;
                    }
                    if (v22 == 1)
                        v22 = 128;
                    else
                        v22 >>= 1;
                    --v18;
                } while (v18);
            }
            break;
        default:
            v4 = *(_DWORD*)(a1 + 184);
            v5 = a2;
            v6 = (char*)(*(_DWORD*)(a1 + 220) + 1);
            v21 = v3 >> 3;
            v25 = 0x80;
            if (v4)
            {
                v17 = *(_DWORD*)(a1 + 184);
                do
                {
                    LOBYTE(v4) = a3;
                    if (((unsigned __int8)a3 & v25) != 0)
                    {
                        v4 = v3 >> 3;
                        qmemcpy(v5, v6, v21);
                    }
                    v6 += v21;
                    v5 += v21;
                    if (v25 == 1)
                        v25 = 0x80;
                    else
                        v25 >>= 1;
                    --v17;
                } while (v17);
            }
            break;
        }
    }
    return v4;
}

//----- (0047DCDB) --------------------------------------------------------
void __cdecl sub_47DCDB(int* a1, int a2, int a3)
{
    int v3; // eax
    int v4; // edx
    unsigned int v5; // esi
    unsigned int v6; // esi
    char* v7; // ebx
    char v8; // al
    unsigned int v9; // ecx
    _BYTE* v10; // edi
    char* v11; // esi
    int v12; // eax
    bool v13; // cc
    void* v14; // edi
    _BYTE* v15; // edi
    _BYTE* v16; // esi
    char v17; // al
    bool v18; // zf
    _BYTE* v19; // edi
    _BYTE* v20; // esi
    char v21; // al
    _BYTE* v22; // edi
    _BYTE* v23; // esi
    char v24; // al
    unsigned int v25; // ecx
    _BYTE v26[4]; // [esp+0h] [ebp-18h] BYREF
    int v27; // [esp+4h] [ebp-14h]
    unsigned int v28; // [esp+8h] [ebp-10h]
    int v29; // [esp+Ch] [ebp-Ch]
    unsigned int v30; // [esp+10h] [ebp-8h]
    unsigned int v31; // [esp+14h] [ebp-4h]
    char* v32; // [esp+24h] [ebp+Ch]
    char v33; // [esp+27h] [ebp+Fh]
    char v34; // [esp+27h] [ebp+Fh]
    char v35; // [esp+27h] [ebp+Fh]

    if (a2 && a1)
    {
        v3 = *a1;
        v4 = dword_49C33C[a3] * *a1;
        v29 = dword_49C33C[a3];
        v5 = *((unsigned __int8*)a1 + 11);
        if (v5 == 1)
        {
            v28 = 0;
            v22 = (_BYTE*)(a2 + ((unsigned int)(v3 - 1) >> 3));
            v23 = (_BYTE*)(a2 + ((unsigned int)(v4 - 1) >> 3));
            v30 = 7 - (((_BYTE)v3 - 1) & 7);
            v31 = 7 - (((_BYTE)v4 - 1) & 7);
            if (v3)
            {
                do
                {
                    v24 = (*v22 >> v30) & 1;
                    v35 = v24;
                    if (v29 > 0)
                    {
                        v27 = v29;
                        while (1)
                        {
                            v18 = v31 == 7;
                            *v23 = (v24 << v31) | *v23 & (32639 >> (7 - v31));
                            if (v18)
                            {
                                v31 = 0;
                                --v23;
                            }
                            else
                            {
                                ++v31;
                            }
                            if (!--v27)
                                break;
                            v24 = v35;
                        }
                    }
                    if (v30 == 7)
                    {
                        v30 = 0;
                        --v22;
                    }
                    else
                    {
                        ++v30;
                    }
                    ++v28;
                } while (v28 < *a1);
            }
        }
        else if (*((_BYTE*)a1 + 11) == 2)
        {
            v28 = 0;
            v19 = (_BYTE*)(a2 + ((unsigned int)(v3 - 1) >> 2));
            v20 = (_BYTE*)(a2 + ((unsigned int)(v4 - 1) >> 2));
            v30 = 2 * (3 - (((_BYTE)v3 - 1) & 3));
            v31 = 2 * (3 - (((_BYTE)v4 - 1) & 3));
            if (v3)
            {
                do
                {
                    v21 = (*v19 >> v30) & 3;
                    v34 = v21;
                    if (v29 > 0)
                    {
                        v27 = v29;
                        while (1)
                        {
                            v18 = v31 == 6;
                            *v20 = (v21 << v31) | *v20 & (16191 >> (6 - v31));
                            if (v18)
                            {
                                v31 = 0;
                                --v20;
                            }
                            else
                            {
                                v31 += 2;
                            }
                            if (!--v27)
                                break;
                            v21 = v34;
                        }
                    }
                    if (v30 == 6)
                    {
                        v30 = 0;
                        --v19;
                    }
                    else
                    {
                        v30 += 2;
                    }
                    ++v28;
                } while (v28 < *a1);
            }
        }
        else if (*((_BYTE*)a1 + 11) == 4)
        {
            v28 = 0;
            v15 = (_BYTE*)(a2 + ((unsigned int)(v3 - 1) >> 1));
            v16 = (_BYTE*)(a2 + ((unsigned int)(v4 - 1) >> 1));
            v30 = 4 - 4 * (((_BYTE)v3 - 1) & 1);
            v31 = 4 - 4 * (((_BYTE)v4 - 1) & 1);
            if (v3)
            {
                do
                {
                    v17 = (*v15 >> v30) & 0xF;
                    v33 = v17;
                    if (v29 > 0)
                    {
                        v27 = v29;
                        while (1)
                        {
                            v18 = v31 == 4;
                            *v16 = (v17 << v31) | *v16 & (3855 >> (4 - v31));
                            if (v18)
                            {
                                v31 = 0;
                                --v16;
                            }
                            else
                            {
                                v31 += 4;
                            }
                            if (!--v27)
                                break;
                            v17 = v33;
                        }
                    }
                    if (v30 == 4)
                    {
                        v30 = 0;
                        --v15;
                    }
                    else
                    {
                        v30 += 4;
                    }
                    ++v28;
                } while (v28 < *a1);
            }
        }
        else
        {
            v31 = 0;
            v6 = v5 >> 3;
            v7 = (char*)(a2 + v6 * (v3 - 1));
            v30 = v6;
            v32 = (char*)(a2 + v6 * (v4 - 1));
            if (v3)
            {
                do
                {
                    v8 = v30;
                    v9 = v30 >> 2;
                    qmemcpy(v26, v7, 4 * (v30 >> 2));
                    v11 = &v7[4 * v9];
                    v10 = &v26[4 * v9];
                    LOBYTE(v9) = v8;
                    v12 = v29;
                    v13 = v29 <= 0;
                    qmemcpy(v10, v11, v9 & 3);
                    if (!v13)
                    {
                        v28 = v12;
                        do
                        {
                            v14 = v32;
                            v32 -= v30;
                            qmemcpy(v14, v26, v30);
                            --v28;
                        } while (v28);
                    }
                    v7 -= v30;
                    ++v31;
                } while (v31 < *a1);
            }
        }
        v25 = (v4 * (unsigned int)*((unsigned __int8*)a1 + 11) + 7) >> 3;
        *a1 = v4;
        a1[1] = v25;
    }
}
// 49C33C: using guessed type int dword_49C33C[7];

//----- (0047DFA4) --------------------------------------------------------
char __cdecl sub_47DFA4(int a1, int a2, _BYTE* a3, unsigned __int8* a4, int a5)
{
    unsigned int v5; // eax
    _BYTE* v6; // edx
    unsigned __int8* v7; // edi
    unsigned int v8; // ecx
    int v9; // esi
    int v10; // ecx
    int v11; // esi
    int v12; // edx
    int v13; // ebx
    int v14; // eax
    bool v15; // zf
    _BYTE* v16; // esi
    unsigned __int8* v17; // edi
    unsigned int v18; // ecx
    unsigned __int8* j; // ebx
    unsigned int v20; // esi
    unsigned int i; // ecx
    unsigned int v22; // ecx
    _BYTE* v23; // esi
    _BYTE* v24; // edx
    unsigned int v25; // ecx
    int v27; // [esp+8h] [ebp-14h]
    unsigned int v28; // [esp+Ch] [ebp-10h]
    _BYTE* v29; // [esp+10h] [ebp-Ch]
    int v30; // [esp+14h] [ebp-8h]
    unsigned __int8* v31; // [esp+18h] [ebp-4h]
    unsigned __int8* v32; // [esp+34h] [ebp+18h]

    LOBYTE(v5) = a5;
    if (a5)
    {
        switch (a5)
        {
        case 1:
            v22 = *(_DWORD*)(a2 + 4);
            v5 = (*(unsigned __int8*)(a2 + 11) + 7) >> 3;
            v23 = &a3[v5];
            if (v5 < v22)
            {
                v24 = a3;
                v25 = v22 - v5;
                do
                {
                    LOBYTE(v5) = *v24;
                    *v23++ += *v24++;
                    --v25;
                } while (v25);
            }
            break;
        case 2:
            v20 = *(_DWORD*)(a2 + 4);
            v5 = (unsigned int)a3;
            for (i = 0; i < v20; ++i)
                *(_BYTE*)v5++ += a4[i];
            break;
        case 3:
            v16 = a3;
            v17 = a4;
            v5 = (*(unsigned __int8*)(a2 + 11) + 7) >> 3;
            v18 = *(_DWORD*)(a2 + 4) - v5;
            for (j = a3; v5; --v5)
                *v16++ += *v17++ >> 1;
            for (; v18; --v18)
            {
                v5 = (*v17 + *j) / 2;
                *v16 += v5;
                ++j;
                ++v17;
                ++v16;
            }
            break;
        case 4:
            v6 = a3;
            v7 = a4;
            v5 = (*(unsigned __int8*)(a2 + 11) + 7) >> 3;
            v8 = *(_DWORD*)(a2 + 4) - v5;
            v29 = a3;
            v32 = a3;
            v31 = a4;
            if (v5)
            {
                v9 = (*(unsigned __int8*)(a2 + 11) + 7) >> 3;
                do
                {
                    LOBYTE(v5) = *v7;
                    *v6++ += *v7++;
                    --v9;
                } while (v9);
                v29 = v6;
            }
            if (v8)
            {
                v28 = v8;
                do
                {
                    v10 = *v32;
                    v11 = *v31;
                    ++v32;
                    v27 = *v7++;
                    ++v31;
                    v12 = v10 - v11;
                    if (v27 - v11 >= 0)
                        v30 = v27 - v11;
                    else
                        v30 = v11 - v27;
                    v13 = v10 - v11;
                    if (v12 < 0)
                        v13 = v11 - v10;
                    v14 = v12 + v27 - v11;
                    if (v14 < 0)
                        v14 = -v14;
                    if (v30 > v13 || v30 > v14)
                    {
                        LOBYTE(v10) = v27;
                        if (v13 > v14)
                            LOBYTE(v10) = v11;
                    }
                    *v29 += v10;
                    LOBYTE(v5) = (_BYTE)v29 + 1;
                    v15 = v28-- == 1;
                    ++v29;
                } while (!v15);
            }
            break;
        default:
            sub_478B0A(a1, (int)"Ignoring bad adaptive filter type");
            LOBYTE(v5) = (_BYTE)a3;
            *a3 = 0;
            break;
        }
    }
    return v5;
}

//----- (0047E11F) --------------------------------------------------------
char* __cdecl sub_47E11F(jmp_buf Buf)
{
    unsigned int v1; // eax
    int v2; // edi
    unsigned int v3; // eax
    unsigned int v4; // ecx
    int v5; // eax
    int v6; // eax
    int v7; // ebx
    char v8; // cl
    char v9; // cl
    int v10; // ecx
    char* v11; // eax
    char* result; // eax
    unsigned int v13; // [esp-14h] [ebp-1Ch]

    Buf[26] = 0;
    sub_47A9FD(Buf);
    v1 = Buf[47];
    if (*((_BYTE*)Buf + 275))
    {
        if ((Buf[24] & 2) == 0)
            v1 = (v1 + 7) >> 3;
        v2 = Buf[46];
        Buf[48] = v1;
        v3 = (v2 - dword_49C320[*((unsigned __int8*)Buf + 276)] + dword_49C33C[*((unsigned __int8*)Buf + 276)] - 1)
            / (unsigned int)dword_49C33C[*((unsigned __int8*)Buf + 276)];
        v4 = ((v3 * *((unsigned __int8*)Buf + 281) + 7) >> 3) + 1;
        Buf[52] = v3;
        Buf[51] = v4;
    }
    else
    {
        v2 = Buf[46];
        Buf[48] = v1;
        v5 = Buf[50] + 1;
        Buf[52] = v2;
        Buf[51] = v5;
    }
    v6 = *((unsigned __int8*)Buf + 281);
    v7 = Buf[24];
    if ((v7 & 4) != 0 && *((_BYTE*)Buf + 279) < 8u)
        v6 = 8;
    if ((v7 & 0x1000) != 0)
    {
        v8 = *((_BYTE*)Buf + 278);
        if (v8 == 3)
        {
            v6 = 8 * (*((_WORD*)Buf + 133) != 0) + 24;
        }
        else if (v8)
        {
            if (v8 == 2 && *((_WORD*)Buf + 133))
                v6 = 4 * v6 / 3;
        }
        else
        {
            if (v6 < 8)
                v6 = 8;
            if (*((_WORD*)Buf + 133))
                v6 *= 2;
        }
    }
    if ((v7 & 0x8000) != 0)
    {
        v9 = *((_BYTE*)Buf + 278);
        if (v9 != 3)
        {
            if (v9)
            {
                if (v9 != 2)
                    goto LABEL_28;
                v10 = v6 > 32 ? 64 : 32;
            }
            else
            {
                v10 = v6 > 8 ? 32 : 16;
            }
            v6 = v10;
            goto LABEL_28;
        }
        v6 = 32;
    }
LABEL_28:
    Buf[55] = (int)sub_47D91C(Buf, ((v6 * ((v2 + 7) & 0xFFFFFFF8) + 7) >> 3) + ((v6 + 7) >> 3) + 1);
    v11 = (char*)sub_47D91C(Buf, Buf[50] + 1);
    v13 = Buf[50] + 1;
    Buf[54] = (int)v11;
    result = sub_47D991(v7, (int)Buf, v11, 0, v13);
    Buf[23] |= 0x40u;
    return result;
}
// 49C320: using guessed type int dword_49C320[7];
// 49C33C: using guessed type int dword_49C33C[7];

//----- (0047E2BE) --------------------------------------------------------
int __cdecl sub_47E2BE(jmp_buf Buf, unsigned int a2)
{
    unsigned int i; // edi

    for (i = Buf[40]; a2 > i; a2 -= i)
        sub_47D9E9((int)Buf, (_BYTE*)Buf[39], Buf[40]);
    if (a2)
        sub_47D9E9((int)Buf, (_BYTE*)Buf[39], a2);
    if (!sub_47DA03(Buf))
        return 0;
    if (((Buf[67] & 0x20) == 0 || (*((_BYTE*)Buf + 93) & 2) != 0)
        && ((Buf[67] & 0x20) != 0 || (*((_BYTE*)Buf + 93) & 4) == 0))
    {
        sub_478B21(Buf, "CRC error");
    }
    sub_478B46((int)Buf, "CRC error");
    return 1;
}

//----- (0047E34C) --------------------------------------------------------
void __cdecl sub_47E34C(jmp_buf Buf, int a2, int a3)
{
    signed int v4; // edi
    int v5; // eax
    char v6; // bl
    unsigned __int8 v7; // al
    char v8; // [esp-Ch] [ebp-34h]
    char v9; // [esp-8h] [ebp-30h]
    char v10; // [esp-4h] [ebp-2Ch]
    int v11; // [esp+Ch] [ebp-1Ch] BYREF
    unsigned __int8 v12[4]; // [esp+10h] [ebp-18h] BYREF
    unsigned __int8 v13; // [esp+14h] [ebp-14h]
    unsigned __int8 v14; // [esp+15h] [ebp-13h]
    unsigned __int8 v15; // [esp+16h] [ebp-12h]
    unsigned __int8 v16; // [esp+17h] [ebp-11h]
    unsigned __int8 v17; // [esp+18h] [ebp-10h]
    int v18; // [esp+1Ch] [ebp-Ch]
    int v19; // [esp+20h] [ebp-8h]
    int v20; // [esp+24h] [ebp-4h]
    int* __attribute__((__org_typedef(jmp_buf))) Bufa; // [esp+30h] [ebp+8h]
    char v22; // [esp+38h] [ebp+10h]

    if (Buf[22])
        sub_478AEB(Buf, (int)"Out of place IHDR");
    if (a3 != 13)
        sub_478AEB(Buf, (int)"Invalid IHDR chunk");
    Buf[22] |= 1u;
    sub_47D9E9((int)Buf, &v11, 0xDu);
    sub_47E2BE(Buf, 0);
    v4 = sub_47D9C3((unsigned __int8*)&v11);
    v5 = sub_47D9C3(v12);
    v6 = v13;
    Bufa = (int*)v5;
    v22 = v14;
    v18 = v15;
    v19 = v16;
    v20 = v17;
    if (v4 <= 0 || v5 <= 0)
        sub_478AEB(Buf, (int)"Invalid image size in IHDR");
    if (v13 != 1 && v13 != 2 && v13 != 4 && v13 != 8 && v13 != 16)
        sub_478AEB(Buf, (int)"Invalid bit depth in IHDR");
    if (v14 == 1 || v14 == 5 || v14 > 6u)
        sub_478AEB(Buf, (int)"Invalid color type in IHDR");
    if (v14 == 3 && v13 > 8u || (v14 == 2 || v14 == 4 || v14 == 6) && v13 < 8u)
        sub_478AEB(Buf, (int)"Invalid color type/bit depth combination in IHDR");
    if (v20 >= 2)
        sub_478AEB(Buf, (int)"Unknown interlace method in IHDR");
    if (v18)
        sub_478AEB(Buf, (int)"Unknown compression method in IHDR");
    if (v19)
        sub_478AEB(Buf, (int)"Unknown filter method in IHDR");
    *((_BYTE*)Buf + 275) = v20;
    Buf[46] = v4;
    Buf[47] = v5;
    *((_BYTE*)Buf + 279) = v6;
    *((_BYTE*)Buf + 278) = v22;
    switch (v22)
    {
    case 0:
        goto LABEL_39;
    case 2:
        *((_BYTE*)Buf + 282) = 3;
        break;
    case 3:
    LABEL_39:
        *((_BYTE*)Buf + 282) = 1;
        break;
    case 4:
        *((_BYTE*)Buf + 282) = 2;
        break;
    case 6:
        *((_BYTE*)Buf + 282) = 4;
        break;
    }
    v10 = v19;
    v7 = v6 * *((_BYTE*)Buf + 282);
    v9 = v18;
    *((_BYTE*)Buf + 281) = v7;
    v8 = v20;
    Buf[50] = (v4 * (unsigned int)v7 + 7) >> 3;
    sub_47ACCB((int)Buf, a2, v4, (int)Bufa, v6, v22, v8, v9, v10);
}
// 47E420: conditional instruction was optimized away because %arg_8.4<100u

//----- (0047E542) --------------------------------------------------------
void __cdecl sub_47E542(jmp_buf Buf, int a2, int a3)
{
    int* __attribute__((__org_typedef(jmp_buf))) v3; // esi
    int v4; // eax
    unsigned int v5; // edx
    int v6; // ebx
    char* v7; // eax
    _BYTE* v8; // edi
    int v9; // edi
    int v10; // [esp-1Ch] [ebp-28h]
    int v11; // [esp+4h] [ebp-8h]
    int v12; // [esp+8h] [ebp-4h]

    v3 = Buf;
    v4 = Buf[22];
    if ((v4 & 1) == 0)
        sub_478AEB(Buf, (int)"Missing IHDR before PLTE");
    if ((v4 & 4) != 0)
    {
        sub_478B0A((int)Buf, (int)"Invalid PLTE after IDAT");
    LABEL_10:
        sub_47E2BE(v3, a3);
        return;
    }
    if ((v4 & 2) != 0)
        sub_478AEB(Buf, (int)"Duplicate PLTE chunk");
    v5 = a3 % 3u;
    Buf[22] |= 2u;
    if (v5)
    {
        if (*((_BYTE*)v3 + 278) == 3)
            sub_478AEB(v3, (int)"Invalid palette chunk");
        sub_478B0A((int)v3, (int)"Invalid palette chunk");
        goto LABEL_10;
    }
    v6 = a3 / 3;
    v7 = sub_47AEDA(v3, a3 / 3, 3);
    *((_BYTE*)v3 + 93) |= 0x10u;
    v11 = (int)v7;
    if (v6 > 0)
    {
        v8 = v7 + 2;
        v12 = v6;
        do
        {
            sub_47D9E9((int)v3, &Buf, 3u);
            *((_WORD*)v8 - 1) = (_WORD)Buf;
            *v8 = BYTE2(Buf);
            v8 += 3;
            --v12;
        } while (v12);
    }
    sub_47E2BE(v3, 0);
    v9 = a2;
    v10 = a2;
    v3[65] = v11;
    *((_WORD*)v3 + 132) = v6;
    sub_47AD6C((int)v3, v10, v11, v6);
    if (*((_BYTE*)v3 + 278) == 3
        && v9
        && (*(_BYTE*)(v9 + 8) & 0x10) != 0
        && *((_WORD*)v3 + 133) > *((_WORD*)v3 + 132))
    {
        sub_478B0A((int)v3, (int)"Truncating incorrect tRNS chunk length");
        *((_WORD*)v3 + 133) = *((_WORD*)v3 + 132);
    }
}

//----- (0047E66C) --------------------------------------------------------
int __cdecl sub_47E66C(jmp_buf Buf, int a2, unsigned int a3)
{
    int v3; // eax

    v3 = Buf[22];
    if ((v3 & 1) == 0 || (v3 & 4) == 0)
        sub_478AEB(Buf, (int)"No image in file");
    Buf[22] |= 0x18u;
    if (a3)
        sub_478B0A((int)Buf, (int)"Incorrect IEND chunk length");
    return sub_47E2BE(Buf, a3);
}

//----- (0047E6B6) --------------------------------------------------------
void __cdecl sub_47E6B6(jmp_buf Buf, int a2, unsigned int a3)
{
    int* __attribute__((__org_typedef(jmp_buf))) v3; // esi
    int v4; // eax
    int v5; // edi
    int v6; // eax
    int v7; // eax
    double v8; // st7

    v3 = Buf;
    v4 = Buf[22];
    v5 = a2;
    if ((v4 & 1) == 0)
        sub_478AEB(Buf, (int)"Missing IHDR before gAMA");
    if ((v4 & 4) != 0)
    {
        sub_478B0A((int)Buf, (int)"Invalid gAMA after IDAT");
        goto LABEL_5;
    }
    if ((v4 & 2) != 0)
    {
        sub_478B0A((int)Buf, (int)"Out of place gAMA chunk");
    }
    else if (a2)
    {
        v6 = *(_DWORD*)(a2 + 8);
        if ((v6 & 1) != 0 && (v6 & 0x800) == 0)
        {
            sub_478B0A((int)Buf, (int)"Duplicate gAMA chunk");
            goto LABEL_5;
        }
    }
    if (a3 != 4)
    {
        sub_478B0A((int)v3, (int)"Incorrect gAMA chunk length");
    LABEL_5:
        sub_47E2BE(v3, a3);
        return;
    }
    sub_47D9E9((int)v3, &Buf, 4u);
    if (!sub_47E2BE(v3, 0))
    {
        v7 = sub_47D9C3((unsigned __int8*)&Buf);
        if (v7)
        {
            if ((*(_DWORD*)(v5 + 8) & 0x800) != 0 && fabs((double)(unsigned int)v7 - 45455.0) > 500.0)
            {
                sub_478B0A((int)v3, (int)"Ignoring incorrect gAMA value when sRGB is also present");
            }
            else
            {
                v8 = (double)(unsigned int)v7 * 0.0000099999997;
                *((float*)v3 + 76) = v8;
                sub_47ACAF((int)v3, v5, v8);
            }
        }
    }
}

//----- (0047E7C1) --------------------------------------------------------
void __cdecl sub_47E7C1(jmp_buf Buf, int a2, unsigned int a3)
{
    int* __attribute__((__org_typedef(jmp_buf))) v3; // esi
    int v4; // eax
    char v5; // di

    v3 = Buf;
    v4 = Buf[22];
    if ((v4 & 1) == 0)
        sub_478AEB(Buf, (int)"Missing IHDR before sRGB");
    if ((v4 & 4) != 0)
    {
        sub_478B0A((int)Buf, (int)"Invalid sRGB after IDAT");
        goto LABEL_5;
    }
    if ((v4 & 2) != 0)
    {
        sub_478B0A((int)Buf, (int)"Out of place sRGB chunk");
    }
    else if (a2 && (*(_BYTE*)(a2 + 9) & 8) != 0)
    {
        sub_478B0A((int)Buf, (int)"Duplicate sRGB chunk");
        goto LABEL_5;
    }
    if (a3 != 1)
    {
        sub_478B0A((int)v3, (int)"Incorrect sRGB chunk length");
    LABEL_5:
        sub_47E2BE(v3, a3);
        return;
    }
    sub_47D9E9((int)v3, (_BYTE*)&Buf + 3, 1u);
    if (!sub_47E2BE(v3, 0))
    {
        v5 = HIBYTE(Buf);
        if (HIBYTE(Buf) < 4u)
        {
            if ((*(_BYTE*)(a2 + 8) & 1) != 0 && fabs(*((float*)v3 + 76) * 100000.0 + 0.5 - 45455.0) > 500.0)
                sub_478B0A((int)v3, (int)"Ignoring incorrect gAMA value when sRGB is also present");
            sub_47ADAC((int)v3, a2, v5);
        }
        else
        {
            sub_478B0A((int)v3, (int)"Unknown sRGB intent");
        }
    }
}

//----- (0047E8B0) --------------------------------------------------------
void __cdecl sub_47E8B0(jmp_buf Buf, int a2, size_t Size)
{
    int v3; // eax
    char v4; // al
    _BYTE* v5; // eax
    __int16 v6; // cx
    __int16 v7; // ax
    __int16 v8; // cx
    unsigned __int8 v9; // [esp+Ch] [ebp-8h] BYREF
    unsigned __int8 v10; // [esp+Dh] [ebp-7h]
    unsigned __int8 v11; // [esp+Eh] [ebp-6h]
    unsigned __int8 v12; // [esp+Fh] [ebp-5h]
    unsigned __int8 v13; // [esp+10h] [ebp-4h]
    unsigned __int8 v14; // [esp+11h] [ebp-3h]

    v3 = Buf[22];
    if ((v3 & 1) == 0)
        sub_478AEB(Buf, (int)"Missing IHDR before tRNS");
    if ((v3 & 4) != 0)
    {
        sub_478B0A((int)Buf, (int)"Invalid tRNS after IDAT");
    LABEL_27:
        sub_47E2BE(Buf, Size);
        return;
    }
    if (a2 && (*(_BYTE*)(a2 + 8) & 0x10) != 0)
    {
        sub_478B0A((int)Buf, (int)"Duplicate tRNS chunk");
        goto LABEL_27;
    }
    v4 = *((_BYTE*)Buf + 278);
    if (v4 == 3)
    {
        if ((Buf[22] & 2) != 0)
        {
            if (Size > *((unsigned __int16*)Buf + 132))
            {
                sub_478B0A((int)Buf, (int)"Incorrect tRNS chunk length");
                sub_47E2BE(Buf, Size);
                return;
            }
        }
        else
        {
            sub_478B0A((int)Buf, (int)"Missing PLTE before tRNS");
        }
        if (!Size)
        {
            sub_478B0A((int)Buf, (int)"Zero length tRNS chunk");
            sub_47E2BE(Buf, 0);
            return;
        }
        v5 = sub_47D91C(Buf, Size);
        *((_BYTE*)Buf + 93) |= 0x20u;
        Buf[87] = (int)v5;
        sub_47D9E9((int)Buf, v5, Size);
        *((_WORD*)Buf + 133) = Size;
        goto LABEL_24;
    }
    if (v4 != 2)
    {
        if (v4)
        {
            sub_478B0A((int)Buf, (int)"tRNS chunk not allowed with alpha channel");
            goto LABEL_27;
        }
        if (Size == 2)
        {
            sub_47D9E9((int)Buf, &v9, 2u);
            *((_WORD*)Buf + 180) = v10 + (v9 << 8);
            goto LABEL_23;
        }
    LABEL_21:
        sub_478B0A((int)Buf, (int)"Incorrect tRNS chunk length");
        goto LABEL_27;
    }
    if (Size != 6)
        goto LABEL_21;
    sub_47D9E9((int)Buf, &v9, 6u);
    v6 = v12;
    *((_WORD*)Buf + 177) = v10 + (v9 << 8);
    v7 = v6 + (v11 << 8);
    v8 = v14;
    *((_WORD*)Buf + 178) = v7;
    *((_WORD*)Buf + 179) = v8 + (v13 << 8);
LABEL_23:
    *((_WORD*)Buf + 133) = 1;
LABEL_24:
    if (!sub_47E2BE(Buf, 0))
        sub_47ADDF((int)Buf, a2, Buf[87], *((unsigned __int16*)Buf + 133), (int)(Buf + 88));
}

//----- (0047EA58) --------------------------------------------------------
int __cdecl sub_47EA58(jmp_buf Buf, int a2, unsigned int a3)
{
    int v3; // eax

    sub_47DA61(Buf, (unsigned __int8*)Buf + 268);
    if ((Buf[67] & 0x20) == 0)
        sub_478B21(Buf, "unknown critical chunk");
    v3 = Buf[22];
    if ((v3 & 4) != 0)
        Buf[22] = v3 | 8;
    return sub_47E2BE(Buf, a3);
}

//----- (0047EAA3) --------------------------------------------------------
int __usercall sub_47EAA3@<eax>(int a1@<ebx>, jmp_buf Buf)
{
    int* __attribute__((__org_typedef(jmp_buf))) v2; // esi
    int result; // eax
    unsigned __int8 v4; // bl
    unsigned int v5; // edx
    bool v6; // zf
    unsigned int v7; // eax
    unsigned int v8; // edx
    _BYTE* v9; // ecx
    int v10; // eax
    const char* v11; // eax
    int v12; // [esp+4h] [ebp-4h] BYREF

    v2 = Buf;
    result = (int)(Buf + 53);
    ++Buf[53];
    if (*(_DWORD*)result >= (unsigned int)v2[48])
    {
        if (*((_BYTE*)v2 + 275))
        {
            *(_DWORD*)result = 0;
            sub_47D991(a1, (int)v2, (char*)v2[54], 0, v2[50] + 1);
            while (1)
            {
                v4 = ++ * ((_BYTE*)v2 + 276);
                if (v4 >= 7u)
                    break;
                result = (v2[46] - dword_49C320[v4] + dword_49C33C[v4] - 1) / (unsigned int)dword_49C33C[v4];
                v5 = ((result * (unsigned int)*((unsigned __int8*)v2 + 281) + 7) >> 3) + 1;
                v6 = (v2[24] & 2) == 0;
                v2[52] = result;
                v2[51] = v5;
                if (v6)
                {
                    result = (v2[47] - dword_49C358[v4] + dword_49C374[v4] - 1) / (unsigned int)dword_49C374[v4];
                    v6 = v2[52] == 0;
                    v2[48] = result;
                    if (v6)
                        continue;
                }
                return result;
            }
        }
        if ((v2[23] & 0x20) == 0)
        {
            v2[28] = (int)&Buf + 3;
            v2[29] = 1;
            while (1)
            {
                if (!v2[26])
                {
                    while (!v2[63])
                    {
                        sub_47E2BE(v2, 0);
                        sub_47AE26(v2, (int)&v12, 4);
                        v2[63] = sub_47D9C3((unsigned __int8*)&v12);
                        sub_47AF37((int)v2);
                        sub_47D9E9((int)v2, (_BYTE*)v2 + 268, 4u);
                        if (v2[67] != *(_DWORD*)"IDAT")
                            sub_478AEB(v2, (int)"Not enough image data");
                    }
                    v7 = v2[40];
                    v8 = v2[63];
                    v9 = (_BYTE*)v2[39];
                    v2[26] = v7;
                    v2[25] = (int)v9;
                    if (v7 > v8)
                        v2[26] = v8;
                    sub_47D9E9((int)v2, v9, v2[26]);
                    v2[63] -= v2[26];
                }
                v10 = sub_47D552(v2 + 25, 1);
                if (v10 == 1)
                    break;
                if (v10)
                {
                    v11 = (const char*)v2[31];
                    if (!v11)
                        v11 = "Decompression Error";
                    sub_478AEB(v2, (int)v11);
                }
                if (!v2[29])
                    sub_478AEB(v2, (int)"Extra compressed data");
            }
            if (!v2[29] || v2[26] || v2[63])
                sub_478AEB(v2, (int)"Extra compressed data");
            v2[22] |= 8u;
            v2[23] |= 0x20u;
            v2[29] = 0;
        }
        if (v2[63] || v2[26])
            sub_478AEB(v2, (int)"Extra compression data");
        result = sub_47D3D1(v2 + 25);
        v2[22] |= 8u;
    }
    return result;
}
// 47EB70: conditional instruction was optimized away because bl.1<7u
// 49C320: using guessed type int dword_49C320[7];
// 49C33C: using guessed type int dword_49C33C[7];
// 49C358: using guessed type int dword_49C358[];
// 49C374: using guessed type int dword_49C374[7];

//----- (0047ECCF) --------------------------------------------------------
int __cdecl sub_47ECCF(int a1, _BYTE* a2, unsigned int a3)
{
    _BYTE* v3; // edx
    unsigned int v5; // esi
    unsigned int v6; // eax
    unsigned int v7; // esi
    _BYTE* v8; // edx
    unsigned int v9; // edi
    unsigned int v10; // esi
    unsigned int v11; // edi
    unsigned int v12; // esi
    unsigned int v13; // edi
    unsigned int v14; // esi

    v3 = a2;
    if (!a2)
        return 0;
    v5 = ~a1;
    if (a3 >= 8)
    {
        v6 = a3 >> 3;
        do
        {
            a3 -= 8;
            v7 = (v5 >> 8) ^ dword_49C820[(unsigned __int8)(v5 ^ *v3)];
            v8 = v3 + 1;
            v9 = (v7 >> 8) ^ dword_49C820[(unsigned __int8)(v7 ^ *v8++)];
            v10 = (v9 >> 8) ^ dword_49C820[(unsigned __int8)(v9 ^ *v8++)];
            v11 = (v10 >> 8) ^ dword_49C820[(unsigned __int8)(v10 ^ *v8++)];
            v12 = (v11 >> 8) ^ dword_49C820[(unsigned __int8)(v11 ^ *v8++)];
            v13 = (v12 >> 8) ^ dword_49C820[(unsigned __int8)(v12 ^ *v8++)];
            v14 = (v13 >> 8) ^ dword_49C820[(unsigned __int8)(v13 ^ *v8++)];
            v5 = dword_49C820[(unsigned __int8)(v14 ^ *v8)] ^ (v14 >> 8);
            v3 = v8 + 1;
            --v6;
        } while (v6);
    }
    for (; a3; --a3)
        v5 = dword_49C820[(unsigned __int8)(v5 ^ *v3++)] ^ (v5 >> 8);
    return ~v5;
}
// 49C820: using guessed type int dword_49C820[256];

//----- (0047EDD8) --------------------------------------------------------
void* __cdecl sub_47EDD8(int a1, size_t Size)
{
    return malloc(Size);
}

//----- (0047EDE6) --------------------------------------------------------
void __cdecl sub_47EDE6(int a1, LPVOID lpMem)
{
    sub_488CEE(lpMem);
}

//----- (0047EDFC) --------------------------------------------------------
int __cdecl sub_47EDFC(int a1)
{
    *(_DWORD*)(*(_DWORD*)a1 + 20) = 48;
    return (**(int(__cdecl***)(int))a1)(a1);
}

//----- (0047EE13) --------------------------------------------------------
int sub_47EE13()
{
    return 0;
}

//----- (0047EE17) --------------------------------------------------------
int __usercall sub_47EE17@<eax>(int a1@<esi>)
{
    int v1; // ebx
    int v2; // edi
    int v3; // eax
    int result; // eax
    _DWORD* v5; // ecx
    int v6; // edi
    int v7; // eax
    int v8; // ecx
    int v9; // [esp+8h] [ebp-10h]
    int v10; // [esp+Ch] [ebp-Ch]
    _DWORD* i; // [esp+10h] [ebp-8h]
    int v12; // [esp+14h] [ebp-4h]

    v1 = *(_DWORD*)(a1 + 384);
    v2 = *(_DWORD*)(a1 + 276);
    v3 = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 8 * *(_DWORD*)(a1 + 32));
    v12 = 0;
    *(_DWORD*)(v1 + 56) = v3;
    *(_DWORD*)(v1 + 60) = v3 + 4 * *(_DWORD*)(a1 + 32);
    result = *(_DWORD*)(a1 + 196);
    if (*(int*)(a1 + 32) > 0)
    {
        v5 = (_DWORD*)(result + 12);
        v10 = v2 + 4;
        for (i = (_DWORD*)(result + 12); ; v5 = i)
        {
            v6 = *v5 * v5[6] / *(_DWORD*)(a1 + 276) * v10;
            v9 = *v5 * v5[6] / *(_DWORD*)(a1 + 276);
            i += 21;
            v7 = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 8 * v6) + 4 * v9;
            v8 = 4 * v12;
            *(_DWORD*)(v8 + *(_DWORD*)(v1 + 56)) = v7;
            ++v12;
            *(_DWORD*)(v8 + *(_DWORD*)(v1 + 60)) = v7 + 4 * v6;
            result = v12;
            if (v12 >= *(_DWORD*)(a1 + 32))
                break;
        }
    }
    return result;
}

//----- (0047EEBF) --------------------------------------------------------
int __usercall sub_47EEBF@<eax>(_DWORD* a1@<edi>)
{
    _DWORD* v1; // ebx
    int result; // eax
    _DWORD* v3; // ecx
    int v4; // eax
    int v5; // edx
    int v6; // esi
    int v7; // ecx
    _DWORD* v8; // eax
    int v9; // ecx
    int* v10; // ecx
    int v11; // edx
    _DWORD* v12; // esi
    bool v13; // zf
    _DWORD* v14; // ecx
    int* v15; // [esp+4h] [ebp-2Ch]
    _DWORD* v16; // [esp+8h] [ebp-28h]
    _DWORD* v17; // [esp+Ch] [ebp-24h]
    int v18; // [esp+10h] [ebp-20h]
    int v19; // [esp+10h] [ebp-20h]
    int v20; // [esp+14h] [ebp-1Ch]
    _DWORD* v21; // [esp+18h] [ebp-18h]
    int* v22; // [esp+1Ch] [ebp-14h]
    int v23; // [esp+20h] [ebp-10h]
    int v24; // [esp+20h] [ebp-10h]
    int v25; // [esp+24h] [ebp-Ch]
    _DWORD* v26; // [esp+28h] [ebp-8h]
    int v27; // [esp+2Ch] [ebp-4h]

    v25 = 0;
    v1 = (_DWORD*)a1[96];
    v20 = a1[69];
    result = a1[49];
    v16 = v1;
    if ((int)a1[8] > 0)
    {
        v3 = (_DWORD*)(result + 12);
        v21 = (_DWORD*)(result + 12);
        v22 = v1 + 2;
        while (1)
        {
            v4 = *v3 * v3[6] / a1[69];
            v17 = *(_DWORD**)(4 * v25 + v1[14]);
            v5 = *(_DWORD*)(4 * v25 + v1[15]);
            v6 = *v22;
            v7 = v4 * (v20 + 2);
            v18 = v4;
            if (v7 > 0)
            {
                v8 = *(_DWORD**)(4 * v25 + v1[15]);
                v23 = v7;
                do
                {
                    v9 = *(_DWORD*)((char*)v8 + v6 - v5);
                    *v8 = v9;
                    *(_DWORD*)((char*)v8++ + (_DWORD)v17 - v5) = v9;
                    --v23;
                } while (v23);
                v1 = v16;
                v4 = v18;
            }
            if (2 * v4 > 0)
            {
                v26 = (_DWORD*)(v5 + 4 * v20 * v4);
                v4 = v18;
                v15 = (int*)(v6 + 4 * v18 * (v20 - 2));
                v27 = v6 - v5;
                v24 = v5 - v6;
                v19 = 2 * v18;
                v10 = v15;
                do
                {
                    *(int*)((char*)v10 + v24) = *(_DWORD*)((char*)v26 + v27);
                    v11 = *v10;
                    v12 = v26++;
                    ++v10;
                    v13 = v19-- == 1;
                    *v12 = v11;
                } while (!v13);
            }
            if (v4 > 0)
            {
                v14 = &v17[-v4];
                do
                {
                    *v14++ = *v17;
                    --v4;
                } while (v4);
            }
            result = ++v25;
            ++v22;
            v21 += 21;
            if (v25 >= a1[8])
                break;
            v3 = v21;
        }
    }
    return result;
}

//----- (0047EFF0) --------------------------------------------------------
int __usercall sub_47EFF0@<eax>(_DWORD* a1@<edi>)
{
    int v1; // ecx
    int result; // eax
    int v3; // esi
    _DWORD* v4; // ebx
    int* v5; // edx
    int* v6; // ebx
    int* v7; // ecx
    int* v8; // eax
    int v9; // esi
    int v10; // edx
    int v11; // [esp+4h] [ebp-1Ch]
    int v12; // [esp+8h] [ebp-18h]
    int v13; // [esp+Ch] [ebp-14h]
    _DWORD* v14; // [esp+10h] [ebp-10h]
    int v15; // [esp+14h] [ebp-Ch]
    int v16; // [esp+18h] [ebp-8h]
    int* v17; // [esp+1Ch] [ebp-4h]

    v1 = a1[96];
    v16 = 0;
    result = a1[49];
    v3 = a1[69];
    v11 = v1;
    v12 = v3;
    if ((int)a1[8] > 0)
    {
        v4 = (_DWORD*)(result + 12);
        v14 = (_DWORD*)(result + 12);
        do
        {
            v15 = *v4 * v4[6] / a1[69];
            v13 = *(_DWORD*)(4 * v16 + *(_DWORD*)(v1 + 56));
            v5 = *(int**)(4 * v16 + *(_DWORD*)(v1 + 60));
            if (v15 > 0)
            {
                v6 = &v5[v15 * (v3 + 2)];
                v7 = &v5[-v15];
                v8 = &v5[v15 * (v3 + 1)];
                v17 = v5;
                v9 = v13 - (_DWORD)v5;
                do
                {
                    *(int*)((char*)v7 + v9) = *(int*)((char*)v8 + v9);
                    *v7 = *v8;
                    *(int*)((char*)v6 + v9) = *(int*)((char*)v17 + v9);
                    v10 = *v17++;
                    *v6 = v10;
                    ++v8;
                    ++v7;
                    ++v6;
                    --v15;
                } while (v15);
                v3 = v12;
                v1 = v11;
                v4 = v14;
            }
            result = ++v16;
            v4 += 21;
            v14 = v4;
        } while (v16 < a1[8]);
    }
    return result;
}

//----- (0047F0C4) --------------------------------------------------------
int __usercall sub_47F0C4@<eax>(_DWORD* a1@<esi>)
{
    int result; // eax
    int v2; // ebx
    _DWORD* v3; // edi
    int v4; // eax
    _DWORD* v5; // edx
    int v6; // [esp+4h] [ebp-Ch]
    int v7; // [esp+4h] [ebp-Ch]
    unsigned int v8; // [esp+8h] [ebp-8h]
    int v9; // [esp+Ch] [ebp-4h]

    v9 = 0;
    result = a1[49];
    v2 = a1[96];
    if ((int)a1[8] > 0)
    {
        v3 = (_DWORD*)(result + 12);
        do
        {
            v6 = *v3 * v3[6] / a1[69];
            v8 = v3[8] % (unsigned int)(*v3 * v3[6]);
            if (!v8)
                v8 = *v3 * v3[6];
            if (!v9)
                *(_DWORD*)(v2 + 72) = (int)(v8 - 1) / v6 + 1;
            if (2 * v6 > 0)
            {
                v4 = *(_DWORD*)(*(_DWORD*)(v2 + 4 * *(_DWORD*)(v2 + 64) + 56) + 4 * v9) + 4 * v8;
                v5 = (_DWORD*)v4;
                v7 = 2 * v6;
                do
                {
                    *v5++ = *(_DWORD*)(v4 - 4);
                    --v7;
                } while (v7);
            }
            result = ++v9;
            v3 += 21;
        } while (v9 < a1[8]);
    }
    return result;
}

//----- (0047F15A) --------------------------------------------------------
int __cdecl sub_47F15A(_DWORD* a1, int a2, int a3, int a4)
{
    int v5; // esi
    int result; // eax
    unsigned int v7; // [esp+10h] [ebp+8h]

    v5 = a1[96];
    if (!*(_BYTE*)(v5 + 48))
    {
        result = (*(int(__cdecl**)(_DWORD*, int))(a1[97] + 12))(a1, v5 + 8);
        if (!result)
            return result;
        *(_BYTE*)(v5 + 48) = 1;
    }
    v7 = a1[69];
    (*(void(__cdecl**)(_DWORD*, int, int, _DWORD, int, int, int))(a1[98] + 4))(a1, v5 + 8, v5 + 52, a1[69], a2, a3, a4);
    result = v7;
    if (*(_DWORD*)(v5 + 52) >= v7)
    {
        *(_BYTE*)(v5 + 48) = 0;
        *(_DWORD*)(v5 + 52) = 0;
    }
    return result;
}

//----- (0047F1C2) --------------------------------------------------------
unsigned int __cdecl sub_47F1C2(_DWORD* a1, int a2, unsigned int* a3, unsigned int a4)
{
    int v4; // ebx
    unsigned int result; // eax
    int v6; // eax
    int v7; // eax

    v4 = a1[96];
    if (!*(_BYTE*)(v4 + 48))
    {
        result = (*(int(__cdecl**)(_DWORD*, _DWORD))(a1[97] + 12))(a1, *(_DWORD*)(v4 + 4 * *(_DWORD*)(v4 + 64) + 56));
        if (!result)
            return result;
        ++*(_DWORD*)(v4 + 76);
        *(_BYTE*)(v4 + 48) = 1;
    }
    v6 = *(_DWORD*)(v4 + 68);
    if (!v6)
    {
    LABEL_9:
        *(_DWORD*)(v4 + 52) = 0;
        *(_DWORD*)(v4 + 72) = a1[69] - 1;
        if (*(_DWORD*)(v4 + 76) == a1[70])
            sub_47F0C4(a1);
        *(_DWORD*)(v4 + 68) = 1;
        goto LABEL_12;
    }
    v7 = v6 - 1;
    if (v7)
    {
        result = v7 - 1;
        if (result)
            return result;
        (*(void(__cdecl**)(_DWORD*, _DWORD, int, _DWORD, int, unsigned int*, unsigned int))(a1[98] + 4))(
            a1,
            *(_DWORD*)(v4 + 4 * *(_DWORD*)(v4 + 64) + 56),
            v4 + 52,
            *(_DWORD*)(v4 + 72),
            a2,
            a3,
            a4);
        result = *(_DWORD*)(v4 + 52);
        if (result < *(_DWORD*)(v4 + 72))
            return result;
        result = a4;
        *(_DWORD*)(v4 + 68) = 0;
        if (*a3 >= a4)
            return result;
        goto LABEL_9;
    }
LABEL_12:
    (*(void(__cdecl**)(_DWORD*, _DWORD, int, _DWORD, int, unsigned int*, unsigned int))(a1[98] + 4))(
        a1,
        *(_DWORD*)(v4 + 4 * *(_DWORD*)(v4 + 64) + 56),
        v4 + 52,
        *(_DWORD*)(v4 + 72),
        a2,
        a3,
        a4);
    result = *(_DWORD*)(v4 + 52);
    if (result >= *(_DWORD*)(v4 + 72))
    {
        if (*(_DWORD*)(v4 + 76) == 1)
            sub_47EFF0(a1);
        *(_DWORD*)(v4 + 64) ^= 1u;
        *(_BYTE*)(v4 + 48) = 0;
        *(_DWORD*)(v4 + 52) = a1[69] + 1;
        result = 2;
        *(_DWORD*)(v4 + 72) = a1[69] + 2;
        *(_DWORD*)(v4 + 68) = 2;
    }
    return result;
}

//----- (0047F2CA) --------------------------------------------------------
int __cdecl sub_47F2CA(int a1, int a2, int a3, int a4)
{
    return (*(int(__cdecl**)(int, _DWORD, _DWORD, _DWORD, int, int, int))(*(_DWORD*)(a1 + 392) + 4))(
        a1,
        0,
        0,
        0,
        a2,
        a3,
        a4);
}

//----- (0047F2ED) --------------------------------------------------------
int __cdecl sub_47F2ED(_DWORD* a1, int a2)
{
    int v2; // esi
    int result; // eax

    v2 = a1[96];
    if (a2)
    {
        result = a2 - 2;
        if (a2 == 2)
        {
            *(_DWORD*)(v2 + 4) = sub_47F2CA;
        }
        else
        {
            *(_DWORD*)(*a1 + 20) = 4;
            return (*(int(__cdecl**)(_DWORD*)) * a1)(a1);
        }
    }
    else
    {
        result = a1[103];
        if (*(_BYTE*)(result + 8))
        {
            *(_DWORD*)(v2 + 4) = sub_47F1C2;
            result = sub_47EEBF(a1);
            *(_DWORD*)(v2 + 64) = 0;
            *(_DWORD*)(v2 + 68) = 0;
            *(_DWORD*)(v2 + 76) = 0;
        }
        else
        {
            *(_DWORD*)(v2 + 4) = sub_47F15A;
        }
        *(_BYTE*)(v2 + 48) = 0;
        *(_DWORD*)(v2 + 52) = 0;
    }
    return result;
}

//----- (0047F357) --------------------------------------------------------
int __cdecl sub_47F357(int a1, char a2)
{
    _DWORD* v3; // ebx
    int result; // eax
    int v5; // ecx
    _DWORD* v6; // edi
    _DWORD* v7; // ebx
    int v8; // [esp+14h] [ebp+8h]
    int v9; // [esp+18h] [ebp+Ch]

    v3 = (_DWORD*)(**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 80);
    *(_DWORD*)(a1 + 384) = v3;
    *v3 = sub_47F2ED;
    if (a2)
    {
        *(_DWORD*)(*(_DWORD*)a1 + 20) = 4;
        (**(void(__cdecl***)(int))a1)(a1);
    }
    if (*(_BYTE*)(*(_DWORD*)(a1 + 412) + 8))
    {
        if (*(int*)(a1 + 276) < 2)
        {
            *(_DWORD*)(*(_DWORD*)a1 + 20) = 46;
            (**(void(__cdecl***)(int))a1)(a1);
        }
        result = sub_47EE17(a1);
        v5 = *(_DWORD*)(a1 + 276) + 2;
        v9 = v5;
    }
    else
    {
        result = *(_DWORD*)(a1 + 276);
        v9 = result;
        v5 = result;
    }
    v8 = 0;
    if (*(int*)(a1 + 32) > 0)
    {
        v6 = (_DWORD*)(*(_DWORD*)(a1 + 196) + 36);
        v7 = v3 + 2;
        while (1)
        {
            ++v8;
            *v7 = (*(int(__cdecl**)(int, int, int, int))(*(_DWORD*)(a1 + 4) + 8))(
                a1,
                1,
                *v6 * *(v6 - 2),
                v5 * (*v6 * *(v6 - 6) / *(_DWORD*)(a1 + 276)));
            result = v8;
            ++v7;
            v6 += 21;
            if (v8 >= *(_DWORD*)(a1 + 32))
                break;
            v5 = v9;
        }
    }
    return result;
}

//----- (0047F42A) --------------------------------------------------------
_DWORD* __thiscall sub_47F42A(_DWORD* this)
{
    _DWORD* result; // eax
    bool v2; // cf
    int v3; // ecx
    int v4; // ecx

    result = (_DWORD*)this[97];
    if ((int)this[72] <= 1)
    {
        v2 = this[32] < (unsigned int)(this[70] - 1);
        v3 = this[73];
        if (v2)
            v4 = *(_DWORD*)(v3 + 12);
        else
            v4 = *(_DWORD*)(v3 + 72);
        result[7] = v4;
    }
    else
    {
        result[7] = 1;
    }
    result[5] = 0;
    result[6] = 0;
    return result;
}

//----- (0047F469) --------------------------------------------------------
_DWORD* __cdecl sub_47F469(_DWORD* a1)
{
    a1[32] = 0;
    return sub_47F42A(a1);
}

//----- (0047F47C) --------------------------------------------------------
int __cdecl sub_47F47C(_DWORD* a1, int a2)
{
    int v3; // ebx
    unsigned int v4; // esi
    int v5; // eax
    int v6; // eax
    _DWORD* v7; // esi
    int v8; // ecx
    int v9; // ebx
    void(__cdecl * v12)(_DWORD*, _DWORD*, _DWORD, int, int); // [esp+Ch] [ebp-38h]
    unsigned int v13; // [esp+10h] [ebp-34h]
    unsigned int v14; // [esp+14h] [ebp-30h]
    int v15; // [esp+18h] [ebp-2Ch]
    int v16; // [esp+1Ch] [ebp-28h]
    _DWORD* v17; // [esp+20h] [ebp-24h]
    int v18; // [esp+24h] [ebp-20h]
    int i; // [esp+28h] [ebp-1Ch]
    int v20; // [esp+2Ch] [ebp-18h]
    _DWORD* v21; // [esp+30h] [ebp-14h]
    int v22; // [esp+34h] [ebp-10h]
    int v23; // [esp+38h] [ebp-Ch]
    int v24; // [esp+3Ch] [ebp-8h]
    int v25; // [esp+40h] [ebp-4h]
    unsigned int v26; // [esp+4Ch] [ebp+8h]

    v3 = a1[97];
    v4 = a1[77] - 1;
    v13 = a1[70] - 1;
    v5 = *(_DWORD*)(v3 + 24);
    v18 = v3;
    v14 = v4;
    while (1)
    {
        v25 = v5;
        if (v5 >= *(_DWORD*)(v3 + 28))
        {
            ++a1[34];
            if (++a1[32] >= a1[70])
            {
                (*(void(__cdecl**)(_DWORD*))(a1[99] + 12))(a1);
                return 4;
            }
            else
            {
                sub_47F42A(a1);
                return 3;
            }
        }
        v26 = *(_DWORD*)(v3 + 20);
        if (v26 <= v4)
            break;
    LABEL_24:
        *(_DWORD*)(v3 + 20) = 0;
        ++v5;
    }
    while (1)
    {
        sub_47BD68(*(void**)(v3 + 32), a1[79] << 7);
        if (!(*(unsigned __int8(__cdecl**)(_DWORD*, int))(a1[101] + 4))(a1, v3 + 32))
            break;
        v6 = 0;
        v20 = 0;
        v23 = 0;
        if ((int)a1[72] > 0)
        {
            v17 = a1 + 73;
            do
            {
                v7 = (_DWORD*)*v17;
                if (*(_BYTE*)(*v17 + 48))
                {
                    v12 = *(void(__cdecl**)(_DWORD*, _DWORD*, _DWORD, int, int))(a1[102] + 4 * v7[1] + 4);
                    if (v26 >= v14)
                        v8 = v7[17];
                    else
                        v8 = v7[13];
                    v9 = v26 * v7[16];
                    v24 = 0;
                    v16 = v8;
                    for (i = *(_DWORD*)(a2 + 4 * v23) + 4 * v25 * v7[9]; v24 < v7[14]; v20 = v6)
                    {
                        if (a1[32] < v13 || v25 + v24 < v7[18])
                        {
                            v22 = v9;
                            if (v16 > 0)
                            {
                                v21 = (_DWORD*)(v18 + 4 * v6 + 32);
                                v15 = v16;
                                do
                                {
                                    v12(a1, v7, *v21, i, v22);
                                    v22 += v7[9];
                                    ++v21;
                                    --v15;
                                } while (v15);
                                v6 = v20;
                            }
                        }
                        v6 += v7[13];
                        ++v24;
                        i += 4 * v7[9];
                    }
                    v3 = v18;
                }
                else
                {
                    v6 += v7[15];
                    v20 = v6;
                }
                ++v23;
                ++v17;
            } while (v23 < a1[72]);
            v4 = v14;
        }
        if (++v26 > v4)
        {
            v5 = v25;
            goto LABEL_24;
        }
    }
    *(_DWORD*)(v3 + 24) = v25;
    *(_DWORD*)(v3 + 20) = v26;
    return 0;
}

//----- (0047F656) --------------------------------------------------------
int sub_47F656()
{
    return 0;
}

//----- (0047F659) --------------------------------------------------------
int __cdecl sub_47F659(_DWORD* a1)
{
    _DWORD* v2; // edi
    int v3; // eax
    _DWORD* i; // eax
    unsigned int v5; // ebx
    bool v6; // cf
    bool v7; // cc
    int v8; // ecx
    int v9; // ebx
    int v10; // edx
    int* j; // ebx
    _DWORD v14[4]; // [esp+Ch] [ebp-34h]
    int* v15; // [esp+1Ch] [ebp-24h]
    int v16; // [esp+20h] [ebp-20h]
    unsigned int v17; // [esp+24h] [ebp-1Ch]
    _DWORD* v18; // [esp+28h] [ebp-18h]
    int v19; // [esp+2Ch] [ebp-14h]
    _DWORD* v20; // [esp+30h] [ebp-10h]
    int v21; // [esp+34h] [ebp-Ch]
    int v22; // [esp+38h] [ebp-8h]
    _DWORD* v23; // [esp+3Ch] [ebp-4h]
    int v24; // [esp+48h] [ebp+8h]
    int v25; // [esp+48h] [ebp+8h]

    v24 = 0;
    v2 = (_DWORD*)a1[97];
    if ((int)a1[72] > 0)
    {
        v23 = a1 + 73;
        do
        {
            v3 = (*(int(__cdecl**)(_DWORD*, _DWORD, int, _DWORD, int))(a1[1] + 32))(
                a1,
                v2[*(_DWORD*)(*v23 + 4) + 18],
                *(_DWORD*)(*v23 + 12) * a1[32],
                *(_DWORD*)(*v23 + 12),
                1);
            ++v23;
            v14[v24++] = v3;
        } while (v24 < a1[72]);
    }
    for (i = (_DWORD*)v2[6]; ; i = (_DWORD*)((char*)i + 1))
    {
        v7 = (int)i < v2[7];
        v23 = i;
        if (!v7)
        {
            if (++a1[32] >= a1[70])
            {
                (*(void(__cdecl**)(_DWORD*))(a1[99] + 12))(a1);
                return 4;
            }
            else
            {
                sub_47F42A(a1);
                return 3;
            }
        }
        v5 = v2[5];
        v6 = v5 < a1[77];
        v17 = v5;
        if (v6)
            break;
    LABEL_20:
        v2[5] = 0;
    }
    while (1)
    {
        v7 = a1[72] <= 0;
        v22 = 0;
        v25 = 0;
        if (!v7)
        {
            v18 = a1 + 73;
            do
            {
                v8 = *v18;
                v9 = *(_DWORD*)(*v18 + 52);
                v19 = 0;
                if (*(int*)(v8 + 56) > 0)
                {
                    v16 = (v17 * v9) << 7;
                    v20 = (_DWORD*)(v14[v25] + 4 * (_DWORD)v23);
                    do
                    {
                        v10 = v16 + *v20;
                        v21 = 0;
                        if (v9 > 0)
                        {
                            for (j = &v2[v22 + 8]; ; j = v15)
                            {
                                ++v22;
                                *j = v10;
                                v10 += 128;
                                ++v21;
                                v15 = j + 1;
                                v9 = *(_DWORD*)(v8 + 52);
                                if (v21 >= v9)
                                    break;
                            }
                        }
                        ++v19;
                        ++v20;
                    } while (v19 < *(_DWORD*)(v8 + 56));
                }
                ++v25;
                ++v18;
            } while (v25 < a1[72]);
            v5 = v17;
        }
        if (!(*(unsigned __int8(__cdecl**)(_DWORD*, _DWORD*))(a1[101] + 4))(a1, v2 + 8))
            break;
        v6 = ++v5 < a1[77];
        v17 = v5;
        if (!v6)
        {
            i = v23;
            goto LABEL_20;
        }
    }
    v2[6] = v23;
    v2[5] = v5;
    return 0;
}

//----- (0047F7F8) --------------------------------------------------------
int __cdecl sub_47F7F8(int a1, int a2)
{
    unsigned int v3; // ebx
    int v4; // eax
    int v5; // ecx
    int result; // eax
    int v7; // edi
    int v8; // ecx
    unsigned int v9; // eax
    int v10; // ebx
    unsigned int v11; // [esp+8h] [ebp-24h]
    void(__cdecl * v12)(int, int, int, int, int); // [esp+Ch] [ebp-20h]
    int v13; // [esp+10h] [ebp-1Ch]
    int v14; // [esp+14h] [ebp-18h]
    _DWORD* v15; // [esp+18h] [ebp-14h]
    int v16; // [esp+1Ch] [ebp-10h]
    unsigned int v17; // [esp+20h] [ebp-Ch]
    int i; // [esp+24h] [ebp-8h]
    int v19; // [esp+28h] [ebp-4h]
    int v20; // [esp+34h] [ebp+8h]
    int v21; // [esp+34h] [ebp+8h]

    v3 = *(_DWORD*)(a1 + 280) - 1;
    v20 = *(_DWORD*)(a1 + 388);
    v11 = v3;
    while (1)
    {
        v4 = *(_DWORD*)(a1 + 124);
        v5 = *(_DWORD*)(a1 + 132);
        if (v4 >= v5 && (v4 != v5 || *(_DWORD*)(a1 + 128) > *(_DWORD*)(a1 + 136)))
            break;
        result = (**(int(__cdecl***)(int))(a1 + 396))(a1);
        if (!result)
            return result;
    }
    v19 = 0;
    v7 = *(_DWORD*)(a1 + 196);
    if (*(int*)(a1 + 32) > 0)
    {
        v15 = (_DWORD*)(v20 + 72);
        do
        {
            if (*(_BYTE*)(v7 + 48))
            {
                v13 = (*(int(__cdecl**)(int, _DWORD, int, _DWORD, _DWORD))(*(_DWORD*)(a1 + 4) + 32))(
                    a1,
                    *v15,
                    *(_DWORD*)(v7 + 12) * *(_DWORD*)(a1 + 136),
                    *(_DWORD*)(v7 + 12),
                    0);
                if (*(_DWORD*)(a1 + 136) >= v3)
                {
                    v21 = *(_DWORD*)(v7 + 32) % *(_DWORD*)(v7 + 12);
                    if (!v21)
                        v21 = *(_DWORD*)(v7 + 12);
                }
                else
                {
                    v21 = *(_DWORD*)(v7 + 12);
                }
                v12 = *(void(__cdecl**)(int, int, int, int, int))(*(_DWORD*)(a1 + 408) + 4 * v19 + 4);
                v8 = 0;
                v16 = *(_DWORD*)(4 * v19 + a2);
                v14 = 0;
                if (v21 > 0)
                {
                    v9 = *(_DWORD*)(v7 + 28);
                    do
                    {
                        v10 = 0;
                        v17 = 0;
                        for (i = *(_DWORD*)(v13 + 4 * v8); v17 < v9; ++v17)
                        {
                            v12(a1, v7, i, v16, v10);
                            i += 128;
                            v10 += *(_DWORD*)(v7 + 36);
                            v9 = *(_DWORD*)(v7 + 28);
                        }
                        v16 += 4 * *(_DWORD*)(v7 + 36);
                        v8 = ++v14;
                    } while (v14 < v21);
                    v3 = v11;
                }
            }
            ++v19;
            ++v15;
            v7 += 84;
        } while (v19 < *(_DWORD*)(a1 + 32));
    }
    return 4 - (++*(_DWORD*)(a1 + 136) < *(_DWORD*)(a1 + 280));
}

//----- (0047F95E) --------------------------------------------------------
char __usercall sub_47F95E@<al>(int a1@<esi>)
{
    int v1; // edi
    _WORD** v2; // eax
    _WORD* v3; // eax
    int* v4; // eax
    _DWORD* v5; // ecx
    int v6; // edx
    int v7; // eax
    _WORD** i; // [esp+8h] [ebp-14h]
    int v10; // [esp+Ch] [ebp-10h]
    int v11; // [esp+10h] [ebp-Ch]
    int v12; // [esp+14h] [ebp-8h]
    char v13; // [esp+1Bh] [ebp-1h]

    v1 = *(_DWORD*)(a1 + 388);
    v13 = 0;
    if (*(_BYTE*)(a1 + 200) && *(_DWORD*)(a1 + 140))
    {
        if (!*(_DWORD*)(v1 + 112))
            *(_DWORD*)(v1 + 112) = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 24 * *(_DWORD*)(a1 + 32));
        v12 = *(_DWORD*)(v1 + 112);
        v10 = 0;
        if (*(int*)(a1 + 32) <= 0)
            return v13;
        v2 = (_WORD**)(*(_DWORD*)(a1 + 196) + 76);
        v11 = 0;
        for (i = v2; ; i += 21)
        {
            v3 = *v2;
            if (!v3)
                break;
            if (!*v3)
                break;
            if (!v3[1])
                break;
            if (!v3[8])
                break;
            if (!v3[16])
                break;
            if (!v3[9])
                break;
            if (!v3[2])
                break;
            v4 = (int*)(v11 + *(_DWORD*)(a1 + 140));
            if (*v4 < 0)
                break;
            v5 = v4 + 1;
            v6 = v12 - (_DWORD)v4;
            v7 = 5;
            do
            {
                *(_DWORD*)((char*)v5 + v6) = *v5;
                if (*v5)
                    v13 = 1;
                ++v5;
                --v7;
            } while (v7);
            v12 += 24;
            ++v10;
            v11 += 256;
            v2 = i + 21;
            if (v10 >= *(_DWORD*)(a1 + 32))
                return v13;
        }
    }
    return 0;
}

//----- (0047FA41) --------------------------------------------------------
int __cdecl sub_47FA41(_DWORD* a1, int a2)
{
    int v3; // eax
    bool v4; // cc
    int v5; // esi
    unsigned int v6; // ebx
    unsigned int v7; // ecx
    int v8; // eax
    int v10; // eax
    _DWORD* v11; // eax
    unsigned __int16* v12; // eax
    int v13; // ecx
    int v14; // eax
    __int16** v15; // edx
    __int16* v16; // ecx
    __int16* v17; // eax
    int v18; // edx
    int v19; // ecx
    int v20; // eax
    int v21; // edx
    int v22; // eax
    int v23; // ecx
    int v24; // eax
    int v25; // ecx
    int v26; // ecx
    int v27; // ebx
    int v28; // eax
    int v29; // edx
    int v30; // eax
    int v31; // eax
    int v32; // edx
    int v33; // ecx
    int v34; // eax
    int v35; // eax
    int v36; // ecx
    int v37; // eax
    int v38; // ecx
    int v39; // edx
    int v40; // ecx
    int v41; // eax
    int v42; // eax
    int v43; // ecx
    int v44; // eax
    int v45; // ecx
    int v46; // edx
    int v47; // ecx
    int v48; // eax
    int v49; // eax
    int v50; // ecx
    int v51; // eax
    int v52; // ecx
    int v53; // eax
    _BYTE v54[2]; // [esp+8h] [ebp-108h] BYREF
    __int16 v55; // [esp+Ah] [ebp-106h]
    __int16 v56; // [esp+Ch] [ebp-104h]
    __int16 v57; // [esp+18h] [ebp-F8h]
    __int16 v58; // [esp+1Ah] [ebp-F6h]
    __int16 v59; // [esp+28h] [ebp-E8h]
    void(__cdecl * v60)(_DWORD*, int, _BYTE*, int, int); // [esp+88h] [ebp-88h]
    unsigned int v61; // [esp+8Ch] [ebp-84h]
    int v62; // [esp+90h] [ebp-80h]
    int v63; // [esp+94h] [ebp-7Ch]
    int v64; // [esp+98h] [ebp-78h]
    unsigned int v65; // [esp+9Ch] [ebp-74h]
    int v66; // [esp+A0h] [ebp-70h]
    int v67; // [esp+A4h] [ebp-6Ch]
    int v68; // [esp+A8h] [ebp-68h]
    int i; // [esp+ACh] [ebp-64h]
    __int16* v70; // [esp+B0h] [ebp-60h]
    int v71; // [esp+B4h] [ebp-5Ch]
    __int16* v72; // [esp+B8h] [ebp-58h]
    int v73; // [esp+BCh] [ebp-54h]
    int v74; // [esp+C0h] [ebp-50h]
    int v75; // [esp+C4h] [ebp-4Ch]
    unsigned int v76; // [esp+C8h] [ebp-48h]
    int v77; // [esp+CCh] [ebp-44h]
    int v78; // [esp+D0h] [ebp-40h]
    int v79; // [esp+D4h] [ebp-3Ch]
    int v80; // [esp+D8h] [ebp-38h]
    int v81; // [esp+DCh] [ebp-34h]
    int v82; // [esp+E0h] [ebp-30h]
    int v83; // [esp+E4h] [ebp-2Ch]
    int v84; // [esp+E8h] [ebp-28h]
    int v85; // [esp+ECh] [ebp-24h]
    _DWORD* v86; // [esp+F0h] [ebp-20h]
    int v87; // [esp+F4h] [ebp-1Ch]
    int v88; // [esp+F8h] [ebp-18h]
    int v89; // [esp+FCh] [ebp-14h]
    int v90; // [esp+100h] [ebp-10h]
    __int16* v91; // [esp+104h] [ebp-Ch]
    char v92; // [esp+10Bh] [ebp-5h]
    _DWORD* v93; // [esp+10Ch] [ebp-4h]
    char v94; // [esp+11Bh] [ebp+Bh]

    v66 = a1[97];
    v61 = a1[70] - 1;
    while (a1[31] <= a1[33])
    {
        v3 = a1[99];
        if (*(_BYTE*)(v3 + 17) || a1[31] == a1[33] && a1[32] > a1[34] + (unsigned int)(a1[90] == 0))
            break;
        if (!(*(int(__cdecl**)(_DWORD*))v3)(a1))
            return 0;
    }
    v4 = a1[8] <= 0;
    v5 = a1[49];
    v74 = 0;
    if (!v4)
    {
        v67 = 0;
        v68 = -72 - v66;
        v86 = (_DWORD*)(v66 + 72);
        do
        {
            if (*(_BYTE*)(v5 + 48))
            {
                v6 = a1[34];
                v7 = *(_DWORD*)(v5 + 12);
                if (v6 >= v61)
                {
                    v90 = *(_DWORD*)(v5 + 32) % v7;
                    if (!v90)
                        v90 = v7;
                    v8 = v90;
                    v92 = 1;
                }
                else
                {
                    v90 = *(_DWORD*)(v5 + 12);
                    v8 = 2 * v7;
                    v92 = 0;
                }
                if (v6)
                {
                    v94 = 0;
                    v10 = (*(int(__cdecl**)(_DWORD*, _DWORD, unsigned int, unsigned int, _DWORD))(a1[1] + 32))(
                        a1,
                        *v86,
                        v7 * (v6 - 1),
                        v7 + v8,
                        0)
                        + 4 * *(_DWORD*)(v5 + 12);
                }
                else
                {
                    v10 = (*(int(__cdecl**)(_DWORD*, _DWORD, _DWORD, int, _DWORD))(a1[1] + 32))(a1, *v86, 0, v8, 0);
                    v94 = 1;
                }
                v64 = v10;
                v11 = (_DWORD*)(v67 + *(_DWORD*)(v66 + 112));
                v88 = 0;
                v93 = v11;
                v12 = *(unsigned __int16**)(v5 + 76);
                v87 = *v12;
                v78 = v12[1];
                v83 = v12[8];
                v75 = v12[16];
                v13 = v12[9];
                v77 = v12[2];
                v14 = v68 + a1[102];
                v81 = v13;
                v60 = *(void(__cdecl**)(_DWORD*, int, _BYTE*, int, int))((char*)v86 + v14 + 4);
                for (i = *(_DWORD*)(a2 + 4 * v74); v88 < v90; i += 4 * v53)
                {
                    v15 = (__int16**)(v64 + 4 * v88);
                    v16 = *v15;
                    v91 = *v15;
                    if (!v94 || v88)
                        v16 = *(v15 - 1);
                    if (!v92 || (v17 = v91, v88 != v90 - 1))
                        v17 = v15[1];
                    v18 = *v16;
                    v71 = 0;
                    v76 = 0;
                    v79 = v18;
                    v84 = v18;
                    v62 = v18;
                    v89 = *v91;
                    v82 = v89;
                    v73 = v89;
                    v80 = *v17;
                    v85 = v80;
                    v63 = v80;
                    v65 = *(_DWORD*)(v5 + 28) - 1;
                    v72 = v17 + 64;
                    v70 = v16 + 64;
                    do
                    {
                        sub_47BD45(v91, v54, 1);
                        if (v76 < v65)
                        {
                            v79 = *v70;
                            v89 = v91[64];
                            v80 = *v72;
                        }
                        if (v93[1] && !v55)
                        {
                            v19 = v78 << 8;
                            v20 = v78 << 7;
                            v21 = 36 * v87 * (v73 - v89);
                            if (v21 < 0)
                            {
                                v24 = (v20 - v21) / v19;
                                v25 = v93[1];
                                if (v25 > 0 && v24 >= 1 << v25)
                                    v24 = (1 << v25) - 1;
                                v22 = -v24;
                            }
                            else
                            {
                                v22 = (v21 + v20) / v19;
                                v23 = v93[1];
                                if (v23 > 0 && v22 >= 1 << v23)
                                    LOWORD(v22) = (1 << v23) - 1;
                            }
                            v55 = v22;
                        }
                        v26 = v93[2];
                        if (v26 && !v57)
                        {
                            v27 = v83 << 8;
                            v28 = v83 << 7;
                            v29 = 36 * v87 * (v84 - v85);
                            if (v29 < 0)
                            {
                                v31 = (v28 - v29) / v27;
                                if (v26 > 0 && v31 >= 1 << v26)
                                    v31 = (1 << v26) - 1;
                                v30 = -v31;
                            }
                            else
                            {
                                v30 = (v29 + v28) / v27;
                                if (v26 > 0 && v30 >= 1 << v26)
                                    LOWORD(v30) = (1 << v26) - 1;
                            }
                            v57 = v30;
                        }
                        if (v93[3] && !v59)
                        {
                            v32 = 9 * v87 * (v84 + v85 - 2 * v82);
                            v33 = v75 << 8;
                            v34 = v75 << 7;
                            if (v32 < 0)
                            {
                                v37 = (v34 - v32) / v33;
                                v38 = v93[3];
                                if (v38 > 0 && v37 >= 1 << v38)
                                    v37 = (1 << v38) - 1;
                                v35 = -v37;
                            }
                            else
                            {
                                v35 = (v32 + v34) / v33;
                                v36 = v93[3];
                                if (v36 > 0 && v35 >= 1 << v36)
                                    LOWORD(v35) = (1 << v36) - 1;
                            }
                            v59 = v35;
                        }
                        if (v93[4] && !v58)
                        {
                            v39 = 5 * v87 * (v62 + v80 - v63 - v79);
                            v40 = v81 << 8;
                            v41 = v81 << 7;
                            if (v39 < 0)
                            {
                                v44 = (v41 - v39) / v40;
                                v45 = v93[4];
                                if (v45 > 0 && v44 >= 1 << v45)
                                    v44 = (1 << v45) - 1;
                                v42 = -v44;
                            }
                            else
                            {
                                v42 = (v39 + v41) / v40;
                                v43 = v93[4];
                                if (v43 > 0 && v42 >= 1 << v43)
                                    LOWORD(v42) = (1 << v43) - 1;
                            }
                            v58 = v42;
                        }
                        if (v93[5] && !v56)
                        {
                            v46 = 9 * v87 * (v73 + v89 - 2 * v82);
                            v47 = v77 << 8;
                            v48 = v77 << 7;
                            if (v46 < 0)
                            {
                                v51 = (v48 - v46) / v47;
                                v52 = v93[5];
                                if (v52 > 0 && v51 >= 1 << v52)
                                    v51 = (1 << v52) - 1;
                                v49 = -v51;
                            }
                            else
                            {
                                v49 = (v46 + v48) / v47;
                                v50 = v93[5];
                                if (v50 > 0 && v49 >= 1 << v50)
                                    LOWORD(v49) = (1 << v50) - 1;
                            }
                            v56 = v49;
                        }
                        v60(a1, v5, v54, i, v71);
                        v91 += 64;
                        v70 += 64;
                        v72 += 64;
                        v62 = v84;
                        v84 = v79;
                        v73 = v82;
                        v82 = v89;
                        v63 = v85;
                        v85 = v80;
                        v71 += *(_DWORD*)(v5 + 36);
                        ++v76;
                    } while (v76 <= v65);
                    v53 = *(_DWORD*)(v5 + 36);
                    ++v88;
                }
            }
            ++v74;
            v67 += 24;
            ++v86;
            v5 += 84;
        } while (v74 < a1[8]);
    }
    return 4 - (++a1[34] < a1[70]);
}

//----- (0047FF6B) --------------------------------------------------------
void __cdecl sub_47FF6B(int a1)
{
    int v1; // edi

    v1 = *(_DWORD*)(a1 + 388);
    if (*(_DWORD*)(v1 + 16))
    {
        if (*(_BYTE*)(a1 + 73) && sub_47F95E(a1))
            *(_DWORD*)(v1 + 12) = sub_47FA41;
        else
            *(_DWORD*)(v1 + 12) = sub_47F7F8;
    }
    *(_DWORD*)(a1 + 136) = 0;
}

//----- (0047FFA9) --------------------------------------------------------
int __cdecl sub_47FFA9(int a1, char a2)
{
    _DWORD* v3; // ebx
    int v4; // eax
    int* v5; // edi
    int v6; // ecx
    int v7; // ebx
    int v8; // eax
    int v9; // eax
    int* v10; // ecx
    int result; // eax
    int* v12; // ecx
    int v13; // edx
    int v14; // [esp-8h] [ebp-18h]
    int v15; // [esp-4h] [ebp-14h]
    _DWORD* v16; // [esp+Ch] [ebp-4h]
    int v17; // [esp+18h] [ebp+8h]
    int* v18; // [esp+1Ch] [ebp+Ch]

    v3 = (_DWORD*)(**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 116);
    *(_DWORD*)(a1 + 388) = v3;
    v16 = v3;
    *v3 = sub_47F469;
    v3[2] = sub_47FF6B;
    v3[28] = 0;
    if (a2)
    {
        v4 = *(_DWORD*)(a1 + 196);
        v17 = 0;
        if (*(int*)(a1 + 32) > 0)
        {
            v5 = (int*)(v4 + 12);
            v18 = v3 + 18;
            do
            {
                v6 = *v5;
                if (*(_BYTE*)(a1 + 200))
                    v6 *= 3;
                v7 = *(_DWORD*)(a1 + 4);
                v15 = v6;
                v14 = sub_47BCE4(v5[5], *v5);
                v8 = sub_47BCE4(v5[4], *(v5 - 1));
                v9 = (*(int(__cdecl**)(int, int, int, int, int, int))(v7 + 20))(a1, 1, 1, v8, v14, v15);
                v10 = v18++;
                ++v17;
                *v10 = v9;
                v5 += 21;
            } while (v17 < *(_DWORD*)(a1 + 32));
            v3 = v16;
        }
        result = (int)(v3 + 18);
        v3[1] = sub_47F659;
        v3[3] = sub_47F7F8;
        v3[4] = v3 + 18;
    }
    else
    {
        result = (*(int(__cdecl**)(int, int, int))(*(_DWORD*)(a1 + 4) + 4))(a1, 1, 1280);
        v12 = v3 + 8;
        v13 = 10;
        do
        {
            *v12++ = result;
            result += 128;
            --v13;
        } while (v13);
        v3[1] = sub_47F656;
        v3[3] = sub_47F47C;
        v3[4] = 0;
    }
    return result;
}

//----- (004800A1) --------------------------------------------------------
int __cdecl sub_4800A1(int a1, int a2, int a3)
{
    _DWORD* v3; // esi
    int v4; // ebx
    int v5; // eax
    int v6; // ecx
    _BYTE* v7; // edi
    int v8; // edx
    unsigned int v9; // ecx
    int v10; // eax
    int v11; // edi
    int v12; // ecx
    int v13; // edx
    char* v14; // eax
    int v15; // eax
    int v16; // ecx
    int v17; // edx
    _DWORD* v18; // eax
    int v19; // edi
    int result; // eax
    unsigned __int8* v21; // edi
    bool v22; // cf
    int v23; // edx
    _BYTE* v24; // ebx
    int v25; // eax
    _BYTE* v26; // edi
    int* v27; // eax
    _DWORD v28[258]; // [esp+8h] [ebp-520h]
    _BYTE v29[260]; // [esp+410h] [ebp-118h] BYREF
    unsigned __int8* v30; // [esp+514h] [ebp-14h]
    int v31; // [esp+518h] [ebp-10h]
    int j; // [esp+51Ch] [ebp-Ch]
    int v33; // [esp+520h] [ebp-8h]
    int v34; // [esp+524h] [ebp-4h]
    int i; // [esp+538h] [ebp+10h]
    int v36; // [esp+538h] [ebp+10h]

    if (!*(_DWORD*)a3)
        *(_DWORD*)a3 = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1492);
    v3 = *(_DWORD**)a3;
    v4 = a2;
    v5 = 0;
    *(_DWORD*)(*(_DWORD*)a3 + 208) = a2;
    v34 = 0;
    for (i = 1; i <= 16; ++i)
    {
        v6 = *(unsigned __int8*)(i + v4);
        v33 = v6;
        if (v6 >= 1)
        {
            v7 = &v29[v5];
            LOBYTE(v4) = i;
            BYTE1(v4) = i;
            v8 = v6;
            v9 = (unsigned int)v6 >> 2;
            v10 = v4 << 16;
            LOWORD(v10) = v4;
            v4 = a2;
            memset32(v7, v10, v9);
            memset(&v7[4 * v9], v10, v8 & 3);
            v5 = v8 + v34;
            v34 += v8;
        }
    }
    v29[v5] = 0;
    v11 = v29[0];
    v12 = 0;
    v13 = 0;
    if (v29[0])
    {
        v14 = v29;
        do
        {
            v15 = *v14;
            while (v15 == v11)
            {
                v15 = (char)v29[v12 + 1];
                v28[++v12] = v13++;
            }
            v13 *= 2;
            v14 = &v29[v12];
            ++v11;
        } while (v29[v12]);
    }
    v16 = 0;
    v17 = 1;
    v18 = v3 + 18;
    do
    {
        if (*(_BYTE*)(v17 + v4))
        {
            v19 = v28[v16 + 1];
            v18[18] = v16;
            *(v18 - 17) = v19;
            v16 += *(unsigned __int8*)(v17 + v4);
            *v18 = v28[v16];
        }
        else
        {
            *v18 = -1;
        }
        ++v17;
        ++v18;
    } while (v17 <= 16);
    v34 = 0;
    v3[34] = 0xFFFFF;
    memset(v3 + 53, 0, 0x400u);
    v36 = 1;
    for (j = 7; j >= 0; --j)
    {
        result = v36;
        v21 = (unsigned __int8*)(v36 + v4);
        v22 = *(_BYTE*)(v36 + v4) == 0;
        v31 = 1;
        v30 = (unsigned __int8*)(v36 + v4);
        if (!v22)
        {
            v23 = 1 << j;
            v24 = (_BYTE*)(v34 + v4 + 17);
            do
            {
                v25 = v28[v34 + 1] << j;
                if (v23 > 0)
                {
                    v26 = (char*)v3 + v25 + 1236;
                    v27 = &v3[v25 + 53];
                    v33 = v23;
                    do
                    {
                        *v27++ = v36;
                        *v26++ = *v24;
                        --v33;
                    } while (v33);
                    v21 = v30;
                }
                ++v31;
                result = *v21;
                ++v34;
                ++v24;
            } while (v31 <= result);
            v4 = a2;
        }
        ++v36;
    }
    return result;
}

//----- (0048024B) --------------------------------------------------------
char __cdecl sub_48024B(unsigned __int8** a1, int a2, int a3, int a4)
{
    unsigned __int8* v4; // ebx
    unsigned __int8* v5; // edi
    unsigned __int8** v6; // eax
    int v7; // ecx
    unsigned __int8** v8; // eax
    unsigned __int8* v9; // ecx

    v4 = a1[1];
    v5 = *a1;
    while (1)
    {
        if (a3 >= 25)
        {
        LABEL_20:
            a1[3] = (unsigned __int8*)a2;
            a1[6] = (unsigned __int8*)a3;
            *a1 = v5;
            a1[1] = v4;
            return 1;
        }
        if (a1[2])
            goto LABEL_14;
        if (!v4)
            break;
    LABEL_6:
        v7 = *v5;
        --v4;
        ++v5;
        if (v7 != 255)
            goto LABEL_18;
        do
        {
            if (!v4)
            {
                if (!(*(unsigned __int8(__cdecl**)(unsigned __int8*))(*((_DWORD*)a1[7] + 5) + 12))(a1[7]))
                    return 0;
                v8 = (unsigned __int8**)*((_DWORD*)a1[7] + 5);
                v5 = *v8;
                v4 = v8[1];
            }
            v9 = (unsigned __int8*)*v5;
            --v4;
            ++v5;
        } while (v9 == (unsigned __int8*)255);
        if (!v9)
        {
            v7 = 255;
            goto LABEL_18;
        }
        a1[2] = v9;
    LABEL_14:
        if (a3 >= a4)
            goto LABEL_20;
        if (!*a1[8])
        {
            *(_DWORD*)(*(_DWORD*)a1[7] + 20) = 113;
            (*(void(__cdecl**)(unsigned __int8*, int))(*(_DWORD*)a1[7] + 4))(a1[7], -1);
            *a1[8] = 1;
        }
        v7 = 0;
    LABEL_18:
        a3 += 8;
        a2 = v7 | (a2 << 8);
    }
    if ((*(unsigned __int8(__cdecl**)(unsigned __int8*))(*((_DWORD*)a1[7] + 5) + 12))(a1[7]))
    {
        v6 = (unsigned __int8**)*((_DWORD*)a1[7] + 5);
        v5 = *v6;
        v4 = v6[1];
        goto LABEL_6;
    }
    return 0;
}

//----- (00480335) --------------------------------------------------------
int __cdecl sub_480335(int a1, int a2, int a3, int a4, int a5)
{
    int v5; // eax
    int v7; // edx
    int v8; // eax
    int v9; // esi
    int v10; // ebx
    int v11; // esi
    int v12; // [esp+8h] [ebp-4h]
    int* v13; // [esp+24h] [ebp+18h]

    v5 = a3;
    v12 = a5;
    if (a3 >= a5)
    {
        v7 = a2;
    }
    else
    {
        if (!sub_48024B((unsigned __int8**)a1, a2, a3, a5))
            return -1;
        v7 = *(_DWORD*)(a1 + 12);
        v5 = *(_DWORD*)(a1 + 24);
    }
    v8 = v5 - a5;
    v9 = ((1 << a5) - 1) & (v7 >> v8);
    v10 = a4;
    if (v9 > *(_DWORD*)(a4 + 4 * a5 + 68))
    {
        v13 = (int*)(a4 + 4 * a5 + 68);
        while (1)
        {
            v11 = 2 * v9;
            if (v8 < 1)
            {
                if (!sub_48024B((unsigned __int8**)a1, v7, v8, 1))
                    return -1;
                v7 = *(_DWORD*)(a1 + 12);
                v8 = *(_DWORD*)(a1 + 24);
            }
            ++v13;
            v9 = (v7 >> --v8) & 1 | v11;
            ++v12;
            if (v9 <= *v13)
            {
                v10 = a4;
                break;
            }
        }
    }
    *(_DWORD*)(a1 + 24) = v8;
    *(_DWORD*)(a1 + 12) = v7;
    if (v12 <= 16)
        return *(unsigned __int8*)(*(_DWORD*)(v10 + 208)
            + *(_DWORD*)(v10 + 4 * v12 + 140)
            - *(_DWORD*)(v10 + 4 * v12)
            + v9
            + 17);
    *(_DWORD*)(**(_DWORD**)(a1 + 28) + 20) = 114;
    (*(void(__cdecl**)(_DWORD, int))(**(_DWORD**)(a1 + 28) + 4))(*(_DWORD*)(a1 + 28), -1);
    return 0;
}

//----- (0048041F) --------------------------------------------------------
char __cdecl sub_48041F(_DWORD* a1)
{
    int v1; // esi
    char result; // al
    int v3; // edx
    _DWORD* v4; // ecx

    v1 = a1[101];
    *(_DWORD*)(a1[100] + 88) += *(_DWORD*)(v1 + 20) / 8;
    *(_DWORD*)(v1 + 20) = 0;
    result = (*(int(__cdecl**)(_DWORD*))(a1[100] + 8))(a1);
    if (result)
    {
        v3 = 0;
        if ((int)a1[72] > 0)
        {
            v4 = (_DWORD*)(v1 + 32);
            do
            {
                *v4 = 0;
                ++v3;
                ++v4;
            } while (v3 < a1[72]);
        }
        *(_DWORD*)(v1 + 48) = a1[63];
        *(_BYTE*)(v1 + 24) = 0;
        return 1;
    }
    return result;
}

//----- (0048047E) --------------------------------------------------------
char __cdecl sub_48047E(_DWORD* a1, int a2)
{
    _DWORD* v2; // ecx
    _DWORD* v3; // ebx
    char result; // al
    int v5; // eax
    unsigned __int8* v6; // edx
    int v7; // eax
    bool v8; // cc
    int v9; // eax
    int v10; // edx
    int v11; // eax
    int v12; // esi
    int v13; // edi
    int v14; // ecx
    int v15; // ecx
    int v16; // esi
    int v17; // ecx
    int v18; // esi
    int v19; // esi
    int v20; // ecx
    int* v21; // ecx
    int v22; // ecx
    int v23; // esi
    int v24; // esi
    int v25; // edi
    int v26; // edi
    int v27; // ecx
    int v28; // edi
    int v29; // esi
    __int16 v30; // cx
    int v31; // ecx
    int v32; // esi
    int v33; // esi
    int v34; // edi
    int v35; // esi
    int v36; // ecx
    int v37; // esi
    unsigned __int8* v38; // [esp+4h] [ebp-54h] BYREF
    int v39; // [esp+8h] [ebp-50h]
    int v40; // [esp+Ch] [ebp-4Ch]
    int v41; // [esp+10h] [ebp-48h]
    int v42; // [esp+1Ch] [ebp-3Ch]
    _DWORD* v43; // [esp+20h] [ebp-38h]
    _DWORD* v44; // [esp+24h] [ebp-34h]
    int v45; // [esp+2Ch] [ebp-2Ch] BYREF
    int v46; // [esp+30h] [ebp-28h]
    int v47; // [esp+34h] [ebp-24h]
    int v48; // [esp+38h] [ebp-20h]
    int v49; // [esp+3Ch] [ebp-1Ch]
    _WORD* v50; // [esp+40h] [ebp-18h]
    int v51; // [esp+44h] [ebp-14h]
    int* v52; // [esp+48h] [ebp-10h]
    int v53; // [esp+4Ch] [ebp-Ch]
    int v54; // [esp+50h] [ebp-8h]
    int i; // [esp+54h] [ebp-4h]

    v2 = a1;
    v3 = (_DWORD*)a1[101];
    if (a1[63] && !v3[12])
    {
        result = sub_48041F(a1);
        if (!result)
            return result;
        v2 = a1;
    }
    v5 = v2[5];
    v6 = *(unsigned __int8**)v5;
    v7 = *(_DWORD*)(v5 + 4);
    v53 = 0;
    v8 = v2[79] <= 0;
    v44 = v3 + 6;
    v45 = v3[8];
    v46 = v3[9];
    v39 = v7;
    v9 = v2[94];
    v47 = v3[10];
    v38 = v6;
    v10 = v3[4];
    v40 = v9;
    v11 = v3[5];
    v43 = v2;
    v48 = v3[11];
    if (v8)
        goto LABEL_66;
    v52 = v2 + 80;
    do
    {
        v50 = *(_WORD**)(a2 + 4 * v53);
        v12 = *v52;
        v13 = v2[*v52 + 73];
        i = v3[*(_DWORD*)(v13 + 20) + 13];
        v14 = v3[*(_DWORD*)(v13 + 24) + 17];
        v49 = v12;
        v51 = v13;
        v54 = v14;
        if (v11 < 8)
        {
            if (!sub_48024B(&v38, v10, v11, 0))
                return 0;
            v11 = v42;
            v10 = v41;
            if (v42 < 8)
            {
                v15 = 1;
            LABEL_14:
                v18 = sub_480335((int)&v38, v10, v11, i, v15);
                if (v18 < 0)
                    return 0;
                v10 = v41;
                v11 = v42;
                goto LABEL_16;
            }
        }
        v16 = (unsigned __int8)(v10 >> (v11 - 8));
        v17 = *(_DWORD*)(i + 4 * v16 + 212);
        if (!v17)
        {
            v15 = 9;
            goto LABEL_14;
        }
        v11 -= v17;
        v18 = *(unsigned __int8*)(v16 + i + 1236);
    LABEL_16:
        if (v18)
        {
            if (v11 < v18)
            {
                if (!sub_48024B(&v38, v10, v11, v18))
                    return 0;
                v10 = v41;
                v11 = v42;
            }
            v11 -= v18;
            i = (1 << v18) - 1;
            v19 = v18;
            v20 = (v10 >> v11) & i;
            v13 = v51;
            if (v20 >= dword_49CC20[v19])
                v18 = (v10 >> v11) & i;
            else
                v18 = v20 + dword_49CC60[v19];
        }
        if (*(_BYTE*)(v13 + 48))
        {
            v21 = &v45 + v49;
            *v21 += v18;
            *v50 = *v21;
            if (*(int*)(v13 + 36) > 1)
            {
                i = 1;
                while (1)
                {
                    if (v11 < 8)
                    {
                        if (!sub_48024B(&v38, v10, v11, 0))
                            return 0;
                        v11 = v42;
                        v10 = v41;
                        if (v42 < 8)
                            break;
                    }
                    v22 = v54;
                    v24 = (unsigned __int8)(v10 >> (v11 - 8));
                    v25 = *(_DWORD*)(v54 + 4 * v24 + 212);
                    if (!v25)
                    {
                        v23 = 9;
                        goto LABEL_33;
                    }
                    v11 -= v25;
                    v26 = *(unsigned __int8*)(v24 + v54 + 1236);
                LABEL_35:
                    v27 = v26 >> 4;
                    v28 = v26 & 0xF;
                    v49 = v28;
                    if (v28)
                    {
                        i += v27;
                        if (v11 < v28)
                        {
                            if (!sub_48024B(&v38, v10, v11, v28))
                                return 0;
                            v10 = v41;
                            v11 = v42;
                        }
                        v11 -= v28;
                        v29 = (v10 >> v11) & ((1 << v28) - 1);
                        if (v29 >= dword_49CC20[v49])
                            v30 = (v10 >> v11) & ((1 << v28) - 1);
                        else
                            v30 = v29 + dword_49CC60[v49];
                        v50[dword_49C160[i]] = v30;
                    }
                    else
                    {
                        if (v27 != 15)
                            goto LABEL_65;
                        i += 15;
                    }
                    if (++i >= 64)
                        goto LABEL_65;
                }
                v22 = v54;
                v23 = 1;
            LABEL_33:
                v26 = sub_480335((int)&v38, v10, v11, v22, v23);
                if (v26 < 0)
                    return 0;
                v10 = v41;
                v11 = v42;
                goto LABEL_35;
            }
        }
        for (i = 1; i < 64; ++i)
        {
            if (v11 >= 8)
                goto LABEL_52;
            if (!sub_48024B(&v38, v10, v11, 0))
                return 0;
            v11 = v42;
            v10 = v41;
            if (v42 >= 8)
            {
            LABEL_52:
                v31 = v54;
                v33 = (unsigned __int8)(v10 >> (v11 - 8));
                v34 = *(_DWORD*)(v54 + 4 * v33 + 212);
                if (v34)
                {
                    v35 = *(unsigned __int8*)(v33 + v54 + 1236);
                    v11 -= v34;
                    goto LABEL_57;
                }
                v32 = 9;
            }
            else
            {
                v31 = v54;
                v32 = 1;
            }
            v35 = sub_480335((int)&v38, v10, v11, v31, v32);
            if (v35 < 0)
                return 0;
            v10 = v41;
            v11 = v42;
        LABEL_57:
            v36 = v35 >> 4;
            v37 = v35 & 0xF;
            if (v37)
            {
                i += v36;
                if (v11 < v37)
                {
                    if (!sub_48024B(&v38, v10, v11, v37))
                        return 0;
                    v10 = v41;
                    v11 = v42;
                }
                v11 -= v37;
            }
            else
            {
                if (v36 != 15)
                    break;
                i += 15;
            }
        }
    LABEL_65:
        ++v53;
        v2 = a1;
        ++v52;
    } while (v53 < a1[79]);
LABEL_66:
    *(_DWORD*)v2[5] = v38;
    *(_DWORD*)(v2[5] + 4) = v39;
    v2[94] = v40;
    --v3[12];
    v3[8] = v45;
    v3[9] = v46;
    v3[10] = v47;
    v3[5] = v11;
    v3[4] = v10;
    v3[11] = v48;
    return 1;
}
// 49C160: using guessed type int dword_49C160[64];
// 49CC20: using guessed type int dword_49CC20[16];
// 49CC60: using guessed type int dword_49CC60[42];

//----- (0048084B) --------------------------------------------------------
int __cdecl sub_48084B(_DWORD* a1)
{
    int v2; // edi
    unsigned int v3; // ebx
    unsigned int v4; // eax
    int result; // eax
    unsigned int v6; // [esp+Ch] [ebp-Ch]
    int v7; // [esp+10h] [ebp-8h]
    _DWORD* v8; // [esp+14h] [ebp-4h]
    _DWORD* v9; // [esp+20h] [ebp+8h]

    v2 = a1[101];
    if (a1[90] || a1[91] != 63 || a1[92] || a1[93])
    {
        *(_DWORD*)(*a1 + 20) = 118;
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, -1);
    }
    v7 = 0;
    if ((int)a1[72] > 0)
    {
        v8 = (_DWORD*)(v2 + 32);
        v9 = a1 + 73;
        do
        {
            v3 = *(_DWORD*)(*v9 + 20);
            v4 = *(_DWORD*)(*v9 + 24);
            v6 = v4;
            if (v3 >= 4 || !a1[v3 + 40])
            {
                *(_DWORD*)(*a1 + 20) = 49;
                *(_DWORD*)(*a1 + 24) = v3;
                (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
                v4 = v6;
            }
            if (v4 >= 4 || !a1[v4 + 44])
            {
                *(_DWORD*)(*a1 + 20) = 49;
                *(_DWORD*)(*a1 + 24) = v4;
                (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
            }
            sub_4800A1((int)a1, a1[v3 + 40], v2 + 4 * v3 + 52);
            sub_4800A1((int)a1, a1[v6 + 44], v2 + 4 * v6 + 68);
            *v8 = 0;
            ++v9;
            ++v8;
            ++v7;
        } while (v7 < a1[72]);
    }
    *(_BYTE*)(v2 + 24) = 0;
    *(_DWORD*)(v2 + 20) = 0;
    *(_DWORD*)(v2 + 8) = 0;
    *(_DWORD*)(v2 + 12) = 0;
    *(_DWORD*)(v2 + 16) = 0;
    result = a1[63];
    *(_DWORD*)(v2 + 48) = result;
    return result;
}

//----- (0048097A) --------------------------------------------------------
_DWORD* __cdecl sub_48097A(int a1)
{
    _DWORD* v1; // eax
    int v2; // ecx
    _DWORD* result; // eax

    v1 = (_DWORD*)(**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 88);
    *(_DWORD*)(a1 + 404) = v1;
    v2 = 4;
    *v1 = sub_48084B;
    v1[1] = sub_48047E;
    result = v1 + 13;
    do
    {
        result[4] = 0;
        *result++ = 0;
        --v2;
    } while (v2);
    return result;
}

//----- (004809B7) --------------------------------------------------------
char __usercall sub_4809B7@<al>(_DWORD* a1@<edi>)
{
    int v1; // esi
    char result; // al
    int v3; // edx
    _DWORD* v4; // ecx

    v1 = a1[101];
    *(_DWORD*)(a1[100] + 88) += *(_DWORD*)(v1 + 20) / 8;
    *(_DWORD*)(v1 + 20) = 0;
    result = (*(int(__cdecl**)(_DWORD*))(a1[100] + 8))(a1);
    if (result)
    {
        v3 = 0;
        if ((int)a1[72] > 0)
        {
            v4 = (_DWORD*)(v1 + 36);
            do
            {
                *v4 = 0;
                ++v3;
                ++v4;
            } while (v3 < a1[72]);
        }
        *(_DWORD*)(v1 + 32) = 0;
        *(_DWORD*)(v1 + 52) = a1[63];
        *(_BYTE*)(v1 + 24) = 0;
        return 1;
    }
    return result;
}

//----- (00480A10) --------------------------------------------------------
char __cdecl sub_480A10(_DWORD* a1, int a2)
{
    bool v3; // zf
    _DWORD* v4; // eax
    int v5; // ecx
    char result; // al
    int v7; // ecx
    bool v8; // cc
    int v9; // edx
    int v10; // edi
    int v11; // eax
    int v12; // esi
    int v13; // ecx
    int v14; // esi
    int v15; // esi
    int v16; // ecx
    _DWORD* v17; // ecx
    int v18; // esi
    unsigned __int8* v19; // [esp+8h] [ebp-58h] BYREF
    int v20; // [esp+Ch] [ebp-54h]
    int v21; // [esp+10h] [ebp-50h]
    int v22; // [esp+14h] [ebp-4Ch]
    int v23; // [esp+20h] [ebp-40h]
    _DWORD* v24; // [esp+24h] [ebp-3Ch]
    _DWORD* v25; // [esp+28h] [ebp-38h]
    _DWORD v26[5]; // [esp+30h] [ebp-30h] BYREF
    _WORD* v27; // [esp+44h] [ebp-1Ch]
    int v28; // [esp+48h] [ebp-18h]
    int v29; // [esp+4Ch] [ebp-14h]
    int* v30; // [esp+50h] [ebp-10h]
    int v31; // [esp+54h] [ebp-Ch]
    _DWORD* v32; // [esp+58h] [ebp-8h]
    int v33; // [esp+5Ch] [ebp-4h]
    int v34; // [esp+68h] [ebp+8h]

    v3 = a1[63] == 0;
    v4 = (_DWORD*)a1[101];
    v5 = a1[93];
    v32 = v4;
    v28 = v5;
    if (!v3 && !v4[13])
    {
        result = sub_4809B7(a1);
        if (!result)
            return result;
        v4 = v32;
    }
    v7 = a1[5];
    v31 = 0;
    v8 = a1[79] <= 0;
    v24 = a1;
    v19 = *(unsigned __int8**)v7;
    v20 = *(_DWORD*)(v7 + 4);
    v21 = a1[94];
    v9 = v4[5];
    v34 = v4[4];
    v25 = v4 + 6;
    qmemcpy(v26, v4 + 8, sizeof(v26));
    if (!v8)
    {
        v30 = a1 + 80;
        do
        {
            v27 = *(_WORD**)(a2 + 4 * v31);
            v29 = *v30;
            v10 = v4[*(_DWORD*)(a1[v29 + 73] + 20) + 14];
            if (v9 < 8)
            {
                if (!sub_48024B(&v19, v34, v9, 0))
                    return 0;
                v9 = v23;
                v34 = v22;
                if (v23 < 8)
                {
                    v11 = 1;
                    goto LABEL_15;
                }
                v4 = v32;
            }
            v12 = (unsigned __int8)(v34 >> (v9 - 8));
            v13 = *(_DWORD*)(v10 + 4 * v12 + 212);
            if (v13)
            {
                v14 = *(unsigned __int8*)(v12 + v10 + 1236);
                v9 -= v13;
                goto LABEL_17;
            }
            v11 = 9;
        LABEL_15:
            v14 = sub_480335((int)&v19, v34, v9, v10, v11);
            if (v14 < 0)
                return 0;
            v9 = v23;
            v34 = v22;
            v4 = v32;
        LABEL_17:
            if (v14)
            {
                if (v9 < v14)
                {
                    if (!sub_48024B(&v19, v34, v9, v14))
                        return 0;
                    v9 = v23;
                    v34 = v22;
                    v4 = v32;
                }
                v9 -= v14;
                v33 = (1 << v14) - 1;
                v15 = v14;
                v16 = (v34 >> v9) & v33;
                if (v16 >= dword_49CD08[v15])
                    v14 = (v34 >> v9) & v33;
                else
                    v14 = v16 + dword_49CD48[v15];
            }
            ++v30;
            v17 = &v26[v29 + 1];
            *v17 += v14;
            v18 = *v17 << v28;
            ++v31;
            *v27 = v18;
        } while (v31 < a1[79]);
    }
    *(_DWORD*)a1[5] = v19;
    *(_DWORD*)(a1[5] + 4) = v20;
    a1[94] = v21;
    --v4[13];
    v4[4] = v34;
    v4[5] = v9;
    qmemcpy(v4 + 8, v26, 0x14u);
    return 1;
}
// 49CD08: using guessed type int dword_49CD08[];
// 49CD48: using guessed type int dword_49CD48[];

//----- (00480C0D) --------------------------------------------------------
char __cdecl sub_480C0D(_DWORD* a1, int* a2)
{
    bool v3; // zf
    _DWORD* v4; // esi
    char result; // al
    int v6; // eax
    int v7; // eax
    int v8; // ebx
    int v9; // eax
    int v10; // ecx
    int v11; // ecx
    int v12; // edx
    int v13; // ecx
    int v14; // ecx
    int v15; // edx
    int v16; // ebx
    unsigned __int8* v17; // [esp+8h] [ebp-48h] BYREF
    int v18; // [esp+Ch] [ebp-44h]
    int v19; // [esp+10h] [ebp-40h]
    int v20; // [esp+14h] [ebp-3Ch]
    int v21; // [esp+20h] [ebp-30h]
    _DWORD* v22; // [esp+24h] [ebp-2Ch]
    _DWORD* v23; // [esp+28h] [ebp-28h]
    int v24; // [esp+30h] [ebp-20h]
    int v25; // [esp+34h] [ebp-1Ch]
    int v26; // [esp+38h] [ebp-18h]
    int v27; // [esp+3Ch] [ebp-14h]
    int v28; // [esp+40h] [ebp-10h]
    int v29; // [esp+44h] [ebp-Ch]
    int v30; // [esp+48h] [ebp-8h]
    int v31; // [esp+4Ch] [ebp-4h]
    int v32; // [esp+58h] [ebp+8h]
    int v33; // [esp+58h] [ebp+8h]
    int v34; // [esp+58h] [ebp+8h]

    v3 = a1[63] == 0;
    v4 = (_DWORD*)a1[101];
    v26 = a1[91];
    v25 = a1[93];
    if (!v3 && !v4[13])
    {
        result = sub_4809B7(a1);
        if (!result)
            return result;
    }
    v30 = v4[8];
    if (v30)
    {
        v6 = v30 - 1;
        goto LABEL_37;
    }
    v7 = a1[5];
    v22 = a1;
    v17 = *(unsigned __int8**)v7;
    v18 = *(_DWORD*)(v7 + 4);
    v19 = a1[94];
    v8 = v4[4];
    v9 = v4[5];
    v23 = v4 + 6;
    v24 = *a2;
    v27 = v4[18];
    v10 = a1[90];
    v29 = v8;
    v31 = v10;
    while (v10 <= v26)
    {
        if (v9 >= 8)
            goto LABEL_11;
        if (!sub_48024B(&v17, v8, v9, 0))
            return 0;
        v9 = v21;
        v8 = v20;
        v29 = v20;
        if (v21 >= 8)
        {
        LABEL_11:
            v12 = (unsigned __int8)(v8 >> (v9 - 8));
            v13 = *(_DWORD*)(v27 + 4 * v12 + 212);
            if (v13)
            {
                v9 -= v13;
                v32 = *(unsigned __int8*)(v12 + v27 + 1236);
                goto LABEL_16;
            }
            v11 = 9;
        }
        else
        {
            v11 = 1;
        }
        v32 = sub_480335((int)&v17, v8, v9, v27, v11);
        if (v32 < 0)
            return 0;
        v8 = v20;
        v9 = v21;
        v29 = v20;
    LABEL_16:
        v14 = v32 >> 4;
        v3 = (v32 & 0xF) == 0;
        v33 = v32 & 0xF;
        v28 = v14;
        if (v3)
        {
            if (v14 != 15)
            {
                v34 = 1 << v14;
                v30 = 1 << v14;
                if (v28)
                {
                    if (v9 < v28)
                    {
                        if (!sub_48024B(&v17, v8, v9, v28))
                            return 0;
                        v8 = v20;
                        v9 = v21;
                    }
                    v9 -= v28;
                    v30 += (v34 - 1) & (v8 >> v9);
                }
                --v30;
                break;
            }
            v31 += 15;
        }
        else
        {
            v31 += v14;
            if (v9 < v33)
            {
                if (!sub_48024B(&v17, v8, v9, v33))
                    return 0;
                v8 = v20;
                v9 = v21;
                v29 = v20;
            }
            v9 -= v33;
            v15 = (v8 >> v9) & ((1 << v33) - 1);
            if (v15 >= dword_49CD08[v33])
                v16 = (v8 >> v9) & ((1 << v33) - 1);
            else
                v16 = v15 + dword_49CD48[v33];
            *(_WORD*)(v24 + 2 * dword_49C160[v31]) = v16 << v25;
            v8 = v29;
        }
        v10 = ++v31;
    }
    *(_DWORD*)a1[5] = v17;
    *(_DWORD*)(a1[5] + 4) = v18;
    a1[94] = v19;
    v4[5] = v9;
    v6 = v30;
    v4[4] = v8;
LABEL_37:
    --v4[13];
    v4[8] = v6;
    return 1;
}
// 49C160: using guessed type int dword_49C160[64];
// 49CD08: using guessed type int dword_49CD08[16];
// 49CD48: using guessed type int dword_49CD48[16];

//----- (00480E36) --------------------------------------------------------
char __cdecl sub_480E36(_DWORD* a1, int a2)
{
    _DWORD* v3; // esi
    bool v4; // zf
    bool v5; // cc
    int v6; // eax
    int v7; // eax
    int v8; // ecx
    _WORD* v9; // ebx
    unsigned __int8* v11; // [esp+Ch] [ebp-2Ch] BYREF
    int v12; // [esp+10h] [ebp-28h]
    int v13; // [esp+14h] [ebp-24h]
    int v14; // [esp+18h] [ebp-20h]
    int v15; // [esp+24h] [ebp-14h]
    _DWORD* v16; // [esp+28h] [ebp-10h]
    _DWORD* v17; // [esp+2Ch] [ebp-Ch]
    int v18; // [esp+34h] [ebp-4h]
    int v19; // [esp+40h] [ebp+8h]

    v3 = (_DWORD*)a1[101];
    v4 = a1[63] == 0;
    v18 = 1 << a1[93];
    if (!v4 && !v3[13] && !sub_4809B7(a1))
        return 0;
    v5 = a1[79] <= 0;
    v6 = a1[5];
    v16 = a1;
    v11 = *(unsigned __int8**)v6;
    v12 = *(_DWORD*)(v6 + 4);
    v13 = a1[94];
    v7 = v3[4];
    v8 = v3[5];
    v17 = v3 + 6;
    v19 = 0;
    if (!v5)
    {
        do
        {
            v9 = *(_WORD**)(a2 + 4 * v19);
            if (v8 < 1)
            {
                if (!sub_48024B(&v11, v7, v8, 1))
                    return 0;
                v7 = v14;
                v8 = v15;
            }
            if (((v7 >> --v8) & 1) != 0)
                *v9 |= v18;
            ++v19;
        } while (v19 < a1[79]);
    }
    *(_DWORD*)a1[5] = v11;
    *(_DWORD*)(a1[5] + 4) = v12;
    a1[94] = v13;
    --v3[13];
    v3[4] = v7;
    v3[5] = v8;
    return 1;
}

//----- (00480F18) --------------------------------------------------------
char __cdecl sub_480F18(_DWORD* a1, int* a2)
{
    int v3; // ecx
    _DWORD* v4; // esi
    bool v5; // zf
    char result; // al
    int v7; // eax
    int v8; // ebx
    int v9; // ecx
    int v10; // eax
    int v11; // eax
    int v12; // eax
    int v13; // ecx
    int v14; // ecx
    int v15; // eax
    int v16; // ecx
    __int16* v17; // eax
    __int16 v18; // dx
    int v19; // eax
    int v20; // ecx
    int v21; // eax
    int i; // eax
    __int16* v23; // eax
    __int16 v24; // dx
    int j; // eax
    int v26; // ecx
    _DWORD v27[65]; // [esp+4h] [ebp-158h]
    unsigned __int8* v28; // [esp+108h] [ebp-54h] BYREF
    int v29; // [esp+10Ch] [ebp-50h]
    int v30; // [esp+110h] [ebp-4Ch]
    int v31; // [esp+114h] [ebp-48h]
    int v32; // [esp+120h] [ebp-3Ch]
    _DWORD* v33; // [esp+124h] [ebp-38h]
    _DWORD* v34; // [esp+128h] [ebp-34h]
    int v35; // [esp+130h] [ebp-2Ch]
    int v36; // [esp+134h] [ebp-28h]
    __int16* v37; // [esp+138h] [ebp-24h]
    int v38; // [esp+13Ch] [ebp-20h]
    int v39; // [esp+140h] [ebp-1Ch]
    int v40; // [esp+144h] [ebp-18h]
    int v41; // [esp+148h] [ebp-14h]
    int v42; // [esp+14Ch] [ebp-10h]
    int v43; // [esp+150h] [ebp-Ch]
    int v44; // [esp+154h] [ebp-8h]
    int v45; // [esp+158h] [ebp-4h]
    int v46; // [esp+164h] [ebp+8h]

    v3 = a1[93];
    v4 = (_DWORD*)a1[101];
    v42 = a1[91];
    v36 = 1 << v3;
    v5 = a1[63] == 0;
    v35 = -1 << v3;
    if (!v5 && !v4[13])
    {
        result = sub_4809B7(a1);
        if (!result)
            return result;
    }
    v7 = a1[5];
    v40 = 0;
    v33 = a1;
    v28 = *(unsigned __int8**)v7;
    v29 = *(_DWORD*)(v7 + 4);
    v30 = a1[94];
    v46 = v4[4];
    v8 = v4[5];
    v34 = v4 + 6;
    v9 = v4[8];
    v41 = *a2;
    v39 = v4[18];
    v10 = a1[90];
    v43 = v9;
    v45 = v10;
    if (v9)
    {
    LABEL_47:
        if (v43)
        {
            for (i = v45; i <= v42; i = ++v45)
            {
                v23 = (__int16*)(v41 + 2 * dword_49C160[i]);
                v5 = *v23 == 0;
                v37 = v23;
                if (!v5)
                {
                    if (v8 < 1)
                    {
                        if (!sub_48024B(&v28, v46, v8, 1))
                            goto LABEL_63;
                        v8 = v32;
                        v46 = v31;
                        v23 = v37;
                    }
                    if (((v46 >> --v8) & 1) != 0)
                    {
                        v24 = v36;
                        if ((*v23 & v36) == 0)
                        {
                            if (*v23 < 0)
                                v24 = v35;
                            *v23 += v24;
                        }
                    }
                }
            }
            --v43;
        }
    LABEL_61:
        *(_DWORD*)a1[5] = v28;
        *(_DWORD*)(a1[5] + 4) = v29;
        a1[94] = v30;
        --v4[13];
        v4[4] = v46;
        v4[8] = v43;
        v4[5] = v8;
        return 1;
    }
    while (1)
    {
        if (v10 > v42)
            goto LABEL_61;
        if (v8 >= 8)
            goto LABEL_10;
        if (!sub_48024B(&v28, v46, v8, 0))
            goto LABEL_63;
        v8 = v32;
        v46 = v31;
        if (v32 >= 8)
        {
        LABEL_10:
            v12 = (unsigned __int8)(v46 >> (v8 - 8));
            v13 = *(_DWORD*)(v39 + 4 * v12 + 212);
            if (v13)
            {
                v8 -= v13;
                v44 = *(unsigned __int8*)(v12 + v39 + 1236);
                goto LABEL_15;
            }
            v11 = 9;
        }
        else
        {
            v11 = 1;
        }
        v44 = sub_480335((int)&v28, v46, v8, v39, v11);
        if (v44 < 0)
            goto LABEL_63;
        v8 = v32;
        v46 = v31;
    LABEL_15:
        v14 = v44 >> 4;
        v5 = (v44 & 0xF) == 0;
        v44 &= 0xFu;
        v38 = v14;
        if (v5)
            break;
        if (v44 != 1)
        {
            *(_DWORD*)(*a1 + 20) = 114;
            (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, -1);
        }
        if (v8 < 1)
        {
            if (!sub_48024B(&v28, v46, v8, 1))
                goto LABEL_63;
            v8 = v32;
            v46 = v31;
        }
        --v8;
        v15 = v36;
        if (((v46 >> v8) & 1) == 0)
            v15 = v35;
        v44 = v15;
    LABEL_25:
        v16 = v45;
        do
        {
            v17 = (__int16*)(v41 + 2 * dword_49C160[v16]);
            v5 = *v17 == 0;
            v37 = v17;
            if (v5)
            {
                if (--v38 < 0)
                    break;
            }
            else
            {
                if (v8 < 1)
                {
                    if (!sub_48024B(&v28, v46, v8, 1))
                        goto LABEL_63;
                    v8 = v32;
                    v46 = v31;
                    v17 = v37;
                }
                if (((v46 >> --v8) & 1) != 0)
                {
                    v18 = v36;
                    if ((*v17 & v36) == 0)
                    {
                        if (*v17 < 0)
                            v18 = v35;
                        *v17 += v18;
                    }
                }
            }
            v16 = ++v45;
        } while (v45 <= v42);
        if (v44)
        {
            v19 = dword_49C160[v16];
            *(_WORD*)(v41 + 2 * v19) = v44;
            v20 = v40++;
            v27[v20 + 1] = v19;
        }
        v10 = ++v45;
    }
    if (v14 == 15)
        goto LABEL_25;
    v21 = 1 << v14;
    v39 = 1 << v14;
    v43 = 1 << v14;
    if (!v14)
        goto LABEL_47;
    if (v8 >= v14)
        goto LABEL_46;
    if (sub_48024B(&v28, v46, v8, v14))
    {
        v8 = v32;
        v46 = v31;
        v21 = v39;
    LABEL_46:
        v8 -= v38;
        v43 += (v21 - 1) & (v46 >> v8);
        goto LABEL_47;
    }
LABEL_63:
    for (j = v40; j > 0; --j)
    {
        v26 = v27[j];
        *(_WORD*)(v41 + 2 * v26) = 0;
    }
    return 0;
}
// 49C160: using guessed type int dword_49C160[64];

//----- (00481286) --------------------------------------------------------
int __cdecl sub_481286(int* a1)
{
    int v2; // eax
    int v3; // ebx
    char v4; // dl
    bool v5; // zf
    int v6; // ecx
    int v7; // eax
    int v8; // eax
    int* v9; // ebx
    int i; // edi
    int v11; // ecx
    int v12; // eax
    unsigned int v13; // edi
    unsigned int v14; // edi
    _DWORD* v15; // eax
    int result; // eax
    int v17; // [esp+10h] [ebp-10h]
    _DWORD* v18; // [esp+10h] [ebp-10h]
    _DWORD* v19; // [esp+14h] [ebp-Ch]
    int* v20; // [esp+14h] [ebp-Ch]
    int v21; // [esp+18h] [ebp-8h]
    int v22; // [esp+1Ch] [ebp-4h]
    int v23; // [esp+1Ch] [ebp-4h]
    bool v24; // [esp+2Bh] [ebp+Bh]

    v2 = a1[90];
    v3 = a1[101];
    v24 = v2 == 0;
    v4 = 0;
    v21 = v3;
    if (v2)
    {
        v6 = a1[91];
        if (v2 > v6 || v6 >= 64)
            v4 = 1;
        v5 = a1[72] == 1;
    }
    else
    {
        v5 = a1[91] == 0;
    }
    if (!v5)
        v4 = 1;
    v7 = a1[92];
    if (v7 && a1[93] != v7 - 1)
        v4 = 1;
    if (a1[93] > 13)
        v4 = 1;
    if (v4)
    {
        *(_DWORD*)(*a1 + 20) = 14;
        *(_DWORD*)(*a1 + 24) = a1[90];
        *(_DWORD*)(*a1 + 28) = a1[91];
        *(_DWORD*)(*a1 + 32) = a1[92];
        *(_DWORD*)(*a1 + 36) = a1[93];
        (*(void(__cdecl**)(int*)) * a1)(a1);
    }
    v22 = 0;
    if (a1[72] > 0)
    {
        v19 = a1 + 73;
        do
        {
            v8 = *(_DWORD*)(*v19 + 4);
            v9 = (int*)(a1[35] + (v8 << 8));
            v17 = v8;
            if (!v24 && *v9 < 0)
            {
                *(_DWORD*)(*a1 + 20) = 111;
                *(_DWORD*)(*a1 + 24) = v8;
                *(_DWORD*)(*a1 + 28) = 0;
                (*(void(__cdecl**)(int*, int))(*a1 + 4))(a1, -1);
                v8 = v17;
            }
            for (i = a1[90]; i <= a1[91]; ++i)
            {
                v11 = v9[i];
                if (v11 < 0)
                    v11 = 0;
                if (a1[92] != v11)
                {
                    *(_DWORD*)(*a1 + 20) = 111;
                    *(_DWORD*)(*a1 + 24) = v8;
                    *(_DWORD*)(*a1 + 28) = i;
                    (*(void(__cdecl**)(int*, int))(*a1 + 4))(a1, -1);
                    v8 = v17;
                }
                v9[i] = a1[93];
            }
            ++v22;
            ++v19;
        } while (v22 < a1[72]);
        v3 = v21;
    }
    if (a1[92])
    {
        if (v24)
            *(_DWORD*)(v3 + 4) = sub_480E36;
        else
            *(_DWORD*)(v3 + 4) = sub_480F18;
    }
    else if (v24)
    {
        *(_DWORD*)(v3 + 4) = sub_480A10;
    }
    else
    {
        *(_DWORD*)(v3 + 4) = sub_480C0D;
    }
    v23 = 0;
    if (a1[72] > 0)
    {
        v18 = (_DWORD*)(v3 + 36);
        v20 = a1 + 73;
        while (1)
        {
            v12 = *v20;
            if (!v24)
                break;
            if (!a1[92])
            {
                v13 = *(_DWORD*)(v12 + 20);
                if (v13 >= 4 || !a1[v13 + 40])
                {
                    *(_DWORD*)(*a1 + 20) = 49;
                    *(_DWORD*)(*a1 + 24) = v13;
                    (*(void(__cdecl**)(int*)) * a1)(a1);
                }
                sub_4800A1((int)a1, a1[v13 + 40], v21 + 4 * v13 + 56);
            LABEL_49:
                v3 = v21;
            }
            v15 = v18;
            ++v23;
            ++v20;
            ++v18;
            *v15 = 0;
            if (v23 >= a1[72])
                goto LABEL_51;
        }
        v14 = *(_DWORD*)(v12 + 24);
        if (v14 >= 4 || !a1[v14 + 44])
        {
            *(_DWORD*)(*a1 + 20) = 49;
            *(_DWORD*)(*a1 + 24) = v14;
            (*(void(__cdecl**)(int*)) * a1)(a1);
        }
        sub_4800A1((int)a1, a1[v14 + 44], v21 + 4 * v14 + 56);
        *(_DWORD*)(v21 + 72) = *(_DWORD*)(v21 + 4 * v14 + 56);
        goto LABEL_49;
    }
LABEL_51:
    *(_BYTE*)(v3 + 24) = 0;
    *(_DWORD*)(v3 + 20) = 0;
    *(_DWORD*)(v3 + 16) = 0;
    *(_DWORD*)(v3 + 32) = 0;
    result = a1[63];
    *(_DWORD*)(v3 + 52) = result;
    return result;
}

//----- (00481529) --------------------------------------------------------
int __cdecl sub_481529(int a1)
{
    int(__cdecl * *v1)(int*); // eax
    int result; // eax
    int v3; // edx
    bool v4; // cc
    char* v5; // ebx
    void* v6; // edi

    v1 = (int(__cdecl**)(int*))(**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 80);
    *(_DWORD*)(a1 + 404) = v1;
    *v1 = sub_481286;
    v1[14] = 0;
    v1[15] = 0;
    v1[16] = 0;
    v1[17] = 0;
    result = (**(int(__cdecl***)(int, int, _DWORD))(a1 + 4))(a1, 1, *(_DWORD*)(a1 + 32) << 8);
    v3 = 0;
    v4 = *(_DWORD*)(a1 + 32) <= 0;
    *(_DWORD*)(a1 + 140) = result;
    v5 = (char*)result;
    if (!v4)
    {
        do
        {
            result = -1;
            v6 = v5;
            v5 += 256;
            ++v3;
            memset(v6, 0xFFu, 0x100u);
        } while (v3 < *(_DWORD*)(a1 + 32));
    }
    return result;
}

//----- (0048158D) --------------------------------------------------------
int __cdecl sub_48158D(_DWORD* a1)
{
    bool v2; // cc
    int result; // eax
    int v4; // edi
    int* v5; // ebx
    int v6; // edi
    int v7; // eax
    int v8; // eax
    int v9; // edx
    int v10; // edx
    int v11; // eax
    double* v12; // ecx
    double v13; // st7
    __int16* v14; // eax
    int v15; // edx
    _WORD* v16; // eax
    int v17; // ecx
    int v18; // edx
    int v19; // [esp+Ch] [ebp-14h]
    int i; // [esp+10h] [ebp-10h]
    int v21; // [esp+14h] [ebp-Ch]
    double* v22; // [esp+18h] [ebp-8h]
    int v23; // [esp+18h] [ebp-8h]
    int v24; // [esp+1Ch] [ebp-4h]
    void* v25; // [esp+28h] [ebp+8h]

    v2 = a1[8] <= 0;
    result = a1[102];
    v4 = a1[49];
    v24 = 0;
    v25 = 0;
    v21 = 0;
    if (!v2)
    {
        v5 = (int*)(result + 44);
        v6 = v4 + 36;
        for (i = result + 44; ; i += 4)
        {
            if (*(_DWORD*)v6 == 1)
            {
                v25 = sub_48559A;
                goto LABEL_19;
            }
            if (*(_DWORD*)v6 == 2)
            {
                v25 = sub_4853DC;
                goto LABEL_19;
            }
            if (*(_DWORD*)v6 == 4)
                break;
            if (*(_DWORD*)v6 != 8)
            {
                *(_DWORD*)(*a1 + 20) = 6;
                *(_DWORD*)(*a1 + 24) = *(_DWORD*)v6;
            LABEL_12:
                (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
                goto LABEL_20;
            }
            v7 = a1[17];
            if (!v7)
            {
                v25 = sub_4855D7;
            LABEL_19:
                v24 = 0;
                goto LABEL_20;
            }
            v8 = v7 - 1;
            if (v8)
            {
                if (v8 != 1)
                {
                    *(_DWORD*)(*a1 + 20) = 47;
                    goto LABEL_12;
                }
                v25 = sub_48566F;
                v24 = 2;
            }
            else
            {
                v25 = sub_485623;
                v24 = 1;
            }
        LABEL_20:
            *(v5 - 10) = (int)v25;
            if (*(_BYTE*)(v6 + 12))
            {
                if (*v5 != v24)
                {
                    v9 = *(_DWORD*)(v6 + 40);
                    v19 = v9;
                    if (v9)
                    {
                        *v5 = v24;
                        if (v24)
                        {
                            if (v24 == 1)
                            {
                                v14 = (__int16*)&unk_49CD88;
                                v15 = v9 - (_DWORD)&unk_49CD88;
                                v23 = *(_DWORD*)(v6 + 44) - (_DWORD)&unk_49CD88;
                                do
                                {
                                    *(__int16*)((char*)v14 + v23) = (*v14 * *(__int16*)((char*)v14 + v15) + 2048) >> 12;
                                    ++v14;
                                } while ((int)v14 < (int)word_49CE08);
                            }
                            else
                            {
                                v10 = *(_DWORD*)(v6 + 44);
                                v11 = 0;
                                v22 = (double*)word_49CE08;
                                do
                                {
                                    v12 = (double*)word_49CE08;
                                    do
                                    {
                                        v13 = (double)*(unsigned __int16*)(v19 + 2 * v11) * *v12++;
                                        *(float*)(v10 + 4 * v11++) = v13 * *v22;
                                    } while ((int)v12 < (int)dbl_49CE48);
                                    ++v22;
                                } while ((int)v22 < (int)dbl_49CE48);
                            }
                        }
                        else
                        {
                            v16 = *(_WORD**)(v6 + 44);
                            v17 = v9 - (_DWORD)v16;
                            v18 = 64;
                            do
                            {
                                *v16 = *(_WORD*)((char*)v16 + v17);
                                ++v16;
                                --v18;
                            } while (v18);
                        }
                    }
                }
            }
            result = ++v21;
            v5 = (int*)(i + 4);
            v6 += 84;
            if (v21 >= a1[8])
                return result;
        }
        v25 = sub_4850C7;
        goto LABEL_19;
    }
    return result;
}
// 481683: conditional instruction was optimized away because %var_4.4==2
// 49CE08: using guessed type __int16 word_49CE08[32];
// 49CE48: using guessed type double dbl_49CE48[32];

//----- (00481744) --------------------------------------------------------
_DWORD* __cdecl sub_481744(int a1)
{
    _DWORD* result; // eax
    _DWORD* v3; // ebx
    void* v4; // edi
    _DWORD* v5; // eax
    int v6; // [esp+4h] [ebp-4h]
    int v7; // [esp+10h] [ebp+8h]

    result = (_DWORD*)(**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 84);
    v6 = 0;
    *(_DWORD*)(a1 + 408) = result;
    *result = sub_48158D;
    if (*(int*)(a1 + 32) > 0)
    {
        v7 = *(_DWORD*)(a1 + 196) + 80;
        v3 = result + 11;
        do
        {
            v4 = (void*)(**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 256);
            v5 = (_DWORD*)v7;
            v7 += 84;
            *v5 = v4;
            memset(v4, 0, 0x100u);
            *v3 = -1;
            result = (_DWORD*)++v6;
            ++v3;
        } while (v6 < *(_DWORD*)(a1 + 32));
    }
    return result;
}

//----- (004817B8) --------------------------------------------------------
int __cdecl sub_4817B8(int a1, int a2, int a3, int a4, int a5, _DWORD* a6, int a7)
{
    int v7; // ebx
    int v8; // esi
    _DWORD* v9; // edi
    unsigned int v10; // eax
    int result; // eax

    v7 = a1;
    v8 = *(_DWORD*)(a1 + 392);
    v9 = a6;
    v10 = a7 - *a6;
    if (v10 > *(_DWORD*)(v8 + 16))
        v10 = *(_DWORD*)(v8 + 16);
    a1 = 0;
    (*(void(__cdecl**)(int, int, int, int, _DWORD, int*, unsigned int))(*(_DWORD*)(v7 + 412) + 4))(
        v7,
        a2,
        a3,
        a4,
        *(_DWORD*)(v8 + 12),
        &a1,
        v10);
    (*(void(__cdecl**)(int, _DWORD, int, int))(*(_DWORD*)(v7 + 420) + 4))(v7, *(_DWORD*)(v8 + 12), a5 + 4 * *v9, a1);
    result = a1;
    *v9 += a1;
    return result;
}

//----- (0048181D) --------------------------------------------------------
unsigned int __cdecl sub_48181D(_DWORD* a1, int a2, int a3, int a4, int a5, _DWORD* a6)
{
    _DWORD* v7; // esi
    unsigned int* v8; // edi
    unsigned int v9; // ecx
    unsigned int result; // eax
    unsigned int v11; // [esp+14h] [ebp+8h]
    unsigned int v12; // [esp+14h] [ebp+8h]

    v7 = (_DWORD*)a1[98];
    v8 = v7 + 6;
    if (!v7[6])
        v7[3] = (*(int(__cdecl**)(_DWORD*, _DWORD, _DWORD, _DWORD, int))(a1[1] + 28))(a1, v7[2], v7[5], v7[4], 1);
    v11 = *v8;
    (*(void(__cdecl**)(_DWORD*, int, int, int, _DWORD, _DWORD*, _DWORD))(a1[103] + 4))(
        a1,
        a2,
        a3,
        a4,
        v7[3],
        v7 + 6,
        v7[4]);
    v9 = v11;
    if (*v8 > v11)
    {
        v12 = *v8 - v11;
        (*(void(__cdecl**)(_DWORD*, unsigned int, _DWORD, unsigned int))(a1[105] + 4))(a1, v7[3] + 4 * v9, 0, v12);
        *a6 += v12;
    }
    result = v7[4];
    if (*v8 >= result)
    {
        v7[5] += result;
        *v8 = 0;
    }
    return result;
}

//----- (004818AD) --------------------------------------------------------
unsigned int __cdecl sub_4818AD(_DWORD* a1, int a2, int a3, int a4, int a5, _DWORD* a6, int a7)
{
    _DWORD* v7; // esi
    unsigned int v8; // edi
    unsigned int result; // eax

    v7 = (_DWORD*)a1[98];
    if (!v7[6])
        v7[3] = (*(int(__cdecl**)(_DWORD*, _DWORD, _DWORD, _DWORD, _DWORD))(a1[1] + 28))(a1, v7[2], v7[5], v7[4], 0);
    v8 = v7[4] - v7[6];
    if (v8 > a7 - *a6)
        v8 = a7 - *a6;
    if (v8 > a1[24] - v7[5])
        v8 = a1[24] - v7[5];
    (*(void(__cdecl**)(_DWORD*, int, int, unsigned int))(a1[105] + 4))(a1, v7[3] + 4 * v7[6], a5 + 4 * *a6, v8);
    *a6 += v8;
    v7[6] += v8;
    result = v7[4];
    if (v7[6] >= result)
    {
        v7[5] += result;
        v7[6] = 0;
    }
    return result;
}

//----- (00481939) --------------------------------------------------------
int __cdecl sub_481939(int a1, int a2)
{
    int result; // eax
    _DWORD* v3; // esi
    bool v4; // zf

    result = a1;
    v3 = *(_DWORD**)(a1 + 392);
    if (a2)
    {
        if (a2 == 2)
        {
            if (!v3[2])
            {
                *(_DWORD*)(*(_DWORD*)a1 + 20) = 4;
                result = (**(int(__cdecl***)(int))a1)(a1);
            }
            v3[1] = sub_4818AD;
        }
        else if (a2 == 3)
        {
            if (!v3[2])
            {
                *(_DWORD*)(*(_DWORD*)a1 + 20) = 4;
                result = (**(int(__cdecl***)(int))a1)(a1);
            }
            v3[1] = sub_48181D;
        }
        else
        {
            *(_DWORD*)(*(_DWORD*)a1 + 20) = 4;
            result = (**(int(__cdecl***)(int))a1)(a1);
        }
    }
    else if (*(_BYTE*)(a1 + 74))
    {
        v4 = v3[3] == 0;
        v3[1] = sub_4817B8;
        if (v4)
        {
            result = (*(int(__cdecl**)(int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD*)(a1 + 4) + 28))(a1, v3[2], 0, v3[4], 1);
            v3[3] = result;
        }
    }
    else
    {
        result = *(_DWORD*)(*(_DWORD*)(a1 + 412) + 4);
        v3[1] = result;
    }
    v3[6] = 0;
    v3[5] = 0;
    return result;
}

//----- (004819E1) --------------------------------------------------------
int(__cdecl** __cdecl sub_4819E1(int a1, char a2))(int a1, int a2)
{
    int(__cdecl * *result)(int, int); // eax
    int(__cdecl * *v3)(int, int); // edi
    int v4; // eax
    int v5; // ebx
    int v6; // eax
    int v7; // [esp-8h] [ebp-10h]

    result = (int(__cdecl**)(int, int))(**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 28);
    v3 = result;
    *(_DWORD*)(a1 + 392) = result;
    *result = sub_481939;
    result[2] = 0;
    result[3] = 0;
    if (*(_BYTE*)(a1 + 74))
    {
        v4 = *(_DWORD*)(a1 + 272);
        v3[4] = (int(__cdecl*)(int, int))v4;
        if (a2)
        {
            v5 = *(_DWORD*)(a1 + 4);
            v7 = v4;
            v6 = sub_47BCE4(*(_DWORD*)(a1 + 96), v4);
            result = (int(__cdecl**)(int, int))(*(int(__cdecl**)(int, int, _DWORD, int, int, int))(v5 + 16))(
                a1,
                1,
                0,
                *(_DWORD*)(a1 + 92) * *(_DWORD*)(a1 + 100),
                v6,
                v7);
            v3[2] = (int(__cdecl*)(int, int))result;
        }
        else
        {
            result = (int(__cdecl**)(int, int))(*(int(__cdecl**)(int, int, int, int))(*(_DWORD*)(a1 + 4) + 8))(
                a1,
                1,
                *(_DWORD*)(a1 + 92) * *(_DWORD*)(a1 + 100),
                v4);
            v3[3] = (int(__cdecl*)(int, int))result;
        }
    }
    return result;
}

//----- (00481A65) --------------------------------------------------------
int __cdecl sub_481A65(_DWORD* a1)
{
    int v1; // ecx
    int result; // eax

    v1 = a1[103];
    *(_DWORD*)(v1 + 92) = a1[68];
    result = a1[24];
    *(_DWORD*)(v1 + 96) = result;
    return result;
}

//----- (00481A82) --------------------------------------------------------
_DWORD* __cdecl sub_481A82(_DWORD* a1, int a2, _DWORD* a3, int a4, int a5, _DWORD* a6, int a7)
{
    int v8; // esi
    int v9; // edi
    unsigned int v10; // edi
    _DWORD* result; // eax
    int v12; // [esp+Ch] [ebp-4h]
    int v13; // [esp+18h] [ebp+8h]
    unsigned int v14; // [esp+30h] [ebp+20h]

    v8 = a1[103];
    if (*(_DWORD*)(v8 + 92) >= a1[68])
    {
        v13 = 0;
        v12 = a1[49];
        if ((int)a1[8] > 0)
        {
            v9 = v8 + 12;
            do
            {
                (*(void(__cdecl**)(_DWORD*, int, int, int))(v9 + 40))(
                    a1,
                    v12,
                    *(_DWORD*)(a2 + 4 * v13) + 4 * *a3 * *(_DWORD*)(v9 + 88),
                    v9);
                v12 += 84;
                ++v13;
                v9 += 4;
            } while (v13 < a1[8]);
        }
        *(_DWORD*)(v8 + 92) = 0;
    }
    v10 = a1[68] - *(_DWORD*)(v8 + 92);
    if (v10 > *(_DWORD*)(v8 + 96))
        v10 = *(_DWORD*)(v8 + 96);
    v14 = a7 - *a6;
    if (v10 > v14)
        v10 = v14;
    (*(void(__cdecl**)(_DWORD*, int, _DWORD, int, unsigned int))(a1[104] + 4))(
        a1,
        v8 + 12,
        *(_DWORD*)(v8 + 92),
        a5 + 4 * *a6,
        v10);
    result = a6;
    *a6 += v10;
    *(_DWORD*)(v8 + 96) -= v10;
    *(_DWORD*)(v8 + 92) += v10;
    if (*(_DWORD*)(v8 + 92) >= a1[68])
    {
        result = a3;
        ++*a3;
    }
    return result;
}

//----- (00481B48) --------------------------------------------------------
_DWORD* __cdecl sub_481B48(int a1, int a2, int a3, _DWORD* a4)
{
    _DWORD* result; // eax

    result = a4;
    *a4 = a3;
    return result;
}

//----- (00481B55) --------------------------------------------------------
_DWORD* __cdecl sub_481B55(int a1, int a2, int a3, _DWORD* a4)
{
    _DWORD* result; // eax

    result = a4;
    *a4 = 0;
    return result;
}

//----- (00481B60) --------------------------------------------------------
const void** __cdecl sub_481B60(unsigned int* a1, int a2, char** a3, int* a4)
{
    int v4; // ebx
    int v6; // eax
    int v7; // ecx
    const void** result; // eax
    int v9; // edi
    char* v10; // edx
    char* v11; // eax
    unsigned int v12; // ecx
    char v13; // al
    int v14; // eax
    unsigned int v15; // [esp+Ch] [ebp-14h]
    int v16; // [esp+14h] [ebp-Ch]
    int i; // [esp+18h] [ebp-8h]
    int v18; // [esp+1Ch] [ebp-4h]
    char* v19; // [esp+28h] [ebp+8h]
    int v21; // [esp+34h] [ebp+14h]

    v4 = *a4;
    v6 = *(_DWORD*)(a2 + 4) + a1[103];
    v7 = *(unsigned __int8*)(v6 + 140);
    result = (const void**)*(unsigned __int8*)(v6 + 150);
    v9 = 0;
    v16 = *a4;
    v21 = v7;
    v18 = (int)result;
    for (i = 0; v9 < (int)a1[68]; i = v9)
    {
        v10 = *a3;
        v11 = *(char**)(v4 + 4 * v9);
        v12 = (unsigned int)&v11[a1[23]];
        v19 = v11;
        v15 = v12;
        while ((unsigned int)v19 < v12)
        {
            v13 = *v10++;
            if (v21 > 0)
            {
                LOBYTE(v4) = v13;
                BYTE1(v4) = v13;
                v14 = v4 << 16;
                LOWORD(v14) = v4;
                v4 = v16;
                memset32(v19, v14, (unsigned int)v21 >> 2);
                memset(&v19[4 * ((unsigned int)v21 >> 2)], v14, v21 & 3);
                v9 = i;
                v12 = v15;
                v19 += v21;
            }
        }
        result = (const void**)v18;
        if (v18 > 1)
            result = sub_47BCFE(v4, v9, v4, v9 + 1, v18 - 1, a1[23]);
        v9 += v18;
        ++a3;
    }
    return result;
}

//----- (00481C3D) --------------------------------------------------------
_BYTE*** __cdecl sub_481C3D(int a1, int a2, int a3, _BYTE*** a4)
{
    _BYTE*** result; // eax
    _BYTE** v6; // esi
    int v7; // edx
    _BYTE* v8; // eax
    char* v9; // edi
    unsigned int v10; // ecx
    char v11; // dl
    _BYTE* v12; // eax
    int v13; // [esp+10h] [ebp+8h]
    int v14; // [esp+1Ch] [ebp+14h]

    result = a4;
    v14 = 0;
    v6 = *result;
    if (*(int*)(a1 + 272) > 0)
    {
        v7 = a3 - (_DWORD)v6;
        v13 = a3 - (_DWORD)v6;
        do
        {
            v8 = *v6;
            v9 = *(_BYTE**)((char*)v6 + v7);
            v10 = (unsigned int)&(*v6)[*(_DWORD*)(a1 + 92)];
            if ((unsigned int)*v6 < v10)
            {
                do
                {
                    v11 = *v9++;
                    *v8 = v11;
                    v12 = v8 + 1;
                    *v12 = v11;
                    v8 = v12 + 1;
                } while ((unsigned int)v8 < v10);
                v7 = v13;
            }
            result = (_BYTE***)++v14;
            ++v6;
        } while (v14 < *(_DWORD*)(a1 + 272));
    }
    return result;
}

//----- (00481C94) --------------------------------------------------------
const void** __cdecl sub_481C94(int a1, int a2, char** a3, int* a4)
{
    const void** result; // eax
    int v5; // ebx
    int v6; // esi
    char* v7; // edx
    _BYTE* v8; // ecx
    _BYTE* v9; // eax
    char v10; // bl
    _BYTE* v11; // ecx
    int i; // [esp+Ch] [ebp-4h]

    result = (const void**)a4;
    v5 = *a4;
    v6 = 0;
    for (i = *a4; v6 < *(_DWORD*)(a1 + 272); v6 += 2)
    {
        v7 = *a3;
        v8 = *(_BYTE**)(v5 + 4 * v6);
        v9 = &v8[*(_DWORD*)(a1 + 92)];
        if (v8 < v9)
        {
            do
            {
                v10 = *v7++;
                *v8 = v10;
                v11 = v8 + 1;
                *v11 = v10;
                v8 = v11 + 1;
            } while (v8 < v9);
            v5 = i;
        }
        result = sub_47BCFE(v5, v6, v5, v6 + 1, 1, *(_DWORD*)(a1 + 92));
        ++a3;
    }
    return result;
}

//----- (00481CFE) --------------------------------------------------------
int __cdecl sub_481CFE(int a1, int a2, int a3, _BYTE*** a4)
{
    _BYTE** v5; // esi
    int result; // eax
    int v7; // ebx
    unsigned __int8* v8; // eax
    int v9; // edx
    _BYTE* v10; // ecx
    unsigned __int8* v11; // eax
    _BYTE* v12; // ecx
    int v13; // edi
    int v14; // edx
    _BYTE* v15; // ecx
    int v16; // edx
    int v17; // [esp+4h] [ebp-4h]
    int v18; // [esp+1Ch] [ebp+14h]

    v18 = 0;
    v5 = *a4;
    result = a1;
    if (*(int*)(a1 + 272) > 0)
    {
        v7 = a3 - (_DWORD)v5;
        do
        {
            v8 = *(_BYTE**)((char*)v5 + v7);
            v9 = *v8;
            v10 = *v5;
            *v10 = v9;
            v11 = v8 + 1;
            *++v10 = (3 * v9 + *v11 + 2) >> 2;
            v12 = v10 + 1;
            if (*(_DWORD*)(a2 + 40) != 2)
            {
                v17 = *(_DWORD*)(a2 + 40) - 2;
                do
                {
                    v13 = *v11;
                    v14 = *(v11++ - 1);
                    v13 *= 3;
                    *v12 = (v14 + v13 + 1) >> 2;
                    v15 = v12 + 1;
                    *v15 = (*v11 + v13 + 2) >> 2;
                    v12 = v15 + 1;
                    --v17;
                } while (v17);
            }
            v16 = *v11;
            ++v18;
            *v12 = (*(v11 - 1) + 3 * v16 + 1) >> 2;
            result = a1;
            v12[1] = v16;
            ++v5;
        } while (v18 < *(_DWORD*)(a1 + 272));
    }
    return result;
}

//----- (00481DA2) --------------------------------------------------------
unsigned __int8** __cdecl sub_481DA2(unsigned __int8** a1, int a2, unsigned __int8** a3, int* a4)
{
    unsigned __int8** result; // eax
    unsigned __int8* v5; // edx
    unsigned __int8* v6; // edi
    _BYTE* v7; // esi
    int v8; // ecx
    unsigned __int8* v9; // edi
    unsigned __int8* v10; // edx
    int v11; // eax
    unsigned __int8* v12; // edi
    unsigned __int8* v13; // edx
    _BYTE* v14; // esi
    _BYTE* v15; // esi
    bool v16; // zf
    int v17; // [esp+0h] [ebp-14h]
    int v18; // [esp+4h] [ebp-10h]
    unsigned __int8** v19; // [esp+8h] [ebp-Ch]
    int v20; // [esp+Ch] [ebp-8h]
    int v21; // [esp+10h] [ebp-4h]
    int v22; // [esp+28h] [ebp+14h]

    v21 = 0;
    v17 = *a4;
    result = a1;
    if ((int)a1[68] > 0)
    {
        result = a3;
        v19 = a3;
        do
        {
            v22 = 0;
            do
            {
                v5 = *result;
                if (v22)
                    v6 = result[1];
                else
                    v6 = *(result - 1);
                v7 = *(_BYTE**)(v17 + 4 * v21++);
                v8 = *v6 + 3 * *v5;
                v9 = v6 + 1;
                v10 = v5 + 1;
                v11 = *v9 + 3 * *v10;
                *v7 = (4 * v8 + 8) >> 4;
                v12 = v9 + 1;
                v13 = v10 + 1;
                *++v7 = (v8 + v11 + 2 * v8 + 7) >> 4;
                v14 = v7 + 1;
                v20 = v11;
                if (*(_DWORD*)(a2 + 40) != 2)
                {
                    v18 = *(_DWORD*)(a2 + 40) - 2;
                    do
                    {
                        v11 = *v12 + 3 * *v13;
                        *v14 = (3 * v20 + v8 + 8) >> 4;
                        ++v12;
                        ++v13;
                        v15 = v14 + 1;
                        *v15 = (3 * v20 + v11 + 7) >> 4;
                        v8 = v20;
                        v14 = v15 + 1;
                        v16 = v18-- == 1;
                        v20 = v11;
                    } while (!v16);
                }
                ++v22;
                *v14 = (v11 + v8 + 2 * v11 + 8) >> 4;
                v14[1] = (4 * v11 + 7) >> 4;
                result = v19;
            } while (v22 < 2);
            result = ++v19;
        } while (v21 < (int)a1[68]);
    }
    return result;
}

//----- (00481EA9) --------------------------------------------------------
int __cdecl sub_481EA9(int a1)
{
    int result; // eax
    int v3; // ebx
    _DWORD* v4; // ecx
    int v5; // edi
    int v6; // ebx
    int v7; // eax
    int v8; // edx
    int v9; // ebx
    int v10; // eax
    int v11; // eax
    int v12; // [esp-4h] [ebp-28h]
    _DWORD* v13; // [esp+10h] [ebp-14h]
    int v14; // [esp+14h] [ebp-10h]
    int v15; // [esp+18h] [ebp-Ch]
    int v16; // [esp+1Ch] [ebp-8h]
    int v17; // [esp+20h] [ebp-4h]
    bool v18; // [esp+2Fh] [ebp+Bh]

    result = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 160);
    v3 = result;
    *(_DWORD*)(a1 + 412) = result;
    *(_BYTE*)(result + 8) = 0;
    *(_DWORD*)result = sub_481A65;
    *(_DWORD*)(result + 4) = sub_481A82;
    v14 = result;
    if (*(_BYTE*)(a1 + 264))
    {
        *(_DWORD*)(*(_DWORD*)a1 + 20) = 23;
        result = (**(int(__cdecl***)(int))a1)(a1);
    }
    v18 = *(_BYTE*)(a1 + 72) && *(int*)(a1 + 276) > 1;
    v16 = 0;
    if (*(int*)(a1 + 32) > 0)
    {
        v4 = (_DWORD*)(v3 + 52);
        v5 = *(_DWORD*)(a1 + 196) + 36;
        v13 = (_DWORD*)(v3 + 52);
        do
        {
            v6 = *(_DWORD*)(a1 + 276);
            v15 = *(_DWORD*)v5 * *(_DWORD*)(v5 - 28) / v6;
            v7 = *(_DWORD*)v5 * *(_DWORD*)(v5 - 24) / v6;
            v8 = *(_DWORD*)(a1 + 268);
            v17 = *(_DWORD*)(a1 + 272);
            v4[12] = v7;
            if (*(_BYTE*)(v5 + 12))
            {
                if (v15 != v8 || v7 != v17)
                {
                    if (2 * v15 == v8)
                    {
                        if (v7 == v17)
                        {
                            if (v18 && *(_DWORD*)(v5 + 4) > 2u)
                                *v4 = sub_481CFE;
                            else
                                *v4 = sub_481C3D;
                        LABEL_30:
                            v12 = *(_DWORD*)(a1 + 272);
                            v9 = *(_DWORD*)(a1 + 4);
                            v10 = sub_47BCE4(*(_DWORD*)(a1 + 92), *(_DWORD*)(a1 + 268));
                            v11 = (*(int(__cdecl**)(int, int, int, int))(v9 + 8))(a1, 1, v10, v12);
                            v4 = v13;
                            *(v13 - 10) = v11;
                            goto LABEL_31;
                        }
                        if (2 * v15 == v8 && 2 * v7 == v17)
                        {
                            if (v18 && *(_DWORD*)(v5 + 4) > 2u)
                            {
                                *v4 = sub_481DA2;
                                *(_BYTE*)(v14 + 8) = 1;
                            }
                            else
                            {
                                *v4 = sub_481C94;
                            }
                            goto LABEL_30;
                        }
                    }
                    if (v8 % v15 || v17 % v7)
                    {
                        *(_DWORD*)(*(_DWORD*)a1 + 20) = 37;
                        (**(void(__cdecl***)(int))a1)(a1);
                    }
                    else
                    {
                        *v4 = sub_481B60;
                        *(_BYTE*)(v16 + v14 + 140) = v8 / v15;
                        *(_BYTE*)(v16 + v14 + 150) = v17 / v7;
                    }
                    goto LABEL_30;
                }
                *v4 = sub_481B48;
            }
            else
            {
                *v4 = sub_481B55;
            }
        LABEL_31:
            result = ++v16;
            ++v4;
            v5 += 84;
            v13 = v4;
        } while (v16 < *(_DWORD*)(a1 + 32));
    }
    return result;
}

//----- (0048206A) --------------------------------------------------------
int __usercall sub_48206A@<eax>(int a1@<eax>)
{
    _DWORD* v2; // esi
    int result; // eax
    int v4; // edx
    int i; // ecx
    int v6; // edi
    int v7; // edi
    int v8; // [esp+Ch] [ebp-8h]
    int v9; // [esp+10h] [ebp-4h]

    v2 = *(_DWORD**)(a1 + 416);
    v2[2] = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1024);
    v2[3] = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1024);
    v2[4] = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1024);
    v2[5] = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1024);
    result = 0;
    v4 = 5990656;
    v8 = -14831872;
    v9 = -11728000;
    for (i = 2919680; i >= -2831590; i -= 22554)
    {
        v6 = v9;
        v9 += 91881;
        *(_DWORD*)(result + v2[2]) = v6 >> 16;
        v7 = v8;
        v8 += 116130;
        *(_DWORD*)(result + v2[3]) = v7 >> 16;
        *(_DWORD*)(result + v2[4]) = v4;
        *(_DWORD*)(result + v2[5]) = i;
        v4 -= 46802;
        result += 4;
    }
    return result;
}

//----- (0048211A) --------------------------------------------------------
_BYTE* __cdecl sub_48211A(int a1, int a2, int a3, _DWORD* a4, _BYTE* a5)
{
    int v5; // ebx
    _BYTE* result; // eax
    int v8; // edi
    int i; // esi
    _BYTE* v10; // ecx
    int v11; // [esp+4h] [ebp-8h]
    _BYTE* v12; // [esp+8h] [ebp-4h]
    int v13; // [esp+14h] [ebp+8h]
    int v14; // [esp+24h] [ebp+18h]

    v5 = *(_DWORD*)(a1 + 92);
    result = a5 - 1;
    v13 = *(_DWORD*)(a1 + 32);
    v11 = v5;
    if ((int)(a5 - 1) >= 0)
    {
        v8 = 4 * a3;
        result = a5;
        v12 = a5;
        do
        {
            for (i = 0; i < v13; ++i)
            {
                v10 = *(_BYTE**)(v8 + *(_DWORD*)(a2 + 4 * i));
                result = (_BYTE*)(i + *a4);
                if (v5)
                {
                    v14 = v5;
                    do
                    {
                        *result = *v10;
                        result += v13;
                        ++v10;
                        --v14;
                    } while (v14);
                    v5 = v11;
                }
            }
            v8 += 4;
            ++a4;
            --v12;
        } while (v12);
    }
    return result;
}

//----- (00482185) --------------------------------------------------------
const void** __cdecl sub_482185(int a1, int* a2, int a3, int a4, int a5)
{
    return sub_47BCFE(*a2, a3, a4, 0, a5, *(_DWORD*)(a1 + 92));
}

//----- (004821A8) --------------------------------------------------------
_BYTE* __cdecl sub_4821A8(_DWORD* a1, _DWORD* a2, int a3, _BYTE** a4, int a5)
{
    _DWORD* v5; // eax
    int v6; // edi
    int v7; // ecx
    _BYTE* result; // eax
    int v9; // edx
    _DWORD* v10; // esi
    unsigned __int8* v11; // ecx
    _BYTE** v12; // eax
    int v13; // ebx
    int v14; // esi
    int v15; // esi
    int v16; // edi
    int v17; // [esp+8h] [ebp-28h]
    int v18; // [esp+Ch] [ebp-24h]
    int v19; // [esp+10h] [ebp-20h]
    int v20; // [esp+14h] [ebp-1Ch]
    int v21; // [esp+18h] [ebp-18h]
    int v22; // [esp+1Ch] [ebp-14h]
    int v23; // [esp+20h] [ebp-10h]
    int v24; // [esp+24h] [ebp-Ch]
    int v25; // [esp+24h] [ebp-Ch]
    int v26; // [esp+28h] [ebp-8h]
    int v27; // [esp+2Ch] [ebp-4h]
    int v28; // [esp+2Ch] [ebp-4h]
    int v29; // [esp+38h] [ebp+8h]
    int v30; // [esp+48h] [ebp+18h]
    int v31; // [esp+48h] [ebp+18h]

    v5 = (_DWORD*)a1[104];
    v6 = a1[23];
    v29 = a1[71];
    v21 = v5[2];
    v18 = v5[3];
    v7 = v5[4];
    v20 = v5[5];
    result = (_BYTE*)(a5 - 1);
    v17 = v6;
    v19 = v7;
    if (a5 - 1 >= 0)
    {
        v9 = 4 * a3;
        v10 = a2;
        v26 = a5;
        do
        {
            v30 = *(_DWORD*)(v9 + *v10);
            v11 = *(unsigned __int8**)(v9 + v10[1]);
            v27 = *(_DWORD*)(v9 + v10[2]);
            v24 = *(_DWORD*)(v9 + v10[3]);
            v12 = a4++;
            result = *v12;
            v9 += 4;
            if (v6)
            {
                v13 = v30 - (_DWORD)v11;
                v14 = v27 - (_DWORD)v11;
                v23 = v30 - (_DWORD)v11;
                v22 = v27 - (_DWORD)v11;
                v25 = v24 - (_DWORD)v11;
                v28 = v6;
                while (1)
                {
                    v31 = v11[v13];
                    v15 = 4 * v11[v14];
                    v16 = 4 * *v11;
                    *result = *(_BYTE*)(v29 - *(_DWORD*)(v15 + v21) - v31 + 255);
                    result += 4;
                    *(result - 3) = *(_BYTE*)(v29 - ((*(_DWORD*)(v15 + v19) + *(_DWORD*)(v16 + v20)) >> 16) - v31 + 255);
                    *(result - 2) = *(_BYTE*)(v29 - *(_DWORD*)(v16 + v18) - v31 + 255);
                    *(result - 1) = (v11++)[v25];
                    if (!--v28)
                        break;
                    v13 = v23;
                    v14 = v22;
                }
                v6 = v17;
                v10 = a2;
            }
            --v26;
        } while (v26);
    }
    return result;
}

//----- (004822DA) --------------------------------------------------------
_BYTE* __cdecl sub_4822DA(_DWORD* a1, _DWORD* a2, int a3, int* a4, int a5)
{
    _DWORD* v5; // eax
    unsigned int v6; // ebx
    int v7; // esi
    int v8; // ecx
    _BYTE* result; // eax
    int v10; // eax
    unsigned int* v11; // edx
    unsigned int* v12; // ecx
    int v13; // eax
    unsigned int* v14; // eax
    unsigned int* v15; // ebx
    unsigned int v16; // edi
    int v17; // edx
    __m64 v18; // mm0
    __m64 v19; // mm3
    __m64 v20; // mm4
    __m64 v21; // mm6
    __m64 v22; // mm2
    __m64 v23; // mm5
    __m64 v24; // mm6
    __m64 v25; // mm7
    __m64 v26; // mm1
    __m64 v27; // mm0
    __m64 v28; // mm1
    __m64 v29; // mm4
    __m64 v30; // mm0
    __m64 v31; // mm3
    __m64 v32; // mm2
    __m64 v33; // mm3
    _BYTE* v34; // ecx
    int v35; // edx
    int v36; // edi
    int v37; // edx
    bool v38; // zf
    _DWORD* v39; // edi
    int v40; // edx
    int* v41; // eax
    unsigned __int8* v42; // ecx
    int v43; // edx
    int v44; // edx
    int v45; // ebx
    unsigned int v46; // [esp+Ch] [ebp-34h]
    int v47; // [esp+Ch] [ebp-34h]
    int v48; // [esp+10h] [ebp-30h]
    int v49; // [esp+10h] [ebp-30h]
    int v50; // [esp+14h] [ebp-2Ch]
    int v51; // [esp+18h] [ebp-28h]
    _BYTE* v52; // [esp+1Ch] [ebp-24h]
    int v53; // [esp+20h] [ebp-20h]
    int v54; // [esp+24h] [ebp-1Ch]
    unsigned int v55; // [esp+24h] [ebp-1Ch]
    unsigned int v56; // [esp+28h] [ebp-18h]
    int v57; // [esp+28h] [ebp-18h]
    unsigned int v58; // [esp+2Ch] [ebp-14h]
    int v59; // [esp+30h] [ebp-10h]
    unsigned int v60; // [esp+34h] [ebp-Ch]
    unsigned int* v61; // [esp+38h] [ebp-8h]
    int v62; // [esp+38h] [ebp-8h]
    int v63; // [esp+38h] [ebp-8h]
    int v64; // [esp+38h] [ebp-8h]
    unsigned int* v65; // [esp+3Ch] [ebp-4h]
    char* v66; // [esp+3Ch] [ebp-4h]
    int v67; // [esp+3Ch] [ebp-4h]
    int v68; // [esp+3Ch] [ebp-4h]
    unsigned int* v69; // [esp+48h] [ebp+8h]
    int v70; // [esp+48h] [ebp+8h]
    unsigned __int8* v71; // [esp+48h] [ebp+8h]

    v5 = (_DWORD*)a1[104];
    v6 = a1[23];
    v7 = a1[71];
    v53 = v5[2];
    v50 = v5[3];
    v8 = v5[4];
    result = (_BYTE*)v5[5];
    v58 = v6;
    v60 = v6 & 0xFFFFFFF8;
    v51 = v8;
    v52 = result;
    if (byte_4B15AC)
    {
        if (a5 - 1 >= 0)
        {
            v46 = 3 * (v6 & 0xFFFFFFF8);
            v10 = 4 * a3;
            v54 = a5;
            while (1)
            {
                v65 = *(unsigned int**)(v10 + *a2);
                v11 = *(unsigned int**)(v10 + a2[1]);
                v12 = *(unsigned int**)(v10 + a2[2]);
                v48 = v10 + 4;
                v13 = *a4++;
                v69 = v11;
                v61 = v12;
                v59 = v13;
                v14 = v65;
                v15 = v11;
                v16 = v60 >> 2;
                v17 = v59;
                do
                {
                    v18 = _m_punpcklbw(_mm_cvtsi32_si64(*v14), 0);
                    v19 = _m_psubsw(_m_punpcklbw(_mm_cvtsi32_si64(*v12), 0), (__m64)qword_4B15B0);
                    v20 = _m_psubsw(_m_punpcklbw(_mm_cvtsi32_si64(*v15), 0), (__m64)qword_4B15B0);
                    v21 = _m_psllwi(v18, 8u);
                    v22 = _m_psradi(_m_paddd(_m_pmaddwd(_m_punpcklwd(v20, v19), (__m64)qword_4B15B8), _m_punpcklwd(v21, 0)), 8u);
                    v23 = _m_psradi(_m_paddd(_m_pmaddwd(_m_punpckhwd(v20, v19), (__m64)qword_4B15B8), _m_punpckhwd(v21, 0)), 8u);
                    v24 = _m_psradi(_m_pmaddwd(_m_punpcklwd(v19, v18), (__m64)qword_4B15C0), 8u);
                    v25 = _m_pmaddwd(_m_punpckhwd(v20, v18), (__m64)qword_4B15C8);
                    v26 = _m_pmaddwd(_m_punpckhwd(v19, v18), (__m64)qword_4B15C0);
                    v27 = _m_psradi(_m_pmaddwd(_m_punpcklwd(v20, v18), (__m64)qword_4B15C8), 8u);
                    v28 = _m_psradi(v26, 8u);
                    v29 = _m_psradi(v25, 8u);
                    v30 = _m_packuswb(
                        _m_packssdw(_m_punpckldq(v24, v22), _m_punpckldq(v27, (__m64)(unsigned int)qword_522318)),
                        _m_packssdw(_m_punpckhdq(v24, v22), _m_punpckhdq(v27, (__m64)qword_522318)));
                    v31 = _m_psrlqi(_m_pand(v30, (__m64)qword_4B15D0), 8u);
                    v17 += 12;
                    v32 = _m_packuswb(
                        _m_packssdw(_m_punpckldq(v28, v23), _m_punpckldq(v29, (__m64)(unsigned int)qword_522318)),
                        _m_packssdw(_m_punpckhdq(v28, v23), _m_punpckhdq(v29, (__m64)qword_522318)));
                    ++v14;
                    *(_DWORD*)(v17 - 12) = _mm_cvtsi64_si32(_m_por(v30, v31));
                    v33 = _m_punpcklwd(_m_psrlqi(v31, 0x20u), v32);
                    ++v12;
                    *(_DWORD*)(v17 - 8) = _mm_cvtsi64_si32(v33);
                    ++v15;
                    *(_DWORD*)(v17 - 4) = _mm_cvtsi64_si32(_m_por(_m_psrlqi(v32, 0x18u), _m_psrlqi(v33, 0x30u)));
                    --v16;
                } while (v16);
                result = (_BYTE*)v60;
                v34 = (_BYTE*)(v46 + v59);
                if (v60 < v58)
                {
                    v35 = (char*)v65 - (char*)v69;
                    result = (char*)v69 + v60;
                    v66 = (char*)((char*)v65 - (char*)v69);
                    v62 = (char*)v61 - (char*)v69;
                    v56 = v58 - v60;
                    while (1)
                    {
                        v70 = (unsigned __int8)result[v35];
                        v36 = 4 * (unsigned __int8)result[v62];
                        v37 = 4 * (unsigned __int8)*result;
                        *v34 = *(_BYTE*)(v70 + *(_DWORD*)(v36 + v53) + v7);
                        v34 += 3;
                        *(v34 - 2) = *(_BYTE*)(v70 + ((*(_DWORD*)(v36 + v51) + *(_DWORD*)&v52[v37]) >> 16) + v7);
                        ++result;
                        v38 = v56-- == 1;
                        *(v34 - 1) = *(_BYTE*)(v70 + *(_DWORD*)(v37 + v50) + v7);
                        if (v38)
                            break;
                        v35 = (int)v66;
                    }
                }
                if (!--v54)
                    break;
                v10 = v48;
            }
        }
        _m_empty();
    }
    else
    {
        result = (_BYTE*)(a5 - 1);
        if (a5 - 1 >= 0)
        {
            v39 = a2;
            v40 = 4 * a3;
            v57 = a5;
            do
            {
                v67 = *(_DWORD*)(v40 + *v39);
                v71 = *(unsigned __int8**)(v40 + v39[1]);
                v63 = *(_DWORD*)(v40 + v39[2]);
                v41 = a4++;
                result = (_BYTE*)*v41;
                v40 += 4;
                v49 = v40;
                if (v6)
                {
                    v42 = v71;
                    v68 = v67 - (_DWORD)v71;
                    v43 = v63 - (_DWORD)v71;
                    v64 = v63 - (_DWORD)v71;
                    v55 = v6;
                    while (1)
                    {
                        v44 = v42[v43];
                        v45 = v42[v68];
                        v47 = *v42;
                        *result = *(_BYTE*)(v45 + *(_DWORD*)(4 * v44 + v53) + v7);
                        result += 3;
                        *(result - 2) = *(_BYTE*)(v45 + ((*(_DWORD*)(4 * v44 + v51) + *(_DWORD*)&v52[4 * v47]) >> 16) + v7);
                        ++v42;
                        v38 = v55-- == 1;
                        *(result - 1) = *(_BYTE*)(v45 + *(_DWORD*)(4 * v47 + v50) + v7);
                        if (v38)
                            break;
                        v43 = v64;
                    }
                    v40 = v49;
                    v39 = a2;
                    v6 = v58;
                }
                --v57;
            } while (v57);
        }
    }
    return result;
}
// 4B15AC: using guessed type char byte_4B15AC;
// 4B15B0: using guessed type __int64 qword_4B15B0;
// 4B15B8: using guessed type __int64 qword_4B15B8;
// 4B15C0: using guessed type __int64 qword_4B15C0;
// 4B15C8: using guessed type __int64 qword_4B15C8;
// 4B15D0: using guessed type __int64 qword_4B15D0;
// 522318: using guessed type __int64 qword_522318;

//----- (0048261E) --------------------------------------------------------
int __cdecl sub_48261E(int a1)
{
    _DWORD* v1; // edi
    int v2; // eax
    bool v3; // zf
    int result; // eax
    bool v5; // zf
    int v6; // eax
    int v7; // ecx

    v1 = (_DWORD*)(**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 24);
    *(_DWORD*)(a1 + 416) = v1;
    *v1 = nullsub_2;
    v2 = *(_DWORD*)(a1 + 36);
    if (v2 == 1)
    {
        v3 = *(_DWORD*)(a1 + 32) == 1;
    LABEL_10:
        if (v3)
            goto LABEL_12;
        goto LABEL_11;
    }
    if (v2 <= 1)
        goto LABEL_7;
    if (v2 <= 3)
    {
        v3 = *(_DWORD*)(a1 + 32) == 3;
        goto LABEL_10;
    }
    if (v2 <= 5)
    {
        v3 = *(_DWORD*)(a1 + 32) == 4;
        goto LABEL_10;
    }
LABEL_7:
    if (*(int*)(a1 + 32) >= 1)
        goto LABEL_12;
LABEL_11:
    *(_DWORD*)(*(_DWORD*)a1 + 20) = 8;
    (**(void(__cdecl***)(int))a1)(a1);
LABEL_12:
    if (*(_DWORD*)(a1 + 40) != 1)
    {
        if (*(_DWORD*)(a1 + 40) == 2)
        {
            result = *(_DWORD*)(a1 + 36);
            *(_DWORD*)(a1 + 100) = 3;
            if (result == 3)
            {
                v1[1] = sub_4822DA;
                goto LABEL_23;
            }
            v5 = result == 2;
        }
        else
        {
            if (*(_DWORD*)(a1 + 40) != 4)
            {
                if (*(_DWORD*)(a1 + 40) == *(_DWORD*)(a1 + 36))
                {
                    result = *(_DWORD*)(a1 + 32);
                    *(_DWORD*)(a1 + 100) = result;
                LABEL_26:
                    v1[1] = sub_48211A;
                    goto LABEL_32;
                }
            LABEL_17:
                *(_DWORD*)(*(_DWORD*)a1 + 20) = 25;
                result = (**(int(__cdecl***)(int))a1)(a1);
                goto LABEL_32;
            }
            result = *(_DWORD*)(a1 + 36);
            *(_DWORD*)(a1 + 100) = 4;
            if (result == 5)
            {
                v1[1] = sub_4821A8;
            LABEL_23:
                result = sub_48206A(a1);
                goto LABEL_32;
            }
            v5 = result == 4;
        }
        if (v5)
            goto LABEL_26;
        goto LABEL_17;
    }
    v6 = *(_DWORD*)(a1 + 36);
    *(_DWORD*)(a1 + 100) = 1;
    if (v6 != 1 && v6 != 3)
        goto LABEL_17;
    v1[1] = sub_482185;
    result = 1;
    if (*(int*)(a1 + 32) > 1)
    {
        v7 = 84;
        do
        {
            *(_BYTE*)(*(_DWORD*)(a1 + 196) + v7 + 48) = 0;
            ++result;
            v7 += 84;
        } while (result < *(_DWORD*)(a1 + 32));
    }
LABEL_32:
    if (*(_BYTE*)(a1 + 74))
    {
        *(_DWORD*)(a1 + 104) = 1;
    }
    else
    {
        result = *(_DWORD*)(a1 + 100);
        *(_DWORD*)(a1 + 104) = result;
    }
    return result;
}
// 471745: using guessed type int nullsub_2();

//----- (00482740) --------------------------------------------------------
int __usercall sub_482740@<eax>(int a1@<eax>)
{
    _DWORD* v2; // esi
    int result; // eax
    int v4; // edx
    int i; // ecx
    int v6; // edi
    int v7; // edi
    int v8; // [esp+Ch] [ebp-8h]
    int v9; // [esp+10h] [ebp-4h]

    v2 = *(_DWORD**)(a1 + 412);
    v2[4] = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1024);
    v2[5] = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1024);
    v2[6] = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1024);
    v2[7] = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1024);
    result = 0;
    v4 = 5990656;
    v8 = -14831872;
    v9 = -11728000;
    for (i = 2919680; i >= -2831590; i -= 22554)
    {
        v6 = v9;
        v9 += 91881;
        *(_DWORD*)(result + v2[4]) = v6 >> 16;
        v7 = v8;
        v8 += 116130;
        *(_DWORD*)(result + v2[5]) = v7 >> 16;
        *(_DWORD*)(result + v2[6]) = v4;
        *(_DWORD*)(result + v2[7]) = i;
        v4 -= 46802;
        result += 4;
    }
    return result;
}

//----- (004827F0) --------------------------------------------------------
int __cdecl sub_4827F0(int a1)
{
    int result; // eax

    result = *(_DWORD*)(a1 + 412);
    *(_BYTE*)(result + 36) = 0;
    *(_DWORD*)(result + 44) = *(_DWORD*)(a1 + 96);
    return result;
}

//----- (00482808) --------------------------------------------------------
const void** __cdecl sub_482808(int a1, int a2, const void** a3, int a4, int a5, _DWORD* a6, int a7)
{
    int v7; // esi
    _DWORD* v8; // ebx
    unsigned int v9; // edi
    const void** result; // eax
    int* v11; // eax
    int v12; // [esp+Ch] [ebp-8h] BYREF
    int v13; // [esp+10h] [ebp-4h]
    unsigned int v14; // [esp+34h] [ebp+20h]

    v7 = *(_DWORD*)(a1 + 412);
    if (*(_BYTE*)(v7 + 36))
    {
        v8 = a6;
        v9 = 1;
        result = sub_47BCFE(v7 + 32, 0, a5 + 4 * *a6, 0, 1, *(_DWORD*)(v7 + 40));
        *(_BYTE*)(v7 + 36) = 0;
    }
    else
    {
        v9 = 2;
        if (*(_DWORD*)(v7 + 44) < 2u)
            v9 = *(_DWORD*)(v7 + 44);
        v8 = a6;
        v14 = a7 - *a6;
        if (v9 > v14)
            v9 = v14;
        v11 = (int*)(a5 + 4 * *a6);
        v12 = *v11;
        if (v9 <= 1)
        {
            v13 = *(_DWORD*)(v7 + 32);
            *(_BYTE*)(v7 + 36) = 1;
        }
        else
        {
            v13 = v11[1];
        }
        result = (const void**)(*(int(__cdecl**)(int, int, const void*, int*))(v7 + 12))(a1, a2, *a3, &v12);
    }
    *v8 += v9;
    *(_DWORD*)(v7 + 44) -= v9;
    if (!*(_BYTE*)(v7 + 36))
    {
        result = a3;
        *a3 = (char*)*a3 + 1;
    }
    return result;
}

//----- (004828AE) --------------------------------------------------------
int __cdecl sub_4828AE(int a1, int a2, _DWORD* a3, int a4, int a5, _DWORD* a6)
{
    int result; // eax

    result = (*(int(__cdecl**)(int, int, _DWORD, int))(*(_DWORD*)(a1 + 412) + 12))(a1, a2, *a3, a5 + 4 * *a6);
    ++*a6;
    ++*a3;
    return result;
}

//----- (004828DF) --------------------------------------------------------
_BYTE* __cdecl sub_4828DF(_DWORD* a1, _DWORD* a2, int a3, _BYTE** a4)
{
    _DWORD* v4; // eax
    int v5; // ecx
    unsigned __int8* v6; // edi
    unsigned __int8* v7; // edx
    unsigned __int8* v8; // esi
    _BYTE* result; // eax
    int v10; // ebx
    int v11; // edx
    int v12; // esi
    int v13; // edx
    unsigned __int8* v14; // edi
    int v15; // edx
    _BYTE* v16; // eax
    int v17; // edi
    int v18; // ebx
    int v19; // esi
    int v20; // [esp+Ch] [ebp-18h]
    int v21; // [esp+10h] [ebp-14h]
    int v22; // [esp+14h] [ebp-10h]
    int v23; // [esp+18h] [ebp-Ch]
    unsigned __int8* v24; // [esp+1Ch] [ebp-8h]
    unsigned __int8* v25; // [esp+20h] [ebp-4h]
    int v26; // [esp+30h] [ebp+Ch]
    int v27; // [esp+34h] [ebp+10h]
    int v28; // [esp+34h] [ebp+10h]
    int v29; // [esp+34h] [ebp+10h]
    int v30; // [esp+38h] [ebp+14h]

    v4 = (_DWORD*)a1[103];
    v5 = a1[71];
    v20 = v4[4];
    v21 = v4[5];
    v23 = v4[7];
    v22 = v4[6];
    v6 = *(unsigned __int8**)(4 * a3 + *a2);
    v7 = *(unsigned __int8**)(4 * a3 + a2[1]);
    v8 = *(unsigned __int8**)(4 * a3 + a2[2]);
    result = *a4;
    if (a1[23] >> 1)
    {
        v30 = a1[23] >> 1;
        do
        {
            v10 = *v7;
            v25 = v7 + 1;
            v11 = 4 * *v8;
            v24 = v8 + 1;
            v26 = *(_DWORD*)(v11 + v20);
            v12 = *(_DWORD*)(v11 + v22) + *(_DWORD*)(4 * v10 + v23);
            v27 = *(_DWORD*)(4 * v10 + v21);
            v13 = *v6;
            *result = *(_BYTE*)(v13 + v26 + v5);
            v12 >>= 16;
            result[1] = *(_BYTE*)(v13 + v12 + v5);
            result[2] = *(_BYTE*)(v27 + v13 + v5);
            v14 = v6 + 1;
            v15 = *v14;
            v16 = result + 3;
            *v16 = *(_BYTE*)(v15 + v26 + v5);
            LOBYTE(v10) = *(_BYTE*)(v15 + v12 + v5);
            v8 = v24;
            v16[1] = v10;
            v16[2] = *(_BYTE*)(v27 + v15 + v5);
            v7 = v25;
            v6 = v14 + 1;
            result = v16 + 3;
            --v30;
        } while (v30);
    }
    if ((a1[23] & 1) != 0)
    {
        v17 = *v6;
        v28 = 4 * *v7;
        v18 = 4 * *v8;
        v19 = *(_DWORD*)(v18 + v22) + *(_DWORD*)(v28 + v23);
        v29 = *(_DWORD*)(v28 + v21);
        *result = *(_BYTE*)(v17 + *(_DWORD*)(v18 + v20) + v5);
        result[1] = *(_BYTE*)(v17 + (v19 >> 16) + v5);
        result[2] = *(_BYTE*)(v29 + v17 + v5);
    }
    return result;
}

//----- (00482A35) --------------------------------------------------------
char __cdecl sub_482A35(_DWORD* a1, _DWORD* a2, int a3, int a4)
{
    _DWORD* v4; // ecx
    int v5; // eax
    unsigned __int8** v6; // edx
    unsigned __int8* v7; // edi
    int v8; // esi
    int v9; // ecx
    unsigned __int8* v10; // edx
    unsigned __int8* v11; // edi
    _BYTE* v12; // ecx
    _BYTE* v13; // esi
    int v14; // ebx
    int v15; // edx
    int v16; // edi
    int v17; // edx
    int v18; // edx
    _BYTE* v19; // ecx
    int v20; // edx
    int v21; // edx
    _BYTE* v22; // esi
    int v23; // ebx
    int v24; // edx
    int v25; // edi
    int v26; // edx
    int v27; // ecx
    int v29; // [esp+Ch] [ebp-20h]
    int v30; // [esp+10h] [ebp-1Ch]
    int v31; // [esp+14h] [ebp-18h]
    int v32; // [esp+18h] [ebp-14h]
    unsigned __int8* v33; // [esp+1Ch] [ebp-10h]
    unsigned __int8* v34; // [esp+20h] [ebp-Ch]
    int v35; // [esp+24h] [ebp-8h]
    int v36; // [esp+28h] [ebp-4h]
    int v37; // [esp+28h] [ebp-4h]
    unsigned __int8* v38; // [esp+38h] [ebp+Ch]
    unsigned __int8* v39; // [esp+38h] [ebp+Ch]
    unsigned __int8* v40; // [esp+3Ch] [ebp+10h]
    unsigned __int8* v41; // [esp+3Ch] [ebp+10h]
    int v42; // [esp+40h] [ebp+14h]
    int v43; // [esp+40h] [ebp+14h]

    v4 = (_DWORD*)a1[103];
    v5 = a1[71];
    v32 = v4[4];
    v29 = v4[5];
    v30 = v4[6];
    v31 = v4[7];
    v6 = (unsigned __int8**)(*a2 + 8 * a3);
    v7 = *v6;
    v8 = 4 * a3;
    v40 = v6[1];
    v9 = a2[2];
    v10 = *(unsigned __int8**)(v8 + a2[1]);
    v38 = v7;
    v11 = *(unsigned __int8**)(v8 + v9);
    v12 = *(_BYTE**)a4;
    v13 = *(_BYTE**)(a4 + 4);
    if (a1[23] >> 1)
    {
        v35 = a1[23] >> 1;
        do
        {
            v14 = *v10;
            v34 = v10 + 1;
            v15 = 4 * *v11;
            v33 = v11 + 1;
            v42 = *(_DWORD*)(v15 + v32);
            v16 = *(_DWORD*)(v15 + v30) + *(_DWORD*)(4 * v14 + v31);
            v36 = *(_DWORD*)(4 * v14 + v29);
            v17 = *v38;
            *v12 = *(_BYTE*)(v17 + v42 + v5);
            v16 >>= 16;
            v39 = v38 + 1;
            v12[1] = *(_BYTE*)(v17 + v16 + v5);
            v12[2] = *(_BYTE*)(v36 + v17 + v5);
            v18 = *v39;
            v19 = v12 + 3;
            *v19 = *(_BYTE*)(v18 + v42 + v5);
            v19[1] = *(_BYTE*)(v18 + v16 + v5);
            v19[2] = *(_BYTE*)(v36 + v18 + v5);
            v20 = *v40;
            v38 = v39 + 1;
            *v13 = *(_BYTE*)(v20 + v42 + v5);
            v13[1] = *(_BYTE*)(v20 + v16 + v5);
            v13[2] = *(_BYTE*)(v36 + v20 + v5);
            v12 = v19 + 3;
            v41 = v40 + 1;
            v21 = *v41;
            v22 = v13 + 3;
            v40 = v41 + 1;
            *v22 = *(_BYTE*)(v21 + v42 + v5);
            v22[1] = *(_BYTE*)(v21 + v16 + v5);
            v22[2] = *(_BYTE*)(v36 + v21 + v5);
            v11 = v33;
            v10 = v34;
            v13 = v22 + 3;
            --v35;
        } while (v35);
    }
    if ((a1[23] & 1) != 0)
    {
        v23 = *v10;
        v24 = 4 * *v11;
        v43 = *(_DWORD*)(v24 + v32);
        v25 = *(_DWORD*)(v24 + v30) + *(_DWORD*)(4 * v23 + v31);
        v37 = *(_DWORD*)(4 * v23 + v29);
        v26 = *v38;
        *v12 = *(_BYTE*)(v26 + v43 + v5);
        v25 >>= 16;
        v12[1] = *(_BYTE*)(v26 + v25 + v5);
        v12[2] = *(_BYTE*)(v37 + v26 + v5);
        v27 = *v40;
        *v13 = *(_BYTE*)(v27 + v43 + v5);
        v13[1] = *(_BYTE*)(v27 + v25 + v5);
        LOBYTE(v5) = *(_BYTE*)(v37 + v27 + v5);
        v13[2] = v5;
    }
    return v5;
}

//----- (00482C1B) --------------------------------------------------------
int __cdecl sub_482C1B(int a1)
{
    int v1; // esi
    int v3; // [esp-4h] [ebp-Ch]

    v1 = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 48);
    *(_DWORD*)(a1 + 412) = v1;
    *(_BYTE*)(v1 + 8) = 0;
    *(_DWORD*)v1 = sub_4827F0;
    *(_DWORD*)(v1 + 40) = *(_DWORD*)(a1 + 92) * *(_DWORD*)(a1 + 100);
    if (*(_DWORD*)(a1 + 272) == 2)
    {
        v3 = *(_DWORD*)(v1 + 40);
        *(_DWORD*)(v1 + 4) = sub_482808;
        *(_DWORD*)(v1 + 12) = sub_482A35;
        *(_DWORD*)(v1 + 32) = (*(int(__cdecl**)(int, int, int))(*(_DWORD*)(a1 + 4) + 4))(a1, 1, v3);
    }
    else
    {
        *(_DWORD*)(v1 + 32) = 0;
        *(_DWORD*)(v1 + 4) = sub_4828AE;
        *(_DWORD*)(v1 + 12) = sub_4828DF;
    }
    return sub_482740(a1);
}

//----- (00482C93) --------------------------------------------------------
_WORD* __cdecl sub_482C93(int a1, _WORD* a2, int a3, int a4)
{
    _WORD* result; // eax
    int v5; // ebx
    int v6; // esi
    int i; // edi
    unsigned __int8* v8; // ecx
    int v9; // [esp+14h] [ebp+8h]

    result = (_WORD*)a1;
    v5 = *(_DWORD*)(a1 + 92);
    v6 = *(_DWORD*)(*(_DWORD*)(a1 + 420) + 24);
    for (i = 0; i < a4; ++i)
    {
        result = a2;
        v8 = *(unsigned __int8**)&a2[2 * i];
        if (v5)
        {
            v9 = v5;
            do
            {
                result = (_WORD*)(*(_DWORD*)(v6 + 4 * (*v8 >> 3)) + 2 * ((v8[2] >> 3) + 32 * (v8[1] >> 2)));
                if (!++ * result)
                    *result = -1;
                v8 += 3;
                --v9;
            } while (v9);
        }
    }
    return result;
}

//----- (00482CFF) --------------------------------------------------------
int __usercall sub_482CFF@<eax>(int a1@<eax>, int* a2@<esi>)
{
    int v2; // ecx
    int v3; // edi
    int v4; // eax
    int v6; // ecx
    int v7; // eax
    int v9; // ebx
    int v10; // ecx
    int v11; // edx
    _WORD* v12; // eax
    int v14; // ecx
    int v15; // edx
    _WORD* v16; // eax
    _WORD* v18; // eax
    int v19; // edx
    _WORD* v20; // eax
    int v21; // edx
    int v22; // edx
    int v23; // eax
    int v24; // ecx
    int v25; // edi
    int result; // eax
    int v27; // [esp+8h] [ebp-28h]
    int v28; // [esp+Ch] [ebp-24h]
    int v29; // [esp+10h] [ebp-20h]
    _WORD* v30; // [esp+14h] [ebp-1Ch]
    _WORD* v31; // [esp+14h] [ebp-1Ch]
    int v32; // [esp+14h] [ebp-1Ch]
    int v33; // [esp+14h] [ebp-1Ch]
    _WORD* v34; // [esp+14h] [ebp-1Ch]
    int v35; // [esp+18h] [ebp-18h]
    int v36; // [esp+18h] [ebp-18h]
    int v37; // [esp+1Ch] [ebp-14h]
    int v38; // [esp+20h] [ebp-10h]
    int v39; // [esp+24h] [ebp-Ch]
    int v40; // [esp+28h] [ebp-8h]
    int v41; // [esp+28h] [ebp-8h]
    int v42; // [esp+28h] [ebp-8h]
    int v43; // [esp+28h] [ebp-8h]
    int v44; // [esp+28h] [ebp-8h]
    int v45; // [esp+2Ch] [ebp-4h]
    int v46; // [esp+2Ch] [ebp-4h]
    int v47; // [esp+2Ch] [ebp-4h]
    int v48; // [esp+2Ch] [ebp-4h]
    int v49; // [esp+2Ch] [ebp-4h]
    int v50; // [esp+2Ch] [ebp-4h]

    v2 = *a2;
    v29 = a2[3];
    v28 = *(_DWORD*)(*(_DWORD*)(a1 + 420) + 24);
    v3 = a2[2];
    v39 = a2[4];
    v35 = *a2;
    v38 = a2[1];
    v27 = v3;
    v37 = a2[5];
    if (*a2 < v38)
    {
        while (1)
        {
            v40 = a2[2];
            if (v3 <= v29)
                break;
        LABEL_8:
            if (++v2 > v38)
                goto LABEL_11;
        }
        v4 = *(_DWORD*)(v28 + 4 * v2) + 2 * (v39 + 32 * v3);
        while (1)
        {
            v45 = a2[4];
            v30 = (_WORD*)v4;
            if (v39 <= v37)
                break;
        LABEL_7:
            ++v40;
            v4 += 64;
            if (v40 > v29)
                goto LABEL_8;
        }
        while (!*v30++)
        {
            if (++v45 > v37)
                goto LABEL_7;
        }
        v35 = v2;
        *a2 = v2;
    LABEL_11:
        v6 = v38;
        if (v38 > v35)
        {
            while (1)
            {
                v41 = v3;
                if (v3 <= v29)
                    break;
            LABEL_18:
                if (--v6 < v35)
                    goto LABEL_21;
            }
            v7 = *(_DWORD*)(v28 + 4 * v6) + 2 * (v39 + 32 * v3);
            while (1)
            {
                v46 = v39;
                v31 = (_WORD*)v7;
                if (v39 <= v37)
                    break;
            LABEL_17:
                ++v41;
                v7 += 64;
                if (v41 > v29)
                    goto LABEL_18;
            }
            while (!*v31++)
            {
                if (++v46 > v37)
                    goto LABEL_17;
            }
            v38 = v6;
            a2[1] = v6;
        }
    }
LABEL_21:
    v9 = v29;
    if (v3 < v29)
    {
        v42 = v3;
        v10 = 2 * (v39 + 32 * v3);
        while (1)
        {
            v11 = v35;
            if (v35 <= v38)
                break;
        LABEL_29:
            ++v42;
            v10 += 64;
            if (v42 > v29)
                goto LABEL_32;
        }
        while (1)
        {
            v12 = (_WORD*)(v10 + *(_DWORD*)(v28 + 4 * v11));
            v47 = v39;
            if (v39 <= v37)
                break;
        LABEL_27:
            if (++v11 > v38)
            {
                v3 = v27;
                goto LABEL_29;
            }
        }
        while (!*v12++)
        {
            if (++v47 > v37)
                goto LABEL_27;
        }
        v3 = v42;
        v27 = v42;
        a2[2] = v42;
    LABEL_32:
        v9 = v29;
        if (v29 > v3)
        {
            v43 = v29;
            v14 = 2 * (v39 + 32 * v29);
            while (1)
            {
                v15 = v35;
                if (v35 <= v38)
                    break;
            LABEL_40:
                --v43;
                v14 -= 64;
                if (v43 < v3)
                {
                    v9 = v29;
                    goto LABEL_43;
                }
            }
            while (1)
            {
                v16 = (_WORD*)(v14 + *(_DWORD*)(v28 + 4 * v15));
                v48 = v39;
                if (v39 <= v37)
                    break;
            LABEL_38:
                if (++v15 > v38)
                {
                    v3 = v27;
                    goto LABEL_40;
                }
            }
            while (!*v16++)
            {
                if (++v48 > v37)
                    goto LABEL_38;
            }
            v3 = v27;
            v9 = v43;
            v29 = v43;
            a2[3] = v43;
        }
    }
LABEL_43:
    if (v39 < v37)
    {
        v49 = v39;
        while (1)
        {
            v32 = v35;
            if (v35 <= v38)
                break;
        LABEL_50:
            if (++v49 > v37)
                goto LABEL_53;
        }
        while (1)
        {
            v18 = (_WORD*)(2 * (v49 + 32 * v3) + *(_DWORD*)(v28 + 4 * v32));
            v19 = v3;
            if (v3 <= v9)
                break;
        LABEL_49:
            if (++v32 > v38)
                goto LABEL_50;
        }
        while (!*v18)
        {
            ++v19;
            v18 += 32;
            if (v19 > v9)
                goto LABEL_49;
        }
        v39 = v49;
        a2[4] = v49;
    LABEL_53:
        if (v37 > v39)
        {
            v50 = v37;
            while (1)
            {
                v33 = v35;
                if (v35 <= v38)
                    break;
            LABEL_60:
                if (--v50 < v39)
                    goto LABEL_63;
            }
            while (1)
            {
                v20 = (_WORD*)(2 * (v50 + 32 * v3) + *(_DWORD*)(v28 + 4 * v33));
                v21 = v3;
                if (v3 <= v9)
                    break;
            LABEL_59:
                if (++v33 > v38)
                    goto LABEL_60;
            }
            while (!*v20)
            {
                ++v21;
                v20 += 32;
                if (v21 > v9)
                    goto LABEL_59;
            }
            v37 = v50;
            a2[5] = v50;
        }
    }
LABEL_63:
    v22 = v9 - v3;
    v44 = 0;
    v23 = v35;
    a2[6] = 16 * (v38 - v35) * 16 * (v38 - v35) + 12 * (v9 - v3) * 12 * (v9 - v3) + 8 * (v37 - v39) * 8 * (v37 - v39);
    while (v23 <= v38)
    {
        if (v27 <= v29)
        {
            v24 = *(_DWORD*)(v28 + 4 * v23) + 2 * (v39 + 32 * v27);
            v25 = v22 + 1;
            do
            {
                v34 = (_WORD*)v24;
                if (v39 <= v37)
                {
                    v36 = v37 - v39 + 1;
                    do
                    {
                        if (*v34)
                            ++v44;
                        ++v34;
                        --v36;
                    } while (v36);
                }
                v24 += 64;
                --v25;
            } while (v25);
        }
        ++v23;
    }
    result = v44;
    a2[7] = v44;
    return result;
}

//----- (00483037) --------------------------------------------------------
int __cdecl sub_483037(int a1, int a2, int a3, int a4)
{
    int result; // eax
    int v5; // ecx
    _DWORD* v6; // edi
    int* v7; // esi
    int v8; // ebx
    int* v9; // ecx
    int* v10; // ecx
    int v11; // eax
    int v12; // ebx
    int v13; // ebx
    int v14; // eax
    int v15; // eax
    int v16; // eax
    int v17; // [esp+0h] [ebp-8h]
    int v18; // [esp+0h] [ebp-8h]
    int v19; // [esp+4h] [ebp-4h]

    result = a3;
    v5 = a2;
    if (a3 < a4)
    {
        v19 = 2 * a3;
        v6 = (_DWORD*)(32 * a3 + a2 + 12);
        while (1)
        {
            v7 = 0;
            v8 = 0;
            if (v19 > a4)
            {
                if (v19 > 0)
                {
                    v10 = (int*)(v5 + 24);
                    v18 = result;
                    do
                    {
                        if (*v10 > v8)
                        {
                            v7 = v10 - 6;
                            v8 = *v10;
                        }
                        v10 += 8;
                        --v18;
                    } while (v18);
                }
            }
            else if (v19 > 0)
            {
                v9 = (int*)(v5 + 28);
                v17 = result;
                do
                {
                    if (*v9 > v8 && *(v9 - 1) > 0)
                    {
                        v7 = v9 - 7;
                        v8 = *v9;
                    }
                    v9 += 8;
                    --v17;
                } while (v17);
            }
            if (!v7)
                break;
            *(v6 - 2) = v7[1];
            *v6 = v7[3];
            v6[2] = v7[5];
            *(v6 - 3) = *v7;
            *(v6 - 1) = v7[2];
            v6[1] = v7[4];
            v11 = 12 * (v7[3] - v7[2]);
            v12 = 1;
            if (16 * (v7[1] - *v7) > v11)
            {
                v11 = 16 * (v7[1] - *v7);
                v12 = 0;
            }
            if (8 * (v7[5] - v7[4]) > v11)
                v12 = 2;
            if (v12)
            {
                v13 = v12 - 1;
                if (v13)
                {
                    if (v13 == 1)
                    {
                        v14 = (v7[4] + v7[5]) / 2;
                        v7[5] = v14;
                        v6[1] = v14 + 1;
                    }
                }
                else
                {
                    v15 = (v7[2] + v7[3]) / 2;
                    v7[3] = v15;
                    *(v6 - 1) = v15 + 1;
                }
            }
            else
            {
                v16 = (*v7 + v7[1]) / 2;
                v7[1] = v16;
                *(v6 - 3) = v16 + 1;
            }
            sub_482CFF(a1, v7);
            sub_482CFF(a1, v6 - 3);
            v19 += 2;
            result = a3 + 1;
            v6 += 8;
            if (++a3 >= a4)
                break;
            v5 = a2;
        }
    }
    return result;
}

//----- (0048318A) --------------------------------------------------------
int __usercall sub_48318A@<eax>(int* a1@<eax>, int a2@<esi>, int a3)
{
    int v3; // ebx
    int v4; // ecx
    int v5; // edx
    int v6; // eax
    int v7; // edi
    int v8; // edi
    int v9; // edi
    int result; // eax
    int v11; // [esp+Ch] [ebp-3Ch]
    int v12; // [esp+10h] [ebp-38h]
    int v13; // [esp+14h] [ebp-34h]
    int v14; // [esp+20h] [ebp-28h]
    int v15; // [esp+24h] [ebp-24h]
    int v16; // [esp+28h] [ebp-20h]
    int v17; // [esp+2Ch] [ebp-1Ch]
    int v18; // [esp+30h] [ebp-18h]
    int v19; // [esp+34h] [ebp-14h]
    int v20; // [esp+38h] [ebp-10h]
    int v21; // [esp+3Ch] [ebp-Ch]
    int v22; // [esp+40h] [ebp-8h]
    unsigned __int16* v23; // [esp+44h] [ebp-4h]

    v18 = 0;
    v17 = 0;
    v16 = 0;
    v15 = 0;
    v3 = a1[5];
    v11 = a1[1];
    v4 = a1[2];
    v14 = a1[3];
    v5 = a1[4];
    v6 = *a1;
    v7 = a3;
    if (v6 <= v11)
    {
        v19 = 8 * v6 + 4;
        do
        {
            if (v4 <= v14)
            {
                v20 = 4 * v4 + 2;
                v21 = *(_DWORD*)(*(_DWORD*)(*(_DWORD*)(a2 + 420) + 24) + 4 * v6) + 2 * (v5 + 32 * v4);
                v8 = v14 - v4 + 1;
                v12 = v8;
                do
                {
                    v23 = (unsigned __int16*)v21;
                    if (v5 <= v3)
                    {
                        v22 = 8 * v5 + 4;
                        v13 = v3 - v5 + 1;
                        do
                        {
                            v9 = *v23++;
                            if (v9)
                            {
                                v18 += v9;
                                v16 += v9 * v20;
                                v17 += v9 * v19;
                                v15 += v9 * v22;
                            }
                            v22 += 8;
                            --v13;
                        } while (v13);
                        v8 = v12;
                    }
                    v21 += 64;
                    v20 += 4;
                    v12 = --v8;
                } while (v8);
                v7 = a3;
            }
            v19 += 8;
            ++v6;
        } while (v6 <= v11);
    }
    *(_BYTE*)(v7 + **(_DWORD**)(a2 + 116)) = ((v18 >> 1) + v17) / v18;
    *(_BYTE*)(v7 + *(_DWORD*)(*(_DWORD*)(a2 + 116) + 4)) = ((v18 >> 1) + v16) / v18;
    result = ((v18 >> 1) + v15) / v18;
    *(_BYTE*)(v7 + *(_DWORD*)(*(_DWORD*)(a2 + 116) + 8)) = result;
    return result;
}

//----- (004832C2) --------------------------------------------------------
int __usercall sub_4832C2@<eax>(int a1@<edi>, int a2)
{
    int* v2; // esi
    int v3; // eax
    int v4; // ebx
    int v5; // eax
    int* v7; // [esp+8h] [ebp-4h]
    int v8; // [esp+14h] [ebp+8h]

    v2 = (int*)(**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 32 * a2);
    v2[1] = 31;
    v2[5] = 31;
    *v2 = 0;
    v2[2] = 0;
    v2[3] = 63;
    v2[4] = 0;
    sub_482CFF(a1, v2);
    v3 = sub_483037(a1, (int)v2, 1, a2);
    v8 = 0;
    v4 = v3;
    if (v3 > 0)
    {
        v7 = v2;
        do
        {
            sub_48318A(v7, a1, v8++);
            v7 += 8;
        } while (v8 < v4);
    }
    v5 = *(_DWORD*)a1;
    *(_DWORD*)(a1 + 112) = v4;
    *(_DWORD*)(v5 + 20) = 95;
    *(_DWORD*)(*(_DWORD*)a1 + 24) = v4;
    return (*(int(__cdecl**)(int, int))(*(_DWORD*)a1 + 4))(a1, 1);
}

//----- (0048334F) --------------------------------------------------------
int __usercall sub_48334F@<eax>(int a1@<eax>, int a2@<edi>, int a3, int a4, int a5)
{
    int v5; // edx
    int v6; // ebx
    int* v7; // eax
    int v8; // ecx
    int v9; // eax
    int v10; // eax
    int v11; // ecx
    int v12; // esi
    int v13; // eax
    int v14; // ecx
    int v15; // eax
    int v16; // eax
    int v17; // ecx
    int v18; // eax
    int v19; // edx
    int v20; // eax
    int v21; // edx
    int v22; // eax
    int v23; // ecx
    bool v24; // cc
    int v25; // ecx
    int result; // eax
    _DWORD v27[256]; // [esp+8h] [ebp-428h]
    int v28; // [esp+408h] [ebp-28h]
    int v29; // [esp+40Ch] [ebp-24h]
    int v30; // [esp+410h] [ebp-20h]
    int v31; // [esp+414h] [ebp-1Ch]
    int v32; // [esp+418h] [ebp-18h]
    int v33; // [esp+41Ch] [ebp-14h]
    int v34; // [esp+420h] [ebp-10h]
    int v35; // [esp+424h] [ebp-Ch]
    int v36; // [esp+428h] [ebp-8h]
    int v37; // [esp+42Ch] [ebp-4h]

    v5 = a3;
    v37 = 0;
    v32 = (2 * a3 + 24) >> 1;
    v6 = a4;
    v30 = (2 * a2 + 28) >> 1;
    v35 = *(_DWORD*)(a1 + 112);
    v29 = (2 * a4 + 24) >> 1;
    v36 = 0x7FFFFFFF;
    if (v35 > 0)
    {
        v7 = *(int**)(a1 + 116);
        v28 = *v7;
        v8 = v7[1];
        v9 = v7[2];
        v34 = v8;
        v33 = v9;
        do
        {
            v10 = *(unsigned __int8*)(v28 + v37);
            v11 = v5 + 24;
            if (v10 >= v5)
            {
                if (v10 > v11)
                {
                    v12 = 2 * (v10 - v11) * 2 * (v10 - v11);
                LABEL_7:
                    v13 = v10 - v5;
                    goto LABEL_8;
                }
                v12 = 0;
                if (v10 > v32)
                    goto LABEL_7;
            }
            else
            {
                v12 = 2 * (v10 - v5) * 2 * (v10 - v5);
            }
            v13 = v10 - v11;
        LABEL_8:
            v14 = 2 * v13 * 2 * v13;
            v15 = *(unsigned __int8*)(v34 + v37);
            if (v15 < a2)
            {
                v12 += 3 * (v15 - a2) * 3 * (v15 - a2);
                v6 = a4;
                v16 = v15 - (a2 + 28);
                goto LABEL_15;
            }
            if (v15 > a2 + 28)
            {
                v12 += 3 * (v15 - (a2 + 28)) * 3 * (v15 - (a2 + 28));
                v6 = a4;
            LABEL_14:
                v16 = v15 - a2;
                goto LABEL_15;
            }
            if (v15 > v30)
                goto LABEL_14;
            v16 = v15 - (a2 + 28);
        LABEL_15:
            v17 = 3 * v16 * 3 * v16 + v14;
            v18 = *(unsigned __int8*)(v33 + v37);
            if (v18 < v6)
            {
                v12 += (v18 - v6) * (v18 - v6);
                v6 = a4;
                v19 = a4 + 24;
            LABEL_31:
                v20 = v18 - v19;
                goto LABEL_22;
            }
            v19 = v6 + 24;
            v31 = v6 + 24;
            if (v18 <= v6 + 24)
            {
                if (v18 <= v29)
                    goto LABEL_31;
            }
            else
            {
                v12 += (v18 - v31) * (v18 - v31);
                v6 = a4;
            }
            v20 = v18 - v6;
        LABEL_22:
            v21 = v20 * v20;
            v22 = v37;
            v23 = v21 + v17;
            v24 = v23 < v36;
            v5 = a3;
            v27[v37] = v12;
            if (v24)
                v36 = v23;
            v37 = v22 + 1;
        } while (v22 + 1 < v35);
    }
    v25 = 0;
    for (result = 0; v25 < v35; ++v25)
    {
        if (v27[v25] <= v36)
        {
            *(_BYTE*)(result + a5) = v25;
            ++result;
        }
    }
    return result;
}

//----- (004834CF) --------------------------------------------------------
int __cdecl sub_4834CF(int a1, int a2, int a3, int a4, int a5, int a6, _BYTE* a7)
{
    int result; // eax
    int v8; // ebx
    _DWORD* v9; // edx
    int v10; // ecx
    int v11; // esi
    int v12; // edx
    int v13; // eax
    int v14; // esi
    int v15; // edx
    int v16; // ecx
    _DWORD v17[128]; // [esp+4h] [ebp-228h] BYREF
    int v18; // [esp+204h] [ebp-28h]
    int v19; // [esp+208h] [ebp-24h]
    int v20; // [esp+20Ch] [ebp-20h]
    _BYTE* v21; // [esp+210h] [ebp-1Ch]
    int v22; // [esp+214h] [ebp-18h]
    int v23; // [esp+218h] [ebp-14h]
    int* v24; // [esp+21Ch] [ebp-10h]
    int v25; // [esp+220h] [ebp-Ch]
    int v26; // [esp+224h] [ebp-8h]
    int v27; // [esp+228h] [ebp-4h]

    v26 = 0;
    result = 0x7FFFFFFF;
    memset32(v17, 0x7FFFFFFF, 0x80u);
    if (a5 > 0)
    {
        do
        {
            v8 = *(unsigned __int8*)(v26 + a6);
            v9 = *(_DWORD**)(a1 + 116);
            v10 = a2 - *(unsigned __int8*)(v8 + *v9);
            v11 = 3 * (a3 - *(unsigned __int8*)(v9[1] + v8));
            v12 = a4 - *(unsigned __int8*)(v9[2] + v8);
            v10 *= 2;
            v13 = v10 * v10 + v11 * v11 + v12 * v12;
            v14 = 8 * (3 * v11 + 18);
            v15 = 16 * (v12 + 4);
            v24 = v17;
            v21 = a7;
            v27 = 32 * (v10 + 8);
            v19 = 4;
            do
            {
                v22 = v13;
                v25 = v14;
                v18 = 8;
                do
                {
                    v16 = v22;
                    v23 = v15;
                    v20 = 4;
                    do
                    {
                        if (v16 < *v24)
                        {
                            *v24 = v16;
                            *v21 = v8;
                        }
                        v16 += v23;
                        v23 += 128;
                        ++v24;
                        ++v21;
                        --v20;
                    } while (v20);
                    v22 += v25;
                    v25 += 288;
                    --v18;
                } while (v18);
                v13 += v27;
                v27 += 512;
                --v19;
            } while (v19);
            result = ++v26;
        } while (v26 < a5);
    }
    return result;
}

//----- (004835E9) --------------------------------------------------------
_WORD* __usercall sub_4835E9@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
    int v4; // esi
    int v5; // eax
    unsigned __int8* v6; // edx
    _DWORD* v7; // ecx
    int v8; // ebx
    _WORD* result; // eax
    int v10; // edi
    _BYTE v11[256]; // [esp+Ch] [ebp-188h] BYREF
    _BYTE v12[128]; // [esp+10Ch] [ebp-88h] BYREF
    int v13; // [esp+18Ch] [ebp-8h]
    int v14; // [esp+190h] [ebp-4h]
    int v15; // [esp+19Ch] [ebp+8h]
    int v16; // [esp+1A0h] [ebp+Ch]
    int v17; // [esp+1A0h] [ebp+Ch]
    int v18; // [esp+1A4h] [ebp+10h]
    int v19; // [esp+1A4h] [ebp+10h]

    v18 = a4 >> 2;
    v16 = a3 >> 2;
    v14 = *(_DWORD*)(*(_DWORD*)(a2 + 420) + 24);
    v4 = a1 >> 3;
    v13 = 32 * v18 + 4;
    v5 = sub_48334F(a2, 32 * (a1 >> 3) + 2, 32 * v16 + 4, v13, (int)v11);
    sub_4834CF(a2, 32 * v16 + 4, 32 * v4 + 2, v13, v5, (int)v11, v12);
    v6 = v12;
    v15 = 2 * (4 * v18 + (v4 << 8));
    v7 = (_DWORD*)(v14 + 16 * v16);
    v17 = 4;
    do
    {
        v8 = v15;
        v19 = 8;
        do
        {
            result = (_WORD*)(v8 + *v7);
            v10 = 4;
            do
            {
                *result++ = *v6++ + 1;
                --v10;
            } while (v10);
            v8 += 64;
            --v19;
        } while (v19);
        ++v7;
        --v17;
    } while (v17);
    return result;
}

//----- (004836B9) --------------------------------------------------------
int __cdecl sub_4836B9(int a1, int a2, _DWORD* a3, int a4)
{
    int result; // eax
    int v5; // ecx
    unsigned __int8* v6; // esi
    int v7; // ecx
    unsigned __int8* v8; // esi
    int v9; // eax
    int v10; // edx
    _WORD* v11; // edi
    _BYTE* v12; // ecx
    bool v13; // zf
    int v14; // [esp+4h] [ebp-14h]
    int v15; // [esp+8h] [ebp-10h]
    int v16; // [esp+Ch] [ebp-Ch]
    int v17; // [esp+10h] [ebp-8h]
    _DWORD* v18; // [esp+14h] [ebp-4h]
    _BYTE* v19; // [esp+2Ch] [ebp+14h]

    result = a1;
    v15 = *(_DWORD*)(*(_DWORD*)(a1 + 420) + 24);
    v5 = *(_DWORD*)(a1 + 92);
    v14 = v5;
    if (a4 > 0)
    {
        result = a2 - (_DWORD)a3;
        v18 = a3;
        v16 = a4;
        do
        {
            v6 = *(unsigned __int8**)((char*)v18 + result);
            v19 = (_BYTE*)*v18;
            if (v5)
            {
                v17 = v5;
                do
                {
                    v7 = *v6 >> 3;
                    v8 = v6 + 1;
                    v9 = *v8++ >> 2;
                    v10 = *v8 >> 3;
                    v11 = (_WORD*)(*(_DWORD*)(v15 + 4 * v7) + 2 * (v10 + 32 * v9));
                    v6 = v8 + 1;
                    if (!*v11)
                        sub_4835E9(v9, a1, v7, v10);
                    v12 = v19++;
                    v13 = v17-- == 1;
                    *v12 = *(_BYTE*)v11 - 1;
                } while (!v13);
                v5 = v14;
                result = a2 - (_DWORD)a3;
            }
            ++v18;
            --v16;
        } while (v16);
    }
    return result;
}

//----- (00483762) --------------------------------------------------------
__int16 __cdecl sub_483762(_DWORD* a1, int a2, _DWORD* a3, int a4)
{
    int v4; // ecx
    int v5; // edx
    int* v6; // eax
    int v7; // esi
    __int16 result; // ax
    int v9; // esi
    unsigned __int8* v10; // eax
    _BYTE* v11; // esi
    _WORD* v12; // esi
    int v13; // ebx
    int v14; // edi
    int v15; // edi
    int v16; // ebx
    _WORD* v17; // eax
    int v18; // eax
    int v19; // edi
    int v20; // ebx
    int v21; // eax
    int v22; // ecx
    int v23; // edi
    int v24; // ecx
    int v25; // ebx
    __int16 v26; // dx
    int v27; // ecx
    int v28; // eax
    __int16 v29; // dx
    bool v30; // zf
    int v31; // [esp+4h] [ebp-68h]
    int v32; // [esp+Ch] [ebp-60h]
    int v33; // [esp+10h] [ebp-5Ch]
    int v34; // [esp+14h] [ebp-58h]
    _WORD* v35; // [esp+18h] [ebp-54h]
    int v36; // [esp+20h] [ebp-4Ch]
    int v37; // [esp+28h] [ebp-44h]
    int v38; // [esp+2Ch] [ebp-40h]
    int v39; // [esp+30h] [ebp-3Ch]
    int v40; // [esp+34h] [ebp-38h]
    __int16 v41; // [esp+38h] [ebp-34h]
    __int16 v42; // [esp+3Ch] [ebp-30h]
    __int16 v43; // [esp+40h] [ebp-2Ch]
    int v44; // [esp+44h] [ebp-28h]
    _DWORD* v45; // [esp+48h] [ebp-24h]
    __int16 v46; // [esp+4Ch] [ebp-20h]
    __int16 v47; // [esp+50h] [ebp-1Ch]
    __int16 v48; // [esp+54h] [ebp-18h]
    int v49; // [esp+58h] [ebp-14h]
    _BYTE* v50; // [esp+5Ch] [ebp-10h]
    int v51; // [esp+64h] [ebp-8h]
    int v52; // [esp+68h] [ebp-4h]
    int v53; // [esp+80h] [ebp+14h]
    int v54; // [esp+80h] [ebp+14h]
    __int16 v55; // [esp+80h] [ebp+14h]
    __int16 v56; // [esp+80h] [ebp+14h]
    __int16 v57; // [esp+80h] [ebp+14h]

    v4 = a1[105];
    v49 = a1[71];
    v36 = *(_DWORD*)(v4 + 24);
    v5 = a1[23];
    v6 = (int*)a1[29];
    v44 = *(_DWORD*)(v4 + 40);
    v34 = *v6;
    v7 = v6[1];
    v32 = v6[2];
    result = a4;
    v31 = v4;
    v38 = v5;
    v33 = v7;
    if (a4 > 0)
    {
        v9 = a2 - (_DWORD)a3;
        v45 = a3;
        v37 = a4;
        while (1)
        {
            v10 = *(unsigned __int8**)((char*)v45 + v9);
            v11 = (_BYTE*)*v45;
            v51 = (int)v10;
            v50 = (_BYTE*)*v45;
            if (*(_BYTE*)(v4 + 36))
            {
                v40 = -1;
                *(_BYTE*)(v4 + 36) = 0;
                v51 = (int)&v10[2 * v5 - 3 + v5];
                v50 = &v11[v5 - 1];
                v12 = (_WORD*)(*(_DWORD*)(v4 + 32) + 2 * (3 * v5 + 3));
                v10 = (unsigned __int8*)v51;
                v52 = -3;
            }
            else
            {
                v12 = *(_WORD**)(v4 + 32);
                v40 = 1;
                v52 = 3;
                *(_BYTE*)(v4 + 36) = 1;
            }
            v5 = v38;
            v13 = 0;
            v46 = 0;
            v47 = 0;
            v48 = 0;
            v14 = 0;
            v53 = 0;
            v41 = 0;
            v42 = 0;
            v43 = 0;
            if (v38)
            {
                v39 = v38;
                while (1)
                {
                    v15 = *(unsigned __int8*)(*v10 + *(_DWORD*)(v44 + 4 * (((__int16)v12[v52] + v14 + 8) >> 4)) + v49);
                    v16 = *(unsigned __int8*)(v10[1] + *(_DWORD*)(v44 + 4 * (((__int16)v12[v52 + 1] + v13 + 8) >> 4)) + v49);
                    v54 = *(unsigned __int8*)(v10[2] + *(_DWORD*)(v44 + 4 * (((__int16)v12[v52 + 2] + v53 + 8) >> 4)) + v49);
                    v17 = (_WORD*)(*(_DWORD*)(v36 + 4 * (v15 >> 3)) + 2 * ((v54 >> 3) + 32 * (v16 >> 2)));
                    v35 = v17;
                    if (!*v17)
                    {
                        sub_4835E9(v16 >> 2, (int)a1, v15 >> 3, v54 >> 3);
                        v17 = v35;
                    }
                    v18 = (unsigned __int16)*v17 - 1;
                    *v50 = v18;
                    v19 = v15 - *(unsigned __int8*)(v18 + v34);
                    v20 = v16 - *(unsigned __int8*)(v18 + v33);
                    v21 = v54 - *(unsigned __int8*)(v18 + v32);
                    v55 = v19;
                    v22 = 2 * v19;
                    v19 *= 3;
                    *v12 = v19 + v48;
                    v23 = v22 + v19;
                    v48 = v23 + v43;
                    v43 = v55;
                    v14 = v22 + v23;
                    v56 = v20;
                    v24 = 2 * v20;
                    v20 *= 3;
                    v12[1] = v20 + v47;
                    v25 = v24 + v20;
                    v47 = v25 + v42;
                    v26 = v56;
                    v57 = v21;
                    v42 = v26;
                    v13 = v24 + v25;
                    v27 = 2 * v21;
                    v21 *= 3;
                    v12[2] = v21 + v46;
                    v12 += v52;
                    v28 = v27 + v21;
                    v46 = v28 + v41;
                    v29 = v57;
                    v53 = v27 + v28;
                    v51 += v52;
                    v50 += v40;
                    v30 = v39-- == 1;
                    v41 = v29;
                    if (v30)
                        break;
                    v10 = (unsigned __int8*)v51;
                }
                v4 = v31;
                v5 = v38;
            }
            ++v45;
            v30 = v37-- == 1;
            *v12 = v48;
            v12[1] = v47;
            result = v46;
            v12[2] = v46;
            if (v30)
                break;
            v9 = a2 - (_DWORD)a3;
        }
    }
    return result;
}

//----- (004839D0) --------------------------------------------------------
int __usercall sub_4839D0@<eax>(int a1@<eax>)
{
    int v1; // esi
    int result; // eax
    int v3; // edx
    int v4; // ecx
    int v5; // edi
    _DWORD* v6; // esi
    _DWORD* v7; // esi
    _DWORD* v8; // esi

    v1 = *(_DWORD*)(a1 + 420);
    result = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 2044) + 1020;
    *(_DWORD*)(v1 + 40) = result;
    v3 = 0;
    v4 = 0;
    v5 = 0;
    v6 = (_DWORD*)result;
    do
    {
        *(_DWORD*)(result + 4 * v4) = v3;
        *v6 = v5;
        ++v4;
        --v6;
        ++v3;
        --v5;
    } while (v4 < 16);
    if (v4 < 48)
    {
        v7 = (_DWORD*)(result - 4 * v4);
        do
        {
            *(_DWORD*)(result + 4 * v4) = v3;
            *v7 = -v3;
            ++v4;
            --v7;
            v3 += (v4 & 1) == 0;
        } while (v4 < 48);
    }
    if (v4 <= 255)
    {
        v8 = (_DWORD*)(result - 4 * v4);
        do
        {
            *(_DWORD*)(result + 4 * v4) = v3;
            *v8 = -v3;
            ++v4;
            --v8;
        } while (v4 <= 255);
    }
    return result;
}

//----- (00483A60) --------------------------------------------------------
int __cdecl sub_483A60(int a1)
{
    int v1; // esi
    int result; // eax

    v1 = *(_DWORD*)(a1 + 420);
    *(_DWORD*)(a1 + 116) = *(_DWORD*)(v1 + 16);
    result = sub_4832C2(a1, *(_DWORD*)(v1 + 20));
    *(_BYTE*)(v1 + 28) = 1;
    return result;
}

//----- (00483A85) --------------------------------------------------------
int __cdecl sub_483A85(_DWORD* a1, char a2)
{
    bool v3; // zf
    int v4; // edi
    int result; // eax
    int v6; // ebx
    unsigned int v7; // ebx
    int i; // esi
    int v9; // [esp+10h] [ebp+8h]

    v3 = a1[19] == 0;
    v4 = a1[105];
    result = *(_DWORD*)(v4 + 24);
    v9 = result;
    if (!v3)
        a1[19] = 2;
    if (a2)
    {
        *(_DWORD*)(v4 + 4) = sub_482C93;
        *(_DWORD*)(v4 + 8) = sub_483A60;
        *(_BYTE*)(v4 + 28) = 1;
    }
    else
    {
        if (a1[19] == 2)
            *(_DWORD*)(v4 + 4) = sub_483762;
        else
            *(_DWORD*)(v4 + 4) = sub_4836B9;
        *(_DWORD*)(v4 + 8) = nullsub_2;
        v6 = a1[28];
        if (v6 < 1)
        {
            *(_DWORD*)(*a1 + 20) = 55;
            *(_DWORD*)(*a1 + 24) = 1;
            (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
        }
        result = 256;
        if (v6 > 256)
        {
            *(_DWORD*)(*a1 + 20) = 56;
            *(_DWORD*)(*a1 + 24) = 256;
            result = (*(int(__cdecl**)(_DWORD*)) * a1)(a1);
        }
        if (a1[19] == 2)
        {
            v7 = 6 * (a1[23] + 2);
            if (!*(_DWORD*)(v4 + 32))
                *(_DWORD*)(v4 + 32) = (*(int(__cdecl**)(_DWORD*, int, unsigned int))(a1[1] + 4))(a1, 1, v7);
            result = sub_47BD68(*(void**)(v4 + 32), v7);
            if (!*(_DWORD*)(v4 + 40))
                result = sub_4839D0((int)a1);
            *(_BYTE*)(v4 + 36) = 0;
        }
    }
    if (*(_BYTE*)(v4 + 28))
    {
        for (i = 0; i < 32; ++i)
            result = sub_47BD68(*(void**)(v9 + 4 * i), 0x1000u);
        *(_BYTE*)(v4 + 28) = 0;
    }
    return result;
}
// 471745: using guessed type int nullsub_2();

//----- (00483B87) --------------------------------------------------------
int __cdecl sub_483B87(int a1)
{
    int result; // eax

    result = *(_DWORD*)(a1 + 420);
    *(_BYTE*)(result + 28) = 1;
    return result;
}

//----- (00483B99) --------------------------------------------------------
int __cdecl sub_483B99(int a1)
{
    int v2; // edi
    int result; // eax
    int v4; // edx
    int v5; // ebx
    int v6; // [esp+10h] [ebp+8h]

    v2 = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 44);
    *(_DWORD*)(a1 + 420) = v2;
    *(_DWORD*)(v2 + 32) = 0;
    *(_DWORD*)(v2 + 40) = 0;
    *(_DWORD*)v2 = sub_483A85;
    *(_DWORD*)(v2 + 12) = sub_483B87;
    if (*(_DWORD*)(a1 + 100) != 3)
    {
        *(_DWORD*)(*(_DWORD*)a1 + 20) = 46;
        (**(void(__cdecl***)(int))a1)(a1);
    }
    v6 = 0;
    *(_DWORD*)(v2 + 24) = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 128);
    do
    {
        result = (*(int(__cdecl**)(int, int, int))(*(_DWORD*)(a1 + 4) + 4))(a1, 1, 4096);
        v4 = v6;
        v6 += 4;
        *(_DWORD*)(v4 + *(_DWORD*)(v2 + 24)) = result;
    } while (v6 < 128);
    *(_BYTE*)(v2 + 28) = 1;
    if (*(_BYTE*)(a1 + 90))
    {
        v5 = *(_DWORD*)(a1 + 84);
        if (v5 < 8)
        {
            *(_DWORD*)(*(_DWORD*)a1 + 20) = 55;
            *(_DWORD*)(*(_DWORD*)a1 + 24) = 8;
            (**(void(__cdecl***)(int))a1)(a1);
        }
        if (v5 > 256)
        {
            *(_DWORD*)(*(_DWORD*)a1 + 20) = 56;
            *(_DWORD*)(*(_DWORD*)a1 + 24) = 256;
            (**(void(__cdecl***)(int))a1)(a1);
        }
        result = (*(int(__cdecl**)(int, int, int, int))(*(_DWORD*)(a1 + 4) + 8))(a1, 1, v5, 3);
        *(_DWORD*)(v2 + 16) = result;
        *(_DWORD*)(v2 + 20) = v5;
    }
    else
    {
        *(_DWORD*)(v2 + 16) = 0;
    }
    if (*(_DWORD*)(a1 + 76))
        *(_DWORD*)(a1 + 76) = 2;
    if (*(_DWORD*)(a1 + 76) == 2)
    {
        *(_DWORD*)(v2 + 32) = (*(int(__cdecl**)(int, int, int))(*(_DWORD*)(a1 + 4) + 4))(
            a1,
            1,
            6 * (*(_DWORD*)(a1 + 92) + 2));
        return sub_4839D0(a1);
    }
    return result;
}

//----- (00483CB6) --------------------------------------------------------
int __cdecl sub_483CB6(_DWORD* a1, char* a2)
{
    _DWORD* v2; // esi
    signed int v3; // ebx
    int v4; // edi
    int v5; // eax
    int v6; // ecx
    int v7; // edi
    signed int v8; // edx
    int v9; // eax
    int* v10; // ecx
    int v11; // edi
    int v12; // eax
    int v14; // [esp+Ch] [ebp-10h]
    int v15; // [esp+10h] [ebp-Ch]
    signed int v16; // [esp+14h] [ebp-8h]
    char v17; // [esp+1Bh] [ebp-1h]

    v2 = a1;
    v3 = a1[25];
    v14 = a1[21];
    v4 = 1;
    do
    {
        v5 = ++v4;
        if (v3 > 1)
        {
            v6 = v3 - 1;
            do
            {
                v5 *= v4;
                --v6;
            } while (v6);
        }
    } while (v5 <= a1[21]);
    v7 = v4 - 1;
    if (v7 < 2)
    {
        *(_DWORD*)(*a1 + 20) = 55;
        *(_DWORD*)(*a1 + 24) = v5;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    v15 = 1;
    if (v3 > 0)
    {
        v8 = v3;
        memset32(a2, v7, v3);
        do
        {
            --v8;
            v15 *= v7;
        } while (v8);
    }
    while (1)
    {
        v17 = 0;
        v16 = 0;
        if (v3 <= 0)
            break;
        while (1)
        {
            v9 = v16;
            if (v2[10] == 2)
                v9 = dword_49CF48[v16];
            v10 = (int*)&a2[4 * v9];
            v11 = *v10 + 1;
            v12 = v11 * (v15 / *v10);
            if (v12 > v14)
                break;
            ++v16;
            *v10 = v11;
            v15 = v12;
            v17 = 1;
            if (v16 >= v3)
                break;
            v2 = a1;
        }
        if (!v17)
            break;
        v2 = a1;
    }
    return v15;
}
// 49CF48: using guessed type int dword_49CF48[];

//----- (00483D81) --------------------------------------------------------
int __usercall sub_483D81@<eax>(_DWORD* a1@<esi>)
{
    int v1; // ebx
    int v2; // eax
    int* v3; // eax
    int result; // eax
    int v5; // ecx
    int v6; // edi
    int i; // edx
    int v8; // eax
    int v9; // [esp+8h] [ebp-34h]
    int v10; // [esp+14h] [ebp-28h]
    int v11; // [esp+18h] [ebp-24h]
    int v12; // [esp+1Ch] [ebp-20h]
    _DWORD* v13; // [esp+20h] [ebp-1Ch]
    int* v14; // [esp+24h] [ebp-18h]
    int v15; // [esp+28h] [ebp-14h]
    int v16; // [esp+2Ch] [ebp-10h]
    int v17; // [esp+34h] [ebp-8h]
    int j; // [esp+38h] [ebp-4h]

    v10 = a1[105];
    v1 = sub_483CB6(a1, (char*)(v10 + 32));
    v2 = *a1;
    if (a1[25] == 3)
    {
        v3 = (int*)(v2 + 24);
        *v3 = v1;
        v3[1] = *(_DWORD*)(v10 + 32);
        v3[2] = *(_DWORD*)(v10 + 36);
        v3[3] = *(_DWORD*)(v10 + 40);
        *(_DWORD*)(*a1 + 20) = 93;
    }
    else
    {
        *(_DWORD*)(v2 + 20) = 94;
        *(_DWORD*)(*a1 + 24) = v1;
    }
    (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
    result = (*(int(__cdecl**)(_DWORD*, int, int, _DWORD))(a1[1] + 8))(a1, 1, v1, a1[25]);
    v12 = 0;
    v9 = result;
    v15 = v1;
    if ((int)a1[25] > 0)
    {
        v13 = (_DWORD*)result;
        v14 = (int*)(v10 + 32);
        do
        {
            v5 = *v14;
            v6 = 0;
            v17 = v15 / *v14;
            if (*v14 > 0)
            {
                v16 = 0;
                v11 = *v14;
                do
                {
                    for (i = v16; i < v1; i += v15)
                    {
                        for (j = 0; j < v17; *(_BYTE*)(v8 + i) = (v6 + (v5 - 1) / 2) / (v5 - 1))
                        {
                            v8 = j + *v13;
                            ++j;
                        }
                    }
                    v16 += v17;
                    v6 += 255;
                    --v11;
                } while (v11);
            }
            ++v12;
            ++v14;
            ++v13;
            v15 = v17;
        } while (v12 < a1[25]);
        result = v9;
    }
    *(_DWORD*)(v10 + 20) = v1;
    *(_DWORD*)(v10 + 16) = result;
    return result;
}

//----- (00483EAE) --------------------------------------------------------
int __cdecl sub_483EAE(_DWORD* a1)
{
    int v1; // esi
    int v2; // ebx
    int result; // eax
    int v4; // ecx
    _BYTE* v5; // edi
    int v6; // edx
    int i; // eax
    int v8; // ebx
    int v9; // edx
    _BYTE* v10; // ecx
    int v11; // [esp+10h] [ebp-18h]
    int v12; // [esp+14h] [ebp-14h]
    int* v13; // [esp+18h] [ebp-10h]
    int v14; // [esp+1Ch] [ebp-Ch]
    int v15; // [esp+20h] [ebp-8h]
    int v16; // [esp+24h] [ebp-4h]

    v1 = a1[105];
    if (a1[19] == 1)
    {
        v14 = 510;
        *(_BYTE*)(v1 + 28) = 1;
    }
    else
    {
        v14 = 0;
        *(_BYTE*)(v1 + 28) = 0;
    }
    v2 = 0;
    *(_DWORD*)(v1 + 24) = (*(int(__cdecl**)(_DWORD*, int, int, _DWORD))(a1[1] + 8))(a1, 1, v14 + 256, a1[25]);
    result = *(_DWORD*)(v1 + 20);
    v11 = 0;
    if ((int)a1[25] > 0)
    {
        v13 = (int*)(v1 + 32);
        while (1)
        {
            v4 = *v13;
            v12 = result / *v13;
            if (v14)
                *(_DWORD*)(*(_DWORD*)(v1 + 24) + 4 * v2) += 255;
            v5 = *(_BYTE**)(*(_DWORD*)(v1 + 24) + 4 * v2);
            v15 = 0;
            v16 = 0;
            v6 = (v4 + 254) / (2 * v4 - 2);
            do
            {
                if (v16 > v6)
                {
                    for (i = 510 * v15; ; i += 510)
                    {
                        ++v15;
                        v6 = (i + 510 + v4 + 254) / (2 * v4 - 2);
                        if (v16 <= v6)
                            break;
                    }
                }
                v8 = v16++;
                v5[v8] = v12 * v15;
            } while (v16 <= 255);
            if (v14)
            {
                v9 = 1;
                v10 = v5 - 1;
                do
                {
                    *v10 = *v5;
                    v5[v9++ + 255] = v5[255];
                    --v10;
                } while (v9 <= 255);
            }
            result = (int)a1;
            ++v13;
            v2 = ++v11;
            if (v11 >= a1[25])
                break;
            result = v12;
        }
    }
    return result;
}

//----- (00483FD9) --------------------------------------------------------
void __usercall sub_483FD9(int a1@<edi>)
{
    int v1; // edx
    int* v2; // ecx
    int v3; // esi
    int v4; // eax
    _DWORD* v5; // ebx
    int v6; // eax
    int v7; // ebx
    int* v8; // ecx
    int i; // esi
    int v10; // eax
    int v11; // [esp+0h] [ebp-14h]
    int v12; // [esp+4h] [ebp-10h]
    int* v13; // [esp+8h] [ebp-Ch]
    int* v14; // [esp+Ch] [ebp-8h]
    int v15; // [esp+10h] [ebp-4h]

    v1 = *(_DWORD*)(a1 + 420);
    v15 = 0;
    v11 = v1;
    if (*(int*)(a1 + 100) > 0)
    {
        v2 = (int*)(v1 + 52);
        v13 = (int*)(v1 + 52);
        do
        {
            v3 = *(v2 - 5);
            v4 = 0;
            if (v15 <= 0)
                goto LABEL_9;
            v5 = (_DWORD*)(v1 + 32);
            while (v3 != *v5)
            {
                ++v4;
                ++v5;
                if (v4 >= v15)
                    goto LABEL_9;
            }
            v6 = *(_DWORD*)(v1 + 4 * v4 + 52);
            if (!v6)
            {
            LABEL_9:
                v12 = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1024);
                v7 = (v3 << 9) - 512;
                v14 = (int*)&unk_49CE48;
                v8 = (int*)v12;
                do
                {
                    for (i = 0; i < 16; ++i)
                    {
                        v10 = (65025 - 510 * *((unsigned __int8*)v14 + i)) / v7;
                        *v8++ = v10;
                    }
                    v14 += 4;
                } while ((int)v14 < (int)dword_49CF48);
                v6 = v12;
                v1 = v11;
                v2 = v13;
            }
            ++v15;
            *v2++ = v6;
            v13 = v2;
        } while (v15 < *(_DWORD*)(a1 + 100));
    }
}
// 49CF48: using guessed type int dword_49CF48[];

//----- (0048409E) --------------------------------------------------------
int __cdecl sub_48409E(_DWORD* a1, int a2, _DWORD* a3, int a4)
{
    int v4; // esi
    int result; // eax
    _DWORD* v6; // ecx
    unsigned __int8* v7; // edx
    int v8; // esi
    _BYTE* v9; // esi
    bool v10; // zf
    int v11; // [esp+4h] [ebp-14h]
    int v12; // [esp+8h] [ebp-10h]
    int v13; // [esp+Ch] [ebp-Ch]
    int v14; // [esp+10h] [ebp-8h]
    int v15; // [esp+14h] [ebp-4h]
    char v16; // [esp+20h] [ebp+8h]
    _BYTE* v17; // [esp+2Ch] [ebp+14h]

    v4 = a1[23];
    result = a1[25];
    v13 = *(_DWORD*)(a1[105] + 24);
    v11 = v4;
    v12 = result;
    if (a4 > 0)
    {
        v6 = a3;
        v14 = a4;
        do
        {
            v7 = *(unsigned __int8**)((char*)v6 + a2 - (_DWORD)a3);
            v17 = (_BYTE*)*v6;
            if (v4)
            {
                v15 = v4;
                do
                {
                    v16 = 0;
                    v8 = 0;
                    if (result > 0)
                    {
                        do
                        {
                            v16 += *(_BYTE*)(*(_DWORD*)(v13 + 4 * v8) + *v7);
                            result = v12;
                            ++v7;
                            ++v8;
                        } while (v8 < v12);
                    }
                    v9 = v17++;
                    v10 = v15-- == 1;
                    *v9 = v16;
                } while (!v10);
                v4 = v11;
            }
            ++v6;
            --v14;
        } while (v14);
    }
    return result;
}

//----- (00484126) --------------------------------------------------------
int __cdecl sub_484126(int a1, int a2, _DWORD* a3, int a4)
{
    int* v4; // eax
    int v5; // edx
    int result; // eax
    int v7; // edx
    _DWORD* v8; // edi
    unsigned __int8* v9; // ecx
    _BYTE* v10; // esi
    char v11; // dl
    unsigned __int8* v12; // ecx
    char v13; // dl
    char v14; // al
    int v15; // [esp+4h] [ebp-10h]
    int v16; // [esp+8h] [ebp-Ch]
    int v17; // [esp+Ch] [ebp-8h]
    int v18; // [esp+10h] [ebp-4h]
    int v19; // [esp+1Ch] [ebp+8h]

    v4 = *(int**)(*(_DWORD*)(a1 + 420) + 24);
    v18 = *v4;
    v5 = v4[1];
    result = v4[2];
    v17 = v5;
    v7 = *(_DWORD*)(a1 + 92);
    v16 = result;
    v15 = v7;
    if (a4 > 0)
    {
        v8 = a3;
        result = a2 - (_DWORD)a3;
        do
        {
            v9 = *(unsigned __int8**)((char*)v8 + result);
            v10 = (_BYTE*)*v8;
            if (v7)
            {
                v19 = v7;
                do
                {
                    v11 = *(_BYTE*)(*v9 + v18);
                    v12 = v9 + 1;
                    v13 = *(_BYTE*)(*v12++ + v17) + v11;
                    v14 = *(_BYTE*)(*v12 + v16);
                    v9 = v12 + 1;
                    *v10++ = v14 + v13;
                    --v19;
                } while (v19);
                v7 = v15;
                result = a2 - (_DWORD)a3;
            }
            ++v8;
            --a4;
        } while (a4);
    }
    return result;
}

//----- (004841B3) --------------------------------------------------------
int __cdecl sub_4841B3(_DWORD* a1, int a2, void** a3, int a4)
{
    _DWORD* v4; // esi
    int result; // eax
    void** v6; // ebx
    int v7; // edi
    int v8; // eax
    _BYTE* v9; // edi
    unsigned __int8* v10; // eax
    int v11; // ecx
    int v12; // edx
    bool v13; // zf
    char v14; // [esp+4h] [ebp-2Ch]
    int v15; // [esp+Ch] [ebp-24h]
    int v16; // [esp+10h] [ebp-20h]
    _DWORD* v17; // [esp+14h] [ebp-1Ch]
    int v18; // [esp+18h] [ebp-18h]
    void** v19; // [esp+1Ch] [ebp-14h]
    unsigned int v20; // [esp+20h] [ebp-10h]
    unsigned int v21; // [esp+24h] [ebp-Ch]
    int v22; // [esp+28h] [ebp-8h]
    _DWORD* v23; // [esp+2Ch] [ebp-4h]
    int v24; // [esp+38h] [ebp+8h]
    int v25; // [esp+44h] [ebp+14h]

    v4 = (_DWORD*)a1[105];
    v21 = a1[23];
    result = a4;
    v22 = a1[25];
    if (a4 > 0)
    {
        v6 = a3;
        v7 = a2 - (_DWORD)a3;
        v19 = a3;
        v18 = a4;
        do
        {
            sub_47BD68(*v6, v21);
            v8 = v4[12];
            v24 = 0;
            v14 = v8;
            if (v22 > 0)
            {
                v16 = v8 << 6;
                v17 = (void**)((char*)v6 + v7);
                v23 = v4 + 13;
                do
                {
                    v25 = 0;
                    v9 = *v6;
                    v10 = (unsigned __int8*)(v24 + *v17);
                    v15 = *(_DWORD*)(v4[6] + 4 * v24);
                    v11 = v16 + *v23;
                    if (v21)
                    {
                        v20 = v21;
                        do
                        {
                            v12 = *v10;
                            v10 += v22;
                            *v9++ += *(_BYTE*)(v12 + *(_DWORD*)(v11 + 4 * v25) + v15);
                            v13 = v20-- == 1;
                            v25 = ((_BYTE)v25 + 1) & 0xF;
                        } while (!v13);
                        v6 = v19;
                    }
                    ++v24;
                    ++v23;
                } while (v24 < v22);
                v7 = a2 - (_DWORD)a3;
                LOBYTE(v8) = v14;
            }
            result = ((_BYTE)v8 + 1) & 0xF;
            ++v6;
            v13 = v18-- == 1;
            v4[12] = result;
            v19 = v6;
        } while (!v13);
    }
    return result;
}

//----- (0048429E) --------------------------------------------------------
_DWORD* __cdecl sub_48429E(int a1, int a2, _BYTE** a3, int a4)
{
    _DWORD* result; // eax
    int* v5; // ecx
    int v6; // edx
    unsigned __int8* v7; // ecx
    int v8; // edx
    int v9; // esi
    unsigned __int8* v10; // ecx
    bool v11; // zf
    int v12; // [esp+4h] [ebp-30h]
    int v13; // [esp+8h] [ebp-2Ch]
    int v14; // [esp+Ch] [ebp-28h]
    int v15; // [esp+10h] [ebp-24h]
    int v16; // [esp+14h] [ebp-20h]
    int v17; // [esp+18h] [ebp-1Ch]
    int v18; // [esp+1Ch] [ebp-18h]
    int v19; // [esp+24h] [ebp-10h]
    int v20; // [esp+28h] [ebp-Ch]
    _BYTE** v21; // [esp+2Ch] [ebp-8h]
    _BYTE* v22; // [esp+30h] [ebp-4h]
    int v23; // [esp+3Ch] [ebp+8h]
    char v24; // [esp+48h] [ebp+14h]
    char v25; // [esp+48h] [ebp+14h]

    result = *(_DWORD**)(a1 + 420);
    v5 = (int*)result[6];
    v16 = *v5;
    v13 = v5[2];
    v18 = *(_DWORD*)(a1 + 92);
    v15 = v5[1];
    if (a4 > 0)
    {
        v6 = a2 - (_DWORD)a3;
        v21 = a3;
        v19 = a4;
        while (1)
        {
            v7 = *(_BYTE**)((char*)v21 + v6);
            v23 = 0;
            v12 = result[12];
            v22 = *v21;
            v8 = (v12 << 6) + result[14];
            v9 = (v12 << 6) + result[13];
            v17 = v8;
            v14 = (v12 << 6) + result[15];
            if (v18)
            {
                v20 = v18;
                while (1)
                {
                    v24 = *(_BYTE*)(*v7 + *(_DWORD*)(v9 + 4 * v23) + v16);
                    v10 = v7 + 1;
                    v25 = *(_BYTE*)(*v10++ + *(_DWORD*)(v8 + 4 * v23) + v15) + v24;
                    *v22 = *(_BYTE*)(*v10 + *(_DWORD*)(v14 + 4 * v23) + v13) + v25;
                    v7 = v10 + 1;
                    ++v22;
                    v11 = v20-- == 1;
                    v23 = ((_BYTE)v23 + 1) & 0xF;
                    if (v11)
                        break;
                    v8 = v17;
                }
            }
            ++v21;
            v11 = v19-- == 1;
            result[12] = ((_BYTE)v12 + 1) & 0xF;
            if (v11)
                break;
            v6 = a2 - (_DWORD)a3;
        }
    }
    return result;
}

//----- (0048439D) --------------------------------------------------------
char __cdecl sub_48439D(_DWORD* a1, int a2, void** a3, int a4)
{
    int v4; // ebx
    int v5; // eax
    int v7; // esi
    unsigned __int8* v8; // edi
    _BYTE* v9; // esi
    _WORD* v10; // ecx
    int v11; // eax
    int v12; // eax
    int v13; // edx
    bool v14; // zf
    int v16; // [esp+8h] [ebp-40h]
    int v17; // [esp+10h] [ebp-38h]
    int v18; // [esp+14h] [ebp-34h]
    int v19; // [esp+18h] [ebp-30h]
    int v20; // [esp+1Ch] [ebp-2Ch]
    _DWORD* v21; // [esp+20h] [ebp-28h]
    int v22; // [esp+24h] [ebp-24h]
    unsigned int v23; // [esp+28h] [ebp-20h]
    int v24; // [esp+2Ch] [ebp-1Ch]
    __int16 v25; // [esp+30h] [ebp-18h]
    __int16 v26; // [esp+34h] [ebp-14h]
    int v27; // [esp+38h] [ebp-10h]
    unsigned int v28; // [esp+3Ch] [ebp-Ch]
    _DWORD* v29; // [esp+40h] [ebp-8h]
    int v30; // [esp+44h] [ebp-4h]
    int v31; // [esp+50h] [ebp+8h]
    void** v32; // [esp+5Ch] [ebp+14h]

    v30 = a1[25];
    v4 = a1[105];
    v5 = a1[71];
    v28 = a1[23];
    v16 = v4;
    v20 = v5;
    if (a4 > 0)
    {
        v7 = a2 - (_DWORD)a3;
        v32 = a3;
        v22 = a4;
        do
        {
            sub_47BD68(*v32, v28);
            v31 = 0;
            if (v30 > 0)
            {
                v21 = (void**)((char*)v32 + v7);
                v29 = (_DWORD*)(v4 + 68);
                do
                {
                    v8 = (unsigned __int8*)(v31 + *v21);
                    v9 = *v32;
                    if (*(_BYTE*)(v4 + 84))
                    {
                        v27 = -1;
                        v9 += v28 - 1;
                        v8 += v30 * (v28 - 1);
                        v24 = -v30;
                        v10 = (_WORD*)(*v29 + 2 * v28 + 2);
                    }
                    else
                    {
                        v24 = v30;
                        v10 = (_WORD*)*v29;
                        v27 = 1;
                    }
                    v19 = *(_DWORD*)(4 * v31 + *(_DWORD*)(v4 + 24));
                    v18 = *(_DWORD*)(4 * v31 + *(_DWORD*)(v4 + 16));
                    v11 = 0;
                    v26 = 0;
                    v25 = 0;
                    if (v28)
                    {
                        v23 = v28;
                        do
                        {
                            v12 = *(unsigned __int8*)(*v8 + (((__int16)v10[v27] + v11 + 8) >> 4) + v20);
                            v13 = *(unsigned __int8*)(v12 + v19);
                            *v9 += v13;
                            v8 += v24;
                            v9 += v27;
                            v17 = v12 - *(unsigned __int8*)(v13 + v18);
                            *v10 = 3 * v17 + v26;
                            v26 = 5 * v17 + v25;
                            v11 = 7 * v17;
                            v14 = v23-- == 1;
                            v25 = v17;
                            v10 += v27;
                        } while (!v14);
                        v4 = v16;
                    }
                    ++v31;
                    ++v29;
                    *v10 = v26;
                } while (v31 < v30);
                v7 = a2 - (_DWORD)a3;
            }
            LOBYTE(v5) = *(_BYTE*)(v4 + 84) == 0;
            ++v32;
            v14 = v22-- == 1;
            *(_BYTE*)(v4 + 84) = v5;
        } while (!v14);
    }
    return v5;
}

//----- (00484521) --------------------------------------------------------
int __usercall sub_484521@<eax>(_DWORD* a1@<esi>)
{
    int result; // eax
    int v2; // ebx
    int* v3; // edi
    int v4; // [esp+4h] [ebp-4h]

    result = a1[105];
    v2 = 0;
    v4 = 2 * a1[23] + 4;
    if ((int)a1[25] > 0)
    {
        v3 = (int*)(result + 68);
        do
        {
            result = (*(int(__cdecl**)(_DWORD*, int, int))(a1[1] + 4))(a1, 1, v4);
            *v3 = result;
            ++v2;
            ++v3;
        } while (v2 < a1[25]);
    }
    return result;
}

//----- (0048455F) --------------------------------------------------------
void __cdecl sub_48455F(_DWORD* a1)
{
    int v2; // esi
    int v3; // eax
    int v4; // eax
    void** v5; // ebx
    bool v6; // zf
    int v7; // esi
    unsigned int i; // [esp+14h] [ebp+8h]

    v2 = a1[105];
    a1[29] = *(_DWORD*)(v2 + 16);
    a1[28] = *(_DWORD*)(v2 + 20);
    v3 = a1[19];
    if (v3)
    {
        v4 = v3 - 1;
        if (v4)
        {
            if (v4 == 1)
            {
                *(_BYTE*)(v2 + 84) = 0;
                v5 = (void**)(v2 + 68);
                v6 = *(_DWORD*)(v2 + 68) == 0;
                *(_DWORD*)(v2 + 4) = sub_48439D;
                if (v6)
                    sub_484521(a1);
                v7 = 0;
                for (i = 2 * a1[23] + 4; v7 < a1[25]; ++v5)
                {
                    sub_47BD68(*v5, i);
                    ++v7;
                }
            }
            else
            {
                *(_DWORD*)(*a1 + 20) = 47;
                (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
            }
        }
        else
        {
            if (a1[25] == 3)
                *(_DWORD*)(v2 + 4) = sub_48429E;
            else
                *(_DWORD*)(v2 + 4) = sub_4841B3;
            v6 = *(_BYTE*)(v2 + 28) == 0;
            *(_DWORD*)(v2 + 48) = 0;
            if (v6)
                sub_483EAE(a1);
            if (!*(_DWORD*)(v2 + 52))
                sub_483FD9((int)a1);
        }
    }
    else if (a1[25] == 3)
    {
        *(_DWORD*)(v2 + 4) = sub_484126;
    }
    else
    {
        *(_DWORD*)(v2 + 4) = sub_48409E;
    }
}

//----- (00484630) --------------------------------------------------------
int __cdecl sub_484630(int a1)
{
    *(_DWORD*)(*(_DWORD*)a1 + 20) = 45;
    return (**(int(__cdecl***)(int))a1)(a1);
}

//----- (00484647) --------------------------------------------------------
int __cdecl sub_484647(_DWORD* a1)
{
    _DWORD* v1; // eax
    int result; // eax

    v1 = (_DWORD*)(*(int(__cdecl**)(_DWORD*, int, int))a1[1])(a1, 1, 88);
    a1[105] = v1;
    v1[17] = 0;
    v1[13] = 0;
    *v1 = sub_48455F;
    v1[2] = nullsub_2;
    v1[3] = sub_484630;
    if ((int)a1[25] > 4)
    {
        *(_DWORD*)(*a1 + 20) = 54;
        *(_DWORD*)(*a1 + 24) = 4;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    if ((int)a1[21] > 256)
    {
        *(_DWORD*)(*a1 + 20) = 56;
        *(_DWORD*)(*a1 + 24) = 256;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    sub_483D81(a1);
    result = sub_483EAE(a1);
    if (a1[19] == 2)
        return sub_484521(a1);
    return result;
}
// 471745: using guessed type int nullsub_2();

//----- (004846D1) --------------------------------------------------------
int(__cdecl* __cdecl sub_4846D1(_DWORD* a1, int a2, _DWORD* a3))(_DWORD, _DWORD, _DWORD)
{
    int v3; // eax
    int(__cdecl * result)(_DWORD, _DWORD, _DWORD); // eax

    if (a3)
        *a3 = a1[15];
    if (*a1 == 4 || *a1 == 5)
        (*(void(__cdecl**)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD*)(a2 + 40), a1[3]);
    if (*a1 == 6)
        sub_485FE8(a1[1], a2);
    v3 = a1[10];
    a1[13] = v3;
    a1[12] = v3;
    result = (int(__cdecl*)(_DWORD, _DWORD, _DWORD))a1[14];
    *a1 = 0;
    a1[7] = 0;
    a1[8] = 0;
    if (result)
    {
        result = (int(__cdecl*)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
        a1[15] = result;
        *(_DWORD*)(a2 + 48) = result;
    }
    return result;
}

//----- (0048473D) --------------------------------------------------------
_DWORD* __cdecl sub_48473D(int a1, int a2, int a3)
{
    _DWORD* v3; // edi
    int v4; // eax
    int v6; // eax

    v3 = (_DWORD*)(*(int(__cdecl**)(_DWORD, int, int))(a1 + 32))(*(_DWORD*)(a1 + 40), 1, 64);
    if (!v3)
        return 0;
    v4 = (*(int(__cdecl**)(_DWORD, int, int))(a1 + 32))(*(_DWORD*)(a1 + 40), 8, 1440);
    v3[9] = v4;
    if (!v4)
    {
        (*(void(__cdecl**)(_DWORD, _DWORD*))(a1 + 36))(*(_DWORD*)(a1 + 40), v3);
        return 0;
    }
    v6 = (*(int(__cdecl**)(_DWORD, int, int))(a1 + 32))(*(_DWORD*)(a1 + 40), 1, a3);
    v3[10] = v6;
    if (v6)
    {
        *v3 = 0;
        v3[11] = a3 + v6;
        v3[14] = a2;
        sub_4846D1(v3, a1, 0);
        return v3;
    }
    else
    {
        (*(void(__cdecl**)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD*)(a1 + 40), v3[9]);
        (*(void(__cdecl**)(_DWORD, _DWORD*))(a1 + 36))(*(_DWORD*)(a1 + 40), v3);
        return 0;
    }
}

//----- (004847CB) --------------------------------------------------------
int __cdecl sub_4847CB(int* a1, int* a2, int a3)
{
    unsigned int v4; // ecx
    int v5; // esi
    char* v6; // eax
    unsigned __int8* v7; // edi
    unsigned int v8; // ecx
    int v9; // eax
    unsigned int v10; // eax
    unsigned int v11; // eax
    int v13; // eax
    int v14; // eax
    int v15; // eax
    int v16; // eax
    unsigned int v17; // eax
    int v18; // eax
    int v19; // eax
    int v20; // ecx
    unsigned int v21; // eax
    unsigned int v22; // ecx
    int v23; // eax
    char* v24; // ecx
    unsigned int v25; // eax
    unsigned int v26; // edx
    int v27; // eax
    unsigned int v28; // ecx
    char* v29; // edx
    unsigned int v30; // eax
    const void* v31; // esi
    void* v32; // edi
    unsigned int v33; // ecx
    int v34; // eax
    unsigned int v35; // eax
    unsigned int v36; // ecx
    unsigned int v37; // eax
    int v38; // eax
    unsigned int i; // ecx
    int v40; // eax
    char v41; // al
    int v42; // ecx
    int v43; // edx
    unsigned int v44; // eax
    int v45; // edx
    int v46; // eax
    int v47; // ecx
    unsigned int v48; // edx
    int v49; // eax
    int v50; // edx
    int v51; // ecx
    int v52; // eax
    unsigned int v53; // eax
    int v54; // eax
    int v55; // eax
    char* v56; // eax
    int v57; // eax
    char* v58; // ecx
    unsigned int v59; // eax
    int v60; // eax
    bool v61; // zf
    int v62; // eax
    char* v63; // eax
    unsigned __int8* v64; // ecx
    int v65; // [esp-28h] [ebp-68h]
    _DWORD* v66; // [esp-1Ch] [ebp-5Ch]
    _DWORD* v67; // [esp-14h] [ebp-54h]
    int v68; // [esp-8h] [ebp-48h]
    int v69; // [esp-8h] [ebp-48h]
    int v70; // [esp-4h] [ebp-44h]
    int v71; // [esp+Ch] [ebp-34h] BYREF
    int v72; // [esp+10h] [ebp-30h] BYREF
    char* v73; // [esp+14h] [ebp-2Ch]
    int v74; // [esp+18h] [ebp-28h] BYREF
    int v75; // [esp+1Ch] [ebp-24h] BYREF
    int v76; // [esp+20h] [ebp-20h] BYREF
    int v77; // [esp+24h] [ebp-1Ch] BYREF
    unsigned int v78; // [esp+28h] [ebp-18h] BYREF
    int v79; // [esp+2Ch] [ebp-14h] BYREF
    int v80; // [esp+30h] [ebp-10h]
    char* v81; // [esp+34h] [ebp-Ch]
    unsigned int v82; // [esp+38h] [ebp-8h]
    unsigned int v83; // [esp+3Ch] [ebp-4h]
    unsigned int v84; // [esp+48h] [ebp+8h]
    unsigned int v85; // [esp+48h] [ebp+8h]
    int v86; // [esp+50h] [ebp+10h]

    v4 = a1[12];
    v5 = (int)a2;
    v82 = a2[1];
    v83 = a1[8];
    v84 = a1[7];
    v6 = (char*)a1[13];
    v7 = (unsigned __int8*)*a2;
    v79 = *a2;
    v81 = v6;
    if ((unsigned int)v6 >= v4)
        v8 = a1[11] - (_DWORD)v6;
    else
        v8 = v4 - (_DWORD)v6 - 1;
    v9 = *a1;
    v80 = v8;
    while (2)
    {
        switch (v9)
        {
        case 0:
            while (v84 < 3)
            {
                if (!v82)
                    goto LABEL_114;
                v13 = *v7;
                a3 = 0;
                --v82;
                v83 |= v13 << v84;
                ++v7;
                v84 += 8;
                v79 = (int)v7;
            }
            v14 = (unsigned __int8)(v83 & 7) >> 1;
            a1[6] = v83 & 1;
            if (!v14)
            {
                v85 = v84 - 3;
                v20 = v85 & 7;
                v21 = v83 >> 3 >> v20;
                v84 = v85 - v20;
                *a1 = 1;
                v83 = v21;
                goto LABEL_107;
            }
            v15 = v14 - 1;
            if (v15)
            {
                v16 = v15 - 1;
                if (!v16)
                {
                    v83 >>= 3;
                    v18 = 3;
                    v84 -= 3;
                    goto LABEL_22;
                }
                if (v16 != 1)
                    goto LABEL_107;
                v17 = v83 >> 3;
                *a1 = 9;
                *(_DWORD*)(v5 + 24) = "invalid block type";
                a1[8] = v17;
                v10 = v84 - 3;
                v70 = -3;
                goto LABEL_7;
            }
            sub_486515(&v74, &v75, &v76, &v77);
            v19 = sub_485A50(v74, v75, v76, v77, v5);
            a1[1] = v19;
            if (!v19)
                goto LABEL_120;
            v83 >>= 3;
            v84 -= 3;
            *a1 = 6;
            goto LABEL_107;
        case 1:
            v22 = v84;
            while (2)
            {
                if (v22 < 0x20)
                {
                    if (v82)
                    {
                        v23 = *v7;
                        a3 = 0;
                        --v82;
                        v83 |= v23 << v22;
                        ++v7;
                        v22 += 8;
                        v79 = (int)v7;
                        v84 = v22;
                        continue;
                    }
                LABEL_114:
                    v70 = a3;
                    a1[8] = v83;
                    a1[7] = v84;
                    *(_DWORD*)(v5 + 4) = 0;
                LABEL_8:
                    *(_DWORD*)(v5 + 8) += &v7[-*(_DWORD*)v5];
                    v11 = (unsigned int)v81;
                LABEL_9:
                    *(_DWORD*)v5 = v7;
                    a1[13] = v11;
                    return sub_486544(a1, (_DWORD*)v5, v70);
                }
                break;
            }
            if (~v83 >> 16 != (unsigned __int16)v83)
            {
                *a1 = 9;
                *(_DWORD*)(v5 + 24) = "invalid stored block lengths";
                goto LABEL_110;
            }
            a1[1] = (unsigned __int16)v83;
            v61 = a1[1] == 0;
            v84 = 0;
            v83 = 0;
            if (v61)
                LABEL_57:
            v18 = a1[6] != 0 ? 7 : 0;
            else
                v18 = 2;
        LABEL_22:
            *a1 = v18;
        LABEL_107:
            v9 = *a1;
            v7 = (unsigned __int8*)v79;
            v5 = (int)a2;
            if ((unsigned int)*a1 > 9)
            {
            LABEL_5:
                v70 = -2;
                goto LABEL_6;
            }
            v8 = v80;
            continue;
        case 2:
            if (!v82)
                goto LABEL_114;
            if (!v8)
            {
                if ((v24 = (char*)a1[11], v81 != v24)
                    || (v25 = a1[12], v26 = a1[10], v26 == v25)
                    || ((v81 = (char*)a1[10], v26 >= v25) ? (v8 = (unsigned int)&v24[-v26]) : (v8 = v25 - v26 - 1),
                        (v80 = v8) == 0))
                {
                    a1[13] = (int)v81;
                    v27 = sub_486544(a1, (_DWORD*)v5, a3);
                    v28 = a1[12];
                    v86 = v27;
                    v81 = (char*)a1[13];
                    v11 = (unsigned int)v81;
                    v78 = v28;
                    if ((unsigned int)v81 >= v28)
                        v8 = a1[11] - (_DWORD)v81;
                    else
                        v8 = v28 - (_DWORD)v81 - 1;
                    v29 = (char*)a1[11];
                    v80 = v8;
                    v73 = v29;
                    if (v81 == v29)
                    {
                        v11 = a1[10];
                        if (v11 == v78)
                        {
                            v11 = (unsigned int)v81;
                        }
                        else
                        {
                            v81 = (char*)a1[10];
                            if (v11 >= v78)
                                v8 = (unsigned int)&v73[-v11];
                            else
                                v8 = v78 - v11 - 1;
                            v80 = v8;
                        }
                    }
                    if (!v8)
                    {
                        v70 = v86;
                        a1[8] = v83;
                        a1[7] = v84;
                        *(_DWORD*)(v5 + 4) = v82;
                        *(_DWORD*)(v5 + 8) += &v7[-*(_DWORD*)v5];
                        goto LABEL_9;
                    }
                }
            }
            v30 = a1[1];
            a3 = 0;
            if (v30 > v82)
                v30 = v82;
            if (v30 > v8)
                v30 = v8;
            v31 = (const void*)v79;
            v32 = v81;
            v79 += v30;
            v82 -= v30;
            v81 += v30;
            v80 -= v30;
            qmemcpy(v32, v31, v30);
            v61 = a1[1] == v30;
            a1[1] -= v30;
            if (v61)
                goto LABEL_57;
            goto LABEL_107;
        case 3:
            v33 = v84;
            while (2)
            {
                if (v33 < 0xE)
                {
                    if (v82)
                    {
                        v34 = *v7;
                        a3 = 0;
                        --v82;
                        v83 |= v34 << v33;
                        ++v7;
                        v33 += 8;
                        v84 = v33;
                        continue;
                    }
                    goto LABEL_114;
                }
                break;
            }
            v35 = v83 & 0x3FFF;
            v36 = v83 & 0x1F;
            a1[1] = v35;
            if (v36 > 0x1D || (v37 = (v35 >> 5) & 0x1F, v37 > 0x1D))
            {
                *a1 = 9;
                *(_DWORD*)(v5 + 24) = "too many length or distance symbols";
            LABEL_110:
                v70 = -3;
            LABEL_6:
                a1[8] = v83;
                v10 = v84;
            LABEL_7:
                a1[7] = v10;
                *(_DWORD*)(v5 + 4) = v82;
                goto LABEL_8;
            }
            v38 = (*(int(__cdecl**)(_DWORD, unsigned int, int))(v5 + 32))(*(_DWORD*)(v5 + 40), v37 + v36 + 258, 4);
            a1[3] = v38;
            if (!v38)
                goto LABEL_120;
            v83 >>= 14;
            v84 -= 14;
            a1[2] = 0;
            *a1 = 4;
        LABEL_71:
            while (a1[2] < ((unsigned int)a1[1] >> 10) + 4)
            {
                for (i = v84; i < 3; v84 = i)
                {
                    if (!v82)
                        goto LABEL_114;
                    v40 = *v7;
                    a3 = 0;
                    --v82;
                    v83 |= v40 << i;
                    ++v7;
                    i += 8;
                }
                v41 = v83;
                v42 = dword_49CF58[a1[2]];
                v43 = a1[3];
                v83 >>= 3;
                *(_DWORD*)(v43 + 4 * v42) = v41 & 7;
                ++a1[2];
                v84 -= 3;
            }
            while ((unsigned int)a1[2] < 0x13)
                *(_DWORD*)(a1[3] + 4 * dword_49CF58[a1[2]++]) = 0;
            v68 = a1[9];
            v67 = (_DWORD*)a1[3];
            a1[4] = 7;
            v80 = sub_486393(v67, (unsigned int*)a1 + 4, a1 + 5, v68, v5);
            if (v80)
            {
                (*(void(__cdecl**)(_DWORD, int))(v5 + 36))(*(_DWORD*)(v5 + 40), a1[3]);
                v61 = v80 == -3;
            LABEL_117:
                if (v61)
                    *a1 = 9;
                v70 = v80;
                goto LABEL_6;
            }
            a1[2] = 0;
            *a1 = 5;
        LABEL_97:
            while (a1[2] < (((unsigned int)a1[1] >> 5) & 0x1F) + (a1[1] & 0x1F) + 258)
            {
                v44 = a1[4];
                while (v84 < v44)
                {
                    if (!v82)
                        goto LABEL_114;
                    v45 = *v7;
                    a3 = 0;
                    --v82;
                    v83 |= v45 << v84;
                    ++v7;
                    v84 += 8;
                }
                v46 = a1[5] + 8 * (v83 & dword_4B2710[v44]);
                v47 = *(unsigned __int8*)(v46 + 1);
                v48 = *(_DWORD*)(v46 + 4);
                v80 = v47;
                v73 = (char*)v48;
                if (v48 >= 0x10)
                {
                    if (v48 == 18)
                        v49 = 7;
                    else
                        v49 = v48 - 14;
                    v79 = 8 * (v48 == 18) + 3;
                    while (v84 < v49 + v80)
                    {
                        if (!v82)
                            goto LABEL_114;
                        v50 = *v7;
                        a3 = 0;
                        --v82;
                        v83 |= v50 << v84;
                        ++v7;
                        v84 += 8;
                    }
                    v83 >>= v80;
                    v79 += v83 & dword_4B2710[v49];
                    v83 >>= v49;
                    v84 -= v80 + v49;
                    v51 = a1[2];
                    if (v51 + v79 > (((unsigned int)a1[1] >> 5) & 0x1F) + (a1[1] & 0x1F) + 258)
                    {
                    LABEL_115:
                        (*(void(__cdecl**)(_DWORD, int))(v5 + 36))(*(_DWORD*)(v5 + 40), a1[3]);
                        v62 = v83;
                        *a1 = 9;
                        *(_DWORD*)(v5 + 24) = "invalid bit length repeat";
                        a1[8] = v62;
                        a1[7] = v84;
                        *(_DWORD*)(v5 + 4) = v82;
                        *(_DWORD*)(v5 + 8) += &v7[-*(_DWORD*)v5];
                        v63 = v81;
                        *(_DWORD*)v5 = v7;
                        a1[13] = (int)v63;
                        return sub_486544(a1, (_DWORD*)v5, -3);
                    }
                    if (v73 == (char*)16)
                    {
                        if (!v51)
                            goto LABEL_115;
                        v52 = *(_DWORD*)(a1[3] + 4 * v51 - 4);
                    }
                    else
                    {
                        v52 = 0;
                    }
                    do
                    {
                        *(_DWORD*)(a1[3] + 4 * v51++) = v52;
                        --v79;
                    } while (v79);
                    a1[2] = v51;
                }
                else
                {
                    v83 >>= v47;
                    v84 -= v47;
                    *(_DWORD*)(a1[3] + 4 * a1[2]++) = v48;
                }
            }
            v53 = a1[1];
            a1[5] = 0;
            v69 = a1[9];
            v66 = (_DWORD*)a1[3];
            v78 = 9;
            v79 = 6;
            v54 = sub_486412(
                (v53 & 0x1F) + 257,
                ((v53 >> 5) & 0x1F) + 1,
                v66,
                &v78,
                (unsigned int*)&v79,
                &v71,
                &v72,
                v69,
                v5);
            v65 = a1[3];
            v80 = v54;
            (*(void(__cdecl**)(_DWORD, int))(v5 + 36))(*(_DWORD*)(v5 + 40), v65);
            if (v80)
            {
                v61 = v80 == -3;
                goto LABEL_117;
            }
            v55 = sub_485A50(v78, v79, v71, v72, v5);
            if (!v55)
            {
            LABEL_120:
                v70 = -4;
                goto LABEL_6;
            }
            a1[1] = v55;
            *a1 = 6;
        LABEL_101:
            a1[8] = v83;
            a1[7] = v84;
            *(_DWORD*)(v5 + 4) = v82;
            *(_DWORD*)(v5 + 8) += &v7[-*(_DWORD*)v5];
            v56 = v81;
            *(_DWORD*)v5 = v7;
            a1[13] = (int)v56;
            v57 = sub_485A84(a1, v5, a3);
            if (v57 != 1)
                return sub_486544(a1, (_DWORD*)v5, v57);
            a3 = 0;
            sub_485FE8(a1[1], v5);
            v7 = *(unsigned __int8**)v5;
            v82 = *(_DWORD*)(v5 + 4);
            v83 = a1[8];
            v58 = (char*)a1[13];
            v84 = a1[7];
            v59 = a1[12];
            v79 = (int)v7;
            v81 = v58;
            if ((unsigned int)v58 >= v59)
                v60 = a1[11] - (_DWORD)v81;
            else
                v60 = v59 - (_DWORD)v58 - 1;
            v61 = a1[6] == 0;
            v80 = v60;
            if (v61)
            {
                *a1 = 0;
                goto LABEL_107;
            }
            *a1 = 7;
        LABEL_122:
            a1[13] = (int)v81;
            v57 = sub_486544(a1, (_DWORD*)v5, a3);
            v61 = a1[12] == a1[13];
            v81 = (char*)a1[13];
            if (v61)
            {
                *a1 = 8;
            LABEL_126:
                v70 = 1;
                goto LABEL_6;
            }
            a1[8] = v83;
            a1[7] = v84;
            *(_DWORD*)(v5 + 4) = v82;
            v64 = &v7[-*(_DWORD*)v5];
            *(_DWORD*)v5 = v7;
            *(_DWORD*)(v5 + 8) += v64;
            a1[13] = (int)v81;
            return sub_486544(a1, (_DWORD*)v5, v57);
        case 4:
            goto LABEL_71;
        case 5:
            goto LABEL_97;
        case 6:
            goto LABEL_101;
        case 7:
            goto LABEL_122;
        case 8:
            goto LABEL_126;
        case 9:
            goto LABEL_110;
        default:
            goto LABEL_5;
        }
    }
}
// 49CF58: using guessed type int dword_49CF58[19];
// 4B2710: using guessed type int dword_4B2710[19];

//----- (00484F66) --------------------------------------------------------
int __cdecl sub_484F66(_DWORD* a1, int a2)
{
    sub_4846D1(a1, a2, 0);
    (*(void(__cdecl**)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD*)(a2 + 40), a1[10]);
    (*(void(__cdecl**)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD*)(a2 + 40), a1[9]);
    (*(void(__cdecl**)(_DWORD, _DWORD*))(a2 + 36))(*(_DWORD*)(a2 + 40), a1);
    return 0;
}

//----- (00484F9C) --------------------------------------------------------
int __cdecl sub_484F9C(unsigned int a1, unsigned __int8* a2, unsigned int a3)
{
    unsigned __int8* v3; // ecx
    unsigned int v4; // esi
    unsigned int v5; // edi
    int v7; // edx
    unsigned int v8; // eax
    int v9; // esi
    int v10; // edi
    int v11; // esi
    int v12; // edi
    int v13; // esi
    int v14; // edi
    int v15; // esi
    int v16; // edi
    int v17; // esi
    int v18; // edi
    int v19; // esi
    int v20; // edi
    int v21; // esi
    int v22; // edi
    int v23; // esi
    int v24; // edi
    int v25; // esi
    int v26; // edi
    int v27; // esi
    int v28; // edi
    int v29; // esi
    int v30; // edi
    int v31; // esi
    int v32; // edi
    int v33; // esi
    int v34; // edi
    int v35; // esi
    int v36; // edi
    int v37; // esi
    int v38; // edi

    v3 = a2;
    v4 = (unsigned __int16)a1;
    v5 = HIWORD(a1);
    if (!a2)
        return 1;
    for (; a3; v5 %= 0xFFF1u)
    {
        v7 = 5552;
        if (a3 < 0x15B0)
            v7 = a3;
        a3 -= v7;
        if (v7 >= 16)
        {
            v8 = (unsigned int)v7 >> 4;
            v7 += -16 * ((unsigned int)v7 >> 4);
            do
            {
                v9 = *v3 + v4;
                v10 = v9 + v5;
                v11 = v3[1] + v9;
                v12 = v11 + v10;
                v13 = v3[2] + v11;
                v14 = v13 + v12;
                v15 = v3[3] + v13;
                v16 = v15 + v14;
                v17 = v3[4] + v15;
                v18 = v17 + v16;
                v19 = v3[5] + v17;
                v20 = v19 + v18;
                v21 = v3[6] + v19;
                v22 = v21 + v20;
                v23 = v3[7] + v21;
                v24 = v23 + v22;
                v25 = v3[8] + v23;
                v26 = v25 + v24;
                v27 = v3[9] + v25;
                v28 = v27 + v26;
                v29 = v3[10] + v27;
                v30 = v29 + v28;
                v31 = v3[11] + v29;
                v32 = v31 + v30;
                v33 = v3[12] + v31;
                v34 = v33 + v32;
                v35 = v3[13] + v33;
                v36 = v35 + v34;
                v37 = v3[14] + v35;
                v38 = v37 + v36;
                v4 = v3[15] + v37;
                v5 = v4 + v38;
                v3 += 16;
                --v8;
            } while (v8);
        }
        for (; v7; --v7)
        {
            v4 += *v3++;
            v5 += v4;
        }
        v4 %= 0xFFF1u;
    }
    return v4 | (v5 << 16);
}

//----- (004850B5) --------------------------------------------------------
int __cdecl sub_4850B5(int a1, int a2, int a3)
{
    return sub_48B813(a2, a3);
}

//----- (004850C7) --------------------------------------------------------
_BYTE* __cdecl sub_4850C7(int a1, int a2, int a3, int a4, int a5)
{
    int v5; // ecx
    int v6; // edx
    unsigned __int16* v7; // esi
    int* v8; // edi
    _WORD* v9; // ecx
    unsigned __int16 v10; // ax
    unsigned __int16 v11; // bx
    __int16 v12; // ax
    unsigned __int16 v13; // bx
    bool v14; // zf
    int v15; // eax
    int v16; // eax
    int v17; // edx
    int v18; // eax
    int v19; // esi
    int v20; // eax
    int v21; // edi
    int v22; // edx
    int v23; // edi
    int v24; // ebx
    int v25; // esi
    int v26; // esi
    int v27; // eax
    char* v28; // ecx
    int v29; // ebx
    _BYTE* result; // eax
    char v31; // bl
    int v32; // esi
    int v33; // edx
    int v34; // edi
    int v35; // edx
    int v36; // esi
    int v37; // ebx
    int v38; // esi
    int v39; // edx
    int v40; // ebx
    int v41; // edi
    int v42; // edi
    char v43; // [esp+Ch] [ebp-98h] BYREF
    _BYTE v44[96]; // [esp+2Ch] [ebp-78h] BYREF
    int v45; // [esp+8Ch] [ebp-18h]
    unsigned __int16* v46; // [esp+90h] [ebp-14h]
    int* v47; // [esp+94h] [ebp-10h]
    int v48; // [esp+98h] [ebp-Ch]
    int v49; // [esp+9Ch] [ebp-8h]
    int v50; // [esp+A0h] [ebp-4h]
    int v51; // [esp+ACh] [ebp+8h]
    int v52; // [esp+ACh] [ebp+8h]
    __int16 v53; // [esp+B0h] [ebp+Ch]
    __int16 v54; // [esp+B0h] [ebp+Ch]
    int v55; // [esp+B0h] [ebp+Ch]
    unsigned __int16 v56; // [esp+B4h] [ebp+10h]
    __int16 v57; // [esp+B4h] [ebp+10h]
    int v58; // [esp+B4h] [ebp+10h]
    int v59; // [esp+B4h] [ebp+10h]

    v5 = *(_DWORD*)(a2 + 80);
    v6 = *(_DWORD*)(a1 + 284) + 128;
    v7 = (unsigned __int16*)(a3 + 96);
    v8 = (int*)v44;
    v48 = v6;
    v51 = 8;
    v47 = (int*)v44;
    v46 = (unsigned __int16*)(a3 + 96);
    v9 = (_WORD*)(v5 + 96);
    do
    {
        if (v51 != 4)
        {
            v56 = v7[8];
            v10 = *v7;
            v53 = *(v7 - 8);
            LOWORD(v50) = *(v7 - 24);
            v11 = *(v7 - 40);
            v45 = v10;
            v49 = v11;
            v12 = v53 | v50 | v11 | v10;
            v13 = *(v7 - 32);
            v14 = (v13 | (unsigned __int16)(v56 | v12)) == 0;
            v15 = (__int16)*(v9 - 48);
            if (v14)
            {
                v16 = 4 * (__int16)*(v7 - 48) * v15;
                *(v8 - 8) = v16;
                *v8 = v16;
                v8[16] = v16;
            }
            else
            {
                v17 = 15137 * (__int16)(v13 * *(v9 - 32)) - 6270 * (__int16)(v45 * *v9);
                v18 = ((__int16)*(v7 - 48) * v15) << 14;
                v19 = v17 + v18;
                v20 = v18 - v17;
                LOWORD(v17) = v56 * v9[8];
                v57 = v50 * *(v9 - 24);
                v54 = v53 * *(v9 - 8);
                v49 = (__int16)v49 * (__int16)*(v9 - 40);
                v21 = v57;
                v50 = (__int16)v49;
                v58 = (__int16)v17;
                v22 = 8697 * (__int16)v49 + 11893 * v54 - 1730 * (__int16)v17 - 17799 * v21;
                v23 = 20995 * (__int16)v49 + 7373 * v21 - 4926 * v54 - 4176 * v58;
                v24 = v19 + v23 + 2048;
                v25 = v19 - v23;
                v8 = v47;
                *(v47 - 8) = v24 >> 12;
                v8[16] = (v25 + 2048) >> 12;
                v26 = v20 + v22 + 2048;
                v27 = v20 - v22;
                v6 = v48;
                *v8 = v26 >> 12;
                v7 = v46;
                v16 = (v27 + 2048) >> 12;
            }
            v8[8] = v16;
        }
        ++v7;
        ++v8;
        ++v9;
        --v51;
        v46 = v7;
        v47 = v8;
    } while (v51 > 0);
    v52 = 0;
    v28 = &v43;
    do
    {
        v29 = *((_DWORD*)v28 + 5);
        result = (_BYTE*)(a5 + *(_DWORD*)(a4 + 4 * v52));
        if (*((_DWORD*)v28 + 2)
            | *((_DWORD*)v28 + 6)
            | *((_DWORD*)v28 + 7)
            | v29
            | *((_DWORD*)v28 + 3)
            | *((_DWORD*)v28 + 1))
        {
            v32 = 15137 * *((__int16*)v28 + 4) - 6270 * *((__int16*)v28 + 12);
            v33 = *(_DWORD*)v28 << 14;
            v34 = v32 + v33;
            v35 = v33 - v32;
            v50 = *((__int16*)v28 + 2);
            v59 = *((__int16*)v28 + 14);
            v55 = (__int16)v29;
            v36 = 8697 * v50 + 11893 * (__int16)v29 - 1730 * v59;
            v49 = v35;
            v37 = *((__int16*)v28 + 6);
            v38 = v36 - 17799 * v37;
            v39 = 20995 * v50 + 7373 * v37 - 4926 * v55 - 4176 * v59;
            v40 = (v34 + v39 + 0x40000) >> 19;
            v41 = v34 - v39;
            v6 = v48;
            *result = *(_BYTE*)((v40 & 0x3FF) + v48);
            LOBYTE(v40) = *(_BYTE*)((((v41 + 0x40000) >> 19) & 0x3FF) + v6);
            v42 = v49;
            result[3] = v40;
            result[1] = *(_BYTE*)((((v42 + v38 + 0x40000) >> 19) & 0x3FF) + v6);
            v31 = *(_BYTE*)((((v42 - v38 + 0x40000) >> 19) & 0x3FF) + v6);
        }
        else
        {
            v31 = *(_BYTE*)((((*(_DWORD*)v28 + 16) >> 5) & 0x3FF) + v6);
            *result = v31;
            result[1] = v31;
            result[3] = v31;
        }
        v28 += 32;
        ++v52;
        result[2] = v31;
    } while (v52 < 4);
    return result;
}

//----- (004853DC) --------------------------------------------------------
_BYTE* __cdecl sub_4853DC(int a1, int a2, int a3, int a4, int a5)
{
    int v5; // ecx
    int v6; // ebx
    int* v7; // edi
    _WORD* v8; // esi
    _WORD* v9; // ecx
    int v10; // eax
    int v11; // edx
    int v12; // eax
    int v13; // eax
    int v14; // edx
    _BYTE* result; // eax
    _BYTE* v16; // edi
    int v17; // ecx
    char v18; // cl
    int v19; // ecx
    int v20; // esi
    _BYTE v21[64]; // [esp+Ch] [ebp-48h] BYREF
    int v22; // [esp+4Ch] [ebp-8h]
    int* v23; // [esp+50h] [ebp-4h]
    int v24; // [esp+5Ch] [ebp+8h]
    int v25; // [esp+5Ch] [ebp+8h]

    v5 = *(_DWORD*)(a2 + 80);
    v6 = *(_DWORD*)(a1 + 284) + 128;
    v7 = (int*)v21;
    v8 = (_WORD*)(a3 + 48);
    v22 = v6;
    v23 = (int*)v21;
    v24 = 8;
    v9 = (_WORD*)(v5 + 48);
    do
    {
        if (v24 != 6 && v24 != 4 && v24 != 2)
        {
            v10 = (__int16)*(v9 - 24);
            v11 = (__int16)*(v8 - 24);
            if (*v8 | (unsigned __int16)(*(v8 - 16) | v8[16] | v8[32]))
            {
                v13 = (v11 * v10) << 15;
                v14 = 29692 * (__int16)(*(v8 - 16) * *(v9 - 16))
                    + 6967 * (__int16)(v8[16] * v9[16])
                    - 5906 * (__int16)(v8[32] * v9[32])
                    - 10426 * (__int16)(*v8 * *v9);
                v7 = v23;
                *v23 = (v14 + v13 + 4096) >> 13;
                v6 = v22;
                v12 = (v13 - v14 + 4096) >> 13;
            }
            else
            {
                v12 = 4 * v11 * v10;
                *v7 = v12;
            }
            v7[8] = v12;
        }
        ++v8;
        ++v7;
        ++v9;
        --v24;
        v23 = v7;
    } while (v24 > 0);
    v25 = 0;
    result = v21;
    do
    {
        v16 = (_BYTE*)(a5 + *(_DWORD*)(a4 + 4 * v25));
        v17 = *(_DWORD*)result;
        if (*((_DWORD*)result + 5) | *((_DWORD*)result + 1) | *((_DWORD*)result + 3) | *((_DWORD*)result + 7))
        {
            v19 = v17 << 15;
            v20 = 6967 * *((__int16*)result + 10)
                + 29692 * *((__int16*)result + 2)
                + -10426 * *((__int16*)result + 6)
                - 5906 * *((__int16*)result + 14);
            v6 = v22;
            *v16 = *(_BYTE*)((((v20 + v19 + 0x80000) >> 20) & 0x3FF) + v22);
            v18 = *(_BYTE*)((((v19 - v20 + 0x80000) >> 20) & 0x3FF) + v6);
        }
        else
        {
            v18 = *(_BYTE*)((((v17 + 16) >> 5) & 0x3FF) + v6);
            *v16 = v18;
        }
        result += 32;
        ++v25;
        v16[1] = v18;
    } while (v25 < 2);
    return result;
}

//----- (0048559A) --------------------------------------------------------
char __cdecl sub_48559A(int a1, int a2, __int16* a3, _DWORD* a4, int a5)
{
    char result; // al

    result = *(_BYTE*)((((*a3 * **(__int16**)(a2 + 80) + 4) >> 3) & 0x3FF) + *(_DWORD*)(a1 + 284) + 128);
    *(_BYTE*)(a5 + *a4) = result;
    return result;
}

//----- (004855D7) --------------------------------------------------------
int __cdecl sub_4855D7(int a1, int a2, __m64* a3, int a4, int a5)
{
    __m64* v6; // [esp-14h] [ebp-A4h]
    int v7; // [esp-4h] [ebp-94h]
    __m64 v8[17]; // [esp+8h] [ebp-88h] BYREF

    v7 = *(_DWORD*)(a1 + 284) + 128;
    v6 = *(__m64**)(a2 + 80);
    if (byte_4B15AC)
        return sub_486ABB(a3, v6, v8, a4, a5, v7);
    else
        return sub_486659((__int16*)a3, (__int16*)v6, (int*)v8, a4, a5, v7);
}
// 4B15AC: using guessed type char byte_4B15AC;

//----- (00485623) --------------------------------------------------------
char __cdecl sub_485623(int a1, int a2, __m64* a3, _DWORD* a4, int a5)
{
    __m64* v6; // [esp-10h] [ebp-A0h]
    int v7; // [esp-4h] [ebp-94h]
    __m64 v8[17]; // [esp+8h] [ebp-88h] BYREF

    v7 = *(_DWORD*)(a1 + 284) + 128;
    v6 = *(__m64**)(a2 + 80);
    if (byte_4B15AC)
        return sub_487523(a3, v8, v6, a4, a5, v7);
    else
        return sub_4871C8(a3, v8, v6, (int)a4, a5, v7);
}
// 4B15AC: using guessed type char byte_4B15AC;

//----- (0048566F) --------------------------------------------------------
char __cdecl sub_48566F(int a1, int a2, __int16* a3, int a4, int a5)
{
    float* v6; // ecx
    float* v7; // eax
    __int16 v8; // si
    __int16 v9; // di
    double v10; // st5
    int v11; // edi
    double v12; // st4
    double v13; // st5
    double v14; // st4
    double v15; // st3
    double v16; // st5
    double v17; // st4
    double v18; // st3
    double v19; // st2
    double v20; // st2
    double v21; // st4
    double v22; // st3
    double v23; // st2
    double v24; // st1
    float* v25; // esi
    _BYTE* v26; // edi
    double v27; // st5
    double v28; // st4
    double v29; // st3
    double v30; // st5
    double v31; // st4
    double v32; // st4
    double v33; // st3
    double v34; // st2
    double v35; // st1
    double v36; // st3
    double v37; // st4
    double v38; // st5
    __int64 v39; // rax
    double v40; // st5
    __int64 v41; // rax
    double v42; // st5
    char result; // al
    bool v44; // cc
    char v45; // [esp+Ch] [ebp-118h] BYREF
    char v46; // [esp+14h] [ebp-110h] BYREF
    int v47; // [esp+10Ch] [ebp-18h]
    float v48; // [esp+110h] [ebp-14h]
    int v49; // [esp+114h] [ebp-10h]
    float v50; // [esp+118h] [ebp-Ch]
    float v51; // [esp+11Ch] [ebp-8h]
    float v52; // [esp+120h] [ebp-4h]
    float v53; // [esp+12Ch] [ebp+8h]
    float v54; // [esp+12Ch] [ebp+8h]
    float v55; // [esp+12Ch] [ebp+8h]
    float v56; // [esp+130h] [ebp+Ch]
    float v57; // [esp+130h] [ebp+Ch]
    float v58; // [esp+130h] [ebp+Ch]
    float v59; // [esp+130h] [ebp+Ch]
    float v60; // [esp+130h] [ebp+Ch]
    float v61; // [esp+130h] [ebp+Ch]
    int v62; // [esp+134h] [ebp+10h]
    float v63; // [esp+134h] [ebp+10h]
    float v64; // [esp+134h] [ebp+10h]
    float v65; // [esp+134h] [ebp+10h]

    v49 = *(_DWORD*)(a1 + 284) + 128;
    v6 = *(float**)(a2 + 80);
    v7 = (float*)&v45;
    v47 = 8;
    do
    {
        v8 = a3[56];
        v9 = a3[48];
        v10 = (double)*a3 * *v6;
        if ((unsigned __int16)v8 | (unsigned __int16)(v9 | a3[40] | a3[32] | a3[24] | a3[16] | a3[8]))
        {
            v53 = v6[16] * (double)a3[16];
            v62 = v9;
            v11 = a3[8];
            v12 = v6[32] * (double)a3[32];
            v63 = v6[48] * (double)v62;
            v56 = v12 + v10;
            v13 = v10 - v12;
            v14 = v63 + v53;
            v15 = (v53 - v63) * 1.4142135 - v14;
            v48 = v14 + v56;
            v64 = v56 - v14;
            v54 = v15 + v13;
            v16 = v13 - v15;
            v17 = v6[8] * (double)v11;
            v18 = v6[24] * (double)a3[24];
            v19 = v6[40] * (double)a3[40];
            LODWORD(v50) = v8;
            v57 = v19;
            v20 = v6[56] * (double)v8;
            v51 = v57 + v18;
            v58 = v57 - v18;
            v52 = v20 + v17;
            v21 = v17 - v20;
            v22 = v52 + v51;
            v50 = (v21 + v58) * 1.847759;
            v23 = v50 - v58 * 2.613126 - v22;
            v24 = (v52 - v51) * 1.4142135 - v23;
            v52 = v24;
            v51 = v21 * 1.0823922 - v50 + v24;
            *v7 = v22 + v48;
            v7[56] = v48 - v22;
            v7[8] = v54 + v23;
            v7[48] = v54 - v23;
            v7[16] = v52 + v16;
            v7[40] = v16 - v52;
            v7[32] = v51 + v64;
            v7[24] = v64 - v51;
        }
        else
        {
            *v7 = v10;
            v7[8] = v10;
            v7[16] = v10;
            v7[24] = v10;
            v7[32] = v10;
            v7[40] = v10;
            v7[48] = v10;
            v7[56] = v10;
        }
        ++v6;
        ++a3;
        ++v7;
        --v47;
    } while (*(float*)&v47 != 0.0);
    v50 = 0.0;
    v25 = (float*)&v46;
    do
    {
        v26 = (_BYTE*)(a5 + *(_DWORD*)(a4 + 4 * LODWORD(v50)));
        v59 = v25[2] + *(v25 - 2);
        v27 = *(v25 - 2) - v25[2];
        v28 = *v25 + v25[4];
        v29 = (*v25 - v25[4]) * 1.4142135 - v28;
        v48 = v28 + v59;
        v65 = v59 - v28;
        v55 = v29 + v27;
        v30 = v27 - v29;
        v31 = v25[3] + v25[1];
        v51 = v31;
        v60 = v25[3] - v25[1];
        v52 = v25[5] + *(v25 - 1);
        *(float*)&v47 = *(v25 - 1) - v25[5];
        v32 = v31 + v52;
        v33 = (*(float*)&v47 + v60) * 1.847759;
        v34 = v33 - v60 * 2.613126 - v32;
        v61 = v34;
        v35 = (v52 - v51) * 1.4142135 - v34;
        v52 = v35;
        v51 = *(float*)&v47 * 1.0823922 - v33 + v35;
        v36 = v48 - v32;
        *v26 = *(_BYTE*)((((int)((__int64)(v48 + v32) + 4) >> 3) & 0x3FF) + v49);
        v26[7] = *(_BYTE*)((((int)((__int64)v36 + 4) >> 3) & 0x3FF) + v49);
        v26[1] = *(_BYTE*)((((int)((__int64)(v61 + v55) + 4) >> 3) & 0x3FF) + v49);
        v37 = v52 + v30;
        v26[6] = *(_BYTE*)((((int)((__int64)(v55 - v61) + 4) >> 3) & 0x3FF) + v49);
        v38 = v30 - v52;
        v26[2] = *(_BYTE*)((((int)((__int64)v37 + 4) >> 3) & 0x3FF) + v49);
        v39 = (__int64)v38;
        v40 = v51 + v65;
        v26[5] = *(_BYTE*)(((((int)v39 + 4) >> 3) & 0x3FF) + v49);
        v41 = (__int64)v40;
        v42 = v65 - v51;
        v26[4] = *(_BYTE*)(((((int)v41 + 4) >> 3) & 0x3FF) + v49);
        result = *(_BYTE*)((((int)((__int64)v42 + 4) >> 3) & 0x3FF) + v49);
        v25 += 8;
        v44 = ++LODWORD(v50) < 8;
        v26[3] = result;
    } while (v44);
    return result;
}

//----- (00485A50) --------------------------------------------------------
int __cdecl sub_485A50(char a1, char a2, int a3, int a4, int a5)
{
    int result; // eax

    result = (*(int(__cdecl**)(_DWORD, int, int))(a5 + 32))(*(_DWORD*)(a5 + 40), 1, 28);
    if (result)
    {
        *(_DWORD*)result = 0;
        *(_BYTE*)(result + 16) = a1;
        *(_BYTE*)(result + 17) = a2;
        *(_DWORD*)(result + 20) = a3;
        *(_DWORD*)(result + 24) = a4;
    }
    return result;
}

//----- (00485A84) --------------------------------------------------------
int __cdecl sub_485A84(_DWORD* a1, int a2, int a3)
{
    _BYTE* v5; // edx
    int v6; // ebx
    unsigned int v7; // eax
    unsigned int v8; // eax
    int v9; // eax
    unsigned int v10; // eax
    int v11; // eax
    unsigned int v12; // eax
    unsigned __int8* v13; // eax
    unsigned __int8* v14; // eax
    unsigned int v15; // eax
    int v16; // ecx
    unsigned int v17; // eax
    unsigned __int8* v18; // eax
    unsigned __int8* v19; // ecx
    int v20; // eax
    unsigned int v21; // eax
    int v22; // ecx
    unsigned int v23; // eax
    unsigned int v24; // eax
    unsigned int v25; // ecx
    int v26; // eax
    unsigned int v27; // eax
    unsigned int v28; // ecx
    unsigned int v29; // eax
    unsigned int v30; // ecx
    int v31; // eax
    unsigned int v32; // eax
    unsigned int v33; // ecx
    unsigned __int8* v34; // ecx
    int v36; // eax
    unsigned __int8* v37; // ebx
    int v38; // [esp-4h] [ebp-28h]
    int v39; // [esp+Ch] [ebp-18h]
    unsigned int v40; // [esp+Ch] [ebp-18h]
    unsigned int v41; // [esp+Ch] [ebp-18h]
    _BYTE* v42; // [esp+10h] [ebp-14h]
    _BYTE* v43; // [esp+14h] [ebp-10h]
    _BYTE* v44; // [esp+14h] [ebp-10h]
    unsigned int v45; // [esp+18h] [ebp-Ch]
    unsigned int v46; // [esp+1Ch] [ebp-8h]
    unsigned __int8* v47; // [esp+20h] [ebp-4h]
    unsigned int v48; // [esp+2Ch] [ebp+8h]
    unsigned int v49; // [esp+30h] [ebp+Ch]
    int v50; // [esp+34h] [ebp+10h]

    v47 = *(unsigned __int8**)a2;
    v5 = (_BYTE*)a1[13];
    v6 = a1[1];
    v46 = *(_DWORD*)(a2 + 4);
    v49 = a1[8];
    v48 = a1[7];
    v7 = a1[12];
    if ((unsigned int)v5 >= v7)
        v8 = a1[11] - (_DWORD)v5;
    else
        v8 = v7 - (_DWORD)v5 - 1;
LABEL_83:
    v45 = v8;
    while (2)
    {
        switch (*(_DWORD*)v6)
        {
        case 0:
            if (v8 >= 0x102 && v46 >= 0xA)
            {
                a1[8] = v49;
                a1[7] = v48;
                *(_DWORD*)(a2 + 4) = v46;
                *(_DWORD*)(a2 + 8) += &v47[-*(_DWORD*)a2];
                *(_DWORD*)a2 = v47;
                a1[13] = v5;
                v9 = sub_4882D2(
                    *(unsigned __int8*)(v6 + 16),
                    *(unsigned __int8*)(v6 + 17),
                    *(_DWORD*)(v6 + 20),
                    *(_DWORD*)(v6 + 24),
                    a1,
                    (unsigned __int8**)a2);
                v5 = (_BYTE*)a1[13];
                a3 = v9;
                v47 = *(unsigned __int8**)a2;
                v46 = *(_DWORD*)(a2 + 4);
                v49 = a1[8];
                v48 = a1[7];
                v10 = a1[12];
                v11 = (unsigned int)v5 >= v10 ? a1[11] - (_DWORD)v5 : v10 - (_DWORD)v5 - 1;
                v45 = v11;
                if (a3)
                {
                    *(_DWORD*)v6 = 2 * (a3 != 1) + 7;
                    goto LABEL_36;
                }
            }
            *(_DWORD*)(v6 + 12) = *(unsigned __int8*)(v6 + 16);
            *(_DWORD*)(v6 + 8) = *(_DWORD*)(v6 + 20);
            *(_DWORD*)v6 = 1;
            goto LABEL_15;
        case 1:
        LABEL_15:
            while (2)
            {
                v12 = *(_DWORD*)(v6 + 12);
                if (v48 >= v12)
                {
                    v13 = (unsigned __int8*)(*(_DWORD*)(v6 + 8) + 8 * (v49 & dword_4B2710[v12]));
                    v49 >>= v13[1];
                    v48 -= v13[1];
                    v39 = *v13;
                    if (*v13)
                    {
                        if ((v39 & 0x10) != 0)
                        {
                            *(_DWORD*)(v6 + 8) = v39 & 0xF;
                            *(_DWORD*)(v6 + 4) = *((_DWORD*)v13 + 1);
                            *(_DWORD*)v6 = 2;
                            goto LABEL_36;
                        }
                        if ((v39 & 0x40) != 0)
                        {
                            if ((v39 & 0x20) != 0)
                            {
                                *(_DWORD*)v6 = 7;
                                goto LABEL_36;
                            }
                            *(_DWORD*)v6 = 9;
                            *(_DWORD*)(a2 + 24) = "invalid literal/length code";
                        LABEL_89:
                            v38 = -3;
                            goto LABEL_85;
                        }
                        *(_DWORD*)(v6 + 12) = v39;
                        v14 = &v13[8 * *((_DWORD*)v13 + 1)];
                    }
                    else
                    {
                        v14 = (unsigned __int8*)*((_DWORD*)v13 + 1);
                        *(_DWORD*)v6 = 6;
                    }
                    goto LABEL_35;
                }
                if (v46)
                {
                    a3 = 0;
                    --v46;
                    v49 |= *v47++ << v48;
                    v48 += 8;
                    continue;
                }
                goto LABEL_91;
            }
        case 2:
            while (2)
            {
                v15 = *(_DWORD*)(v6 + 8);
                if (v48 < v15)
                {
                    if (v46)
                    {
                        a3 = 0;
                        --v46;
                        v49 |= *v47++ << v48;
                        v48 += 8;
                        continue;
                    }
                LABEL_91:
                    v38 = a3;
                    a1[8] = v49;
                    a1[7] = v48;
                    *(_DWORD*)(a2 + 4) = 0;
                    goto LABEL_86;
                }
                break;
            }
            v16 = *(_DWORD*)(v6 + 8);
            *(_DWORD*)(v6 + 4) += v49 & dword_4B2710[v15];
            v49 >>= v16;
            v48 -= v16;
            *(_DWORD*)(v6 + 12) = *(unsigned __int8*)(v6 + 17);
            *(_DWORD*)(v6 + 8) = *(_DWORD*)(v6 + 24);
            *(_DWORD*)v6 = 3;
        LABEL_30:
            while (1)
            {
                v17 = *(_DWORD*)(v6 + 12);
                if (v48 >= v17)
                    break;
                if (!v46)
                    goto LABEL_91;
                a3 = 0;
                --v46;
                v49 |= *v47++ << v48;
                v48 += 8;
            }
            v18 = (unsigned __int8*)(*(_DWORD*)(v6 + 8) + 8 * (v49 & dword_4B2710[v17]));
            v49 >>= v18[1];
            v48 -= v18[1];
            v19 = v18;
            v20 = *v18;
            if ((v20 & 0x10) != 0)
            {
                *(_DWORD*)(v6 + 8) = v20 & 0xF;
                *(_DWORD*)(v6 + 12) = *((_DWORD*)v19 + 1);
                *(_DWORD*)v6 = 4;
                goto LABEL_36;
            }
            if ((v20 & 0x40) != 0)
            {
                *(_DWORD*)v6 = 9;
                *(_DWORD*)(a2 + 24) = "invalid distance code";
                goto LABEL_89;
            }
            *(_DWORD*)(v6 + 12) = v20;
            v14 = &v19[8 * *((_DWORD*)v19 + 1)];
        LABEL_35:
            *(_DWORD*)(v6 + 8) = v14;
        LABEL_36:
            v8 = v45;
            continue;
        case 3:
            goto LABEL_30;
        case 4:
            while (2)
            {
                v21 = *(_DWORD*)(v6 + 8);
                if (v48 < v21)
                {
                    if (v46)
                    {
                        a3 = 0;
                        --v46;
                        v49 |= *v47++ << v48;
                        v48 += 8;
                        continue;
                    }
                    goto LABEL_91;
                }
                break;
            }
            v22 = *(_DWORD*)(v6 + 8);
            *(_DWORD*)(v6 + 12) += v49 & dword_4B2710[v21];
            v49 >>= v22;
            v48 -= v22;
            *(_DWORD*)v6 = 5;
        LABEL_41:
            v23 = *(_DWORD*)(v6 + 12);
            if ((unsigned int)&v5[-a1[10]] >= v23)
                v42 = &v5[-v23];
            else
                v42 = &v5[a1[11] - a1[10] - *(_DWORD*)(v6 + 12)];
            v8 = v45;
        LABEL_45:
            if (!*(_DWORD*)(v6 + 4))
            {
                *(_DWORD*)v6 = 0;
                continue;
            }
            if (v8)
                goto LABEL_62;
            if (v5 == (_BYTE*)a1[11])
            {
                v24 = a1[12];
                v25 = a1[10];
                if (v24 != v25)
                {
                    v5 = (_BYTE*)a1[10];
                    v8 = v25 >= v24 ? a1[11] - v25 : v24 - v25 - 1;
                    if (v8)
                        goto LABEL_62;
                }
            }
            a1[13] = v5;
            v26 = sub_486544(a1, (_DWORD*)a2, a3);
            v5 = (_BYTE*)a1[13];
            v50 = v26;
            v27 = a1[12];
            v40 = v27;
            if ((unsigned int)v5 >= v27)
                v8 = a1[11] - (_DWORD)v5;
            else
                v8 = v27 - (_DWORD)v5 - 1;
            v43 = (_BYTE*)a1[11];
            if (v5 == v43)
            {
                v28 = a1[10];
                if (v40 != v28)
                {
                    v5 = (_BYTE*)a1[10];
                    if (v28 >= v40)
                        v8 = (unsigned int)&v43[-v28];
                    else
                        v8 = v40 - v28 - 1;
                }
            }
            if (v8)
            {
            LABEL_62:
                a3 = 0;
                *v5++ = *v42++;
                v45 = --v8;
                if (v42 == (_BYTE*)a1[11])
                    v42 = (_BYTE*)a1[10];
                --*(_DWORD*)(v6 + 4);
                goto LABEL_45;
            }
        LABEL_92:
            v38 = v50;
        LABEL_85:
            a1[8] = v49;
            a1[7] = v48;
            *(_DWORD*)(a2 + 4) = v46;
        LABEL_86:
            v34 = &v47[-*(_DWORD*)a2];
            *(_DWORD*)a2 = v47;
            *(_DWORD*)(a2 + 8) += v34;
        LABEL_87:
            a1[13] = v5;
            return sub_486544(a1, (_DWORD*)a2, v38);
        case 5:
            goto LABEL_41;
        case 6:
            if (!v8)
            {
                if (v5 != (_BYTE*)a1[11]
                    || (v29 = a1[12], v30 = a1[10], v29 == v30)
                    || ((v5 = (_BYTE*)a1[10], v30 >= v29) ? (v8 = a1[11] - v30) : (v8 = v29 - v30 - 1), !v8))
                {
                    a1[13] = v5;
                    v31 = sub_486544(a1, (_DWORD*)a2, a3);
                    v5 = (_BYTE*)a1[13];
                    v50 = v31;
                    v32 = a1[12];
                    v41 = v32;
                    if ((unsigned int)v5 >= v32)
                        v8 = a1[11] - (_DWORD)v5;
                    else
                        v8 = v32 - (_DWORD)v5 - 1;
                    v44 = (_BYTE*)a1[11];
                    if (v5 == v44)
                    {
                        v33 = a1[10];
                        if (v41 != v33)
                        {
                            v5 = (_BYTE*)a1[10];
                            if (v33 >= v41)
                                v8 = (unsigned int)&v44[-v33];
                            else
                                v8 = v41 - v33 - 1;
                        }
                    }
                    if (!v8)
                        goto LABEL_92;
                }
            }
            a3 = 0;
            *v5++ = *(_BYTE*)(v6 + 8);
            --v8;
            *(_DWORD*)v6 = 0;
            goto LABEL_83;
        case 7:
            if (v48 > 7)
            {
                v48 -= 8;
                ++v46;
                --v47;
            }
            a1[13] = v5;
            v36 = sub_486544(a1, (_DWORD*)a2, a3);
            v5 = (_BYTE*)a1[13];
            if ((_BYTE*)a1[12] != v5)
            {
                a1[8] = v49;
                a1[7] = v48;
                *(_DWORD*)(a2 + 4) = v46;
                v37 = &v47[-*(_DWORD*)a2];
                *(_DWORD*)a2 = v47;
                *(_DWORD*)(a2 + 8) += v37;
                v38 = v36;
                goto LABEL_87;
            }
            *(_DWORD*)v6 = 8;
        LABEL_98:
            v38 = 1;
            goto LABEL_85;
        case 8:
            goto LABEL_98;
        case 9:
            goto LABEL_89;
        default:
            v38 = -2;
            goto LABEL_85;
        }
    }
}
// 4B2710: using guessed type int dword_4B2710[19];

//----- (00485FE8) --------------------------------------------------------
int __cdecl sub_485FE8(int a1, int a2)
{
    return (*(int(__cdecl**)(_DWORD, int))(a2 + 36))(*(_DWORD*)(a2 + 40), a1);
}

//----- (00485FFB) --------------------------------------------------------
int __usercall sub_485FFB@<eax>(
    unsigned int* a1@<eax>,
    _DWORD* a2,
    unsigned int a3,
    unsigned int a4,
    int a5,
    int a6,
    _DWORD* a7,
    int a8,
    unsigned int* a9,
    unsigned int* a10)
{
    _DWORD* v10; // ecx
    unsigned int v12; // edx
    unsigned int v14; // ebx
    unsigned int v15; // ecx
    unsigned int v16; // eax
    int v17; // edx
    int v18; // edx
    unsigned int v19; // esi
    int* v20; // ecx
    int v21; // ebx
    int v22; // edx
    int v23; // ecx
    unsigned int v24; // eax
    int v25; // ebx
    int* v26; // ecx
    unsigned int v27; // ebx
    int v28; // eax
    int* v29; // eax
    int v30; // ecx
    int v31; // eax
    int v32; // ebx
    unsigned int v33; // eax
    unsigned int j; // ecx
    unsigned int v35; // esi
    unsigned int v36; // ecx
    unsigned int v37; // eax
    unsigned int v38; // eax
    _DWORD* v39; // edx
    unsigned int v40; // edx
    unsigned int v41; // eax
    unsigned int v42; // eax
    unsigned int v43; // esi
    _DWORD* v44; // edx
    unsigned int v45; // esi
    unsigned int v46; // eax
    int v47; // ecx
    int v48; // edx
    unsigned int v49; // eax
    int v50; // eax
    int v51; // esi
    unsigned int v52; // eax
    _DWORD* v53; // ecx
    unsigned int v54; // esi
    unsigned int i; // eax
    int v56; // ecx
    int v57; // eax
    _DWORD v59[15]; // [esp+Ch] [ebp-F8h] BYREF
    int v60; // [esp+48h] [ebp-BCh] BYREF
    _DWORD v61[15]; // [esp+4Ch] [ebp-B8h]
    int v62; // [esp+88h] [ebp-7Ch] BYREF
    _DWORD v63[15]; // [esp+8Ch] [ebp-78h] BYREF
    unsigned int v64; // [esp+C8h] [ebp-3Ch]
    signed int v65; // [esp+CCh] [ebp-38h]
    int v66; // [esp+D0h] [ebp-34h]
    int v67; // [esp+D4h] [ebp-30h]
    signed int v68; // [esp+D8h] [ebp-2Ch]
    int v69; // [esp+DCh] [ebp-28h]
    _DWORD* v70; // [esp+E0h] [ebp-24h]
    unsigned int v71; // [esp+E4h] [ebp-20h]
    int v72; // [esp+E8h] [ebp-1Ch]
    int v73; // [esp+ECh] [ebp-18h]
    unsigned int v74; // [esp+F0h] [ebp-14h]
    unsigned int v75; // [esp+F4h] [ebp-10h]
    int v76; // [esp+F8h] [ebp-Ch]
    signed int v77; // [esp+FCh] [ebp-8h]
    unsigned int v78; // [esp+100h] [ebp-4h]
    int* v79; // [esp+10Ch] [ebp+8h]
    unsigned int* v80; // [esp+10Ch] [ebp+8h]
    int v81; // [esp+110h] [ebp+Ch]

    v10 = a2;
    v62 = 0;
    memset(v63, 0, sizeof(v63));
    v12 = a3;
    do
    {
        ++v63[*v10++ - 1];
        --v12;
    } while (v12);
    if (v62 != a3)
    {
        v14 = *a1;
        v78 = *a1;
        v15 = 1;
        v16 = 15;
        do
        {
            if (v63[v15 - 1])
                break;
            ++v15;
        } while (v15 <= 0xF);
        v77 = v15;
        if (v14 < v15)
            v78 = v15;
        do
        {
            if (v63[v16 - 1])
                break;
            --v16;
        } while (v16);
        v68 = v16;
        if (v78 > v16)
            v78 = v16;
        *a1 = v78;
        v17 = 1 << v15;
        while (v15 < v16)
        {
            v18 = v17 - v63[v15 - 1];
            if (v18 < 0)
                return -3;
            ++v15;
            v17 = 2 * v18;
        }
        v19 = v16;
        v20 = &v63[v16 - 1];
        v21 = *v20;
        v22 = v17 - *v20;
        v66 = v22;
        if (v22 < 0)
            return -3;
        *v20 = v22 + v21;
        v23 = 0;
        v24 = v16 - 1;
        v61[0] = 0;
        if (v24)
        {
            v25 = 0;
            do
            {
                v23 += v63[v25++];
                --v24;
                v61[v25] = v23;
            } while (v24);
        }
        v26 = a2;
        v27 = 0;
        do
        {
            v28 = *v26++;
            v79 = v26;
            if (v28)
            {
                v29 = &v61[v28 - 1];
                v30 = *v29;
                a10[v30] = v27;
                v22 = v66;
                *v29 = v30 + 1;
                v26 = v79;
            }
            ++v27;
        } while (v27 < a3);
        v31 = v61[v19 - 1];
        v76 = -1;
        v81 = v31;
        v80 = a10;
        v32 = -v78;
        v71 = 0;
        v60 = 0;
        v59[0] = 0;
        v69 = 0;
        v75 = 0;
        if (v77 > v68)
        {
        LABEL_67:
            if (!v22 || v68 == 1)
                return 0;
            return -5;
        }
        else
        {
            v67 = v77 - 1;
            v70 = &v63[v77 - 1];
            while (1)
            {
                v72 = *v70;
                if (v72)
                    break;
            LABEL_66:
                ++v77;
                ++v70;
                ++v67;
                if (v77 > v68)
                    goto LABEL_67;
            }
            while (1)
            {
                --v72;
                v33 = v32 + v78;
                if (v77 > (int)(v32 + v78))
                    break;
            LABEL_49:
                BYTE1(v73) = v77 - v32;
                if (v80 < &a10[v81])
                {
                    v49 = *v80;
                    if (*v80 >= a4)
                    {
                        v50 = 4 * (v49 - a4);
                        LOBYTE(v73) = *(_BYTE*)(v50 + a6) + 80;
                        v49 = *(_DWORD*)(v50 + a5);
                    }
                    else
                    {
                        LOBYTE(v73) = v49 < 0x100 ? 0 : 0x60;
                    }
                    ++v80;
                    v74 = v49;
                }
                else
                {
                    LOBYTE(v73) = -64;
                }
                v51 = 1 << (v77 - v32);
                v52 = v71 >> v32;
                if (v71 >> v32 < v75)
                {
                    v53 = (_DWORD*)(v69 + 8 * v52);
                    do
                    {
                        *v53 = v73;
                        v53[1] = v74;
                        v52 += v51;
                        v53 += 2 * v51;
                    } while (v52 < v75);
                    v22 = v66;
                }
                v54 = v71;
                for (i = 1 << v67; (i & v54) != 0; i >>= 1)
                    v54 ^= i;
                v71 = i ^ v54;
                v56 = (i ^ v54) & ((1 << v32) - 1);
                v57 = v76;
                if (v56 != v61[v76 - 1])
                {
                    do
                    {
                        v32 -= v78;
                        --v57;
                    } while ((v71 & ((1 << v32) - 1)) != v61[v57 - 1]);
                    v76 = v57;
                }
                if (!v72)
                    goto LABEL_66;
            }
            for (j = v32 - v78; ; j = v64)
            {
                ++v76;
                v32 += v78;
                v35 = v68 - v32;
                v64 = v78 + j;
                v65 = v78 + v33;
                if (v68 - v32 > v78)
                    v35 = v78;
                v36 = v77 - v32;
                v37 = 1 << (v77 - v32);
                if (v37 > v72 + 1)
                {
                    v38 = -1 - v72 + v37;
                    v39 = v70;
                    if (v36 < v35 && ++v36 < v35)
                    {
                        while (1)
                        {
                            v75 = (unsigned int)(v39 + 1);
                            v40 = v39[1];
                            v41 = 2 * v38;
                            if (v41 <= v40)
                                break;
                            v38 = v41 - v40;
                            if (++v36 >= v35)
                                break;
                            v39 = (_DWORD*)v75;
                        }
                    }
                }
                v42 = *a9;
                v43 = *a9 + (1 << v36);
                v75 = 1 << v36;
                if (v43 > 0x5A0)
                    break;
                v44 = &v59[v76];
                v69 = a8 + 8 * v42;
                *v44 = v69;
                *a9 = v43;
                if (v76)
                {
                    v45 = v71;
                    v61[v76 - 1] = v71;
                    BYTE1(v73) = v78;
                    LOBYTE(v73) = v36;
                    v46 = v45 >> v64;
                    v47 = *(v44 - 1);
                    v48 = ((v69 - v47) >> 3) - (v45 >> v64);
                    *(_DWORD*)(v47 + 8 * v46) = v73;
                    v74 = v48;
                    *(_DWORD*)(v47 + 8 * v46 + 4) = v48;
                }
                else
                {
                    *a7 = v69;
                }
                v33 = v65;
                if (v77 <= v65)
                {
                    v22 = v66;
                    goto LABEL_49;
                }
            }
            return -4;
        }
    }
    *a7 = 0;
    *a1 = 0;
    return 0;
}

//----- (00486393) --------------------------------------------------------
int __cdecl sub_486393(_DWORD* a1, unsigned int* a2, _DWORD* a3, int a4, int a5)
{
    unsigned int* v6; // eax
    int v8; // eax
    int v9; // ebx
    unsigned int v10; // [esp+4h] [ebp-4h] BYREF
    unsigned int* v11; // [esp+20h] [ebp+18h]

    v10 = 0;
    v6 = (unsigned int*)(*(int(__cdecl**)(_DWORD, int, int))(a5 + 32))(*(_DWORD*)(a5 + 40), 19, 4);
    v11 = v6;
    if (!v6)
        return -4;
    v8 = sub_485FFB(a2, a1, 0x13u, 0x13u, 0, 0, a3, a4, &v10, v6);
    v9 = v8;
    if (v8 == -3)
    {
        *(_DWORD*)(a5 + 24) = "oversubscribed dynamic bit lengths tree";
    }
    else if (v8 == -5 || !*a2)
    {
        *(_DWORD*)(a5 + 24) = "incomplete dynamic bit lengths tree";
        v9 = -3;
    }
    (*(void(__cdecl**)(_DWORD, unsigned int*))(a5 + 36))(*(_DWORD*)(a5 + 40), v11);
    return v9;
}

//----- (00486412) --------------------------------------------------------
int __cdecl sub_486412(
    unsigned int a1,
    unsigned int a2,
    _DWORD* a3,
    unsigned int* a4,
    unsigned int* a5,
    _DWORD* a6,
    _DWORD* a7,
    int a8,
    int a9)
{
    unsigned int* v10; // eax
    int v12; // eax
    int v13; // edi
    unsigned int v14; // [esp+4h] [ebp-4h] BYREF
    unsigned int* v15; // [esp+30h] [ebp+28h]

    v14 = 0;
    v10 = (unsigned int*)(*(int(__cdecl**)(_DWORD, int, int))(a9 + 32))(*(_DWORD*)(a9 + 40), 288, 4);
    v15 = v10;
    if (!v10)
        return -4;
    v12 = sub_485FFB(a4, a3, a1, 0x101u, (int)&unk_49D0D0, (int)&unk_49D150, a6, a8, &v14, v10);
    if (v12)
    {
        if (v12 == -3)
        {
            *(_DWORD*)(a9 + 24) = "oversubscribed literal/length tree";
            goto LABEL_20;
        }
        if (v12 == -4)
            goto LABEL_20;
    LABEL_18:
        *(_DWORD*)(a9 + 24) = "incomplete literal/length tree";
        goto LABEL_19;
    }
    if (!*a4)
        goto LABEL_18;
    v12 = sub_485FFB(a5, &a3[a1], a2, 0, (int)&unk_49D1D0, (int)&unk_49D248, a7, a8, &v14, v15);
    if (v12)
    {
        switch (v12)
        {
        case -3:
            *(_DWORD*)(a9 + 24) = "oversubscribed distance tree";
            break;
        case -5:
            *(_DWORD*)(a9 + 24) = "incomplete distance tree";
        LABEL_19:
            v12 = -3;
            break;
        case -4:
            break;
        default:
        LABEL_14:
            *(_DWORD*)(a9 + 24) = "empty distance tree with lengths";
            goto LABEL_19;
        }
    LABEL_20:
        v13 = v12;
        goto LABEL_21;
    }
    if (!*a5 && a1 > 0x101)
        goto LABEL_14;
    v13 = 0;
LABEL_21:
    (*(void(__cdecl**)(_DWORD, unsigned int*))(a9 + 36))(*(_DWORD*)(a9 + 40), v15);
    return v13;
}

//----- (00486515) --------------------------------------------------------
int __cdecl sub_486515(_DWORD* a1, _DWORD* a2, _DWORD* a3, _DWORD* a4)
{
    *a1 = dword_4B1608;
    *a2 = dword_4B160C;
    *a3 = &unk_4B1610;
    *a4 = &unk_4B2610;
    return 0;
}
// 4B1608: using guessed type int dword_4B1608;
// 4B160C: using guessed type int dword_4B160C;

//----- (00486544) --------------------------------------------------------
int __cdecl sub_486544(_DWORD* a1, _DWORD* a2, int a3)
{
    char* v4; // edx
    unsigned int v5; // edi
    unsigned int v6; // eax
    unsigned int v7; // edi
    int(__cdecl * v8)(_DWORD, char*, unsigned int); // eax
    int v9; // eax
    char v10; // al
    unsigned int v11; // ecx
    char* v12; // edi
    char* v13; // eax
    char* v14; // edx
    unsigned int v15; // eax
    unsigned int v16; // edi
    int(__cdecl * v17)(_DWORD, char*, unsigned int); // eax
    int v18; // eax
    char v19; // al
    unsigned int v20; // ecx
    char* v21; // edi
    char* v23; // [esp+Ch] [ebp-8h]
    char* v24; // [esp+Ch] [ebp-8h]
    unsigned int v25; // [esp+10h] [ebp-4h]
    unsigned int v26; // [esp+10h] [ebp-4h]
    char* v27; // [esp+1Ch] [ebp+8h]
    char* v28; // [esp+1Ch] [ebp+8h]
    char* v29; // [esp+1Ch] [ebp+8h]

    v4 = (char*)a1[12];
    v5 = a1[13];
    v23 = (char*)a2[3];
    v27 = v4;
    if ((unsigned int)v4 > v5)
        v5 = a1[11];
    v6 = a2[4];
    v7 = v5 - (_DWORD)v4;
    v25 = v7;
    if (v7 > v6)
    {
        v25 = a2[4];
        v7 = v25;
    }
    if (v7 && a3 == -5)
        a3 = 0;
    a2[5] += v7;
    a2[4] = v6 - v7;
    v8 = (int(__cdecl*)(_DWORD, char*, unsigned int))a1[14];
    if (v8)
    {
        v9 = v8(a1[15], v4, v7);
        v4 = v27;
        a1[15] = v9;
        a2[12] = v9;
    }
    v10 = v7;
    v11 = v7 >> 2;
    qmemcpy(v23, v4, 4 * (v7 >> 2));
    v12 = &v23[4 * (v7 >> 2)];
    v24 = &v23[v25];
    v28 = &v27[v25];
    qmemcpy(v12, &v4[4 * v11], v10 & 3);
    v13 = (char*)a1[11];
    if (v28 == v13)
    {
        v14 = (char*)a1[10];
        v29 = v14;
        if ((char*)a1[13] == v13)
            a1[13] = v14;
        v15 = a2[4];
        v16 = a1[13] - (_DWORD)v14;
        v26 = v16;
        if (v16 > v15)
        {
            v26 = a2[4];
            v16 = v26;
        }
        if (v16 && a3 == -5)
            a3 = 0;
        a2[5] += v16;
        a2[4] = v15 - v16;
        v17 = (int(__cdecl*)(_DWORD, char*, unsigned int))a1[14];
        if (v17)
        {
            v18 = v17(a1[15], v14, v16);
            v14 = v29;
            a1[15] = v18;
            a2[12] = v18;
        }
        v19 = v16;
        v20 = v16 >> 2;
        qmemcpy(v24, v14, 4 * (v16 >> 2));
        v21 = &v24[4 * (v16 >> 2)];
        v24 += v26;
        v28 = &v29[v26];
        qmemcpy(v21, &v14[4 * v20], v19 & 3);
    }
    a2[3] = v24;
    a1[12] = v28;
    return a3;
}

//----- (00486659) --------------------------------------------------------
int __cdecl sub_486659(__int16* a1, __int16* a2, int* a3, int a4, int a5, int a6)
{
    int v6; // ecx
    int v7; // ebx
    int v8; // eax
    int v9; // ebx
    int v10; // eax
    int v11; // edx
    int v12; // ebx
    int v13; // edx
    int v14; // edx
    int v15; // ebx
    int v16; // edx
    int v17; // esi
    int v18; // ecx
    int v19; // ebx
    int v20; // eax
    int v21; // ecx
    int v22; // eax
    int v23; // edx
    int v24; // ecx
    int v25; // esi
    int v26; // edi
    int* v27; // edi
    int v28; // ecx
    int v29; // ebx
    int v30; // eax
    int v31; // ebx
    int v32; // edx
    int v33; // ebx
    int v34; // edx
    int v35; // eax
    int v36; // edx
    int v37; // esi
    int v38; // ecx
    int v39; // ebx
    int v40; // eax
    int v41; // ecx
    int v42; // eax
    int v43; // edx
    int v44; // esi
    int result; // eax
    int* v48; // [esp+14h] [ebp-3Ch]
    int* v49; // [esp+14h] [ebp-3Ch]
    int v50; // [esp+18h] [ebp-38h]
    int v51; // [esp+18h] [ebp-38h]
    int v52; // [esp+1Ch] [ebp-34h]
    int v53; // [esp+1Ch] [ebp-34h]
    int v54; // [esp+1Ch] [ebp-34h]
    int v55; // [esp+1Ch] [ebp-34h]
    int v56; // [esp+1Ch] [ebp-34h]
    int v57; // [esp+20h] [ebp-30h]
    int v58; // [esp+20h] [ebp-30h]
    int v59; // [esp+20h] [ebp-30h]
    int v60; // [esp+20h] [ebp-30h]
    int v61; // [esp+24h] [ebp-2Ch]
    int v62; // [esp+24h] [ebp-2Ch]
    int v63; // [esp+28h] [ebp-28h]
    int v64; // [esp+28h] [ebp-28h]
    int v65; // [esp+2Ch] [ebp-24h]
    int v66; // [esp+2Ch] [ebp-24h]
    int v67; // [esp+30h] [ebp-20h]
    int v68; // [esp+30h] [ebp-20h]
    int v69; // [esp+34h] [ebp-1Ch]
    int v70; // [esp+34h] [ebp-1Ch]
    int v71; // [esp+34h] [ebp-1Ch]
    int v72; // [esp+38h] [ebp-18h]
    int v73; // [esp+40h] [ebp-10h]
    int v74; // [esp+4Ch] [ebp-4h]

    v48 = a3;
    v50 = 8;
    do
    {
        v6 = a2[48] * a1[48];
        v7 = a2[16] * a1[16];
        v8 = 6270 * v7;
        v9 = 4433 * (v6 + v7);
        v52 = v9 - 15137 * v6;
        v57 = v9 + v8;
        v10 = *a2 * *a1;
        v11 = a2[32] * a1[32];
        v12 = (v10 + v11) << 13;
        v13 = (v10 - v11) << 13;
        v61 = v57 + v12;
        v63 = v52 + v13;
        v65 = v12 - v57;
        v67 = v13 - v52;
        v69 = a2[56] * a1[56];
        v53 = a2[24] * a1[24];
        v58 = a2[8] * a1[8];
        v14 = a2[40] * a1[40];
        v15 = v58 + v14;
        v16 = -20995 * (v53 + v14);
        v17 = 9633 * (v15 + v53 + v69);
        v18 = v17 - 16069 * (v53 + v69);
        v19 = v17 - 3196 * v15;
        v20 = v18 - 7373 * (v58 + v69);
        v21 = v16 + v18;
        v22 = 2446 * v69 + v20;
        v23 = 16819 * a2[40] * a1[40] + v19 + v16;
        v24 = 25172 * v53 + v21;
        v25 = 12299 * v58 + v19 - 7373 * (v58 + v69);
        v48[32] = (v65 - v22 + 1024) >> 11;
        v48[24] = (v65 + v22 + 1024) >> 11;
        v48[40] = (v67 - v23 + 1024) >> 11;
        v48[48] = (v63 - v24 + 1024) >> 11;
        v48[16] = (v67 + v23 + 1024) >> 11;
        v48[8] = (v63 + v24 + 1024) >> 11;
        v48[56] = (v61 - v25 + 1024) >> 11;
        *v48 = (v25 + v61 + 1024) >> 11;
        ++a1;
        ++v48;
        ++a2;
        --v50;
    } while (v50);
    v51 = 8;
    v74 = 0;
    v49 = a3;
    do
    {
        v26 = *(_DWORD*)(v74 + a4);
        v74 += 4;
        v27 = (int*)(a5 + v26);
        v28 = v49[6];
        v29 = v49[2];
        v30 = 6270 * v29;
        v31 = 4433 * (v28 + v29);
        v54 = v31 - 15137 * v28;
        v59 = v31 + v30;
        v32 = v49[4];
        v33 = (*v49 + v32) << 13;
        v34 = (*v49 - v32) << 13;
        v62 = v59 + v33;
        v64 = v54 + v34;
        v66 = v33 - v59;
        v68 = v34 - v54;
        v70 = v49[7];
        v55 = v49[3];
        v35 = v49[5];
        v60 = v49[1];
        v73 = 16819 * v35;
        v36 = -20995 * (v55 + v35);
        v37 = 9633 * (v60 + v35 + v55 + v70);
        v38 = v37 - 16069 * (v55 + v70);
        v39 = v37 - 3196 * (v60 + v35);
        v40 = v38 - 7373 * (v60 + v70);
        v41 = v36 + v38;
        v42 = 2446 * v70 + v40;
        v43 = v73 + v39 + v36;
        v44 = 12299 * v60 + v39 - 7373 * (v60 + v70);
        v71 = v42;
        v72 = v43;
        v56 = 25172 * v55 + v41;
        LOBYTE(v42) = *(_BYTE*)(a6 + (((v42 + v66 + 0x20000) >> 18) & 0x3FF));
        LOBYTE(v43) = *(_BYTE*)(a6 + (((v62 - v44 + 0x20000) >> 18) & 0x3FF));
        v42 <<= 8;
        v43 <<= 8;
        LOBYTE(v42) = *(_BYTE*)(a6 + (((v72 + v68 + 0x20000) >> 18) & 0x3FF));
        LOBYTE(v43) = *(_BYTE*)(a6 + (((v64 - v56 + 0x20000) >> 18) & 0x3FF));
        v42 <<= 8;
        v43 <<= 8;
        LOBYTE(v42) = *(_BYTE*)(a6 + (((v56 + v64 + 0x20000) >> 18) & 0x3FF));
        LOBYTE(v43) = *(_BYTE*)(a6 + (((v68 - v72 + 0x20000) >> 18) & 0x3FF));
        v42 <<= 8;
        v43 <<= 8;
        LOBYTE(v42) = *(_BYTE*)(a6 + (((v44 + v62 + 0x20000) >> 18) & 0x3FF));
        LOBYTE(v43) = *(_BYTE*)(a6 + (((v66 - v71 + 0x20000) >> 18) & 0x3FF));
        *v27 = v42;
        v27[1] = v43;
        v49 += 8;
        result = --v51;
    } while (v51);
    return result;
}

//----- (00486ABB) --------------------------------------------------------
int __cdecl sub_486ABB(__m64* a1, __m64* a2, __m64* a3, int a4, int a5, int a6)
{
    __m64 v6; // mm0
    __m64 v7; // mm2
    __m64 v8; // mm4
    __m64 v9; // mm5
    __m64 v10; // mm0
    __m64 v11; // mm6
    __m64 v12; // mm0
    __m64 v13; // mm6
    __m64 v14; // mm4
    __m64 v15; // mm3
    __m64 v16; // mm5
    __m64 v17; // mm6
    __m64 v18; // mm1
    __m64 v19; // mm0
    __m64 v20; // mm1
    __m64 v21; // mm6
    __m64 v22; // mm0
    __m64 v23; // mm6
    __m64 v24; // mm2
    __m64 v25; // mm1
    __m64 v26; // mm0
    __m64 v27; // mm2
    __m64 v28; // mm1
    __m64 v29; // mm3
    __m64 v30; // mm6
    __m64 v31; // mm4
    __m64 v32; // mm5
    __m64 v33; // mm7
    __m64 v34; // mm0
    __m64 v35; // mm2
    __m64 v36; // mm4
    __m64 v37; // mm1
    __m64 v38; // mm5
    __m64 v39; // mm3
    __m64 v40; // mm0
    __m64 v41; // mm7
    __m64 v42; // mm6
    __m64 v43; // mm1
    __m64 v44; // mm5
    __m64 v45; // mm2
    __m64 v46; // mm4
    __m64 v47; // mm6
    __m64 v48; // mm0
    __m64 v49; // mm1
    __m64 v50; // mm0
    __m64 v51; // mm2
    __m64 v52; // mm0
    __m64 v53; // mm1
    __m64 v54; // mm4
    __m64 v55; // mm7
    __m64 v56; // mm1
    __m64 v57; // mm0
    __m64 v58; // mm6
    __m64 v59; // mm2
    __m64 v60; // mm6
    __m64 v61; // mm0
    __m64 v62; // mm3
    __m64 v63; // mm1
    int result; // eax
    __m64 v65; // mm1
    __m64 v66; // mm4
    __m64 v67; // mm2
    __m64 v68; // mm5
    __m64 v69; // mm7
    __m64 v70; // mm5
    __m64 v71; // mm3
    __m64 v72; // mm4
    __m64 v73; // mm7
    __m64 v74; // mm5
    __m64 v75; // mm3
    __m64 v76; // mm5
    __m64 v77; // mm1
    __m64 v78; // mm0
    __m64 v79; // mm1
    __m64 v80; // mm3
    __m64 v81; // mm2
    __m64 v82; // mm1
    __m64 v83; // mm0
    int v84; // edi
    __m64 v85; // mm3
    unsigned int v86; // eax
    __m64 v87; // mm4
    __m64 v88; // mm2
    __m64 v89; // [esp+Ch] [ebp-FCh]
    __m64 v90; // [esp+14h] [ebp-F4h]
    __m64 v91; // [esp+1Ch] [ebp-ECh]
    __m64 v92; // [esp+24h] [ebp-E4h]
    __m64 v93; // [esp+2Ch] [ebp-DCh]
    __m64 v94; // [esp+3Ch] [ebp-CCh]
    __m64 v95; // [esp+44h] [ebp-C4h]
    __m64 v96; // [esp+4Ch] [ebp-BCh]
    __m64 v97; // [esp+5Ch] [ebp-ACh]
    __m64 v98; // [esp+6Ch] [ebp-9Ch]
    __m64 v99; // [esp+74h] [ebp-94h]
    __m64 v100; // [esp+7Ch] [ebp-8Ch]
    __m64 v101; // [esp+84h] [ebp-84h]
    __m64 v102; // [esp+8Ch] [ebp-7Ch]
    __m64 v103; // [esp+9Ch] [ebp-6Ch]
    __m64 v104; // [esp+ACh] [ebp-5Ch]
    __m64 v105; // [esp+B4h] [ebp-54h]
    __m64 v106; // [esp+BCh] [ebp-4Ch]
    __m64 v107; // [esp+CCh] [ebp-3Ch]
    __m64 v108; // [esp+D4h] [ebp-34h]
    __m64 v109; // [esp+DCh] [ebp-2Ch]
    __m64 v110; // [esp+E4h] [ebp-24h]
    __m64 v111; // [esp+ECh] [ebp-1Ch]
    __m64* v113; // [esp+F8h] [ebp-10h]
    __m64* v114; // [esp+F8h] [ebp-10h]
    int v116; // [esp+100h] [ebp-8h]
    int v117; // [esp+104h] [ebp-4h]
    int v118; // [esp+104h] [ebp-4h]

    v117 = 2;
    v113 = a3;
    do
    {
        v6 = _m_pmullw(a1[4], a2[4]);
        v7 = _m_pmullw(a1[12], a2[12]);
        v8 = _m_pmaddwd(v6, (__m64)0x187E0000187ELL);
        v9 = _m_pmaddwd(_m_psrlqi(v6, 0x10u), (__m64)0x187E0000187ELL);
        v10 = _m_paddw(v6, v7);
        v11 = _m_psrlqi(v10, 0x10u);
        v12 = _m_pmaddwd(v10, (__m64)0x115100001151LL);
        v13 = _m_pmaddwd(v11, (__m64)0x115100001151LL);
        v14 = _m_paddd(v8, v12);
        v15 = _m_paddd(
            _m_paddd(
                _m_pxor(_m_pmaddwd(_m_psrlqi(v7, 0x10u), (__m64)0x3B2100003B21LL), (__m64) - 1LL),
                (__m64)0x100000001LL),
            v13);
        v16 = _m_paddd(v9, v13);
        v89 = _m_paddd(_m_paddd(_m_pxor(_m_pmaddwd(v7, (__m64)0x3B2100003B21LL), (__m64) - 1LL), (__m64)0x100000001LL), v12);
        v17 = _m_pmullw(a1[8], a2[8]);
        v18 = _m_pmullw((__m64)a1->m64_u64, (__m64)a2->m64_u64);
        v19 = _m_paddw(v18, v17);
        v20 = _m_psubw(v18, v17);
        v21 = v19;
        v22 = _m_pslldi(_m_pmaddwd(v19, (__m64)0x100000001LL), 0xDu);
        v23 = _m_pslldi(_m_pmaddwd(_m_psrlqi(v21, 0x10u), (__m64)0x100000001LL), 0xDu);
        v24 = _m_pslldi(_m_pmaddwd(_m_psrlqi(v20, 0x10u), (__m64)0x100000001LL), 0xDu);
        v91 = _m_psubd(v22, v14);
        v93 = _m_paddd(v16, v23);
        v94 = _m_psubd(v23, v16);
        v96 = _m_paddd(v14, v22);
        v25 = _m_pslldi(_m_pmaddwd(v20, (__m64)0x100000001LL), 0xDu);
        v97 = _m_paddd(v15, v24);
        v98 = _m_psubd(v24, v15);
        v100 = _m_paddd(v89, v25);
        v102 = _m_psubd(v25, v89);
        v103 = _m_pmullw(a1[2], a2[2]);
        v104 = _m_pmullw(a1[14], a2[14]);
        v26 = _m_paddw(v104, v103);
        v106 = _m_pmullw(a1[10], a2[10]);
        v107 = _m_pmullw(a1[6], a2[6]);
        v27 = _m_paddw(v106, v107);
        v28 = _m_paddw(v104, v107);
        v29 = _m_paddw(v106, v103);
        v30 = _m_paddw(v28, v29);
        v109 = _m_pmaddwd(v30, (__m64)0x25A1000025A1LL);
        v31 = _m_psrlqi(v27, 0x10u);
        v110 = _m_pmaddwd(_m_psrlqi(v30, 0x10u), (__m64)0x25A1000025A1LL);
        v32 = _m_psrlqi(v28, 0x10u);
        v95 = _m_paddd(_m_pxor(_m_pmaddwd(v26, (__m64)0x1CCD00001CCDLL), (__m64) - 1LL), (__m64)0x100000001LL);
        v33 = _m_pmaddwd(_m_psrlqi(v26, 0x10u), (__m64)0x1CCD00001CCDLL);
        v34 = _m_psrlqi(v29, 0x10u);
        v35 = _m_paddd(_m_pxor(_m_pmaddwd(v27, (__m64)0x520300005203LL), (__m64) - 1LL), (__m64)0x100000001LL);
        v36 = _m_paddd(_m_pxor(_m_pmaddwd(v31, (__m64)0x520300005203LL), (__m64) - 1LL), (__m64)0x100000001LL);
        v101 = _m_paddd(_m_pxor(v33, (__m64) - 1LL), (__m64)0x100000001LL);
        v37 = _m_paddd(_m_paddd(_m_pxor(_m_pmaddwd(v28, (__m64)0x3EC500003EC5LL), (__m64) - 1LL), (__m64)0x100000001LL), v109);
        v38 = _m_paddd(_m_paddd(_m_pxor(_m_pmaddwd(v32, (__m64)0x3EC500003EC5LL), (__m64) - 1LL), (__m64)0x100000001LL), v110);
        v39 = _m_paddd(_m_paddd(_m_pxor(_m_pmaddwd(v29, (__m64)0xC7C00000C7CLL), (__m64) - 1LL), (__m64)0x100000001LL), v109);
        v40 = _m_paddd(_m_paddd(_m_pxor(_m_pmaddwd(v34, (__m64)0xC7C00000C7CLL), (__m64) - 1LL), (__m64)0x100000001LL), v110);
        v111 = _m_paddd(v37, v35);
        v105 = _m_paddd(v38, v36);
        v92 = _m_paddd(_m_pmaddwd(v104, (__m64)0x98E0000098ELL), _m_paddd(v95, v37));
        v108 = _m_paddd(_m_pmaddwd(_m_psrlqi(v104, 0x10u), (__m64)0x98E0000098ELL), _m_paddd(v101, v38));
        v41 = _m_paddd(_m_pmaddwd(v103, (__m64)0x300B0000300BLL), _m_paddd(v39, v95));
        v42 = _m_paddd(_m_pmaddwd(_m_psrlqi(v103, 0x10u), (__m64)0x300B0000300BLL), _m_paddd(v40, v101));
        v99 = _m_paddd(_m_pmaddwd(v106, (__m64)0x41B3000041B3LL), _m_paddd(v35, v39));
        v90 = _m_paddd(_m_pmaddwd(_m_psrlqi(v106, 0x10u), (__m64)0x41B3000041B3LL), _m_paddd(v36, v40));
        v43 = _m_psradi(_m_paddd(_m_psubd(v93, v42), (__m64)0x40000000400LL), 0xBu);
        v44 = _m_paddd(_m_pmaddwd(v107, (__m64)0x625400006254LL), v111);
        v45 = _m_psradi(_m_paddd(_m_psubd(v96, v41), (__m64)0x40000000400LL), 0xBu);
        v46 = _m_paddd(_m_pmaddwd(_m_psrlqi(v107, 0x10u), (__m64)0x625400006254LL), v105);
        v113[14].m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpcklwd(v45, v43), _m_punpckhwd(v45, v43));
        v47 = _m_psradi(_m_paddd(_m_paddd(v42, v93), (__m64)0x40000000400LL), 0xBu);
        v48 = _m_psradi(_m_paddd(_m_paddd(v41, v96), (__m64)0x40000000400LL), 0xBu);
        v113->m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpcklwd(v48, v47), _m_punpckhwd(v48, v47));
        v49 = _m_psradi(_m_paddd(_m_psubd(v97, v46), (__m64)0x40000000400LL), 0xBu);
        v50 = _m_psradi(_m_paddd(_m_psubd(v100, v44), (__m64)0x40000000400LL), 0xBu);
        v51 = _m_punpcklwd(v50, v49);
        v52 = _m_punpckhwd(v50, v49);
        v53 = _m_psradi(_m_paddd(_m_paddd(v44, v100), (__m64)0x40000000400LL), 0xBu);
        v113[12].m64_u64 = (unsigned __int64)_m_punpckldq(v51, v52);
        v54 = _m_psradi(_m_paddd(_m_paddd(v46, v97), (__m64)0x40000000400LL), 0xBu);
        v113[2].m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpcklwd(v53, v54), _m_punpckhwd(v53, v54));
        v55 = _m_psradi(_m_paddd(_m_paddd(v98, v90), (__m64)0x40000000400LL), 0xBu);
        v56 = _m_psradi(_m_paddd(_m_paddd(v102, v99), (__m64)0x40000000400LL), 0xBu);
        v57 = _m_psradi(_m_paddd(_m_psubd(v98, v90), (__m64)0x40000000400LL), 0xBu);
        v113[4].m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpcklwd(v56, v55), _m_punpckhwd(v56, v55));
        v58 = _m_psradi(_m_paddd(_m_psubd(v102, v99), (__m64)0x40000000400LL), 0xBu);
        v59 = _m_punpckldq(_m_punpcklwd(v58, v57), _m_punpckhwd(v58, v57));
        v60 = _m_psradi(_m_paddd(_m_paddd(v91, v92), (__m64)0x40000000400LL), 0xBu);
        v61 = _m_psradi(_m_paddd(_m_paddd(v94, v108), (__m64)0x40000000400LL), 0xBu);
        v62 = _m_psradi(_m_paddd(_m_psubd(v91, v92), (__m64)0x40000000400LL), 0xBu);
        v113[10].m64_u64 = (unsigned __int64)v59;
        v63 = _m_psradi(_m_paddd(_m_psubd(v94, v108), (__m64)0x40000000400LL), 0xBu);
        v113[6].m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpcklwd(v60, v61), _m_punpckhwd(v60, v61));
        ++a1;
        ++a2;
        v113[8].m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpcklwd(v62, v63), _m_punpckhwd(v62, v63));
        ++v113;
        result = --v117;
    } while (v117);
    v118 = 8;
    v114 = a3;
    v116 = 0;
    do
    {
        v65 = v114[1];
        v66 = _m_paddw((__m64)v114->m64_u64, v65);
        v67 = _m_pmaddwd(v66, (__m64)0x115100000000LL);
        v68 = _m_pmaddwd(_m_punpckhdq((__m64)v114->m64_u64, v65), (__m64)0x3B210000187ELL);
        v69 = _m_psradi(_m_pslldi(_m_punpckldq(v66, _m_psubw((__m64)v114->m64_u64, v65)), 0x10u), 3u);
        v70 = _m_paddd(
            _m_punpckldq(v68, _m_psrlqi(_m_paddd(_m_pxor(v68, (__m64) - 1LL), (__m64)0x100000001LL), 0x20u)),
            _m_punpckhdq(v67, v67));
        v71 = v66;
        v72 = _m_paddd(v69, v70);
        v73 = _m_psubd(v69, v70);
        v74 = _m_pmaddwd(_m_paddw(_m_punpckldq(v71, v71), v71), (__m64)0x25A1000000000000LL);
        v75 = _m_paddd(
            _m_paddd(_m_pxor(_m_pmaddwd(v71, (__m64)0x3EC500000C7C0000LL), (__m64) - 1LL), (__m64)0x100000001LL),
            _m_punpckhdq(v74, v74));
        v76 = _m_paddd(
            _m_pxor(
                _m_pmaddwd(
                    _m_paddw(
                        _m_punpckhdq((__m64)v114->m64_u64, _m_punpckldq((__m64)v114->m64_u64, (__m64)v114->m64_u64)),
                        v65),
                    (__m64)0x1CCD000052030000LL),
                (__m64) - 1LL),
            (__m64)0x100000001LL);
        v77 = _m_paddd(_m_pmaddwd(v65, (__m64)0x98E000041B30000LL), _m_paddd(v76, v75));
        v78 = _m_paddd(
            _m_pmaddwd((__m64)v114->m64_u64, (__m64)0x62540000300B0000LL),
            _m_paddd(_m_punpckhdq(v76, _m_punpckldq(v76, v76)), v75));
        v79 = _m_punpckhdq(v77, _m_punpckldq(v77, v77));
        v80 = _m_psubd(v72, v78);
        v81 = _m_psubd(v73, v79);
        v82 = _m_pand(_m_psradi(_m_paddd(_m_paddd(v79, v73), (__m64)0x2000000020000LL), 0x12u), (__m64)0x3FF000003FFLL);
        v83 = _m_pand(_m_psradi(_m_paddd(_m_paddd(v78, v72), (__m64)0x2000000020000LL), 0x12u), (__m64)0x3FF000003FFLL);
        BYTE1(result) = *(_BYTE*)(a6 + _mm_cvtsi64_si32(v82));
        v84 = *(_DWORD*)(v116 + a4);
        LOBYTE(result) = *(_BYTE*)(a6 + _mm_cvtsi64_si32(_m_psrlqi(v82, 0x20u)));
        v116 += 4;
        v85 = _m_pand(_m_psradi(_m_paddd(v80, (__m64)0x2000000020000LL), 0x12u), (__m64)0x3FF000003FFLL);
        v86 = result << 16;
        LOBYTE(v86) = *(_BYTE*)(a6 + _mm_cvtsi64_si32(v83));
        BYTE1(v86) = *(_BYTE*)(a6 + _mm_cvtsi64_si32(_m_psrlqi(v83, 0x20u)));
        v87 = _mm_cvtsi32_si64(v86);
        v88 = _m_pand(_m_psradi(_m_paddd(v81, (__m64)0x2000000020000LL), 0x12u), (__m64)0x3FF000003FFLL);
        BYTE1(v86) = *(_BYTE*)(a6 + _mm_cvtsi64_si32(v85));
        LOBYTE(v86) = *(_BYTE*)(a6 + _mm_cvtsi64_si32(_m_psrlqi(v85, 0x20u)));
        v86 <<= 16;
        LOBYTE(v86) = *(_BYTE*)(a6 + _mm_cvtsi64_si32(v88));
        BYTE1(v86) = *(_BYTE*)(a6 + _mm_cvtsi64_si32(_m_psrlqi(v88, 0x20u)));
        v114 += 2;
        *(__m64*)(a5 + v84) = _m_punpckldq(v87, _mm_cvtsi32_si64(v86));
        result = v118 - 1;
        v118 = result;
    } while (result);
    _m_empty();
    return result;
}

//----- (004871C8) --------------------------------------------------------
__int16 __cdecl sub_4871C8(_WORD* a1, _WORD* a2, _WORD* a3, int a4, int a5, int a6)
{
    __int16 v6; // bx
    __int16 v7; // dx
    __int16 v8; // ax
    __int16 v9; // bx
    __int16 v10; // bx
    __int16 v11; // ax
    __int16 v12; // bx
    __int16 v13; // cx
    __int16 v14; // ax
    __int16 v15; // bx
    __int16 v16; // dx
    __int16 v17; // bx
    __int16 v18; // cx
    __int16 v19; // ax
    int v20; // ecx
    __int16 v21; // dx
    int v22; // ebx
    __int16 v23; // dx
    __int16 v24; // dx
    _BYTE* v25; // edi
    __int16 v26; // bx
    __int16 v27; // dx
    __int16 v28; // ax
    __int16 v29; // bx
    __int16 v30; // bx
    __int16 v31; // ax
    __int16 v32; // bx
    __int16 v33; // cx
    __int16 v34; // ax
    __int16 v35; // bx
    __int16 v36; // dx
    __int16 v37; // bx
    __int16 v38; // cx
    __int16 v39; // ax
    int v40; // ecx
    __int16 v41; // dx
    int v42; // ebx
    __int16 v43; // dx
    __int16 result; // ax
    _WORD* v47; // [esp+14h] [ebp-24h]
    _WORD* v48; // [esp+14h] [ebp-24h]
    int v49; // [esp+18h] [ebp-20h]
    __int16 v50; // [esp+1Ch] [ebp-1Ch]
    __int16 v51; // [esp+1Ch] [ebp-1Ch]
    __int16 v52; // [esp+20h] [ebp-18h]
    __int16 v53; // [esp+20h] [ebp-18h]
    __int16 v54; // [esp+20h] [ebp-18h]
    __int16 v55; // [esp+20h] [ebp-18h]
    __int16 v56; // [esp+20h] [ebp-18h]
    __int16 v57; // [esp+24h] [ebp-14h]
    __int16 v58; // [esp+24h] [ebp-14h]
    __int16 v59; // [esp+28h] [ebp-10h]
    __int16 v60; // [esp+28h] [ebp-10h]
    __int16 v61; // [esp+2Ch] [ebp-Ch]
    __int16 v62; // [esp+2Ch] [ebp-Ch]
    __int16 v63; // [esp+30h] [ebp-8h]
    __int16 v64; // [esp+30h] [ebp-8h]
    __int16 v65; // [esp+30h] [ebp-8h]
    __int16 v66; // [esp+30h] [ebp-8h]
    __int16 v67; // [esp+34h] [ebp-4h]

    v47 = a2;
    v50 = 8;
    do
    {
        v6 = a3[32] * a1[32];
        v7 = a3[48] * a1[48];
        v52 = *a3 * *a1;
        v8 = v6 + v52;
        v53 = v52 - v6;
        v9 = a3[16] * a1[16];
        v57 = v7 + v9 + v8;
        v59 = v8 - (v7 + v9);
        v10 = ((362 * (__int16)(v9 - v7)) >> 8) - (v7 + v9);
        v11 = v10 + v53;
        v54 = v53 - v10;
        v61 = v11;
        v12 = a3[56] * a1[56];
        v13 = a3[24] * a1[24];
        v63 = a3[8] * a1[8];
        v14 = v12 + v63;
        v64 = v63 - v12;
        v15 = a3[40] * a1[40];
        v16 = v13 + v15;
        v17 = v15 - v13;
        v18 = v14;
        v19 = v16 + v14;
        v20 = (__int16)(v18 - v16);
        v21 = v17;
        v22 = (473 * (__int16)(v64 + v17)) >> 8;
        v23 = v22 + ((-669 * v21) >> 8) - v19;
        *v47 = v57 + v19;
        v47[56] = v57 - v19;
        v47[8] = v61 + v23;
        v47[48] = v61 - v23;
        v24 = ((362 * v20) >> 8) - v23;
        v47[16] = v54 + v24;
        v47[40] = v54 - v24;
        LOWORD(v20) = v24 + ((277 * v64) >> 8) - v22;
        v47[32] = v59 + v20;
        v47[24] = v59 - v20;
        ++a1;
        ++a3;
        ++v47;
        --v50;
    } while (v50);
    v49 = 0;
    v51 = 8;
    v48 = a2;
    do
    {
        v25 = (_BYTE*)(a5 + *(_DWORD*)(v49 + a4));
        v49 += 4;
        v26 = v48[4];
        v27 = v48[6];
        v28 = v26 + *v48;
        v55 = *v48 - v26;
        v29 = v48[2];
        v58 = v27 + v29 + v28;
        v60 = v28 - (v27 + v29);
        v30 = ((362 * (__int16)(v29 - v27)) >> 8) - (v27 + v29);
        v31 = v30 + v55;
        v56 = v55 - v30;
        v62 = v31;
        v32 = v48[7];
        v33 = v48[3];
        v65 = v48[1];
        v34 = v32 + v65;
        v66 = v65 - v32;
        v35 = v48[5];
        v36 = v33 + v35;
        v37 = v35 - v33;
        v38 = v34;
        v39 = v36 + v34;
        v40 = (__int16)(v38 - v36);
        v41 = v37;
        v42 = (473 * (__int16)(v66 + v37)) >> 8;
        v43 = v42 + ((-669 * v41) >> 8) - v39;
        LOWORD(v40) = ((362 * v40) >> 8) - v43;
        v67 = v40 + ((277 * v66) >> 8) - v42;
        LOBYTE(v42) = *(_BYTE*)(a6 + (((__int16)(v58 - v39) >> 5) & 0x3FF));
        *v25 = *(_BYTE*)(a6 + (((__int16)(v58 + v39) >> 5) & 0x3FF));
        v25[7] = v42;
        LOBYTE(v42) = *(_BYTE*)(a6 + (((__int16)(v62 - v43) >> 5) & 0x3FF));
        v25[1] = *(_BYTE*)(a6 + (((__int16)(v62 + v43) >> 5) & 0x3FF));
        v25[6] = v42;
        LOBYTE(v42) = *(_BYTE*)(a6 + (((__int16)(v56 - v40) >> 5) & 0x3FF));
        v25[2] = *(_BYTE*)(a6 + (((__int16)(v56 + v40) >> 5) & 0x3FF));
        v25[5] = v42;
        LOBYTE(v39) = *(_BYTE*)(a6 + (((__int16)(v60 - v67) >> 5) & 0x3FF));
        v25[4] = *(_BYTE*)(a6 + (((__int16)(v60 + v67) >> 5) & 0x3FF));
        v25[3] = v39;
        v48 += 8;
        result = --v51;
    } while (v51);
    return result;
}

//----- (00487523) --------------------------------------------------------
char __cdecl sub_487523(__m64* a1, __m64* a2, __m64* a3, _DWORD* a4, int a5, int a6)
{
    __m64 v6; // mm0
    __m64 v7; // mm2
    __m64 v8; // mm5
    __m64 v9; // mm6
    __m64 v10; // mm2
    __m64 v11; // mm4
    __m64 v12; // mm3
    __m64 v13; // mm4
    __m64 v14; // mm5
    __m64 v15; // mm6
    __m64 v16; // mm0
    __m64 v17; // mm3
    __m64 v18; // mm7
    __m64 v19; // mm4
    __m64 v20; // mm3
    __m64 v21; // mm0
    __m64 v22; // mm5
    __m64 v23; // mm4
    __m64 v24; // mm0
    __m64 v25; // mm4
    __m64 v26; // mm5
    __m64 v27; // mm2
    __m64 v28; // mm1
    __m64 v29; // mm0
    __m64 v30; // mm3
    __m64 v31; // mm4
    __m64 v32; // mm1
    __m64 v33; // mm2
    __m64 v34; // mm4
    __m64 v35; // mm0
    __m64 v36; // mm6
    __m64 v37; // mm3
    __m64 v38; // mm0
    __m64 v39; // mm1
    __m64 m64_u64; // mm6
    __m64 v41; // mm1
    __m64 v42; // mm7
    __m64 v43; // mm5
    __m64 v44; // mm2
    __m64 v45; // mm4
    __m64 v46; // mm0
    __m64 v47; // mm1
    __m64 v48; // mm4
    __m64 v49; // mm3
    __m64 v50; // mm1
    __m64 v51; // mm6
    __m64 v52; // mm5
    __m64 v53; // mm6
    __m64 v54; // mm7
    __m64 v55; // mm3
    __m64 v56; // mm0
    __m64 v57; // mm3
    __m64 v58; // mm4
    __m64 v59; // mm6
    __m64 v60; // mm5
    __m64 v61; // mm6
    __m64 v62; // mm4
    __m64 v63; // mm5
    __m64 v64; // mm1
    __m64 v65; // mm2
    __m64 v66; // mm7
    __m64 v67; // mm3
    __m64 v68; // mm6
    __m64 v69; // mm3
    __m64 v70; // mm1
    __m64 v71; // mm4
    __m64 v72; // mm0
    __m64 v73; // mm2
    __m64 v74; // mm6
    __m64 v75; // mm1
    __m64 v76; // mm0
    __m64 v77; // mm5
    __m64 v78; // mm6
    __m64 v79; // mm0
    __m64 v80; // mm5
    __m64 v81; // mm0
    __m64 v82; // mm6
    __m64 v83; // mm2
    __m64 v84; // mm3
    __m64 v85; // mm7
    __m64 v86; // mm2
    __m64 v87; // mm5
    __m64 v88; // mm4
    __m64 v89; // mm3
    __m64 v90; // mm2
    __m64 v91; // mm7
    __m64 v92; // mm3
    __m64 v93; // mm1
    __m64 v94; // mm2
    __m64 v95; // mm0
    __m64 v96; // mm2
    __m64 v97; // mm1
    __m64 v98; // mm4
    __m64 v99; // mm3
    __m64 v100; // mm4
    __m64 v101; // mm1
    __m64 v102; // mm5
    __m64 v103; // mm0
    __m64 v104; // mm1
    __m64 v105; // mm3
    __m64 v106; // mm2
    __m64 v107; // mm5
    __m64 v108; // mm4
    __m64 v109; // mm1
    __m64 v110; // mm0
    __m64 v111; // mm3
    __m64 v112; // mm1
    __m64 v113; // mm4
    __m64 v114; // mm2
    __m64 v115; // mm0
    __m64 v116; // mm2
    __m64 v117; // mm0
    __m64 v118; // mm2
    __m64 v119; // mm5
    __m64 v120; // mm4
    __m64 v121; // mm2
    __m64 v122; // mm1
    __m64 v123; // mm4
    __m64 v124; // mm6
    __m64 v125; // mm5
    __m64 v126; // mm0
    __m64 v127; // mm3
    __m64 v128; // mm7
    __m64 v129; // mm4
    __m64 v130; // mm3
    __m64 v131; // mm0
    __m64 v132; // mm2
    __m64 v133; // mm6
    __m64 v134; // mm4
    __m64 v135; // mm5
    __m64 v136; // mm1
    __m64 v137; // mm0
    __m64 v138; // mm3
    __m64 v139; // mm1
    __m64 v140; // mm2
    __m64 v141; // mm4
    __m64 v142; // mm0
    __m64 v143; // mm6
    __m64 v144; // mm3
    __m64 v145; // mm0
    __m64 v146; // mm1
    __m64 v147; // mm6
    __m64 v148; // mm1
    __m64 v149; // mm7
    __m64 v150; // mm5
    __m64 v151; // mm2
    __m64 v152; // mm6
    __m64 v153; // mm4
    __m64 v154; // mm3
    __m64 v155; // mm1
    __m64 v156; // mm5
    __m64 v157; // mm7
    __m64 v158; // mm6
    __m64 v159; // mm4
    __m64 v160; // mm3
    __m64 v161; // mm0
    __m64 v162; // mm3
    __m64 v163; // mm6
    __m64 v164; // mm5
    __m64 v165; // mm6
    __m64 v166; // mm4
    __m64 v167; // mm5
    __m64 v168; // mm1
    __m64 v169; // mm2
    __m64 v170; // mm4
    __m64 v171; // mm2
    __m64 v172; // mm3
    __m64 v173; // mm6
    __m64 v174; // mm3
    __m64 v175; // mm1
    __m64 v176; // mm4
    __m64 v177; // mm2
    __m64 v178; // mm6
    __m64 v179; // mm1
    __m64 v180; // mm5
    __m64 v181; // mm0
    __m64 v182; // mm6
    _BYTE* v183; // ebx
    __m64 v184; // mm0
    __m64 v185; // mm5
    __m64 v186; // mm0
    __m64 v187; // mm2
    __m64 v188; // mm6
    __m64 v189; // mm3
    __m64 v190; // mm7
    __m64 v191; // mm2
    __m64 v192; // mm4
    __m64 v193; // mm5
    __m64 v194; // mm5
    __m64 v195; // mm5
    _BYTE* v196; // ebx
    __m64 v197; // mm4
    __m64 v198; // mm3
    __m64 v199; // mm4
    __m64 v200; // mm4
    __m64 v201; // mm4
    _BYTE* v202; // ecx
    __m64 v203; // mm0
    __m64 v204; // mm0
    __m64 v205; // mm0
    _BYTE* v206; // ebx
    __m64 v207; // mm3
    __m64 v208; // mm3
    __m64 v209; // mm3
    _BYTE* v210; // ebx
    __m64 v211; // mm4
    __m64 v212; // mm5
    __m64 v213; // mm2
    __m64 v214; // mm3
    __m64 v215; // mm7
    __m64 v216; // mm3
    __m64 v217; // mm1
    __m64 v218; // mm6
    __m64 v219; // mm6
    __m64 v220; // mm6
    _BYTE* v221; // ebx
    __m64 v222; // mm2
    __m64 v223; // mm2
    __m64 v224; // mm2
    _BYTE* v225; // ecx
    __m64 v226; // mm5
    __m64 v227; // mm5
    __m64 v228; // mm5
    _BYTE* v229; // ebx
    __m64 v230; // mm1
    __m64 v231; // mm1
    __m64 v232; // mm1
    _BYTE* v233; // ebx
    __m64 v234; // mm1
    __m64 v235; // mm2
    __m64 v236; // mm0
    __m64 v237; // mm2
    __m64 v238; // mm4
    __m64 v239; // mm1
    __m64 v240; // mm5
    __m64 v241; // mm3
    __m64 v242; // mm4
    __m64 v243; // mm1
    __m64 v244; // mm0
    __m64 v245; // mm1
    __m64 v246; // mm3
    __m64 v247; // mm0
    __m64 v248; // mm0
    __m64 v249; // mm0
    _BYTE* v250; // ebx
    __m64 v251; // mm2
    __m64 v252; // mm5
    __m64 v253; // mm4
    __m64 v254; // mm1
    __m64 v255; // mm1
    __m64 v256; // mm1
    _BYTE* v257; // ecx
    __m64 v258; // mm0
    __m64 v259; // mm1
    __m64 v260; // mm3
    __m64 v261; // mm1
    __m64 v262; // mm4
    __m64 v263; // mm2
    __m64 v264; // mm2
    __m64 v265; // mm2
    _BYTE* v266; // ebx
    __m64 v267; // mm2
    __m64 v268; // mm5
    __m64 v269; // mm5
    __m64 v270; // mm5
    __m64 v271; // mm0
    __m64 v272; // mm2
    __m64 v273; // mm4
    __m64 v274; // mm5
    _BYTE* v275; // ebx
    __m64 v276; // mm3
    __m64 v277; // mm3
    __m64 v278; // mm3
    _BYTE* v279; // ebx
    __m64 v280; // mm4
    __m64 v281; // mm4
    __m64 v282; // mm4
    _BYTE* v283; // ecx
    __m64 v284; // mm1
    __m64 v285; // mm1
    __m64 v286; // mm1
    _BYTE* v287; // ebx
    __m64 v288; // mm5
    __m64 v289; // mm5
    __m64 v290; // mm5
    char result; // al
    __m64 v292; // [esp+Ch] [ebp-18h]
    __m64 v293; // [esp+14h] [ebp-10h]
    __m64 v294; // [esp+14h] [ebp-10h]

    v6 = _m_pmullw(a1[12], a3[12]);
    v7 = _m_pmullw(a1[4], a3[4]);
    v8 = _m_pmullw(a1[8], a3[8]);
    v9 = _m_psubw(v7, v6);
    v10 = _m_paddw(v7, v6);
    v11 = _m_pmullw((__m64)a1->m64_u64, (__m64)a3->m64_u64);
    v12 = _m_paddw(v11, v8);
    v13 = _m_psubw(v11, v8);
    v14 = _m_psubw(
        _m_packssdw(
            _m_psradi(_m_pmaddwd(_m_punpcklwd(v9, 0), (__m64)0x16A0000016ALL), 8u),
            _m_psradi(_m_pmaddwd(_m_punpckhwd(v9, 0), (__m64)0x16A0000016ALL), 8u)),
        v10);
    a2[4].m64_u64 = (unsigned __int64)_m_paddw(v12, v10);
    a2[12].m64_u64 = (unsigned __int64)_m_paddw(v14, v13);
    v15 = _m_psubw(v12, v10);
    a2->m64_u64 = (unsigned __int64)_m_psubw(v13, v14);
    v16 = _m_pmullw(a1[6], a3[6]);
    v17 = _m_pmullw(a1[10], a3[10]);
    v18 = _m_psubw(v17, v16);
    v19 = _m_pmullw(a1[14], a3[14]);
    v20 = _m_paddw(v17, v16);
    v21 = _m_pmullw(a1[2], a3[2]);
    v22 = _m_paddw(v21, v19);
    v23 = _m_psubw(v21, v19);
    v293 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v23, 0), (__m64)0x11500000115LL), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v23, 0), (__m64)0x11500000115LL), 8u));
    v24 = _m_paddw(v18, v23);
    v25 = v22;
    v26 = _m_paddw(v22, v20);
    v27 = _m_psubw(v25, v20);
    v28 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v24, 0), (__m64)0x1D9000001D9LL), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v24, 0), (__m64)0x1D9000001D9LL), 8u));
    v29 = _m_psubw(v293, v28);
    v30 = v15;
    v31 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v27, 0), (__m64)0x16A0000016ALL), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v27, 0), (__m64)0x16A0000016ALL), 8u));
    v32 = _m_psubw(
        _m_paddw(
            v28,
            _m_packssdw(
                _m_psradi(_m_pmaddwd(_m_punpcklwd(v18, 0), (__m64)0xFD630000FD63LL), 8u),
                _m_psradi(_m_pmaddwd(_m_punpckhwd(v18, 0), (__m64)0xFD630000FD63LL), 8u))),
        v26);
    v33 = a2[12];
    v34 = _m_psubw(v31, v32);
    v35 = _m_paddw(v29, v34);
    v36 = _m_psubw(v15, v35);
    v37 = _m_paddw(v30, v35);
    v38 = v32;
    v39 = a2[4];
    a2[8].m64_u64 = (unsigned __int64)v37;
    a2[6].m64_u64 = (unsigned __int64)v36;
    m64_u64 = (__m64)a2->m64_u64;
    a2->m64_u64 = (unsigned __int64)_m_paddw(v39, v26);
    a2[14].m64_u64 = (unsigned __int64)_m_psubw(v39, v26);
    a2[2].m64_u64 = (unsigned __int64)_m_paddw(v33, v38);
    a2[12].m64_u64 = (unsigned __int64)_m_psubw(v33, v38);
    v41 = _m_pmullw(a1[5], a3[5]);
    a2[4].m64_u64 = (unsigned __int64)_m_paddw(m64_u64, v34);
    a2[10].m64_u64 = (unsigned __int64)_m_psubw(m64_u64, v34);
    v42 = _m_pmullw(a1[13], a3[13]);
    v43 = _m_pmullw(a1[9], a3[9]);
    v44 = _m_paddw(v41, v42);
    v45 = _m_psubw(v41, v42);
    v46 = _m_pmullw(a1[11], a3[11]);
    v47 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v45, 0), (__m64)0x16A0000016ALL), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v45, 0), (__m64)0x16A0000016ALL), 8u));
    v48 = _m_pmullw(a1[1], a3[1]);
    v49 = _m_paddw(v48, v43);
    v50 = _m_psubw(v47, v44);
    v51 = a1[7];
    v52 = _m_psubw(v48, v43);
    a2[5].m64_u64 = (unsigned __int64)_m_paddw(v49, v44);
    v53 = _m_pmullw(v51, a3[7]);
    v54 = _m_psubw(v49, v44);
    a2[13].m64_u64 = (unsigned __int64)_m_paddw(v52, v50);
    v55 = v46;
    a2[9].m64_u64 = (unsigned __int64)_m_psubw(v52, v50);
    v56 = _m_paddw(v46, v53);
    v57 = _m_psubw(v55, v53);
    v58 = _m_pmullw(a1[15], a3[15]);
    v292 = v54;
    v59 = _m_pmullw(a1[3], a3[3]);
    v60 = _m_paddw(v59, v58);
    v61 = _m_psubw(v59, v58);
    v62 = v60;
    v63 = _m_paddw(v60, v56);
    v64 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v57, 0), (__m64)0xFD630000FD63LL), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v57, 0), (__m64)0xFD630000FD63LL), 8u));
    v65 = _m_psubw(v62, v56);
    v66 = _m_paddw(v57, v61);
    v67 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v66, 0), (__m64)0x1D9000001D9LL), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v66, 0), (__m64)0x1D9000001D9LL), 8u));
    v68 = _m_psubw(
        _m_packssdw(
            _m_psradi(_m_pmaddwd(_m_punpcklwd(v61, 0), (__m64)0x11500000115LL), 8u),
            _m_psradi(_m_pmaddwd(_m_punpckhwd(v61, 0), (__m64)0x11500000115LL), 8u)),
        v67);
    v69 = _m_psubw(_m_paddw(v67, v64), v63);
    v70 = a2[5];
    v71 = _m_psubw(
        _m_packssdw(
            _m_psradi(_m_pmaddwd(_m_punpcklwd(v65, 0), (__m64)0x16A0000016ALL), 8u),
            _m_psradi(_m_pmaddwd(_m_punpckhwd(v65, 0), (__m64)0x16A0000016ALL), 8u)),
        v69);
    v72 = _m_paddw(v70, v63);
    v73 = a2[13];
    v74 = _m_paddw(v68, v71);
    v75 = _m_psubw(v70, v63);
    a2[1].m64_u64 = (unsigned __int64)v72;
    v76 = a2[9];
    v77 = _m_paddw(v292, v74);
    a2[7].m64_u64 = (unsigned __int64)_m_psubw(v292, v74);
    a2[3].m64_u64 = (unsigned __int64)_m_paddw(v73, v69);
    v78 = _m_psubw(v76, v71);
    a2[5].m64_u64 = (unsigned __int64)_m_paddw(v76, v71);
    v79 = v77;
    v80 = _m_punpcklwd(v77, v78);
    v81 = _m_punpckhwd(v79, v78);
    v82 = (__m64)a2->m64_u64;
    v83 = _m_psubw(v73, v69);
    v84 = _m_punpcklwd(v83, v75);
    v85 = a2[2];
    v86 = _m_punpckhwd(v83, v75);
    a2[9].m64_u64 = (unsigned __int64)_m_punpckldq(v80, v84);
    a2[11].m64_u64 = (unsigned __int64)_m_punpckhdq(v80, v84);
    a2[13].m64_u64 = (unsigned __int64)_m_punpckldq(v81, v86);
    a2[15].m64_u64 = (unsigned __int64)_m_punpckhdq(v81, v86);
    v87 = _m_punpckhwd(v82, v85);
    v88 = a2[6];
    v89 = a2[4];
    v90 = _m_punpcklwd(v82, v85);
    v91 = _m_punpcklwd(v89, v88);
    v92 = _m_punpckhwd(v89, v88);
    a2->m64_u64 = (unsigned __int64)_m_punpckldq(v90, v91);
    a2[2].m64_u64 = (unsigned __int64)_m_punpckhdq(v90, v91);
    a2[4].m64_u64 = (unsigned __int64)_m_punpckldq(v87, v92);
    a2[6].m64_u64 = (unsigned __int64)_m_punpckhdq(v87, v92);
    v93 = a2[3];
    v94 = a2[1];
    v95 = _m_punpcklwd(v94, v93);
    v96 = _m_punpckhwd(v94, v93);
    v97 = a2[7];
    v98 = a2[5];
    v99 = _m_punpcklwd(v98, v97);
    v100 = _m_punpckhwd(v98, v97);
    v101 = v95;
    v102 = v96;
    v103 = _m_punpckldq(v95, v99);
    v104 = _m_punpckhdq(v101, v99);
    v105 = a2[8];
    a2[8].m64_u64 = (unsigned __int64)v103;
    v106 = _m_punpckldq(v96, v100);
    v107 = _m_punpckhdq(v102, v100);
    v108 = a2[10];
    a2[10].m64_u64 = (unsigned __int64)v104;
    v109 = v105;
    v110 = a2[12];
    v111 = _m_punpcklwd(v105, v108);
    v112 = _m_punpckhwd(v109, v108);
    v113 = a2[14];
    a2[12].m64_u64 = (unsigned __int64)v106;
    v114 = v110;
    a2[14].m64_u64 = (unsigned __int64)v107;
    v115 = _m_punpcklwd(v110, v113);
    v116 = _m_punpckhwd(v114, v113);
    a2[1].m64_u64 = (unsigned __int64)_m_punpckldq(v111, v115);
    a2[3].m64_u64 = (unsigned __int64)_m_punpckhdq(v111, v115);
    a2[5].m64_u64 = (unsigned __int64)_m_punpckldq(v112, v116);
    a2[7].m64_u64 = (unsigned __int64)_m_punpckhdq(v112, v116);
    v117 = a2[12];
    v118 = a2[4];
    v119 = a2[8];
    v120 = _m_psubw(v118, v117);
    v121 = _m_paddw(v118, v117);
    v122 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v120, 0), (__m64)0x16A0000016ALL), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v120, 0), (__m64)0x16A0000016ALL), 8u));
    v123 = _m_psubw((__m64)a2->m64_u64, v119);
    v124 = _m_paddw((__m64)a2->m64_u64, v119);
    v125 = _m_psubw(v122, v121);
    a2[4].m64_u64 = (unsigned __int64)_m_paddw(v124, v121);
    a2[12].m64_u64 = (unsigned __int64)_m_paddw(v125, v123);
    a2->m64_u64 = (unsigned __int64)_m_psubw(v123, v125);
    v126 = a2[6];
    v127 = a2[10];
    v128 = _m_psubw(v127, v126);
    v129 = a2[14];
    v130 = _m_paddw(v127, v126);
    v294 = _m_psubw(v124, v121);
    v131 = a2[2];
    v132 = _m_psubw(v131, v129);
    v133 = _m_paddw(v128, v132);
    v134 = _m_paddw(v131, v129);
    v135 = _m_paddw(v134, v130);
    v136 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v133, 0), (__m64)0x1D9000001D9LL), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v133, 0), (__m64)0x1D9000001D9LL), 8u));
    v137 = _m_psubw(
        _m_packssdw(
            _m_psradi(_m_pmaddwd(_m_punpcklwd(v132, 0), (__m64)0x11500000115LL), 8u),
            _m_psradi(_m_pmaddwd(_m_punpckhwd(v132, 0), (__m64)0x11500000115LL), 8u)),
        v136);
    v138 = _m_psubw(v134, v130);
    v139 = _m_psubw(
        _m_paddw(
            v136,
            _m_packssdw(
                _m_psradi(_m_pmaddwd(_m_punpcklwd(v128, 0), (__m64)0xFD630000FD63LL), 8u),
                _m_psradi(_m_pmaddwd(_m_punpckhwd(v128, 0), (__m64)0xFD630000FD63LL), 8u))),
        v135);
    v140 = a2[12];
    v141 = _m_psubw(
        _m_packssdw(
            _m_psradi(_m_pmaddwd(_m_punpcklwd(v138, 0), (__m64)0x16A0000016ALL), 8u),
            _m_psradi(_m_pmaddwd(_m_punpckhwd(v138, 0), (__m64)0x16A0000016ALL), 8u)),
        v139);
    v142 = _m_paddw(v137, v141);
    v143 = _m_psubw(v294, v142);
    v144 = _m_paddw(v294, v142);
    v145 = v139;
    v146 = a2[4];
    a2[8].m64_u64 = (unsigned __int64)v144;
    a2[6].m64_u64 = (unsigned __int64)v143;
    v147 = (__m64)a2->m64_u64;
    a2->m64_u64 = (unsigned __int64)_m_paddw(v146, v135);
    a2[14].m64_u64 = (unsigned __int64)_m_psubw(v146, v135);
    a2[2].m64_u64 = (unsigned __int64)_m_paddw(v140, v145);
    a2[12].m64_u64 = (unsigned __int64)_m_psubw(v140, v145);
    v148 = a2[5];
    a2[4].m64_u64 = (unsigned __int64)_m_paddw(v147, v141);
    a2[10].m64_u64 = (unsigned __int64)_m_psubw(v147, v141);
    v149 = a2[13];
    v150 = a2[9];
    v151 = _m_paddw(v148, v149);
    v152 = _m_psubw(v148, v149);
    v153 = a2[1];
    v154 = _m_paddw(v153, v150);
    v155 = _m_psubw(
        _m_packssdw(
            _m_psradi(_m_pmaddwd(_m_punpcklwd(v152, 0), (__m64)0x16A0000016ALL), 8u),
            _m_psradi(_m_pmaddwd(_m_punpckhwd(v152, 0), (__m64)0x16A0000016ALL), 8u)),
        v151);
    v156 = _m_psubw(v153, v150);
    a2[5].m64_u64 = (unsigned __int64)_m_paddw(v154, v151);
    a2[13].m64_u64 = (unsigned __int64)_m_paddw(v156, v155);
    v157 = _m_psubw(v154, v151);
    a2[9].m64_u64 = (unsigned __int64)_m_psubw(v156, v155);
    v158 = a2[7];
    v159 = a2[15];
    v160 = a2[11];
    v161 = _m_paddw(v160, v158);
    v162 = _m_psubw(v160, v158);
    v163 = a2[3];
    v164 = _m_paddw(v163, v159);
    v165 = _m_psubw(v163, v159);
    v166 = v164;
    v167 = _m_paddw(v164, v161);
    v168 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v162, 0), (__m64)0xFD630000FD63LL), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v162, 0), (__m64)0xFD630000FD63LL), 8u));
    v169 = _m_psubw(v166, v161);
    v170 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v169, 0), (__m64)0x16A0000016ALL), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v169, 0), (__m64)0x16A0000016ALL), 8u));
    v171 = _m_paddw(v162, v165);
    v172 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v171, 0), (__m64)0x1D9000001D9LL), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v171, 0), (__m64)0x1D9000001D9LL), 8u));
    v173 = _m_psubw(
        _m_packssdw(
            _m_psradi(_m_pmaddwd(_m_punpcklwd(v165, 0), (__m64)0x11500000115LL), 8u),
            _m_psradi(_m_pmaddwd(_m_punpckhwd(v165, 0), (__m64)0x11500000115LL), 8u)),
        v172);
    v174 = _m_psubw(_m_paddw(v172, v168), v167);
    v175 = a2[5];
    v176 = _m_psubw(v170, v174);
    v177 = a2[13];
    v178 = _m_paddw(v173, v176);
    a2[1].m64_u64 = (unsigned __int64)_m_paddw(v175, v167);
    v179 = _m_psubw(v175, v167);
    v180 = _m_paddw(v157, v178);
    v181 = a2[9];
    a2[7].m64_u64 = (unsigned __int64)_m_psubw(v157, v178);
    a2[3].m64_u64 = (unsigned __int64)_m_paddw(v177, v174);
    v182 = _m_psubw(v181, v176);
    a2[5].m64_u64 = (unsigned __int64)_m_paddw(v181, v176);
    v183 = (_BYTE*)(a5 + a4[4]);
    v184 = v180;
    v185 = _m_punpcklwd(v180, v182);
    v186 = _m_punpckhwd(v184, v182);
    v187 = _m_psubw(v177, v174);
    v188 = (__m64)a2->m64_u64;
    v189 = _m_punpcklwd(v187, v179);
    v190 = a2[2];
    v191 = _m_punpckhwd(v187, v179);
    v192 = v185;
    v193 = _m_psrlwi(_m_punpckldq(v185, v189), 5u);
    v183[4] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v193) & 0x3FF));
    v194 = _m_psrlqi(v193, 0x10u);
    v183[5] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v194) & 0x3FF));
    v195 = _m_psrlqi(v194, 0x10u);
    v183[6] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v195) & 0x3FF));
    v183[7] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v195, 0x10u)) & 0x3FF));
    v196 = (_BYTE*)(a5 + a4[5]);
    v197 = _m_punpckhdq(v192, v189);
    v198 = v186;
    v199 = _m_psrlwi(v197, 5u);
    v196[4] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v199) & 0x3FF));
    v200 = _m_psrlqi(v199, 0x10u);
    v196[5] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v200) & 0x3FF));
    v201 = _m_psrlqi(v200, 0x10u);
    v196[6] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v201) & 0x3FF));
    v196[7] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v201, 0x10u)) & 0x3FF));
    v202 = (_BYTE*)(a5 + a4[6]);
    v203 = _m_psrlwi(_m_punpckldq(v186, v191), 5u);
    v202[4] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v203) & 0x3FF));
    v204 = _m_psrlqi(v203, 0x10u);
    v202[5] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v204) & 0x3FF));
    v205 = _m_psrlqi(v204, 0x10u);
    v202[6] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v205) & 0x3FF));
    v202[7] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v205, 0x10u)) & 0x3FF));
    v206 = (_BYTE*)(a5 + a4[7]);
    v207 = _m_psrlwi(_m_punpckhdq(v198, v191), 5u);
    v206[4] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v207) & 0x3FF));
    v208 = _m_psrlqi(v207, 0x10u);
    v206[5] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v208) & 0x3FF));
    v209 = _m_psrlqi(v208, 0x10u);
    v206[6] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v209) & 0x3FF));
    v206[7] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v209, 0x10u)) & 0x3FF));
    v210 = (_BYTE*)(a5 + *a4);
    v211 = a2[6];
    v212 = _m_punpckhwd(v188, v190);
    v213 = _m_punpcklwd(v188, v190);
    v214 = a2[4];
    v215 = _m_punpcklwd(v214, v211);
    v216 = _m_punpckhwd(v214, v211);
    v217 = v212;
    v218 = _m_psrlwi(_m_punpckldq(v213, v215), 5u);
    *v210 = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v218) & 0x3FF));
    v219 = _m_psrlqi(v218, 0x10u);
    v210[1] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v219) & 0x3FF));
    v220 = _m_psrlqi(v219, 0x10u);
    v210[2] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v220) & 0x3FF));
    v210[3] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v220, 0x10u)) & 0x3FF));
    v221 = (_BYTE*)(a5 + a4[1]);
    v222 = _m_psrlwi(_m_punpckhdq(v213, v215), 5u);
    *v221 = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v222) & 0x3FF));
    v223 = _m_psrlqi(v222, 0x10u);
    v221[1] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v223) & 0x3FF));
    v224 = _m_psrlqi(v223, 0x10u);
    v221[2] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v224) & 0x3FF));
    v221[3] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v224, 0x10u)) & 0x3FF));
    v225 = (_BYTE*)(a5 + a4[2]);
    v226 = _m_psrlwi(_m_punpckldq(v212, v216), 5u);
    *v225 = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v226) & 0x3FF));
    v227 = _m_psrlqi(v226, 0x10u);
    v225[1] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v227) & 0x3FF));
    v228 = _m_psrlqi(v227, 0x10u);
    v225[2] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v228) & 0x3FF));
    v225[3] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v228, 0x10u)) & 0x3FF));
    v229 = (_BYTE*)(a5 + a4[3]);
    v230 = _m_psrlwi(_m_punpckhdq(v217, v216), 5u);
    *v229 = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v230) & 0x3FF));
    v231 = _m_psrlqi(v230, 0x10u);
    v229[1] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v231) & 0x3FF));
    v232 = _m_psrlqi(v231, 0x10u);
    v229[2] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v232) & 0x3FF));
    v229[3] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v232, 0x10u)) & 0x3FF));
    v233 = (_BYTE*)(a5 + a4[4]);
    v234 = a2[3];
    v235 = a2[1];
    v236 = _m_punpcklwd(v235, v234);
    v237 = _m_punpckhwd(v235, v234);
    v238 = a2[5];
    v239 = a2[7];
    v240 = v237;
    v241 = _m_punpcklwd(v238, v239);
    v242 = _m_punpckhwd(v238, v239);
    v243 = v236;
    v244 = _m_punpckldq(v236, v241);
    v245 = _m_punpckhdq(v243, v241);
    v246 = a2[8];
    v247 = _m_psrlwi(v244, 5u);
    *v233 = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v247) & 0x3FF));
    v248 = _m_psrlqi(v247, 0x10u);
    v233[1] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v248) & 0x3FF));
    v249 = _m_psrlqi(v248, 0x10u);
    v233[2] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v249) & 0x3FF));
    v233[3] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v249, 0x10u)) & 0x3FF));
    v250 = (_BYTE*)(a5 + a4[5]);
    v251 = _m_punpckldq(v237, v242);
    v252 = _m_punpckhdq(v240, v242);
    v253 = a2[10];
    v254 = _m_psrlwi(v245, 5u);
    *v250 = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v254) & 0x3FF));
    v255 = _m_psrlqi(v254, 0x10u);
    v250[1] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v255) & 0x3FF));
    v256 = _m_psrlqi(v255, 0x10u);
    v250[2] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v256) & 0x3FF));
    v250[3] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v256, 0x10u)) & 0x3FF));
    v257 = (_BYTE*)(a5 + a4[6]);
    v258 = a2[12];
    v259 = v246;
    v260 = _m_punpcklwd(v246, v253);
    v261 = _m_punpckhwd(v259, v253);
    v262 = a2[14];
    v263 = _m_psrlwi(v251, 5u);
    *v257 = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v263) & 0x3FF));
    v264 = _m_psrlqi(v263, 0x10u);
    v257[1] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v264) & 0x3FF));
    v265 = _m_psrlqi(v264, 0x10u);
    v257[2] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v265) & 0x3FF));
    v257[3] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v265, 0x10u)) & 0x3FF));
    v266 = (_BYTE*)(a5 + a4[7]);
    v267 = v258;
    v268 = _m_psrlwi(v252, 5u);
    *v266 = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v268) & 0x3FF));
    v269 = _m_psrlqi(v268, 0x10u);
    v266[1] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v269) & 0x3FF));
    v270 = _m_psrlqi(v269, 0x10u);
    v266[2] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v270) & 0x3FF));
    v266[3] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v270, 0x10u)) & 0x3FF));
    v271 = _m_punpcklwd(v258, v262);
    v272 = _m_punpckhwd(v267, v262);
    v273 = v260;
    v274 = v261;
    v275 = (_BYTE*)(a5 + *a4);
    v276 = _m_psrlwi(_m_punpckldq(v260, v271), 5u);
    v275[4] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v276) & 0x3FF));
    v277 = _m_psrlqi(v276, 0x10u);
    v275[5] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v277) & 0x3FF));
    v278 = _m_psrlqi(v277, 0x10u);
    v275[6] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v278) & 0x3FF));
    v275[7] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v278, 0x10u)) & 0x3FF));
    v279 = (_BYTE*)(a5 + a4[1]);
    v280 = _m_psrlwi(_m_punpckhdq(v273, v271), 5u);
    v279[4] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v280) & 0x3FF));
    v281 = _m_psrlqi(v280, 0x10u);
    v279[5] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v281) & 0x3FF));
    v282 = _m_psrlqi(v281, 0x10u);
    v279[6] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v282) & 0x3FF));
    v279[7] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v282, 0x10u)) & 0x3FF));
    v283 = (_BYTE*)(a5 + a4[2]);
    v284 = _m_psrlwi(_m_punpckldq(v261, v272), 5u);
    v283[4] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v284) & 0x3FF));
    v285 = _m_psrlqi(v284, 0x10u);
    v283[5] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v285) & 0x3FF));
    v286 = _m_psrlqi(v285, 0x10u);
    v283[6] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v286) & 0x3FF));
    v283[7] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v286, 0x10u)) & 0x3FF));
    v287 = (_BYTE*)(a5 + a4[3]);
    v288 = _m_psrlwi(_m_punpckhdq(v274, v272), 5u);
    v287[4] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v288) & 0x3FF));
    v289 = _m_psrlqi(v288, 0x10u);
    v287[5] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v289) & 0x3FF));
    v290 = _m_psrlqi(v289, 0x10u);
    v287[6] = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(v290) & 0x3FF));
    result = *(_BYTE*)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v290, 0x10u)) & 0x3FF));
    v287[7] = result;
    _m_empty();
    return result;
}

//----- (004882D2) --------------------------------------------------------
int __cdecl sub_4882D2(int a1, int a2, int a3, int a4, _DWORD* a5, unsigned __int8** a6)
{
    _DWORD* v7; // edi
    _BYTE* v8; // ecx
    unsigned int v9; // ebx
    unsigned int j; // edx
    unsigned int v11; // eax
    int v12; // eax
    unsigned __int8* v13; // eax
    bool i; // zf
    unsigned __int8 v15; // cl
    int v16; // ecx
    unsigned int v17; // ebx
    unsigned int v18; // edx
    int v19; // eax
    unsigned __int8* v20; // eax
    int v21; // ecx
    int v22; // ebx
    unsigned int v23; // ebx
    unsigned int v24; // ecx
    int v25; // eax
    _BYTE* v26; // ecx
    char* v27; // eax
    unsigned int v28; // ecx
    _BYTE* v29; // ebx
    char v30; // cl
    _BYTE* v31; // ecx
    unsigned int v32; // ecx
    unsigned int v33; // eax
    unsigned __int8* v34; // ecx
    unsigned __int8* v35; // eax
    int v36; // ecx
    int v38; // [esp+Ch] [ebp-18h]
    int v39; // [esp+10h] [ebp-14h]
    unsigned int v40; // [esp+14h] [ebp-10h]
    unsigned int v41; // [esp+18h] [ebp-Ch]
    unsigned __int8* v42; // [esp+1Ch] [ebp-8h]
    unsigned int v43; // [esp+20h] [ebp-4h]
    unsigned int v44; // [esp+2Ch] [ebp+8h]
    unsigned int v45; // [esp+2Ch] [ebp+8h]
    unsigned int v46; // [esp+2Ch] [ebp+8h]
    int v47; // [esp+30h] [ebp+Ch]
    unsigned int v48; // [esp+30h] [ebp+Ch]
    unsigned int v49; // [esp+30h] [ebp+Ch]
    int v50; // [esp+30h] [ebp+Ch]
    _BYTE* v51; // [esp+40h] [ebp+1Ch]

    v42 = *a6;
    v7 = a5;
    v8 = (_BYTE*)a5[13];
    v9 = a5[8];
    j = a5[7];
    v43 = (unsigned int)a6[1];
    v11 = a5[12];
    v51 = v8;
    if ((unsigned int)v8 >= v11)
        v12 = a5[11] - (_DWORD)v8;
    else
        v12 = v11 - (_DWORD)v8 - 1;
    v40 = v12;
    v39 = dword_4B2710[a1];
    v38 = dword_4B2710[a2];
LABEL_6:
    while (j < 0x14)
    {
        --v43;
        v9 |= *v42++ << j;
        j += 8;
    }
    v13 = (unsigned __int8*)(a3 + 8 * (v9 & v39));
    v47 = *v13;
    for (i = v47 == 0; ; i = v47 == 0)
    {
        v15 = v13[1];
        if (i)
        {
            v9 >>= v15;
            j -= v13[1];
            v31 = v51++;
            --v40;
            *v31 = v13[4];
        LABEL_32:
            if (v40 < 0x102 || v43 < 0xA)
            {
                v32 = (unsigned int)&a6[1][-v43];
                if (j >> 3 < v32)
                    v32 = j >> 3;
                v50 = 0;
                goto LABEL_47;
            }
            goto LABEL_6;
        }
        v9 >>= v15;
        j -= v13[1];
        if ((v47 & 0x10) != 0)
        {
            v41 = *((_DWORD*)v13 + 1) + (v9 & dword_4B2710[v47 & 0xF]);
            v16 = v47 & 0xF;
            v17 = v9 >> v16;
            v18 = j - v16;
            v44 = v17;
            if (v18 < 0xF)
            {
                do
                {
                    --v43;
                    v19 = *v42 << v18;
                    v18 += 8;
                    v17 |= v19;
                    ++v42;
                } while (v18 < 0xF);
                v44 = v17;
            }
            v20 = (unsigned __int8*)(a4 + 8 * (v17 & v38));
            v45 = v44 >> v20[1];
            for (j = v18 - v20[1]; ; j -= v21)
            {
                v22 = *v20;
                if ((v22 & 0x10) != 0)
                {
                    v23 = v22 & 0xF;
                    while (j < v23)
                    {
                        --v43;
                        v45 |= *v42++ << j;
                        j += 8;
                    }
                    v7 = a5;
                    v24 = *((_DWORD*)v20 + 1) + (v45 & dword_4B2710[v23]);
                    v40 -= v41;
                    v25 = a5[10];
                    v48 = v24;
                    v46 = v45 >> v23;
                    j -= v23;
                    if ((unsigned int)&v51[-v25] < v24)
                    {
                        v28 = v24 + v25 - (_DWORD)v51;
                        v27 = (char*)(a5[11] - v28);
                        v49 = v28;
                        if (v41 > v28)
                        {
                            v41 -= v28;
                            do
                            {
                                v29 = v51;
                                v30 = *v27;
                                ++v51;
                                ++v27;
                                i = v49-- == 1;
                                *v29 = v30;
                            } while (!i);
                            v27 = (char*)a5[10];
                        }
                        v26 = v51;
                    }
                    else
                    {
                        *v51 = v51[-v24];
                        v51[1] = v51[-v24 + 1];
                        v26 = v51 + 2;
                        v27 = &v51[-v48 + 2];
                        v41 -= 2;
                    }
                    do
                    {
                        *v26++ = *v27++;
                        --v41;
                    } while (v41);
                    v9 = v46;
                    v51 = v26;
                    goto LABEL_32;
                }
                if ((v22 & 0x40) != 0)
                    break;
                v20 += 8 * *((_DWORD*)v20 + 1) + 8 * (v45 & dword_4B2710[v22]);
                v21 = v20[1];
                v45 >>= v21;
            }
            v32 = (unsigned int)&a6[1][-v43];
            a6[6] = "invalid distance code";
            if (j >> 3 < v32)
                v32 = j >> 3;
            v7 = a5;
            v9 = v45;
            goto LABEL_46;
        }
        if ((v47 & 0x40) != 0)
            break;
        v13 += 8 * *((_DWORD*)v13 + 1) + 8 * (v9 & dword_4B2710[v47]);
        v47 = *v13;
    }
    v33 = j >> 3;
    v34 = a6[1];
    if ((v47 & 0x20) == 0)
    {
        v32 = (unsigned int)&v34[-v43];
        a6[6] = "invalid literal/length code";
        if (v33 < v32)
            v32 = j >> 3;
    LABEL_46:
        v50 = -3;
        goto LABEL_47;
    }
    v32 = (unsigned int)&v34[-v43];
    if (v33 < v32)
        v32 = j >> 3;
    v50 = 1;
LABEL_47:
    v7[8] = v9;
    v7[7] = j - 8 * v32;
    v35 = &v42[-v32];
    a6[1] = (unsigned __int8*)(v43 + v32);
    v36 = &v42[-v32] - *a6;
    *a6 = v35;
    a6[2] += v36;
    v7[13] = v51;
    return v50;
}
// 4B2710: using guessed type int dword_4B2710[19];

//----- (004885A6) --------------------------------------------------------
void __cdecl sub_4885A6(LPVOID lpMem)
{
    sub_488CEE(lpMem);
}

//----- (0048861D) --------------------------------------------------------
double __usercall sub_48861D@<st0>(
    char a1@<zf>,
    unsigned int a2@<eax>,
    __int16 a3@<dx>,
    double result@<st0>,
    int a5,
    int a6)
{
    char v6; // fps

    if (a1)
    {
        if ((a2 & 0xFFFFF) != 0 || a5)
        {
            _convertTOStoQNaN();
            goto LABEL_17;
        }
    LABEL_16:
        result = *(double*)&tbyte_4B2910;
    LABEL_17:
        if (dword_522320)
            return result;
    LABEL_18:
        ((void(__fastcall*)(char*, int))_startOneArgErrorHandling)(aAcos, 13);
        return result;
    }
    if (a3 != 639)
        _load_CW();
    if (a2 < 0x3FF00000)
    {
        result = atan2(sqrt((result + 1.0) * (1.0 - result)), result);
        goto LABEL_6;
    }
    if (a2 > 0x3FF00000 || a5 | a6 & 0xFFFFF)
        goto LABEL_16;
    if (a6 < 0)
        result = 3.141592653589793238;
    else
        result = 0.0;
LABEL_6:
    if (!dword_522320 && a3 != 639 && (a3 & 0x20) != 0 && (v6 & 0x20) != 0)
        goto LABEL_18;
    return result;
}
// 488636: variable 'a2' is possibly undefined
// 48BFD7: using guessed type double _startOneArgErrorHandling();
// 48C035: using guessed type double _load_CW();
// 48C04C: using guessed type double _convertTOStoQNaN();
// 4B2910: using guessed type _TBYTE tbyte_4B2910;
// 522320: using guessed type int dword_522320;

//----- (004886ED) --------------------------------------------------------
double __usercall sub_4886ED@<st0>(
    char a1@<zf>,
    unsigned int a2@<eax>,
    __int16 a3@<dx>,
    double result@<st0>,
    int a5,
    int a6)
{
    char v6; // fps

    if (a1)
    {
        if ((a2 & 0xFFFFF) != 0 || a5)
        {
            _convertTOStoQNaN();
            goto LABEL_16;
        }
    LABEL_15:
        result = *(double*)&tbyte_4B2910;
    LABEL_16:
        if (dword_522320)
            return result;
    LABEL_17:
        _startOneArgErrorHandling(aAsin, 14);
        return result;
    }
    if (a3 != 639)
        _load_CW();
    if (a2 < 0x3FF00000)
    {
        result = atan2(result, sqrt((result + 1.0) * (1.0 - result)));
        goto LABEL_6;
    }
    if (a2 > 0x3FF00000 || a5 | a6 & 0xFFFFF)
        goto LABEL_15;
    result = *(double*)&tbyte_4B291A;
    if (a6 < 0)
        result = -*(double*)&tbyte_4B291A;
LABEL_6:
    if (!dword_522320 && a3 != 639 && (a3 & 0x20) != 0 && (v6 & 0x20) != 0)
        goto LABEL_17;
    return result;
}
// 488706: variable 'a2' is possibly undefined
// 48BFD7: using guessed type double __fastcall _startOneArgErrorHandling(_DWORD, _DWORD);
// 48C035: using guessed type double _load_CW(void);
// 48C04C: using guessed type double _convertTOStoQNaN(void);
// 4B2910: using guessed type _TBYTE tbyte_4B2910;
// 4B291A: using guessed type _TBYTE tbyte_4B291A;
// 522320: using guessed type int dword_522320;

//----- (00488CEE) --------------------------------------------------------
void __cdecl sub_488CEE(LPVOID lpMem)
{
    _DWORD* v1; // eax
    bool v2; // zf
    _BYTE* v3; // eax
    int v4; // [esp+Ch] [ebp-28h] BYREF
    _BYTE* v5; // [esp+10h] [ebp-24h]
    int v6; // [esp+14h] [ebp-20h] BYREF
    _DWORD* v7; // [esp+18h] [ebp-1Ch]
    CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]

    if (lpMem)
    {
        if (dword_523A84 == 3)
        {
            _lock(9);
            ms_exc.registration.TryLevel = 0;
            v1 = (_DWORD*)((int(__cdecl*)(LPVOID))__sbh_find_block)(lpMem);
            v7 = v1;
            if (v1)
                sub_48D6E8(v1, (int)lpMem);
            ms_exc.registration.TryLevel = -1;
            _unlock(9);
            v2 = v7 == 0;
        }
        else
        {
            if (dword_523A84 != 2)
            {
            LABEL_11:
                HeapFree(hHeap, 0, lpMem);
                return;
            }
            _lock(9);
            ms_exc.registration.TryLevel = 1;
            v3 = (_BYTE*)sub_48E418((unsigned int)lpMem, &v4, (unsigned int*)&v6);
            v5 = v3;
            if (v3)
                sub_48E46F(v4, v6, v3);
            ms_exc.registration.TryLevel = -1;
            _unlock(9);
            v2 = v5 == 0;
        }
        if (!v2)
            return;
        goto LABEL_11;
    }
}
// 48D6BD: using guessed type int __sbh_find_block();
// 48E8B2: using guessed type _DWORD __cdecl _lock(_DWORD);
// 48E913: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 523A84: using guessed type int dword_523A84;

//----- (00488DD7) --------------------------------------------------------
void* __cdecl sub_488DD7(LPVOID lpMem, SIZE_T dwBytes)
{
    void* v2; // ebx
    void* result; // eax
    SIZE_T v4; // esi
    _DWORD* block; // eax
    size_t v6; // eax
    size_t v7; // eax
    _BYTE* v8; // eax
    _BYTE* v9; // edi
    size_t v10; // eax
    size_t v11; // eax
    int v12; // [esp+Ch] [ebp-38h] BYREF
    size_t v13; // [esp+10h] [ebp-34h]
    _BYTE* v14; // [esp+14h] [ebp-30h]
    _DWORD* v15; // [esp+18h] [ebp-2Ch] BYREF
    _DWORD* v16; // [esp+1Ch] [ebp-28h]
    void* v17; // [esp+20h] [ebp-24h]
    size_t v18; // [esp+24h] [ebp-20h]
    CPPEH_RECORD ms_exc; // [esp+2Ch] [ebp-18h]

    v2 = lpMem;
    if (!lpMem)
        return malloc(dwBytes);
    v4 = dwBytes;
    if (dwBytes)
    {
        if (dword_523A84 == 3)
        {
            while (1)
            {
                v17 = 0;
                if (v4 <= 0xFFFFFFE0)
                {
                    _lock(9);
                    ms_exc.registration.TryLevel = 0;
                    block = (_DWORD*)__sbh_find_block(lpMem);
                    v16 = block;
                    if (block)
                    {
                        if (v4 <= dword_523A7C)
                        {
                            if (((int(__cdecl*)(_DWORD*, LPVOID, SIZE_T))__sbh_resize_block)(block, lpMem, v4))
                            {
                                v17 = lpMem;
                            }
                            else
                            {
                                v17 = (void*)((int(__cdecl*)(SIZE_T))__sbh_alloc_block)(v4);
                                if (v17)
                                {
                                    v6 = *((_DWORD*)lpMem - 1) - 1;
                                    v18 = v6;
                                    if (v6 >= v4)
                                        v6 = v4;
                                    memcpy_0(v17, lpMem, v6);
                                    v16 = (_DWORD*)__sbh_find_block(lpMem);
                                    sub_48D6E8(v16, (int)lpMem);
                                }
                            }
                        }
                        if (!v17)
                        {
                            if (!v4)
                                v4 = 1;
                            v4 = (v4 + 15) & 0xFFFFFFF0;
                            v17 = HeapAlloc(hHeap, 0, v4);
                            if (v17)
                            {
                                v7 = *((_DWORD*)lpMem - 1) - 1;
                                v18 = v7;
                                if (v7 >= v4)
                                    v7 = v4;
                                memcpy_0(v17, lpMem, v7);
                                sub_48D6E8(v16, (int)lpMem);
                            }
                        }
                    }
                    ms_exc.registration.TryLevel = -1;
                    _unlock(9);
                    if (!v16)
                    {
                        if (!v4)
                            v4 = 1;
                        v4 = (v4 + 15) & 0xFFFFFFF0;
                        v17 = HeapReAlloc(hHeap, 0, lpMem, v4);
                    }
                }
                result = v17;
                if (v17 || !dword_522424)
                    break;
                if (!_callnewh(v4))
                    return 0;
            }
        }
        else if (dword_523A84 == 2)
        {
            if (dwBytes <= 0xFFFFFFE0)
                v4 = (dwBytes + 15) & 0xFFFFFFF0;
            while (1)
            {
                v17 = 0;
                if (v4 <= 0xFFFFFFE0)
                {
                    _lock(9);
                    ms_exc.registration.TryLevel = 1;
                    v8 = (_BYTE*)sub_48E418((unsigned int)v2, &v12, (unsigned int*)&v15);
                    v9 = v8;
                    v14 = v8;
                    if (v8)
                    {
                        if (v4 < dword_4B498C)
                        {
                            if (sub_48E7E0(v12, v15, v8, v4 >> 4))
                            {
                                v17 = lpMem;
                            }
                            else
                            {
                                v17 = (void*)sub_48E4B4(v4 >> 4);
                                if (v17)
                                {
                                    v10 = 16 * (unsigned __int8)*v9;
                                    v13 = v10;
                                    if (v10 >= v4)
                                        v10 = v4;
                                    memcpy_0(v17, lpMem, v10);
                                    sub_48E46F(v12, (int)v15, v9);
                                }
                            }
                            v2 = lpMem;
                        }
                        if (!v17)
                        {
                            v17 = HeapAlloc(hHeap, 0, v4);
                            if (v17)
                            {
                                v11 = 16 * (unsigned __int8)*v9;
                                v13 = v11;
                                if (v11 >= v4)
                                    v11 = v4;
                                memcpy_0(v17, v2, v11);
                                sub_48E46F(v12, (int)v15, v9);
                            }
                        }
                    }
                    else
                    {
                        v17 = HeapReAlloc(hHeap, 0, v2, v4);
                    }
                    ms_exc.registration.TryLevel = -1;
                    _unlock(9);
                }
                result = v17;
                if (v17 || !dword_522424)
                    break;
                if (!_callnewh(v4))
                    return 0;
            }
        }
        else
        {
            while (1)
            {
                result = 0;
                if (v4 <= 0xFFFFFFE0)
                {
                    if (!v4)
                        v4 = 1;
                    v4 = (v4 + 15) & 0xFFFFFFF0;
                    result = HeapReAlloc(hHeap, 0, lpMem, v4);
                }
                if (result || !dword_522424)
                    break;
                if (!_callnewh(v4))
                    return 0;
            }
        }
    }
    else
    {
        sub_488CEE(lpMem);
        return 0;
    }
    return result;
}
// 488F7B: conditional instruction was optimized away because %dwBytes.4 is in (1..FFFFFFE0)
// 48D6BD: using guessed type int __cdecl __sbh_find_block(_DWORD);
// 48DA11: using guessed type int __sbh_alloc_block();
// 48DEC6: using guessed type int __sbh_resize_block();
// 48E8B2: using guessed type _DWORD __cdecl _lock(_DWORD);
// 48E913: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 4B498C: using guessed type int dword_4B498C;
// 523A7C: using guessed type int dword_523A7C;
// 523A84: using guessed type int dword_523A84;

//----- (00489562) --------------------------------------------------------
LPVOID __cdecl sub_489562(unsigned int a1)
{
    LPVOID result; // eax
    SIZE_T v2; // esi
    int v3; // eax
    SIZE_T v4; // eax
    int v5; // [esp+Ch] [ebp-1Ch]
    int v6; // [esp+Ch] [ebp-1Ch]

    if (dword_523A84 == 3)
    {
        if (a1 <= dword_523A7C)
        {
            _lock(9);
            v5 = __sbh_alloc_block(a1);
            _unlock(9);
            result = (LPVOID)v5;
            if (v5)
                return result;
        }
        goto LABEL_12;
    }
    if (dword_523A84 != 2)
    {
    LABEL_12:
        v3 = a1;
        if (!a1)
            v3 = 1;
        v4 = v3 + 15;
        LOBYTE(v4) = v4 & 0xF0;
        return HeapAlloc(hHeap, 0, v4);
    }
    if (a1)
        v2 = (a1 + 15) & 0xFFFFFFF0;
    else
        v2 = 16;
    if (v2 > dword_4B498C)
        return HeapAlloc(hHeap, 0, v2);
    _lock(9);
    v6 = sub_48E4B4(v2 >> 4);
    _unlock(9);
    result = (LPVOID)v6;
    if (!v6)
        return HeapAlloc(hHeap, 0, v2);
    return result;
}
// 48DA11: using guessed type int __cdecl __sbh_alloc_block(_DWORD);
// 48E8B2: using guessed type _DWORD __cdecl _lock(_DWORD);
// 48E913: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 4B498C: using guessed type int dword_4B498C;
// 523A7C: using guessed type int dword_523A7C;
// 523A84: using guessed type int dword_523A84;

//----- (004898CA) --------------------------------------------------------
size_t __cdecl sub_4898CA(void* Buffer, size_t ElementSize, size_t ElementCount, FILE* Stream)
{
    size_t v4; // esi

    _lock_file(Stream);
    v4 = fread(Buffer, ElementSize, ElementCount, Stream);
    _unlock_file(Stream);
    return v4;
}

//----- (00489D27) --------------------------------------------------------
int sub_489D27()
{
    return flsall(1);
}
// 489D30: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (0048A1BB) --------------------------------------------------------
int __cdecl sub_48A1BB(char* String)
{
    return atol(String);
}

//----- (0048A21D) --------------------------------------------------------
size_t __cdecl sub_48A21D(void* Buffer, size_t ElementSize, size_t ElementCount, FILE* Stream)
{
    size_t v4; // esi

    _lock_file(Stream);
    v4 = fwrite(Buffer, ElementSize, ElementCount, Stream);
    _unlock_file(Stream);
    return v4;
}

//----- (0048B1FD) --------------------------------------------------------
int __cdecl sub_48B1FD(FILE* Stream, int a2, int a3)
{
    int v3; // edi
    int v4; // ebx

    _lock_file(Stream);
    v3 = _stbuf(Stream);
    v4 = _output(Stream, a2, (int)&a3);
    _ftbuf(v3, Stream);
    _unlock_file(Stream);
    return v4;
}
// 48EDE5: using guessed type _DWORD __cdecl _stbuf(_DWORD);
// 48EE72: using guessed type _DWORD __cdecl _ftbuf(_DWORD, _DWORD);

//----- (0048B813) --------------------------------------------------------
int __cdecl sub_48B813(int a1, int a2)
{
    SIZE_T v2; // esi
    int result; // eax
    void* v4; // [esp+14h] [ebp-20h]
    size_t v5; // [esp+18h] [ebp-1Ch]

    v2 = a2 * a1;
    v5 = a2 * a1;
    if ((unsigned int)(a2 * a1) <= 0xFFFFFFE0)
    {
        if (!v2)
            v2 = 1;
        v2 = (v2 + 15) & 0xFFFFFFF0;
    }
    while (1)
    {
        v4 = 0;
        if (v2 <= 0xFFFFFFE0)
        {
            if (dword_523A84 == 3)
            {
                if (v5 > dword_523A7C)
                    goto LABEL_14;
                _lock(9);
                v4 = (void*)__sbh_alloc_block(v5);
                _unlock(9);
                if (v4)
                {
                    memset(v4, 0, v5);
                    goto LABEL_14;
                }
            LABEL_15:
                v4 = HeapAlloc(hHeap, 8u, v2);
                goto LABEL_16;
            }
            if (dword_523A84 == 2 && v2 <= dword_4B498C)
            {
                _lock(9);
                v4 = (void*)sub_48E4B4(v2 >> 4);
                _unlock(9);
                if (!v4)
                    goto LABEL_15;
                memset(v4, 0, v2);
            }
        LABEL_14:
            if (v4)
                return (int)v4;
            goto LABEL_15;
        }
    LABEL_16:
        if (v4 || !dword_522424)
            return (int)v4;
        result = _callnewh(v2);
        if (!result)
            return result;
    }
}
// 48DA11: using guessed type int __cdecl __sbh_alloc_block(_DWORD);
// 48E8B2: using guessed type _DWORD __cdecl _lock(_DWORD);
// 48E913: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 4B498C: using guessed type int dword_4B498C;
// 523A7C: using guessed type int dword_523A7C;
// 523A84: using guessed type int dword_523A84;

//----- (0048CB2B) --------------------------------------------------------
void __thiscall __noreturn sub_48CB2B(EXCEPTION_POINTERS* this)
{
    int v1; // [esp-Ch] [ebp-24h] BYREF
    CPPEH_RECORD ms_exc; // [esp+0h] [ebp-18h]

    ms_exc.registration.ScopeTable = stru_49D698;
    ms_exc.registration.ExceptionHandler = _except_handler3;
    ms_exc.registration.Next = (struct _EH3_EXCEPTION_REGISTRATION*)NtCurrentTeb()->NtTib.ExceptionList;
    ms_exc.exc_ptr = this;
    ms_exc.old_esp = (DWORD)&v1;
    ms_exc.registration.TryLevel = 0;
    if (off_4B2954)
    {
        ms_exc.registration.TryLevel = 1;
        off_4B2954();
    }
    ms_exc.registration.TryLevel = -1;
    JUMPOUT(0x48CACA);
}
// 48CB7C: control flows out of bounds to 48CACA
// 49D698: using guessed type _SCOPETABLE_ENTRY stru_49D698[2];
// 4B2954: using guessed type void (__cdecl __noreturn *off_4B2954)();

//----- (0048D4A3) --------------------------------------------------------
char __cdecl sub_48D4A3(int a1)
{
    HMODULE ModuleHandleA; // eax
    int v2; // ecx

    *(_DWORD*)a1 = 0;
    ModuleHandleA = GetModuleHandleA(0);
    if (*(_WORD*)ModuleHandleA == 23117)
    {
        v2 = *((_DWORD*)ModuleHandleA + 15);
        if (v2)
        {
            ModuleHandleA = (HMODULE)((char*)ModuleHandleA + v2);
            *(_BYTE*)a1 = *((_BYTE*)ModuleHandleA + 26);
            LOBYTE(ModuleHandleA) = *((_BYTE*)ModuleHandleA + 27);
            *(_BYTE*)(a1 + 1) = (_BYTE)ModuleHandleA;
        }
    }
    return (char)ModuleHandleA;
}

//----- (0048D4D0) --------------------------------------------------------
int sub_48D4D0()
{
    int result; // eax
    CHAR* i; // ecx
    char v2; // al
    CHAR* v3; // eax
    CHAR* j; // ecx
    char v5; // al
    char* v6; // eax
    const char* v7; // eax
    const char* v8; // ecx
    CHAR Buffer[4240]; // [esp+4h] [ebp-122Ch] BYREF
    CHAR Filename[260]; // [esp+1094h] [ebp-19Ch] BYREF
    struct _OSVERSIONINFOA VersionInformation; // [esp+1198h] [ebp-98h] BYREF
    _BYTE v12[4]; // [esp+122Ch] [ebp-4h] BYREF

    VersionInformation.dwOSVersionInfoSize = 148;
    if (GetVersionExA(&VersionInformation)
        && VersionInformation.dwPlatformId == 2
        && VersionInformation.dwMajorVersion >= 5)
    {
        return 1;
    }
    if (!GetEnvironmentVariableA("__MSVCRT_HEAP_SELECT", Buffer, 0x1090u))
        goto LABEL_29;
    for (i = Buffer; *i; ++i)
    {
        v2 = *i;
        if (*i >= 97 && v2 <= 122)
            *i = v2 - 32;
    }
    if (!strncmp("__GLOBAL_HEAP_SELECTED", Buffer, 0x16u))
    {
        v3 = Buffer;
    }
    else
    {
        GetModuleFileNameA(0, Filename, 0x104u);
        for (j = Filename; *j; ++j)
        {
            v5 = *j;
            if (*j >= 97 && v5 <= 122)
                *j = v5 - 32;
        }
        v3 = strstr(Buffer, Filename);
    }
    if (!v3)
        goto LABEL_29;
    v6 = strchr(v3, 44);
    if (!v6)
        goto LABEL_29;
    v7 = v6 + 1;
    v8 = v7;
    while (*v8)
    {
        if (*v8 == 59)
            *v8 = 0;
        else
            ++v8;
    }
    result = strtol(v7, 0, 10);
    if (result != 2 && result != 3 && result != 1)
    {
    LABEL_29:
        sub_48D4A3((int)v12);
        return 3 - (v12[0] < 6u);
    }
    return result;
}

//----- (0048D618) --------------------------------------------------------
int __cdecl sub_48D618(int a1)
{
    int v1; // eax
    int* v2; // eax

    hHeap = HeapCreate(a1 == 0, 0x1000u, 0);
    if (!hHeap)
        return 0;
    v1 = sub_48D4D0();
    dword_523A84 = v1;
    if (v1 == 3)
    {
        v2 = (int*)((int(__cdecl*)(int))__sbh_heap_init)(1016);
    }
    else
    {
        if (v1 != 2)
            return 1;
        v2 = sub_48E1BC();
    }
    if (!v2)
    {
        HeapDestroy(hHeap);
        return 0;
    }
    return 1;
}
// 48D675: using guessed type int __sbh_heap_init();
// 523A84: using guessed type int dword_523A84;

//----- (0048D6E8) --------------------------------------------------------
_DWORD* __cdecl sub_48D6E8(_DWORD* a1, int a2)
{
    _DWORD* result; // eax
    int* v3; // esi
    unsigned int v4; // edi
    int v5; // ecx
    char* v6; // ebx
    unsigned int v7; // edx
    _BYTE* v8; // ecx
    unsigned int v9; // ebx
    bool v10; // zf
    _BYTE* v11; // ecx
    unsigned int v12; // ebx
    unsigned int v13; // edx
    unsigned int v14; // ebx
    unsigned int v15; // esi
    unsigned int v16; // esi
    _DWORD* v17; // ecx
    LPVOID* v18; // eax
    _DWORD* v19; // [esp+Ch] [ebp-10h]
    int v20; // [esp+10h] [ebp-Ch]
    int v21; // [esp+14h] [ebp-8h]
    int v22; // [esp+18h] [ebp-4h]
    char* v23; // [esp+28h] [ebp+Ch]
    int* v24; // [esp+28h] [ebp+Ch]
    char v25; // [esp+2Bh] [ebp+Fh]

    result = (_DWORD*)a1[4];
    v3 = (int*)(a2 - 4);
    v4 = (unsigned int)(a2 - a1[3]) >> 15;
    v19 = &result[129 * v4 + 81];
    v5 = *(_DWORD*)(a2 - 4) - 1;
    v22 = v5;
    if ((v5 & 1) == 0)
    {
        v6 = (char*)v3 + v5;
        v20 = *(int*)((char*)v3 + v5);
        v21 = *(_DWORD*)(a2 - 8);
        v23 = (char*)v3 + v5;
        if ((v20 & 1) == 0)
        {
            v7 = (v20 >> 4) - 1;
            if (v7 > 0x3F)
                v7 = 63;
            if (*((_DWORD*)v6 + 1) == *((_DWORD*)v6 + 2))
            {
                if (v7 >= 0x20)
                {
                    v11 = (char*)result + v7 + 4;
                    v12 = ~(0x80000000 >> (v7 - 32));
                    result[v4 + 49] &= v12;
                    v10 = (*v11)-- == 1;
                    if (v10)
                        a1[1] &= v12;
                }
                else
                {
                    v8 = (char*)result + v7 + 4;
                    v9 = ~(0x80000000 >> v7);
                    result[v4 + 17] &= v9;
                    v10 = (*v8)-- == 1;
                    if (v10)
                        *a1 &= v9;
                }
                v5 = v22;
                v6 = v23;
            }
            v5 += v20;
            *(_DWORD*)(*((_DWORD*)v6 + 2) + 4) = *((_DWORD*)v6 + 1);
            v22 = v5;
            *(_DWORD*)(*((_DWORD*)v23 + 1) + 8) = *((_DWORD*)v23 + 2);
        }
        v13 = (v5 >> 4) - 1;
        if (v13 > 0x3F)
            v13 = 63;
        if ((v21 & 1) != 0)
        {
            v14 = (unsigned int)a1;
        }
        else
        {
            v24 = (int*)((char*)v3 - v21);
            v14 = (v21 >> 4) - 1;
            if (v14 > 0x3F)
                v14 = 63;
            v22 = v21 + v5;
            v13 = ((v21 + v5) >> 4) - 1;
            if (v13 > 0x3F)
                v13 = 63;
            if (v14 != v13)
            {
                if (v24[1] == v24[2])
                {
                    if (v14 >= 0x20)
                    {
                        v16 = ~(0x80000000 >> (v14 - 32));
                        result[v4 + 49] &= v16;
                        v10 = (*((_BYTE*)result + v14 + 4))-- == 1;
                        if (v10)
                            a1[1] &= v16;
                    }
                    else
                    {
                        v15 = ~(0x80000000 >> v14);
                        result[v4 + 17] &= v15;
                        v10 = (*((_BYTE*)result + v14 + 4))-- == 1;
                        if (v10)
                            *a1 &= v15;
                    }
                }
                *(_DWORD*)(v24[2] + 4) = v24[1];
                *(_DWORD*)(v24[1] + 8) = v24[2];
            }
            v3 = v24;
        }
        if ((v21 & 1) != 0 || v14 != v13)
        {
            v17 = &v19[2 * v13];
            v3[1] = v17[1];
            v3[2] = (int)v17;
            v17[1] = v3;
            *(_DWORD*)(v3[1] + 8) = v3;
            if (v3[1] == v3[2])
            {
                v25 = *((_BYTE*)result + v13 + 4);
                *((_BYTE*)result + v13 + 4) = v25 + 1;
                if (v13 >= 0x20)
                {
                    if (!v25)
                        a1[1] |= 0x80000000 >> (v13 - 32);
                    result[v4 + 49] |= 0x80000000 >> (v13 - 32);
                }
                else
                {
                    if (!v25)
                        *a1 |= 0x80000000 >> v13;
                    result[v4 + 17] |= 0x80000000 >> v13;
                }
            }
        }
        *v3 = v22;
        *(int*)((char*)v3 + v22 - 4) = v22;
        result += 129 * v4 + 81;
        v10 = (*v19)-- == 1;
        if (v10)
        {
            if (dword_523A70)
            {
                VirtualFree((LPVOID)(*((_DWORD*)dword_523A70 + 3) + (dword_523A68 << 15)), 0x8000u, 0x4000u);
                *((_DWORD*)dword_523A70 + 2) |= 0x80000000 >> dword_523A68;
                *(_DWORD*)(*((_DWORD*)dword_523A70 + 4) + 4 * dword_523A68 + 196) = 0;
                --*(_BYTE*)(*((_DWORD*)dword_523A70 + 4) + 67);
                v18 = (LPVOID*)dword_523A70;
                if (!*(_BYTE*)(*((_DWORD*)dword_523A70 + 4) + 67))
                {
                    *((_DWORD*)dword_523A70 + 1) &= ~1u;
                    v18 = (LPVOID*)dword_523A70;
                }
                if (v18[2] == (LPVOID)-1)
                {
                    VirtualFree(v18[3], 0, 0x8000u);
                    HeapFree(hHeap, 0, *((LPVOID*)dword_523A70 + 4));
                    memcpy(dword_523A70, (char*)dword_523A70 + 20, (size_t)lpMem + 20 * dword_523A74 - (_DWORD)dword_523A70 - 20);
                    --dword_523A74;
                    if (a1 > dword_523A70)
                        a1 -= 5;
                    dword_523A6C = (int)lpMem;
                }
            }
            result = a1;
            dword_523A68 = v4;
            dword_523A70 = a1;
        }
    }
    return result;
}
// 523A68: using guessed type int dword_523A68;
// 523A6C: using guessed type int dword_523A6C;
// 523A74: using guessed type int dword_523A74;

//----- (0048E1BC) --------------------------------------------------------
int* sub_48E1BC()
{
    int* v0; // esi
    _DWORD* v1; // eax
    _DWORD* v2; // edi
    int* v3; // eax
    int v4; // ebp
    int v5; // edx

    if (dword_4B2978 == -1)
    {
        v0 = (int*)&off_4B2968;
    }
    else
    {
        v0 = (int*)HeapAlloc(hHeap, 0, 0x2020u);
        if (!v0)
            return 0;
    }
    v1 = VirtualAlloc(0, 0x400000u, 0x2000u, 4u);
    v2 = v1;
    if (!v1)
    {
    LABEL_19:
        if (v0 != (int*)&off_4B2968)
            HeapFree(hHeap, 0, v0);
        return 0;
    }
    if (!VirtualAlloc(v1, 0x10000u, 0x1000u, 4u))
    {
        VirtualFree(v2, 0, 0x8000u);
        goto LABEL_19;
    }
    if (v0 == (int*)&off_4B2968)
    {
        if (!off_4B2968)
            off_4B2968 = &off_4B2968;
        if (!off_4B296C)
            off_4B296C = &off_4B2968;
    }
    else
    {
        *v0 = (int)&off_4B2968;
        v0[1] = (int)off_4B296C;
        off_4B296C = v0;
        *(_DWORD*)v0[1] = v0;
    }
    v0[5] = (int)(v2 + 0x100000);
    v3 = v0 + 6;
    v0[3] = (int)(v0 + 38);
    v0[4] = (int)v2;
    v0[2] = (int)(v0 + 6);
    v4 = 0;
    do
    {
        v5 = v4++ >= 16 ? -1 : 240;
        *v3 = v5;
        v3[1] = 241;
        v3 += 2;
    } while (v4 < 1024);
    memset(v2, 0, 0x10000u);
    while ((unsigned int)v2 < v0[4] + 0x10000)
    {
        *((_BYTE*)v2 + 248) = -1;
        *v2 = v2 + 2;
        v2[1] = 240;
        v2 += 1024;
    }
    return v0;
}
// 4B2968: using guessed type _UNKNOWN *off_4B2968;
// 4B2978: using guessed type int dword_4B2978;

//----- (0048E300) --------------------------------------------------------
_UNKNOWN** __cdecl sub_48E300(LPVOID* lpMem)
{
    _UNKNOWN** result; // eax

    result = (_UNKNOWN**)VirtualFree(lpMem[4], 0, 0x8000u);
    if (off_4B4988 == (_UNKNOWN**)lpMem)
    {
        result = (_UNKNOWN**)lpMem[1];
        off_4B4988 = result;
    }
    if (lpMem == (LPVOID*)&off_4B2968)
    {
        dword_4B2978 = -1;
    }
    else
    {
        *(_DWORD*)lpMem[1] = *lpMem;
        *((_DWORD*)*lpMem + 1) = lpMem[1];
        return (_UNKNOWN**)HeapFree(hHeap, 0, lpMem);
    }
    return result;
}
// 4B2968: using guessed type _UNKNOWN *off_4B2968;
// 4B2978: using guessed type int dword_4B2978;
// 4B4988: using guessed type _UNKNOWN **off_4B4988;

//----- (0048E356) --------------------------------------------------------
void __cdecl sub_48E356(int a1)
{
    _DWORD* v1; // esi
    _DWORD* v2; // edi
    int i; // ebx
    unsigned int v4; // eax
    _DWORD* v5; // ecx
    _DWORD* v6; // eax
    int j; // edx
    int v8; // [esp+Ch] [ebp-4h]

    v1 = off_4B296C;
    do
    {
        if (v1[4] != -1)
        {
            v8 = 0;
            v2 = v1 + 2052;
            for (i = 4190208; i >= 0; i -= 4096)
            {
                if (*v2 == 240 && VirtualFree((LPVOID)(v1[4] + i), 0x1000u, 0x4000u))
                {
                    *v2 = -1;
                    --dword_5223BC;
                    v4 = v1[3];
                    if (!v4 || v4 > (unsigned int)v2)
                        v1[3] = v2;
                    ++v8;
                    if (!--a1)
                        break;
                }
                v2 -= 2;
            }
            v5 = v1;
            v1 = (_DWORD*)v1[1];
            if (v8 && v5[6] == -1)
            {
                v6 = v5 + 8;
                for (j = 1; j < 1024; ++j)
                {
                    if (*v6 != -1)
                        break;
                    v6 += 2;
                }
                if (j == 1024)
                    sub_48E300((LPVOID*)v5);
            }
        }
    } while (v1 != off_4B296C && a1 > 0);
}
// 5223BC: using guessed type int dword_5223BC;

//----- (0048E418) --------------------------------------------------------
unsigned int __cdecl sub_48E418(unsigned int a1, _DWORD* a2, unsigned int* a3)
{
    _UNKNOWN** v3; // ecx

    v3 = &off_4B2968;
    while (a1 <= (unsigned int)v3[4] || a1 >= (unsigned int)v3[5])
    {
        v3 = (_UNKNOWN**)*v3;
        if (v3 == &off_4B2968)
            return 0;
    }
    if ((a1 & 0xF) == 0 && (a1 & 0xFFF) >= 0x100)
    {
        *a2 = v3;
        *a3 = a1 & 0xFFFFF000;
        return ((int)(a1 - (a1 & 0xFFFFF000) - 256) >> 4) + (a1 & 0xFFFFF000) + 8;
    }
    return 0;
}
// 4B2968: using guessed type _UNKNOWN *off_4B2968;

//----- (0048E46F) --------------------------------------------------------
void __cdecl sub_48E46F(int a1, int a2, _BYTE* a3)
{
    _DWORD* v3; // eax
    bool v4; // zf

    v3 = (_DWORD*)(a1 + 8 * ((a2 - *(_DWORD*)(a1 + 16)) >> 12) + 24);
    *v3 += (unsigned __int8)*a3;
    *a3 = 0;
    v4 = *v3 == 240;
    v3[1] = 241;
    if (v4 && ++dword_5223BC == 32)
        sub_48E356(16);
}
// 5223BC: using guessed type int dword_5223BC;

//----- (0048E4B4) --------------------------------------------------------
int __cdecl sub_48E4B4(unsigned int a1)
{
    _UNKNOWN** v1; // esi
    void* v2; // edx
    unsigned int* v3; // edi
    int v4; // eax
    unsigned int v5; // ebx
    int result; // eax
    char* v7; // edi
    _DWORD* v8; // ebx
    _DWORD* v9; // eax
    _DWORD* i; // esi
    _DWORD* v11; // ecx
    _DWORD* v12; // eax
    _UNKNOWN** v13; // eax
    bool v14; // cf
    int* v15; // eax
    int v16; // ecx
    unsigned int Val; // [esp+Ch] [ebp-8h]
    int v18; // [esp+10h] [ebp-4h]
    int v19; // [esp+10h] [ebp-4h]
    int v20; // [esp+10h] [ebp-4h]

    v1 = off_4B4988;
    do
    {
        v2 = v1[4];
        if (v2 == (void*)-1)
        {
            v5 = a1;
        }
        else
        {
            v3 = (unsigned int*)v1[2];
            v4 = (int)v2 + 4096 * (((char*)v3 - (char*)v1 - 24) >> 3);
            v18 = v4;
            if (v3 < (unsigned int*)v1 + 2054)
            {
                while (1)
                {
                    v5 = a1;
                    if ((int)*v3 >= (int)a1 && v3[1] > a1)
                    {
                        result = sub_48E6BC(v4, *v3, a1);
                        if (result)
                        {
                        LABEL_21:
                            off_4B4988 = v1;
                            *v3 -= v5;
                            v1[2] = v3;
                            return result;
                        }
                        v4 = v18;
                        v3[1] = a1;
                    }
                    v3 += 2;
                    v4 += 4096;
                    v18 = v4;
                    if (v3 >= (unsigned int*)v1 + 2054)
                        goto LABEL_11;
                }
            }
            v5 = a1;
        LABEL_11:
            v3 = (unsigned int*)(v1 + 6);
            Val = (unsigned int)v1[2];
            v19 = (int)v1[4];
            if ((unsigned int)(v1 + 6) < Val)
            {
                do
                {
                    if ((int)*v3 >= (int)v5 && v3[1] > v5)
                    {
                        result = sub_48E6BC(v19, *v3, v5);
                        if (result)
                            goto LABEL_21;
                        v3[1] = v5;
                    }
                    v19 += 4096;
                    v3 += 2;
                } while ((unsigned int)v3 < Val);
            }
        }
        v1 = (_UNKNOWN**)*v1;
    } while (v1 != off_4B4988);
    v7 = (char*)&off_4B2968;
    while (*((_DWORD*)v7 + 4) == -1 || !*((_DWORD*)v7 + 3))
    {
        v7 = *(char**)v7;
        if (v7 == (char*)&off_4B2968)
        {
            v15 = sub_48E1BC();
            if (v15)
            {
                v16 = v15[4];
                *(_BYTE*)(v16 + 8) = v5;
                off_4B4988 = (_UNKNOWN**)v15;
                *(_DWORD*)v16 = v16 + v5 + 8;
                *(_DWORD*)(v16 + 4) = 240 - v5;
                v15[6] -= (unsigned __int8)v5;
                return v16 + 256;
            }
            return 0;
        }
    }
    v8 = (_DWORD*)*((_DWORD*)v7 + 3);
    v20 = 0;
    v9 = v8;
    for (i = (_DWORD*)(*((_DWORD*)v7 + 4) + (((char*)v8 - v7 - 24) >> 3 << 12)); *v9 == -1; ++v20)
    {
        if (v20 >= 16)
            break;
        v9 += 2;
    }
    if (VirtualAlloc(i, v20 << 12, 0x1000u, 4u) != i)
        return 0;
    v11 = v8;
    if (v20 > 0)
    {
        v12 = i + 1;
        do
        {
            *((_BYTE*)v12 + 244) = -1;
            *(v12 - 1) = v12 + 1;
            *v12 = 240;
            *v11 = 240;
            v11[1] = 241;
            v12 += 1024;
            v11 += 2;
            --v20;
        } while (v20);
    }
    off_4B4988 = (_UNKNOWN**)v7;
    v13 = (_UNKNOWN**)(v7 + 8216);
    while (1)
    {
        v14 = v11 < v13;
        if (v11 >= v13)
            break;
        if (*v11 == -1)
        {
            v14 = v11 < v13;
            break;
        }
        v11 += 2;
    }
    *((_DWORD*)v7 + 3) = v14 ? v11 : 0;
    *((_BYTE*)i + 8) = a1;
    *((_DWORD*)v7 + 2) = v8;
    *v8 -= a1;
    i[1] -= a1;
    result = (int)(i + 64);
    *i = (char*)i + a1 + 8;
    return result;
}
// 4B2968: using guessed type _UNKNOWN *off_4B2968;
// 4B4988: using guessed type _UNKNOWN **off_4B4988;

//----- (0048E6BC) --------------------------------------------------------
int __cdecl sub_48E6BC(int a1, unsigned int a2, unsigned int a3)
{
    unsigned int v4; // esi
    _BYTE* v5; // edi
    unsigned int v6; // ebx
    _BYTE* v7; // eax
    _BYTE* v8; // eax
    _BYTE* v9; // esi
    _BYTE* v10; // ebx
    unsigned int v11; // esi
    _BYTE* v12; // esi
    _BYTE* v13; // ebx
    unsigned int v14; // eax
    _BYTE* v16; // [esp+Ch] [ebp-4h]
    unsigned int v17; // [esp+18h] [ebp+8h]

    v4 = *(_DWORD*)(a1 + 4);
    v5 = *(_BYTE**)a1;
    v6 = a1 + 248;
    v16 = *(_BYTE**)a1;
    v7 = *(_BYTE**)a1;
    v17 = a1 + 248;
    if (v4 >= a3)
    {
        *v5 = a3;
        if ((unsigned int)&v5[a3] >= v6)
        {
            *(_DWORD*)(a1 + 4) = 0;
            *(_DWORD*)a1 = a1 + 8;
        }
        else
        {
            *(_DWORD*)a1 += a3;
            *(_DWORD*)(a1 + 4) -= a3;
        }
        v8 = v5 + 8;
        return 16 * (_DWORD)v8 - 15 * a1;
    }
    v9 = &v5[v4];
    if (*v9)
        v7 = v9;
    if ((unsigned int)&v7[a3] >= v6)
    {
    LABEL_20:
        v12 = (_BYTE*)(a1 + 8);
        while (v12 < v5 && (unsigned int)&v12[a3] < v17)
        {
            if (*v12)
            {
                v12 += (unsigned __int8)*v12;
            }
            else
            {
                v13 = v12 + 1;
                v14 = 1;
                while (!*v13)
                {
                    ++v13;
                    ++v14;
                }
                if (v14 >= a3)
                {
                    if ((unsigned int)&v12[a3] >= v17)
                    {
                        *(_DWORD*)(a1 + 4) = 0;
                        *(_DWORD*)a1 = a1 + 8;
                    }
                    else
                    {
                        *(_DWORD*)a1 = &v12[a3];
                        *(_DWORD*)(a1 + 4) = v14 - a3;
                    }
                    *v12 = a3;
                    v8 = v12 + 8;
                    return 16 * (_DWORD)v8 - 15 * a1;
                }
                a2 -= v14;
                if (a2 < a3)
                    return 0;
                v12 = v13;
            }
        }
        return 0;
    }
    while (*v7)
    {
        v7 += (unsigned __int8)*v7;
    LABEL_19:
        if ((unsigned int)&v7[a3] >= v17)
            goto LABEL_20;
    }
    v10 = v7 + 1;
    v11 = 1;
    while (!*v10)
    {
        ++v10;
        ++v11;
    }
    if (v11 < a3)
    {
        if (v7 == v16)
        {
            *(_DWORD*)(a1 + 4) = v11;
        }
        else
        {
            a2 -= v11;
            if (a2 < a3)
                return 0;
        }
        v5 = v16;
        v7 = v10;
        goto LABEL_19;
    }
    if ((unsigned int)&v7[a3] >= v17)
    {
        *(_DWORD*)(a1 + 4) = 0;
        *(_DWORD*)a1 = a1 + 8;
    }
    else
    {
        *(_DWORD*)a1 = &v7[a3];
        *(_DWORD*)(a1 + 4) = v11 - a3;
    }
    *v7 = a3;
    v8 = v7 + 8;
    return 16 * (_DWORD)v8 - 15 * a1;
}

//----- (0048E7E0) --------------------------------------------------------
int __cdecl sub_48E7E0(int a1, _DWORD* a2, _BYTE* a3, unsigned int a4)
{
    unsigned int v4; // ecx
    _DWORD* v5; // edi
    _BYTE* v6; // esi
    _BYTE* i; // eax
    bool v8; // zf
    int v9; // eax
    int v11; // [esp+Ch] [ebp-4h]

    v4 = (unsigned __int8)*a3;
    v11 = 0;
    v5 = (_DWORD*)(a1 + 8 * (((int)a2 - *(_DWORD*)(a1 + 16)) >> 12) + 24);
    if (v4 > a4)
    {
        *a3 = a4;
        *v5 += v4 - a4;
        v5[1] = 241;
        return 1;
    }
    if (v4 < a4)
    {
        v6 = &a3[a4];
        if (a2 + 62 >= (_DWORD*)&a3[a4])
        {
            for (i = &a3[v4]; ; ++i)
            {
                v8 = i == v6;
                if (i >= v6)
                    break;
                if (*i)
                {
                    v8 = i == v6;
                    break;
                }
            }
            if (v8)
            {
                *a3 = a4;
                if ((unsigned int)a3 <= *a2 && (unsigned int)v6 > *a2)
                {
                    if (v6 >= (_BYTE*)a2 + 248)
                    {
                        a2[1] = 0;
                        *a2 = a2 + 2;
                    }
                    else
                    {
                        v9 = 0;
                        *a2 = v6;
                        if (!*v6)
                        {
                            do
                                ++v9;
                            while (!v6[v9]);
                        }
                        a2[1] = v9;
                    }
                }
                *v5 += v4 - a4;
                return 1;
            }
        }
    }
    return v11;
}

//----- (0048F4F9) --------------------------------------------------------
SIZE_T __cdecl sub_48F4F9(_DWORD* lpMem)
{
    int v1; // esi
    bool v2; // zf
    unsigned __int8* v3; // eax
    int v5; // [esp+Ch] [ebp-2Ch] BYREF
    unsigned __int8* v6; // [esp+10h] [ebp-28h]
    unsigned int v7; // [esp+14h] [ebp-24h] BYREF
    int v8; // [esp+18h] [ebp-20h]
    int block; // [esp+1Ch] [ebp-1Ch]
    CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h]

    if (dword_523A84 == 3)
    {
        _lock(9);
        ms_exc.registration.TryLevel = 0;
        block = __sbh_find_block(lpMem);
        if (block)
        {
            v1 = *(lpMem - 1) - 9;
            v8 = v1;
        }
        else
        {
            v1 = v8;
        }
        ms_exc.registration.TryLevel = -1;
        _unlock(9);
        v2 = block == 0;
    }
    else
    {
        if (dword_523A84 != 2)
            return HeapSize(hHeap, 0, lpMem);
        _lock(9);
        ms_exc.registration.TryLevel = 1;
        v3 = (unsigned __int8*)sub_48E418((unsigned int)lpMem, &v5, &v7);
        v6 = v3;
        if (v3)
        {
            v1 = 16 * *v3;
            v8 = v1;
        }
        else
        {
            v1 = v8;
        }
        ms_exc.registration.TryLevel = -1;
        _unlock(9);
        v2 = v6 == 0;
    }
    if (v2)
        return HeapSize(hHeap, 0, lpMem);
    return v1;
}
// 48D6BD: using guessed type int __cdecl __sbh_find_block(_DWORD);
// 48E8B2: using guessed type _DWORD __cdecl _lock(_DWORD);
// 48E913: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 523A84: using guessed type int dword_523A84;

//----- (00492D53) --------------------------------------------------------
int __cdecl sub_492D53(int a1, int a2)
{
    return ((int(__cdecl*)(int, int, void*))_ld12cvt)(a1, a2, &unk_4B53E0);
}
// 492BE7: using guessed type int _ld12cvt();

//----- (00492D69) --------------------------------------------------------
int __cdecl sub_492D69(int a1, int a2)
{
    return _ld12cvt(a1, a2, &unk_4B53F8);
}
// 492BE7: using guessed type int __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (00492D7F) --------------------------------------------------------
int __cdecl sub_492D7F(int a1, int a2)
{
    _BYTE v3[12]; // [esp+0h] [ebp-Ch] BYREF

    __strgtold12(v3, &a2, a2, 0, 0, 0, 0);
    return sub_492D53((int)v3, a1);
}
// 493CBB: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00492DAC) --------------------------------------------------------
int __cdecl sub_492DAC(int a1, int a2)
{
    _BYTE v3[12]; // [esp+0h] [ebp-Ch] BYREF

    __strgtold12(v3, &a2, a2, 0, 0, 0, 0);
    return sub_492D69((int)v3, a1);
}
// 493CBB: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00493081) --------------------------------------------------------
LONG(__stdcall* sub_493081())(struct _EXCEPTION_POINTERS* ExceptionInfo)
{
    LONG(__stdcall * result)(struct _EXCEPTION_POINTERS*); // eax

    result = SetUnhandledExceptionFilter(__CxxUnhandledExceptionFilter);
    lpfn = result;
    return result;
}

//----- (00493092) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_493092()
{
    return SetUnhandledExceptionFilter(lpfn);
}

//----- (004986BA) --------------------------------------------------------
void sub_4986BA()
{
    qmemcpy(&unk_521700, off_4AEFBC, 0x1Cu);
}
// 4AEFBC: using guessed type int (__stdcall *off_4AEFBC[6])(int, int, int);

// nfuncs=1987 queued=1673 decompiled=1673 lumina nreq=0 worse=0 better=0
// ALL OK, 1673 function(s) have been successfully decompiled
